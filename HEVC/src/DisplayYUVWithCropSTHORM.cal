  // Author: Damien de Saint Jorre
import  std.video.Display.*;
import  std.util.Math.*;
import  std.stdio.Source.*;


actor DisplayYUVWithCropSTHORM(uint(size=8) BLK_SIDE)
	uint(size=8)  Byte,
	uint(size=14) DispCoord,
	uint(size=9)  PicSizeInMb
		==>
		:

	int (size=32) pictureSizeInMb;
	int (size=32) nbBlockGot;
	uint(size=2)  chromaComponent;
	uint(size=16) pictureWidthLuma;
	uint(size=12) xIdxLuma;
	uint(size=12) yIdxLuma;
	uint(size=12) xIdxChroma;
	uint(size=32) yIdxChroma;
	uint(size=14) xMin;
	uint(size=14) xMax;
	uint(size=14) yMin;
	uint(size=14) yMax;

	int count := 0;

	int counter;
	
	int current_idx;
	int ongoing_transfer;
	
	@native
	procedure notify_full(int buffer_idx) end

	@native
	procedure wait_empty(int buffer_idx) end

	@native
	procedure dma_wait_on_display() end

	@native
	procedure memcpy_loc2ext(uint(size=8) base[64], int ext_offset, int comp, int idx) end	
	
	@trace
	getPictureSize: action DispCoord:[dispCoord] repeat 4, PicSizeInMb:[picWidth, picHeight] ==>
	do

		pictureWidthLuma  := picWidth * BLK_SIDE;
		pictureSizeInMb   := picWidth * picHeight;
		xMin := dispCoord[0];
		xMax := dispCoord[1];
		yMin := dispCoord[2];
		yMax := dispCoord[3];
		println("xMin "+xMin +" xMax " + xMax +" yMin " + yMin + " yMax " + yMax);
		nbBlockGot := 0;
		xIdxLuma   := 0;
		yIdxLuma   := 0;
		xIdxChroma := 0;
		yIdxChroma := 0;
		
		println(count);
		count := count + 1;
		counter := 0;
	end

	getPixValue.launch.Luma.read: action Byte :[bytes] repeat 64 ==>
	guard
		nbBlockGot < pictureSizeInMb, counter < 64
	do
		if ongoing_transfer = 1 then 
			dma_wait_on_display();
		end
		memcpy_loc2ext(bytes, xIdxLuma + pictureWidthLuma * (yIdxLuma + counter), 0, current_idx);
		ongoing_transfer := 1;

		counter := counter + 1;
	end
	
	getPixValue.launch.Luma.done: action ==>
	guard counter = 64
	do
		nbBlockGot := nbBlockGot + 1;
		xIdxLuma := xIdxLuma + 64;
		chromaComponent := 0;
		counter := 0;		
	end
	
	getPixValue.launch.Chroma.read: action Byte :[bytes] repeat 32 ==>
	guard
		counter < 32
	do
		if ongoing_transfer = 1 then 
			dma_wait_on_display();
		end
		memcpy_loc2ext(bytes, xIdxChroma + pictureWidthLuma/2 * (yIdxChroma + counter), 1 + chromaComponent, current_idx);
		ongoing_transfer := 1;
	
		counter := counter + 1;
	end

	getPixValue.launch.Chroma.done: action ==>
	guard counter = 32
	do
	if chromaComponent != 0 then
			xIdxChroma := xIdxChroma + 32;
			if xIdxLuma = pictureWidthLuma then
				xIdxLuma   := 0;
				xIdxChroma := 0;
				yIdxLuma   := yIdxLuma + 64;
				yIdxChroma := yIdxChroma + 32;
			end
		end
		chromaComponent := 1;
		counter := 0;
	end
	
	displayPicture: action ==>
	guard
		nbBlockGot >= pictureSizeInMb
	do
		notify_full(current_idx);
		wait_empty(current_idx ^ 1);
		current_idx := current_idx ^ 1;
	end
	
	
	schedule fsm GetPictureSize:
		GetPictureSize  (getPictureSize                )--> GetLumaBlock;
		GetLumaBlock    (getPixValue.launch.Luma.read  )--> GetLumaBlock;
		GetLumaBlock    (getPixValue.launch.Luma.done  )--> GetChroma1Block;
		GetChroma1Block (getPixValue.launch.Chroma.read)--> GetChroma1Block;
		GetChroma1Block (getPixValue.launch.Chroma.done)--> GetChroma2Block;
		GetChroma2Block (getPixValue.launch.Chroma.read)--> GetChroma2Block;
		GetChroma2Block (getPixValue.launch.Chroma.done)--> GetLumaBlock;
		GetLumaBlock    (displayPicture                )--> GetPictureSize;
	end

	priority
		getPixValue > displayPicture;
		getPixValue.launch.Luma.read > getPixValue.launch.Luma.done;
		getPixValue.launch.Chroma.read > getPixValue.launch.Chroma.done;
	end

end