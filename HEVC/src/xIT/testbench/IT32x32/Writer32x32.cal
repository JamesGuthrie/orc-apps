// Author: Endri Bezati <endri.bezati@epfl.ch>
// original code: Writer.cal actor of the jpeg encoder package

// Modified by Eduardo Juarez, Ren Rong and Wei Jianguo of UPM (Spain) <eduardo.juarez@epfl.ch>


package xIT.testbench.IT32x32;  

actor Writer32x32()  int(size=16)  Res, 
                     bool          EOF		
                     ==> 
                     :
                                      
	bool  	DEBUG_L1 := true;
	bool    DEBUG_L2 := false;
	
	@native procedure Writer_init() end
	@native procedure Writer_write(uint(size=8) byte) end
	@native procedure Writer_close() end
	
	uint(size=32) nbTransformUnit := 0; // number of TU written
	
	initialize ==>
	do
	  Writer_init();
		
	  if (DEBUG_L1) then
		println("Writer32x32 ACTION: initialize");
        println("Writer32x32  STATE: WriteFile");
        println("------------------------------");
      end
	end	
	
	closeFile: action EOF:[ eof ] 
	                  ==>	
    guard
      eof
	do	
	  if (DEBUG_L1) then
		println("Writer32x32 ACTION: closeFile");
	    println("------------------------------");
	  end	
	  Writer_close();
	end		
	
	write_32x32: action Res:[ res ] repeat 1024,  // 32x32 TU = 1024 16-bit residual coefficients 
			 	        EOF:[ eof ]
	                    ==>	
	guard
	  not eof
	var
	  uint(size=8) LSB,
	  uint(size=8) MSB	  
	do
      foreach int i in 0 .. 1023 do
 	    LSB := res[i];
	    MSB := (res[i] >> 8);
        Writer_write(LSB);
	    Writer_write(MSB);         
      end	 
      nbTransformUnit := nbTransformUnit + 1;      
		
	  if (DEBUG_L1) then
	    println("Writer32x32 ACTION: write_32x32");
		println("-------------------------------");
		if (DEBUG_L2) then
          foreach int i in 0 .. 1023 do
            println("res[" + i + "]");		
            println("LSB    = " + LSB);
            println("MSB    = " + MSB);
		    println("-------------------------------");
		  end
          println("endOfFile = " + eof);
		  println("nbTranformUnit = " + nbTransformUnit);
		  println("-------------------------------");		  
		end
	  end	  				
	end	
		
end
