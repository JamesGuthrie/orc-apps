// Authors: Eduardo Juarez, Wei Jianguo and Ren Rong <eduardo.juarez@upm.es> of UPM (Spain) 
// modified by: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>

package xIT;

import devel.org.sc29.wg11.mpegh.part2.xIT.CommonConstant.*;

actor IT16x16_2d ()
	int(size=16) Coeff 
		==>
	int(size=16) Block
		:


	procedure it16x16_1d(int(size=16) input[256], int(size=16) output[256], int(size=8) shift)
	var
		int(size=25) evenEvenEven[2],
		int(size=25) evenEvenOdd[2],
		int(size=26) evenEven[4],
		int(size=26) evenOdd[4],
		int(size=27) even[8],
		int(size=27) odd[8],
   		int   		 rounding = 1 << (shift - 1)
	begin
		foreach int i in 0 .. 15
		do
		    evenEvenEven := [( input[i + 16*0] * g_aiT16[0][0] ) + ( input[i + 16*8] * g_aiT16[8][0] ),
		                     ( input[i + 16*0] * g_aiT16[0][1] ) + ( input[i + 16*8] * g_aiT16[8][1] )
		                    ];
		                      
		    evenEvenOdd  := [( input[i + 16*4] * g_aiT16[4][0] ) + ( input[i + 16*12] * g_aiT16[12][0] ),
		                     ( input[i + 16*4] * g_aiT16[4][1] ) + ( input[i + 16*12] * g_aiT16[12][1] )
		                    ]; 
		                    
		    evenEven := [ evenEvenEven[0] + evenEvenOdd[0],
		                  evenEvenEven[1] + evenEvenOdd[1],
		                  evenEvenEven[1] - evenEvenOdd[1],
		                  evenEvenEven[0] - evenEvenOdd[0]
		                ];                                        
		                 
		    evenOdd  := [( input[i + 16*2] * g_aiT16[2][0] ) + ( input[i + 16*6] * g_aiT16[6][0] ) + ( input[i + 16*10] * g_aiT16[10][0] ) + ( input[i + 16*14] * g_aiT16[14][0] ),
		                 ( input[i + 16*2] * g_aiT16[2][1] ) + ( input[i + 16*6] * g_aiT16[6][1] ) + ( input[i + 16*10] * g_aiT16[10][1] ) + ( input[i + 16*14] * g_aiT16[14][1] ),
		                 ( input[i + 16*2] * g_aiT16[2][2] ) + ( input[i + 16*6] * g_aiT16[6][2] ) + ( input[i + 16*10] * g_aiT16[10][2] ) + ( input[i + 16*14] * g_aiT16[14][2] ),
		                 ( input[i + 16*2] * g_aiT16[2][3] ) + ( input[i + 16*6] * g_aiT16[6][3] ) + ( input[i + 16*10] * g_aiT16[10][3] ) + ( input[i + 16*14] * g_aiT16[14][3] )
		                ]; 
		                
		    even := [ evenEven[0] + evenOdd[0],
		    	      evenEven[1] + evenOdd[1],
		    	      evenEven[2] + evenOdd[2],
		    	      evenEven[3] + evenOdd[3],
		    	      evenEven[3] - evenOdd[3],
		    	      evenEven[2] - evenOdd[2],
		    	      evenEven[1] - evenOdd[1],
		    	      evenEven[0] - evenOdd[0]
		            ];                       
		         
		    odd  := [( input[i + 16*1] * g_aiT16[1][0] ) + ( input[i + 16*3]  * g_aiT16[3] [0] ) + ( input[i + 16*5]  * g_aiT16[5] [0] ) + ( input[i + 16*7]  * g_aiT16[7] [0] ) +
		    	     ( input[i + 16*9] * g_aiT16[9][0] ) + ( input[i + 16*11] * g_aiT16[11][0] ) + ( input[i + 16*13] * g_aiT16[13][0] ) + ( input[i + 16*15] * g_aiT16[15][0] ),
		    	      
		             ( input[i + 16*1] * g_aiT16[1][1] ) + ( input[i + 16*3]  * g_aiT16[3] [1] ) + ( input[i + 16*5]  * g_aiT16[5] [1] ) + ( input[i + 16*7]  * g_aiT16[7] [1] ) +
		             ( input[i + 16*9] * g_aiT16[9][1] ) + ( input[i + 16*11] * g_aiT16[11][1] ) + ( input[i + 16*13] * g_aiT16[13][1] ) + ( input[i + 16*15] * g_aiT16[15][1] ),
		                          
		             ( input[i + 16*1] * g_aiT16[1][2] ) + ( input[i + 16*3]  * g_aiT16[3] [2] ) + ( input[i + 16*5]  * g_aiT16[5] [2] ) + ( input[i + 16*7]  * g_aiT16[7] [2] ) +
		             ( input[i + 16*9] * g_aiT16[9][2] ) + ( input[i + 16*11] * g_aiT16[11][2] ) + ( input[i + 16*13] * g_aiT16[13][2] ) + ( input[i + 16*15] * g_aiT16[15][2] ),
		             
		             ( input[i + 16*1] * g_aiT16[1][3] ) + ( input[i + 16*3]  * g_aiT16[3] [3] ) + ( input[i + 16*5]  * g_aiT16[5] [3] ) + ( input[i + 16*7]  * g_aiT16[7] [3] ) +
		             ( input[i + 16*9] * g_aiT16[9][3] ) + ( input[i + 16*11] * g_aiT16[11][3] ) + ( input[i + 16*13] * g_aiT16[13][3] ) + ( input[i + 16*15] * g_aiT16[15][3] ),
		             
		             ( input[i + 16*1] * g_aiT16[1][4] ) + ( input[i + 16*3]  * g_aiT16[3] [4] ) + ( input[i + 16*5]  * g_aiT16[5] [4] ) + ( input[i + 16*7]  * g_aiT16[7] [4] ) +
		             ( input[i + 16*9] * g_aiT16[9][4] ) + ( input[i + 16*11] * g_aiT16[11][4] ) + ( input[i + 16*13] * g_aiT16[13][4] ) + ( input[i + 16*15] * g_aiT16[15][4] ),
		             
		             ( input[i + 16*1] * g_aiT16[1][5] ) + ( input[i + 16*3]  * g_aiT16[3] [5] ) + ( input[i + 16*5]  * g_aiT16[5] [5] ) + ( input[i + 16*7]  * g_aiT16[7] [5] ) +
		             ( input[i + 16*9] * g_aiT16[9][5] ) + ( input[i + 16*11] * g_aiT16[11][5] ) + ( input[i + 16*13] * g_aiT16[13][5] ) + ( input[i + 16*15] * g_aiT16[15][5] ),
		             
		             ( input[i + 16*1] * g_aiT16[1][6] ) + ( input[i + 16*3]  * g_aiT16[3] [6] ) + ( input[i + 16*5]  * g_aiT16[5] [6] ) + ( input[i + 16*7]  * g_aiT16[7] [6] ) +
		             ( input[i + 16*9] * g_aiT16[9][6] ) + ( input[i + 16*11] * g_aiT16[11][6] ) + ( input[i + 16*13] * g_aiT16[13][6] ) + ( input[i + 16*15] * g_aiT16[15][6] ),
		             
		             ( input[i + 16*1] * g_aiT16[1][7] ) + ( input[i + 16*3]  * g_aiT16[3] [7] ) + ( input[i + 16*5]  * g_aiT16[5] [7] ) + ( input[i + 16*7]  * g_aiT16[7] [7] ) +
		             ( input[i + 16*9] * g_aiT16[9][7] ) + ( input[i + 16*11] * g_aiT16[11][7] ) + ( input[i + 16*13] * g_aiT16[13][7] ) + ( input[i + 16*15] * g_aiT16[15][7] )             
		            ];
			output[16*i +  0] := (even[0] + odd[0]+ rounding) >> shift;
			output[16*i +  1] := (even[1] + odd[1] + rounding) >> shift;
			output[16*i +  2] := (even[2] + odd[2] + rounding) >> shift;
			output[16*i +  3] := (even[3] + odd[3] + rounding) >> shift;
			output[16*i +  4] := (even[4] + odd[4] + rounding) >> shift;
			output[16*i +  5] := (even[5] + odd[5] + rounding) >> shift;
			output[16*i +  6] := (even[6] + odd[6] + rounding) >> shift;
			output[16*i +  7] := (even[7] + odd[7] + rounding) >> shift;
			output[16*i +  8] := (even[7] - odd[7] + rounding) >> shift;
			output[16*i +  9] := (even[6] - odd[6] + rounding) >> shift;
			output[16*i + 10] := (even[5] - odd[5] + rounding) >> shift;
			output[16*i + 11] := (even[4] - odd[4] + rounding) >> shift;
			output[16*i + 12] := (even[3] - odd[3] + rounding) >> shift;
			output[16*i + 13] := (even[2] - odd[2] + rounding) >> shift;
			output[16*i + 14] := (even[1] - odd[1] + rounding) >> shift;
			output[16*i + 15] := (even[0] - odd[0] + rounding) >> shift;
		end
	end

	action
		Coeff:[ src ] repeat 256
			==>
		Block:[ dst ] repeat 256
	var
		int(size=16) x[256] := [src[i]: for int i in 0 .. 255],
		int(size=16) y[256],
		int(size=16) dst[256]
	do
		it16x16_1d(x, y, 7);
		it16x16_1d(y, x, 12);
		dst := [x[i]: for int i in 0 .. 255];
	end
end
