// Authors: Eduardo Juarez, Wei Jianguo and Ren Rong <eduardo.juarez@upm.es> of UPM (Spain) 
// modified by: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>

package xIT;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.xIT.CommonConstant.*;

actor IT_Merger()
	int(size=8)  Size,                                          
	int(size=16) Coeff
		==>                                    
	int(size=16) Block  
		:
 
 	int(size=16) block[32*32];
 	int(size=16) firstPassBlk[32*32];
 
	procedure invDst4x4(int(size=16) input[32*32], int(size=16) output[32*32], int(size=8) shift)
	var
		int(size=16) rounding = 1 << (shift-1),
		int(size=32) c[4]
	begin
		foreach int i in 0 .. 3
		do
			c:= [
				input[  i] + input[ 8+i],
	    		input[8+i] + input[12+i],
	    		input[  i] - input[12+i],
	    		74* input[4+i]
	    		];
		    output[4*i+0] := clip_i32((29 * c[0] + 55 * c[1]     + c[3]            + rounding) >> shift, -32768, 32767);
		    output[4*i+1] := clip_i32((55 * c[2] - 29 * c[1]     + c[3]            + rounding) >> shift, -32768, 32767);
		    output[4*i+2] := clip_i32((74 * (input[i] - input[8+i]  + input[12+i]) + rounding) >> shift, -32768, 32767);
		    output[4*i+3] := clip_i32((55 * c[0] + 29 * c[2]     - c[3]            + rounding) >> shift, -32768, 32767);
		end
	end

 	procedure it4x4_1d(int(size=16) input[32*32], int(size=16) output[32*32], int shift)
 	var    
 		int x0, int x1, int x2, int x3,
		int rounding = 1 << (shift - 1)
	begin
		foreach int i in 0 .. 3 do
			x0 := (input[i + 4*0] * g_aiT4[0][0]) + (input[i + 4*2] * g_aiT4[2][0]);
			x2 := (input[i + 4*0] * g_aiT4[0][1]) + (input[i + 4*2] * g_aiT4[2][1]);        
			x1 := (input[i + 4*1] * g_aiT4[1][0]) + (input[i + 4*3] * g_aiT4[3][0]);
			x3 := (input[i + 4*1] * g_aiT4[1][1]) + (input[i + 4*3] * g_aiT4[3][1]);                      
			output[4*i + 0] := (x0 + x1 + rounding) >> shift;
			output[4*i + 1] := (x2 + x3 + rounding) >> shift;
			output[4*i + 2] := (x2 - x3 + rounding) >> shift;
			output[4*i + 3] := (x0 - x1 + rounding) >> shift;
		end
	end

	procedure it8x8_1d(int(size=16) input[32*32], int(size=16) output[32*32], int shift)
	var
		int(size=26) even[4],
		int(size=26) odd[4],
		int(size=26) rounding = 1 << shift - 1
	begin
		foreach int i in 0 .. 7 do
			even[0] := input[i + 8*0] * g_aiT8[0][0] + input[i + 8*4] * g_aiT8[4][0] +
			           input[i + 8*2] * g_aiT8[2][0] + input[i + 8*6] * g_aiT8[6][0];
			even[1] := input[i + 8*0] * g_aiT8[0][1] + input[i + 8*4] * g_aiT8[4][1] +
			           input[i + 8*2] * g_aiT8[2][1] + input[i + 8*6] * g_aiT8[6][1];
			even[2] := input[i + 8*0] * g_aiT8[0][1] + input[i + 8*4] * g_aiT8[4][1] -
			          (input[i + 8*2] * g_aiT8[2][1] + input[i + 8*6] * g_aiT8[6][1]);
			even[3] := input[i + 8*0] * g_aiT8[0][0] + input[i + 8*4] * g_aiT8[4][0] -
			          (input[i + 8*2] * g_aiT8[2][0] + input[i + 8*6] * g_aiT8[6][0]);
	
			odd[0]  := input[i + 8*1] * g_aiT8[1][0] + input[i + 8*3] * g_aiT8[3][0] +
			           input[i + 8*5] * g_aiT8[5][0] + input[i + 8*7] * g_aiT8[7][0];
			odd[1]  := input[i + 8*1] * g_aiT8[1][1] + input[i + 8*3] * g_aiT8[3][1] +
			           input[i + 8*5] * g_aiT8[5][1] + input[i + 8*7] * g_aiT8[7][1];
			odd[2]  := input[i + 8*1] * g_aiT8[1][2] + input[i + 8*3] * g_aiT8[3][2] +
			           input[i + 8*5] * g_aiT8[5][2] + input[i + 8*7] * g_aiT8[7][2];
			odd[3]  := input[i + 8*1] * g_aiT8[1][3] + input[i + 8*3] * g_aiT8[3][3] +
			           input[i + 8*5] * g_aiT8[5][3] + input[i + 8*7] * g_aiT8[7][3];
	
			output[8*i +  0] := (even[0] + odd[0] + rounding) >> shift;
			output[8*i +  1] := (even[1] + odd[1] + rounding) >> shift;
			output[8*i +  2] := (even[2] + odd[2] + rounding) >> shift;
			output[8*i +  3] := (even[3] + odd[3] + rounding) >> shift;
			output[8*i +  4] := (even[3] - odd[3] + rounding) >> shift;
			output[8*i +  5] := (even[2] - odd[2] + rounding) >> shift;
			output[8*i +  6] := (even[1] - odd[1] + rounding) >> shift;
			output[8*i +  7] := (even[0] - odd[0] + rounding) >> shift;
		end
	end

	procedure it16x16_1d(int(size=16) input[32*32], int(size=16) output[32*32], int(size=8) shift)
	var
		int(size=25) evenEvenEven[2],
		int(size=25) evenEvenOdd[2],
		int(size=26) evenEven[4],
		int(size=26) evenOdd[4],
		int(size=27) even[8],
		int(size=27) odd[8],
   		int   		 rounding = 1 << (shift - 1)
	begin
		foreach int i in 0 .. 15
		do
		    evenEvenEven := [( input[i + 16*0] * g_aiT16[0][0] ) + ( input[i + 16*8] * g_aiT16[8][0] ),
		                     ( input[i + 16*0] * g_aiT16[0][1] ) + ( input[i + 16*8] * g_aiT16[8][1] )
		                    ];
		                      
		    evenEvenOdd  := [( input[i + 16*4] * g_aiT16[4][0] ) + ( input[i + 16*12] * g_aiT16[12][0] ),
		                     ( input[i + 16*4] * g_aiT16[4][1] ) + ( input[i + 16*12] * g_aiT16[12][1] )
		                    ]; 
		                    
		    evenEven := [ evenEvenEven[0] + evenEvenOdd[0],
		                  evenEvenEven[1] + evenEvenOdd[1],
		                  evenEvenEven[1] - evenEvenOdd[1],
		                  evenEvenEven[0] - evenEvenOdd[0]
		                ];                                        
		                 
		    evenOdd  := [( input[i + 16*2] * g_aiT16[2][0] ) + ( input[i + 16*6] * g_aiT16[6][0] ) + ( input[i + 16*10] * g_aiT16[10][0] ) + ( input[i + 16*14] * g_aiT16[14][0] ),
		                 ( input[i + 16*2] * g_aiT16[2][1] ) + ( input[i + 16*6] * g_aiT16[6][1] ) + ( input[i + 16*10] * g_aiT16[10][1] ) + ( input[i + 16*14] * g_aiT16[14][1] ),
		                 ( input[i + 16*2] * g_aiT16[2][2] ) + ( input[i + 16*6] * g_aiT16[6][2] ) + ( input[i + 16*10] * g_aiT16[10][2] ) + ( input[i + 16*14] * g_aiT16[14][2] ),
		                 ( input[i + 16*2] * g_aiT16[2][3] ) + ( input[i + 16*6] * g_aiT16[6][3] ) + ( input[i + 16*10] * g_aiT16[10][3] ) + ( input[i + 16*14] * g_aiT16[14][3] )
		                ]; 
		                
		    even := [ evenEven[0] + evenOdd[0],
		    	      evenEven[1] + evenOdd[1],
		    	      evenEven[2] + evenOdd[2],
		    	      evenEven[3] + evenOdd[3],
		    	      evenEven[3] - evenOdd[3],
		    	      evenEven[2] - evenOdd[2],
		    	      evenEven[1] - evenOdd[1],
		    	      evenEven[0] - evenOdd[0]
		            ];                       
		         
		    odd  := [( input[i + 16*1] * g_aiT16[1][0] ) + ( input[i + 16*3]  * g_aiT16[3] [0] ) + ( input[i + 16*5]  * g_aiT16[5] [0] ) + ( input[i + 16*7]  * g_aiT16[7] [0] ) +
		    	     ( input[i + 16*9] * g_aiT16[9][0] ) + ( input[i + 16*11] * g_aiT16[11][0] ) + ( input[i + 16*13] * g_aiT16[13][0] ) + ( input[i + 16*15] * g_aiT16[15][0] ),
		    	      
		             ( input[i + 16*1] * g_aiT16[1][1] ) + ( input[i + 16*3]  * g_aiT16[3] [1] ) + ( input[i + 16*5]  * g_aiT16[5] [1] ) + ( input[i + 16*7]  * g_aiT16[7] [1] ) +
		             ( input[i + 16*9] * g_aiT16[9][1] ) + ( input[i + 16*11] * g_aiT16[11][1] ) + ( input[i + 16*13] * g_aiT16[13][1] ) + ( input[i + 16*15] * g_aiT16[15][1] ),
		                          
		             ( input[i + 16*1] * g_aiT16[1][2] ) + ( input[i + 16*3]  * g_aiT16[3] [2] ) + ( input[i + 16*5]  * g_aiT16[5] [2] ) + ( input[i + 16*7]  * g_aiT16[7] [2] ) +
		             ( input[i + 16*9] * g_aiT16[9][2] ) + ( input[i + 16*11] * g_aiT16[11][2] ) + ( input[i + 16*13] * g_aiT16[13][2] ) + ( input[i + 16*15] * g_aiT16[15][2] ),
		             
		             ( input[i + 16*1] * g_aiT16[1][3] ) + ( input[i + 16*3]  * g_aiT16[3] [3] ) + ( input[i + 16*5]  * g_aiT16[5] [3] ) + ( input[i + 16*7]  * g_aiT16[7] [3] ) +
		             ( input[i + 16*9] * g_aiT16[9][3] ) + ( input[i + 16*11] * g_aiT16[11][3] ) + ( input[i + 16*13] * g_aiT16[13][3] ) + ( input[i + 16*15] * g_aiT16[15][3] ),
		             
		             ( input[i + 16*1] * g_aiT16[1][4] ) + ( input[i + 16*3]  * g_aiT16[3] [4] ) + ( input[i + 16*5]  * g_aiT16[5] [4] ) + ( input[i + 16*7]  * g_aiT16[7] [4] ) +
		             ( input[i + 16*9] * g_aiT16[9][4] ) + ( input[i + 16*11] * g_aiT16[11][4] ) + ( input[i + 16*13] * g_aiT16[13][4] ) + ( input[i + 16*15] * g_aiT16[15][4] ),
		             
		             ( input[i + 16*1] * g_aiT16[1][5] ) + ( input[i + 16*3]  * g_aiT16[3] [5] ) + ( input[i + 16*5]  * g_aiT16[5] [5] ) + ( input[i + 16*7]  * g_aiT16[7] [5] ) +
		             ( input[i + 16*9] * g_aiT16[9][5] ) + ( input[i + 16*11] * g_aiT16[11][5] ) + ( input[i + 16*13] * g_aiT16[13][5] ) + ( input[i + 16*15] * g_aiT16[15][5] ),
		             
		             ( input[i + 16*1] * g_aiT16[1][6] ) + ( input[i + 16*3]  * g_aiT16[3] [6] ) + ( input[i + 16*5]  * g_aiT16[5] [6] ) + ( input[i + 16*7]  * g_aiT16[7] [6] ) +
		             ( input[i + 16*9] * g_aiT16[9][6] ) + ( input[i + 16*11] * g_aiT16[11][6] ) + ( input[i + 16*13] * g_aiT16[13][6] ) + ( input[i + 16*15] * g_aiT16[15][6] ),
		             
		             ( input[i + 16*1] * g_aiT16[1][7] ) + ( input[i + 16*3]  * g_aiT16[3] [7] ) + ( input[i + 16*5]  * g_aiT16[5] [7] ) + ( input[i + 16*7]  * g_aiT16[7] [7] ) +
		             ( input[i + 16*9] * g_aiT16[9][7] ) + ( input[i + 16*11] * g_aiT16[11][7] ) + ( input[i + 16*13] * g_aiT16[13][7] ) + ( input[i + 16*15] * g_aiT16[15][7] )             
		            ];
			output[16*i +  0] := (even[0] + odd[0]+ rounding) >> shift;
			output[16*i +  1] := (even[1] + odd[1] + rounding) >> shift;
			output[16*i +  2] := (even[2] + odd[2] + rounding) >> shift;
			output[16*i +  3] := (even[3] + odd[3] + rounding) >> shift;
			output[16*i +  4] := (even[4] + odd[4] + rounding) >> shift;
			output[16*i +  5] := (even[5] + odd[5] + rounding) >> shift;
			output[16*i +  6] := (even[6] + odd[6] + rounding) >> shift;
			output[16*i +  7] := (even[7] + odd[7] + rounding) >> shift;
			output[16*i +  8] := (even[7] - odd[7] + rounding) >> shift;
			output[16*i +  9] := (even[6] - odd[6] + rounding) >> shift;
			output[16*i + 10] := (even[5] - odd[5] + rounding) >> shift;
			output[16*i + 11] := (even[4] - odd[4] + rounding) >> shift;
			output[16*i + 12] := (even[3] - odd[3] + rounding) >> shift;
			output[16*i + 13] := (even[2] - odd[2] + rounding) >> shift;
			output[16*i + 14] := (even[1] - odd[1] + rounding) >> shift;
			output[16*i + 15] := (even[0] - odd[0] + rounding) >> shift;
		end
	end

	procedure it32x32_1d(int(size=16) input[32*32], int(size=16) output[32*32], int(size=8) shift)
	var
		int(size=25) evenEvenEvenEven[2],
		int(size=25) evenEvenEvenOdd[2],
		int(size=26) evenEvenEven[4],
		int(size=26) evenEvenOdd[4],
		int(size=27) evenEven[8],
		int(size=27) evenOdd[8],
		int(size=28) even[16],
		int(size=28) odd[16],
   		int(size=28) rounding = 1 << (shift - 1)
	begin
		foreach int j in 0 .. 31
		do
			evenEvenEvenEven := [( input[j + 32*0] * g_aiT32[0][0] ) + ( input[j + 32*16] * g_aiT32[16][0] ),
	                         ( input[j + 32*0] * g_aiT32[0][1] ) + ( input[j + 32*16] * g_aiT32[16][1] )
	                        ];
	
			evenEvenEvenOdd  := [( input[j + 32*8] * g_aiT32[8][0] ) + ( input[j + 32*24] * g_aiT32[24][0] ),
	                         ( input[j + 32*8] * g_aiT32[8][1] ) + ( input[j + 32*24] * g_aiT32[24][1] )
	                        ];
	
			evenEvenEven := [ evenEvenEvenEven[0] + evenEvenEvenOdd[0],
	                      evenEvenEvenEven[1] + evenEvenEvenOdd[1],                                  
	                      evenEvenEvenEven[1] - evenEvenEvenOdd[1],
	                      evenEvenEvenEven[0] - evenEvenEvenOdd[0]
	                    ];
	
			evenEvenOdd  := [ ( input[j + 32*4] * g_aiT32[4][i] ) + ( input[j + 32*12] * g_aiT32[12][i] ) + ( input[j + 32*20] * g_aiT32[20][i] ) + ( input[j + 32*28] * g_aiT32[28][i] )
	    	              : for int i in 0 .. 3
	                    ];
	
			evenEven := [ evenEvenEven[0] + evenEvenOdd[0],
	                  evenEvenEven[1] + evenEvenOdd[1],
	                  evenEvenEven[2] + evenEvenOdd[2],
	                  evenEvenEven[3] + evenEvenOdd[3],
	                  evenEvenEven[3] - evenEvenOdd[3],
	                  evenEvenEven[2] - evenEvenOdd[2],                                    
	                  evenEvenEven[1] - evenEvenOdd[1],
	                  evenEvenEven[0] - evenEvenOdd[0]
	                ];
	
			evenOdd  := [( input[j + 32*2]  * g_aiT32[2] [i] ) + ( input[j + 32*6]  * g_aiT32[6] [i] ) + ( input[j + 32*10] * g_aiT32[10][i] ) + ( input[j + 32*14] * g_aiT32[14][i] ) +
	    	         ( input[j + 32*18] * g_aiT32[18][i] ) + ( input[j + 32*22] * g_aiT32[22][i] ) + ( input[j + 32*26] * g_aiT32[26][i] ) + ( input[j + 32*30] * g_aiT32[30][i] )
	    	         : for int i in 0 .. 7
	    	        ];
	
			even := [ evenEven[0] + evenOdd[0],
	    	      evenEven[1] + evenOdd[1],
	    	      evenEven[2] + evenOdd[2],
	    	      evenEven[3] + evenOdd[3],
	    	      evenEven[4] + evenOdd[4],
	    	      evenEven[5] + evenOdd[5],
	    	      evenEven[6] + evenOdd[6],
	    	      evenEven[7] + evenOdd[7],
	    	      evenEven[7] - evenOdd[7],
	    	      evenEven[6] - evenOdd[6],
	    	      evenEven[5] - evenOdd[5],
	    	      evenEven[4] - evenOdd[4],    	      
	    	      evenEven[3] - evenOdd[3],
	    	      evenEven[2] - evenOdd[2],
	    	      evenEven[1] - evenOdd[1],
	    	      evenEven[0] - evenOdd[0]
	            ];
	
			odd  := [( input[j + 32*1]  * g_aiT32[1] [i] ) + ( input[j + 32*3]  * g_aiT32[3] [i] ) + ( input[j + 32*5]  * g_aiT32[5] [i] ) + ( input[j + 32*7]  * g_aiT32[7] [i] ) +
	    	     ( input[j + 32*9]  * g_aiT32[9] [i] ) + ( input[j + 32*11] * g_aiT32[11][i] ) + ( input[j + 32*13] * g_aiT32[13][i] ) + ( input[j + 32*15] * g_aiT32[15][i] ) +
	    	     ( input[j + 32*17] * g_aiT32[17][i] ) + ( input[j + 32*19] * g_aiT32[19][i] ) + ( input[j + 32*21] * g_aiT32[21][i] ) + ( input[j + 32*23] * g_aiT32[23][i] ) +
	    	     ( input[j + 32*25] * g_aiT32[25][i] ) + ( input[j + 32*27] * g_aiT32[27][i] ) + ( input[j + 32*29] * g_aiT32[29][i] ) + ( input[j + 32*31] * g_aiT32[31][i] )
	    	     : for int i in 0 .. 15
	    	    ];
	
			output[32*j +  0] := (even[0]  + odd[0] + rounding) >> shift;
			output[32*j +  1] := (even[1]  + odd[1] + rounding) >> shift;
			output[32*j +  2] := (even[2]  + odd[2] + rounding) >> shift;
			output[32*j +  3] := (even[3]  + odd[3] + rounding) >> shift;
			output[32*j +  4] := (even[4]  + odd[4] + rounding) >> shift;
			output[32*j +  5] := (even[5]  + odd[5] + rounding) >> shift;
			output[32*j +  6] := (even[6]  + odd[6] + rounding) >> shift;
			output[32*j +  7] := (even[7]  + odd[7] + rounding) >> shift;
			output[32*j +  8] := (even[8]  + odd[8] + rounding) >> shift;
			output[32*j +  9] := (even[9]  + odd[9] + rounding) >> shift;
			output[32*j +  10] := (even[10] + odd[10] + rounding) >> shift;
			output[32*j +  11] := (even[11] + odd[11] + rounding) >> shift;
			output[32*j +  12] := (even[12] + odd[12] + rounding) >> shift;
			output[32*j +  13] := (even[13] + odd[13] + rounding) >> shift;
			output[32*j +  14] := (even[14] + odd[14] + rounding) >> shift;
			output[32*j +  15] := (even[15] + odd[15] + rounding) >> shift; 
			output[32*j +  16] := (even[15] - odd[15] + rounding) >> shift;
			output[32*j +  17] := (even[14] - odd[14] + rounding) >> shift;
			output[32*j +  18] := (even[13] - odd[13] + rounding) >> shift;
			output[32*j +  19] := (even[12] - odd[12] + rounding) >> shift;
			output[32*j +  20] := (even[11] - odd[11] + rounding) >> shift;
			output[32*j +  21] := (even[10] - odd[10] + rounding) >> shift;
			output[32*j +  22] := (even[9]  - odd[9] + rounding) >> shift;
			output[32*j +  23] := (even[8]  - odd[8] + rounding) >> shift;
			output[32*j +  24] := (even[7]  - odd[7] + rounding) >> shift;
			output[32*j +  25] := (even[6]  - odd[6] + rounding) >> shift;
			output[32*j +  26] := (even[5]  - odd[5] + rounding) >> shift;
			output[32*j +  27] := (even[4]  - odd[4] + rounding) >> shift;
			output[32*j +  28] := (even[3]  - odd[3] + rounding) >> shift;
			output[32*j +  29] := (even[2]  - odd[2] + rounding) >> shift;
			output[32*j +  30] := (even[1]  - odd[1] + rounding) >> shift;
			output[32*j +  31] := (even[0]  - odd[0] + rounding) >> shift;
		end
	end



	block.is4x4.IT: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff],
		Coeff:[coeff] repeat 4*4
			==>
		Block:[block] repeat 4*4
	guard
		sizeOfTU = 4 and RCskip = 0  and isDST = 0 and transfSkipFlag = 0
	do
		block := [coeff[i]: for int i in 0 .. 4*4-1];
		it4x4_1d(block, firstPassBlk, 7);
		it4x4_1d(firstPassBlk, block, 12);
	end

	block.is4x4.dst: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff],
		Coeff:[coeff] repeat 4*4
			==>
		Block:[block] repeat 4*4
	guard
		sizeOfTU = 4 and RCskip = 0  and isDST = 1 and transfSkipFlag = 0
	do
		block := [coeff[i]: for int i in 0 .. 4*4-1];
		invDst4x4(block, firstPassBlk, 7);
		invDst4x4(firstPassBlk, block, 12);
	end

	block.is4x4.trans_skip: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff],
		Coeff:[res] repeat 4*4
			==>
		Block:[res] repeat 4*4
	guard
		sizeOfTU = 4 and RCskip = 0  and transfSkipFlag = 1
	end

	block.is4x4.skip: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff]
			==>
		Block:[[0: for int i in 1 .. 4*4]] repeat 4*4
	guard
		sizeOfTU = 4 and RCskip != 0
	end



	block.is8x8: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff],
		Coeff:[coeff] repeat 8*8
			==>
		Block:[block] repeat 8*8
	guard
		sizeOfTU = 8 and RCskip = 0 and transfSkipFlag = 0
	do
		block := [coeff[i]: for int i in 0 .. 8*8-1];
		it8x8_1d(block, firstPassBlk, 7);
		it8x8_1d(firstPassBlk, block, 12);
	end

	block.is8x8.trans_skip: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff],
		Coeff:[res] repeat 8*8
			==>
		Block:[res] repeat 8*8
	guard
		sizeOfTU = 8 and RCskip = 0  and transfSkipFlag = 1
	end

	block.is8x8.skip: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff]
			==>
		Block:[[0: for int i in 1 .. 8*8]] repeat 8*8
	guard
		sizeOfTU = 8 and RCskip != 0
	end



	block.is16x16: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff],
		Coeff:[coeff] repeat 16*16
			==>
		Block:[block] repeat 16*16
	guard
		sizeOfTU = 16 and RCskip = 0 and transfSkipFlag = 0
	do
		block := [coeff[i]: for int i in 0 .. 16*16-1];
		it16x16_1d(block, firstPassBlk, 7);
		it16x16_1d(firstPassBlk, block, 12);
	end

	block.is16x16.trans_skip: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff],
		Coeff:[res] repeat 16*16
			==>
		Block:[res] repeat 16*16
	guard
		sizeOfTU = 16 and RCskip = 0  and transfSkipFlag = 1
	end

	block.is16x16.skip: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff]
			==>
		Block:[[0: for int i in 1 .. 16*16]] repeat 16*16
	guard
		sizeOfTU = 16 and RCskip != 0
	end



	block.is32x32: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff],
		Coeff:[coeff] repeat 32*32
			==>
		Block:[block] repeat 32*32
	guard
		sizeOfTU = 32 and RCskip = 0 and transfSkipFlag = 0
	do
		block := [coeff[i]: for int i in 0 .. 32*32-1];
		it32x32_1d(block, firstPassBlk, 7);
		it32x32_1d(firstPassBlk, block, 12);
	end

	block.is32x32.trans_skip: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff],
		Coeff:[res] repeat 32*32
			==>
		Block:[res] repeat 32*32
	guard
		sizeOfTU = 32 and RCskip = 0  and transfSkipFlag = 1
	end

	block.is32x32.skip: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff]
			==>
		Block:[[0: for int i in 1 .. 32*32]] repeat 32*32
	guard
		sizeOfTU = 32 and RCskip != 0
	end



	block.is64x64.skip: action
		Size:[sizeOfTU, RCskip, isDST, transfSkipFlag, slcQp, rcCIdx, qpOff]
			==>
		Block:[[0: for int i in 1 .. 64*64]] repeat 64*64
	guard
		sizeOfTU = 64
	end
end
