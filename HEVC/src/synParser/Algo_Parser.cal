package synParser;

import  common.BitstreamReadUtils.*;
import  synParser.Algo_ParserUtils.*;

actor Algo_Parser () 
				uint(size= 8) byte
				==>
:
	bool DEBUG_BITSTREAM = false;
	uint(size= 8) se_idx;
	uint(size=32) cnt_i;
	/**************************************************************************
	 **************************************************************************
	 ********        Bitstream Reader                     *********************
	 **************************************************************************
	 *************************************************************************/
	
	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
	uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL];
	uint(size= 2) zeroByte := 0;
	/* */
 	action byte:[ b ] ==>
	guard 
		fifo[FIFO_CPT_BITS] <= (FIFO_SIZE-1)<<3
	var
		uint(size=4) fifo_idx  =  fifo[FIFO_IDX]
	do
		if b != EPR_VALUE or zeroByte != 3 then
			if b = START_CODE_VALUE and zeroByte = 3 then
				fifo[fifo_idx]      := b + START_CODE_FLAG;
			else
				fifo[fifo_idx]      := b;
			end
			fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] + 8;
			if DEBUG_BITSTREAM then
				println("fifo["+fifo_idx+"] := "+b+" \t "+fifo[FIFO_CPT_BITS]);
			end
			fifo[FIFO_IDX]      := (fifo_idx+1) & (FIFO_SIZE-1);
		end
		if b = 0 then
			zeroByte := ((zeroByte << 1) + 1) & 0x3;
		else
			zeroByte := 0;
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        NAL UNTI                             *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * byte_align_a
	 *************************************************************************/	
	byte_align_a : action ==>
	do
		byte_align(fifo);
	end 	
	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		not IsStartCode(fifo) and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
   	do
		flushBits( 8, fifo );
		if DEBUG_BITSTREAM then		
  			println("start_code.search");
   		end
	end
	start_code.done: action ==>
	guard
		IsStartCode(fifo) and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then
			println("start_code.done");
		end
	end
	/**************************************************************************
	 * read_nal_unit_header
	 *************************************************************************/
	uint(size=2) nal_ref_flag;
	uint(size=5) nal_unit_type;
	uint(size=3) temporal_id;
	uint(size=1) output_flag;
	
	read_nal_unit_header : action ==>
	var
		uint(size=32) res[1]
	do
		if DEBUG_BITSTREAM then
			println("=========== NAL_UNIT ===========");
			flushBits_name( 1, fifo,   "reserved_zero_1bits                     ");
			vld_u_name(  2, fifo, res, "nal_ref_flag                            "); nal_ref_flag  := res[0];
			vld_u_name(  5, fifo, res, "nal_unit_type                           "); nal_unit_type := res[0];
		else
			flushBits( 1 , fifo );
			vld_u(  2, fifo, res); nal_ref_flag  := res[0];
			vld_u(  5, fifo, res); nal_unit_type := res[0];
		end
		temporal_id   := 0;
		output_flag   := 1; 
		se_idx := 1;
	end
	/**************************************************************************
	 * look_for.SPS_header
	 *************************************************************************/
	look_for.SPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_SPS
	do
		if DEBUG_PARSER then
			println("=========== Sequence Parameter Set ID    ===========");
		end
	end
	/**************************************************************************
	 * look_for.PPS_header
	 *************************************************************************/
	look_for.PPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_PPS
	do
		if DEBUG_PARSER then
			println("=========== Picture Parameter Set ID    ===========");
		end
	end
	/**************************************************************************
	 * look_for.Slice_header
	 *************************************************************************/
	look_for.Slice_header: action ==>
	guard
		(nal_unit_type = NAL_UNIT_NON_IDR_AND_NON_CRA or
		 nal_unit_type = NAL_UNIT_CRA                 or
		 nal_unit_type = NAL_UNIT_IDR)
	var
		uint(size=32) res[1]
	do
		if DEBUG_BITSTREAM then
			vld_u_name(  3, fifo, res, "temporal_id                             "); temporal_id := res[0];
			vld_u_name(  1, fifo, res, "output_flag                             "); output_flag := res[0];
			flushBits_name( 4, fifo,   "reserved_zero_4bits                     ");
		else
			vld_u(  3, fifo, res); temporal_id := res[0];
			vld_u(  1, fifo, res); output_flag := res[0];
			flushBits( 4, fifo  );
		end
		if DEBUG_PARSER then
			println("=========== Slice ===========");
		end
	end
	/**************************************************************************
	 * look_for_other_header
	 *************************************************************************/
	look_for_other_header: action ==>
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Sequence Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) sps_profile_idc;
	uint(size= 8) sps_level_idc;
	uint(size= 8) sps_sps_id;
	uint(size= 8) sps_max_temporal_layers_minus1;
	uint(size=16) sps_pic_width_in_luma_samples;
	uint(size=16) sps_pic_height_in_luma_samples;
	uint(size= 3) sps_bit_depth_luma_minus8;
	uint(size= 3) sps_bit_depth_chroma_minus8;
	uint(size= 4) sps_pcm_bit_depth_luma_minus1; 
	uint(size= 4) sps_pcm_bit_depth_chroma_minus1;
	uint(size=32) sps_log2_max_pic_order_cnt_lsb_minus4;
	uint(size=32) sps_max_num_ref_pics;
	uint(size=32) sps_max_num_reorder_pics;
	uint(size= 1) sps_disableInter4x4;
	uint(size= 8) sps_log2_min_coding_block_size_minus3;
	uint(size= 8) sps_log2_diff_max_min_coding_block_size;	
	uint(size=32) sps_log2_min_transform_block_size_minus2;
	uint(size=32) sps_log2_diff_max_min_transform_block_size;
	uint(size=32) sps_log2_min_pcm_coding_block_size_minus3;
	uint(size=32) sps_max_transform_hierarchy_depth_inter;
	uint(size=32) sps_max_transform_hierarchy_depth_intra;
	uint(size= 1) sps_chroma_pred_from_luma_enabled_flag;
	uint(size= 1) sps_loop_filter_across_slice_flag;
	uint(size= 1) sps_sample_adaptive_offset_enabled_flag;
	uint(size= 1) sps_adaptive_loop_filter_enabled_flag;
	uint(size= 1) sps_pcm_loop_filter_disable_flag;
	uint(size= 1) sps_cu_qp_delta_enabled_flag;
	uint(size= 1) sps_temporal_id_nesting_flag;
	uint(size=32) sps_padX;
	uint(size=32) sps_padY;
	uint(size= 1) sps_useMRG;
	uint(size= 1) sps_amvpMode[MAX_TLAYER];
	uint(size= 1) sps_uniform_spacing_idc;
	uint(size= 1) sps_tile_boundary_independence_idc;
	uint(size= 1) sps_num_tile_columns_minus1;
	uint(size= 1) sps_num_tile_rows_minus1;	
	uint(size=32) sps_column_width[32];
	uint(size=32) sps_row_height[32];
	uint(size= 1) sps_enable_nsqt;
	uint(size= 1) sps_enable_amp;
	/* */
	uint(size=32) sps_maxCUWidth;
	uint(size= 8) sps_maxCUDepth;

	/**************************************************************************
	 * read_SPS_Header.se_idx_1
	 *************************************************************************/
	read_SPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "profile_idc                             "); sps_profile_idc                := res[0];
		flushBits_name( 8, fifo,   "reserved_zero_8bits                     ");
		vld_u_name(  8, fifo, res, "level_idc                               "); sps_level_idc                  := res[0];
		vld_ue_name(    fifo, res, "seq_parameter_set_id                    "); sps_sps_id                     := res[0]; // getBits(10) max
		vld_u_name(  3, fifo, res, "max_temporal_layers_minus1              "); sps_max_temporal_layers_minus1 := res[0];
		vld_u_name( 16, fifo, res, "pic_width_in_luma_samples               "); sps_pic_width_in_luma_samples  := res[0];
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_2
	 *************************************************************************/
	read_SPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name( 16, fifo, res, "pic_height_in_luma_samples              "); sps_pic_height_in_luma_samples        := res[0];
		vld_ue_name(    fifo, res, "bit_depth_luma_minus8                   "); sps_bit_depth_luma_minus8             := res[0]; // getBits(5) max
		vld_ue_name(    fifo, res, "bit_depth_chroma_minus8                 "); sps_bit_depth_chroma_minus8           := res[0]; // getBits(5) max
		vld_u_name(  4, fifo, res, "pcm_bit_depth_luma_minus1               "); sps_pcm_bit_depth_luma_minus1         := res[0];
		vld_u_name(  4, fifo, res, "pcm_bit_depth_chroma_minus1             "); sps_pcm_bit_depth_chroma_minus1       := res[0];
		vld_ue_name(    fifo, res, "log2_max_pic_order_cnt_lsb_minus4       "); sps_log2_max_pic_order_cnt_lsb_minus4 := res[0];
		vld_ue_name(    fifo, res, "max_num_ref_pics                        "); sps_max_num_ref_pics                  := res[0];
		vld_ue_name(    fifo, res, "max_num_reorder_pics                    "); sps_max_num_reorder_pics              := res[0];
//		vld_u_name(  1, fifo, res, "disableInter4x4                         "); sps_disableInter4x4                   := res[0];		
		vld_u(  1, fifo, res); sps_disableInter4x4                   := res[0];		
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_3
	 *************************************************************************/
	read_SPS_Header.se_idx_3 : action ==>
	guard
		se_idx = 3 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "log2_min_coding_block_size_minus3       "); sps_log2_min_coding_block_size_minus3      := res[0]; // getBits(7) max
		vld_ue_name(    fifo, res, "log2_diff_max_min_coding_block_size     "); sps_log2_diff_max_min_coding_block_size    := res[0]; // getBits(32) max ?????
		vld_ue_name(    fifo, res, "log2_min_transform_block_size_minus2    "); sps_log2_min_transform_block_size_minus2   := res[0]; // getBits(32) max ?????
		vld_ue_name(    fifo, res, "log2_diff_max_min_transform_block_size  "); sps_log2_diff_max_min_transform_block_size := res[0]; // getBits(32) max ?????
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_4
	 *************************************************************************/	
	read_SPS_Header.se_idx_4 : action ==>
	guard
		se_idx = 4 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "log2_min_pcm_coding_block_size_minus3   "); sps_log2_min_pcm_coding_block_size_minus3 := res[0]; // getBits(32) max ?????
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_inter     "); sps_max_transform_hierarchy_depth_inter   := res[0]; // getBits(32) max ?????
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_intra     "); sps_max_transform_hierarchy_depth_intra   := res[0]; // getBits(32) max ?????
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_5
	 *************************************************************************/	
	read_SPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do
		vld_u_name(  1, fifo, res, "chroma_pred_from_luma_enabled_flag      "); sps_chroma_pred_from_luma_enabled_flag  := res[0];
		vld_u_name(  1, fifo, res, "loop_filter_across_slice_flag           "); sps_loop_filter_across_slice_flag       := res[0];
		vld_u_name(  1, fifo, res, "sample_adaptive_offset_enabled_flag     "); sps_sample_adaptive_offset_enabled_flag := res[0];
		vld_u_name(  1, fifo, res, "adaptive_loop_filter_enabled_flag       "); sps_adaptive_loop_filter_enabled_flag   := res[0];
		vld_u_name(  1, fifo, res, "pcm_loop_filter_disable_flag            "); sps_pcm_loop_filter_disable_flag        := res[0];
		vld_u_name(  1, fifo, res, "cu_qp_delta_enabled_flag                "); sps_cu_qp_delta_enabled_flag            := res[0];
		vld_u_name(  1, fifo, res, "temporal_id_nesting_flag                "); sps_temporal_id_nesting_flag            := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_6
	 *************************************************************************/
	read_SPS_Header.se_idx_6 : action ==>
	guard
		se_idx = 6 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size= 8) uiAddCUDepth := 0
   	do
		sps_maxCUWidth  := 1<<(sps_log2_min_coding_block_size_minus3 + 3 + sps_log2_diff_max_min_coding_block_size);
  		while( ( sps_maxCUWidth >> sps_log2_diff_max_min_coding_block_size ) > ( 1 << ( sps_log2_min_transform_block_size_minus2 + 2 + uiAddCUDepth )  ) ) 
  		do
  			uiAddCUDepth := uiAddCUDepth + 1;
  		end    
  		sps_maxCUDepth := sps_log2_diff_max_min_coding_block_size + uiAddCUDepth;


		//vld_ue_name(    fifo, res, "padX                                    "); sps_padX                := res[0]; // getBits(32) max ?????
		vld_ue(    fifo, res); sps_padX                := res[0]; // getBits(32) max ?????
		//vld_ue_name(    fifo, res, "padY                                    "); sps_padY                := res[0]; // getBits(32) max ?????
		vld_ue(    fifo, res); sps_padY                := res[0]; // getBits(32) max ?????
		//vld_u_name(  1, fifo, res, "useMRG                                  "); sps_useMRG              := res[0];
   		vld_u(  1, fifo, res); sps_useMRG              := res[0];
   		foreach uint(size=8) i in 0 .. sps_maxCUDepth - 1 do
   			//vld_u_name(  1, fifo, res, "amvpMode[ ]                             "); sps_amvpMode[i]     := res[0];
   			vld_u(  1, fifo, res); sps_amvpMode[i]     := res[0];
		end
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_7
	 *************************************************************************/	
	read_SPS_Header.se_idx_7 : action ==>
	guard
		se_idx = 7 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "uniform_spacing_idc                     "); sps_uniform_spacing_idc            := res[0];
		vld_u_name(  1, fifo, res, "tile_boundary_independence_idc          "); sps_tile_boundary_independence_idc := res[0];
		vld_ue_name(    fifo, res, "num_tile_columns_minus1                 "); sps_num_tile_columns_minus1        := res[0];
		vld_ue_name(    fifo, res, "num_tile_rows_minus1                    "); sps_num_tile_rows_minus1           := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_8
	 *************************************************************************/	
	read_SPS_Header.se_idx_8.loop : action ==>
	guard
		se_idx = 8  and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and 
		sps_uniform_spacing_idc = 1 and cnt_i <= sps_num_tile_columns_minus1
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "column_width[ ]                         "); sps_column_width[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_8.loopEnd : action ==>
	guard
		se_idx = 8 and sps_uniform_spacing_idc = 1 and cnt_i > sps_num_tile_columns_minus1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_SPS_Header.se_idx_8.noLoop : action ==>
	guard
		se_idx = 8 and sps_uniform_spacing_idc = 0
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_9
	 *************************************************************************/	
	read_SPS_Header.se_idx_9.loop : action ==>
	guard
		se_idx = 9  and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		sps_uniform_spacing_idc = 1 and cnt_i <= sps_num_tile_rows_minus1
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "row_height[ ]                           "); sps_row_height[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_9.loopEnd : action ==>
	guard
		se_idx = 9 and sps_uniform_spacing_idc = 1 and cnt_i > sps_num_tile_rows_minus1
   	do
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header_done
	 *************************************************************************/	
	read_SPS_Header_done : action ==>
	guard
		se_idx = 10
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "enable_nsqt                             "); sps_enable_nsqt := res[0];
		vld_u_name(  1, fifo, res, "enable_amp                              "); sps_enable_amp  := res[0];	
	end 
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size=32) pps_pps_id;
	uint(size=32) pps_sps_id;
	uint(size=32) pps_num_short_term_ref_pic_sets;
	uint(size=32) pps_long_term_ref_pics_present_flag;
	uint(size= 1) pps_entropy_coding_mode_flag;
	uint(size=32) pps_entropy_coding_synchro;
	uint(size= 1) pps_cabac_istate_reset;
	uint(size=32) pps_num_substreams_minus1;
	uint(size= 8) pps_num_temporal_layer_switching_point_flags;
	uint(size= 1) pps_temporal_layer_switching_point_flag[MAX_TLAYER];
	uint(size= 1) pps_constrained_intra_pred_flag;
	uint(size= 2) pps_slice_granularity;
	uint(size=32) pps_max_cu_qp_delta_depth;
	uint(size= 1) pps_weighted_pred_flag;
	uint(size= 2) pps_weighted_bipred_idc;
	uint(size= 1) pps_tile_info_present_flag;
	uint(size= 1) pps_uniform_spacing_idc;
	uint(size= 1) pps_tile_boundary_independence_idc;
	uint(size=32) pps_num_tile_columns_minus1;
	uint(size=32) pps_num_tile_rows_minus1;
	uint(size=32) pps_column_width[32];
	uint(size=32) pps_row_height[32];
	/**************************************************************************
	 * read_PPS_Header.se_idx_1
	 *************************************************************************/	
	read_PPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "pic_parameter_set_id                    "); pps_pps_id                      := res[0];
		vld_ue_name(    fifo, res, "seq_parameter_set_id                    "); pps_sps_id                      := res[0];
		vld_ue_name(    fifo, res, "num_short_term_ref_pic_sets             "); pps_num_short_term_ref_pic_sets := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_2
	 *************************************************************************/
	uint(size= 1) pps_inter_RPS_flag[32];
	uint(size=32) pps_num_negative_pics[32];
	uint(size=32) pps_num_positive_pics[32];
	uint(size=32) pps_num_pics[32];
	 int(size=32) pps_deltaPOC[32][32];
	uint(size= 1) pps_used[32][32];
	uint(size=32) pps_delta_idx_minus1[32];
	uint(size= 1) pps_delta_rps_sign[32];
	uint(size=32) pps_abs_delta_rps_minus1[32];
	uint(size=32) pps_num_ref_idc[32];
	uint(size=32) pps_ref_idc[32][32];
	

	read_PPS_Header.se_idx_2.loop : action ==>
	guard
		se_idx = 2 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		cnt_i < pps_num_short_term_ref_pic_sets
	var
		uint(size=32) res[1],
		uint(size= 8) rIdx,
		 int(size=32) deltaRPS,
		 int(size=32) deltaPOC,
		 int(size=32) k    := 0,
		 int(size=32) k0   := 0,
		 int(size=32) k1   := 0,
		uint(size=32) prev := 0
   	do
 		vld_u_name(  1, fifo, res, "inter_RPS_flag                          "); pps_inter_RPS_flag[cnt_i]   := res[0];
		if res[0] = 1 then 	
  			vld_ue_name(    fifo, res, "delta_idx_minus1                        "); pps_delta_idx_minus1[cnt_i]     := res[0];
    		rIdx := cnt_i - 1 - res[0];
    		vld_u_name(  1, fifo, res, "delta_rps_sign                          "); pps_delta_rps_sign[cnt_i]       := res[0];
    		vld_ue_name(    fifo, res, "abs_delta_rps_minus1                    "); pps_abs_delta_rps_minus1[cnt_i] := res[0];
    		deltaRPS := (1 - (pps_delta_rps_sign[rIdx]<<1)) * (res[0] + 1);
    		foreach uint(size=8) i in 0 ..  pps_num_pics[rIdx]-1 do
    			vld_u_name(  1, fifo, res, "ref_idc0                                ");
    			if res[0] = 0 then
	    			vld_u_name(  1, fifo, res, "ref_idc1                                ");
	    			res[0] := res[0] << 1;
    			end
    			if res[0] = 1 or res[0] = 2 then
    				if i < pps_num_pics[rIdx] then
    					deltaPOC := deltaRPS + pps_deltaPOC[rIdx][i];
    				else
    					deltaPOC := deltaRPS;
					end
			        if deltaPOC < 0 then
          				k0 := k0 + 1;
        			else 
          				k1 := k1 + 1;
        			end
        			k := k + 1; 			
    			end
    			pps_ref_idc[cnt_i][i] := res[0];
    		end
    		pps_num_ref_idc[cnt_i]       := pps_num_ref_idc[rIdx]+1;  
    		pps_num_pics[cnt_i]          := k;
    		pps_num_negative_pics[cnt_i] := k0;
			pps_num_positive_pics[cnt_i] := k1;
			sortDeltaPOC(cnt_i, k, k0, pps_deltaPOC, pps_used);
  		else
    		vld_ue_name(    fifo, res, "num_negative_pics                       "); pps_num_negative_pics[cnt_i] := res[0];
    		vld_ue_name(    fifo, res, "num_positive_pics                       "); pps_num_positive_pics[cnt_i] := res[0];
    		pps_num_pics[cnt_i] := pps_num_positive_pics[cnt_i] + res[0];
    		if pps_num_negative_pics[cnt_i] != 0 then
    			foreach uint(size=8) i in 0 ..  pps_num_negative_pics[cnt_i]-1 do
	    			vld_ue_name(    fifo, res, "delta_poc_s0_minus1                     ");
					prev := prev-res[0]-1;
					pps_deltaPOC[cnt_i][i] := prev;
					vld_u_name(  1, fifo, res, "used_by_curr_pic_s0_flag                "); pps_used[cnt_i][i]       := res[0];
				end
			end
			prev := 0;
			if pps_num_positive_pics[cnt_i] != 0 then
    			foreach uint(size=8) i in pps_num_negative_pics[cnt_i] .. pps_num_pics[cnt_i]-1 do
	    			vld_ue_name(    fifo, res, "delta_poc_s1_minus1                     ");
					prev := prev-res[0]-1;
					pps_deltaPOC[cnt_i][i] := prev;
					vld_u_name(  1, fifo, res, "used_by_curr_pic_s1_flag                "); pps_used[cnt_i][i]       := res[0];
				end
			end
		end
		printDeltaPOC(cnt_i, pps_num_pics[cnt_i], pps_deltaPOC, pps_used,
					  pps_inter_RPS_flag[cnt_i], pps_num_ref_idc[cnt_i], pps_ref_idc);
		cnt_i := cnt_i + 1;
 	end
 	read_PPS_Header.se_idx_2.loopEnd : action ==>
	guard
		se_idx = 2 and cnt_i = pps_num_short_term_ref_pic_sets
   	do
		se_idx := se_idx + 2;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_PPS_Header.se_idx_4
	 *************************************************************************/	
	read_PPS_Header.se_idx_4 : action ==>
	guard
		se_idx = 4 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do
		vld_u_name(  1, fifo, res, "long_term_ref_pics_present_flag         "); pps_long_term_ref_pics_present_flag := res[0];
		vld_u_name(  1, fifo, res, "entropy_coding_mode_flag                "); pps_entropy_coding_mode_flag    := res[0];
		if pps_entropy_coding_mode_flag = 1 then
			vld_ue_name(    fifo, res, "entropy_coding_synchro                  "); pps_entropy_coding_synchro  := res[0];
			vld_u_name(  1, fifo, res, "cabac_istate_reset                      "); pps_cabac_istate_reset      := res[0];
			if pps_entropy_coding_synchro != 0 then
				vld_ue_name(    fifo, res, "num_substreams_minus1                   "); pps_entropy_coding_synchro := res[0];
			end
		end
		vld_ue_name(    fifo, res, "num_temporal_layer_switching_point_flags"); pps_num_temporal_layer_switching_point_flags := res[0];
		foreach uint(size=8) i in 0 .. pps_num_temporal_layer_switching_point_flags - 1 do
			vld_u_name(  1, fifo, res, "temporal_layer_switching_point_flag[ ]  "); pps_temporal_layer_switching_point_flag[i]     := res[0];
		end	
		vld_u_name(  1, fifo, res, "constrained_intra_pred_flag             "); pps_constrained_intra_pred_flag   := res[0];
		vld_u_name(  2, fifo, res, "slice_granularity                       "); pps_slice_granularity             := res[0];
		if sps_cu_qp_delta_enabled_flag = 1 then
			vld_ue_name(    fifo, res, "max_cu_qp_delta_depth                   "); pps_max_cu_qp_delta_depth := res[0];
		end
		vld_u_name(  1, fifo, res, "weighted_pred_flag                      "); pps_weighted_pred_flag     := res[0];
		vld_u_name(  2, fifo, res, "weighted_bipred_idc                     "); pps_weighted_bipred_idc    := res[0];
		vld_u_name(  1, fifo, res, "tile_info_present_flag                  "); pps_tile_info_present_flag := res[0];
		pps_uniform_spacing_idc := 0;
		if pps_tile_info_present_flag = 1 then
			vld_u_name(  1, fifo, res, "uniform_spacing_idc                     "); pps_uniform_spacing_idc            := res[0];
			vld_u_name(  1, fifo, res, "tile_boundary_independence_idc          "); pps_tile_boundary_independence_idc := res[0];
			vld_ue_name(    fifo, res, "num_tile_columns_minus1                 "); pps_num_tile_columns_minus1        := res[0];
			vld_ue_name(    fifo, res, "num_tile_rows_minus1                    "); pps_num_tile_rows_minus1           := res[0];
		end
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_5
	 *************************************************************************/	
  	read_PPS_Header.se_idx_5.loop : action ==>
	guard
		se_idx = 5  and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		pps_uniform_spacing_idc = 1 and cnt_i <= pps_num_tile_columns_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "column_width[ ]                         "); pps_column_width[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end 
	read_PPS_Header.se_idx_5.loopEnd : action ==>
	guard
		se_idx = 5 and pps_uniform_spacing_idc = 1 and cnt_i > pps_num_tile_columns_minus1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_PPS_Header.se_idx_5.noLoop : action ==>
	guard
		se_idx = 5 and pps_uniform_spacing_idc = 0
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_6
	 *************************************************************************/	
	read_SPS_Header.se_idx_6.loop : action ==>
	guard
		se_idx = 6 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		pps_uniform_spacing_idc = 1 and cnt_i <= pps_num_tile_rows_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "row_height[ ]                          "); pps_row_height[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_6.loopEnd : action ==>
	guard
		se_idx = 6 and pps_uniform_spacing_idc = 1 and cnt_i > pps_num_tile_rows_minus1
   	do
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_PPS_Header_done
	 *************************************************************************/	
	read_PPS_Header_done : action ==>
	guard
		se_idx = 7
	end 	
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 1) slice_lightweight_slice_flag;
	uint(size= 2) slice_slice_type;
	uint(size= 8) slice_pps_id;
	uint(size=32) slice_aps_id;
	uint(size=10) slice_pic_order_cnt_lsb;
	uint(size= 3) slice_num_ref_idx_l0_active_minus1;
	uint(size= 3) slice_num_ref_idx_l1_active_minus1;
	uint(size= 1) slice_ref_pic_list_combination_flag;
	uint(size=32) slice_num_ref_idx_lc_active_minus1;
	uint(size= 1) slice_ref_pic_list_modification_flag_lc;
	uint(size= 1) slice_pic_from_list_0_flag[MAX_NUM_REF_LC];
	uint(size= 1) slice_ref_idx_list_curr[MAX_NUM_REF_LC];
	uint(size=32) slice_slice_address;
	 int(size=32) slice_slice_qp;
	uint(size= 1) slice_loop_filter_disable;
	uint(size= 1) slice_collocated_from_l0_flag;
	uint(size=32) wp[2][MAX_NUM_REF][3][WP_MAX_STRUCT];
	uint(size= 1) slice_symbolMode; 
	uint(size= 1) slice_drbFlag; 
	uint(size= 2) slice_erbIndex; 
	uint(size= 1) slice_tileMarkerFlag; 
	uint(size=32) slice_puiSubstreamSizes[255];
	uint(size= 5) slice_tileLocationCount_minus1;
	uint(size= 5) slice_bitsUsedByDiff_minus1;
	uint(size= 5) slice_tileLocation[32];

	/**************************************************************************
	 * read_SliceHeader.se_idx_1
	 *************************************************************************/	
	read_SliceHeader.se_idx_1 : action ==>
	guard
		se_idx = 1 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do	
		slice_num_ref_idx_l0_active_minus1 := 0;
		slice_num_ref_idx_l1_active_minus1 := 0;
		vld_u_name(  1, fifo, res, "lightweight_slice_flag                  "); slice_lightweight_slice_flag       := res[0];
		if slice_lightweight_slice_flag = 0 then
			vld_ue_name(    fifo, res, "slice_type                              "); slice_slice_type               := res[0]; // getBits(3) max
			vld_ue_name(    fifo, res, "pic_parameter_set_id                    "); slice_pps_id                   := res[0];
			if sps_sample_adaptive_offset_enabled_flag = 1 or sps_adaptive_loop_filter_enabled_flag = 1 then
				vld_ue_name(    fifo, res, "aps_id                                  "); slice_aps_id               := res[0];
			end
			vld_u_name( 10, fifo, res, "pic_order_cnt_lsb                       "); slice_pic_order_cnt_lsb            := res[0];
			if slice_slice_type = I_SLICE then
				vld_u_name(  1, fifo, res, "num_ref_idx_active_override_flag        ");
				if res[0] = 1 then
					vld_u_name(  3, fifo, res, "num_ref_idx_l0_active_minus1            "); slice_num_ref_idx_l0_active_minus1 := res[0];
					if slice_slice_type = B_SLICE then
						vld_u_name(  3, fifo, res, "num_ref_idx_l1_active_minus1            "); slice_num_ref_idx_l1_active_minus1 := res[0];
					end
				end
			end
		end	
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_2
	 *************************************************************************/	
	read_SliceHeader.se_idx_2 : action ==>
	guard
		se_idx = 2 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do	
   		slice_ref_pic_list_combination_flag     := 0;
   		slice_ref_pic_list_modification_flag_lc := 0;
		if slice_slice_type = B_SLICE then
			vld_u_name(  1, fifo, res, "ref_pic_list_combination_flag           "); slice_ref_pic_list_combination_flag         := res[0];
			if slice_ref_pic_list_combination_flag = 1 then
				vld_ue_name(    fifo, res, "num_ref_idx_lc_active_minus1            "); slice_num_ref_idx_lc_active_minus1      := res[0];
				vld_u_name(  1, fifo, res, "ref_pic_list_modification_flag_lc       "); slice_ref_pic_list_modification_flag_lc := res[0];
				if slice_ref_pic_list_modification_flag_lc = 1 then
		   			foreach uint(size=8) i in 0 .. slice_num_ref_idx_lc_active_minus1 do
						vld_u_name(  1, fifo, res, "pic_from_list_0_flag                    "); slice_pic_from_list_0_flag[i]   := res[0];
						vld_ue_name(    fifo, res, "ref_idx_list_curr                       "); slice_ref_idx_list_curr[i]      := res[0];
		   			end
		   		end
			end
		end
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_3
	 *************************************************************************/	
	read_SliceHeader.se_idx_3 : action ==>
	guard
		se_idx = 3 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=32) iNumCUs = ( (sps_pic_width_in_luma_samples  + sps_maxCUWidth - 1) / sps_maxCUWidth ) * 
	 							( (sps_pic_height_in_luma_samples + sps_maxCUDepth - 1) / sps_maxCUDepth),
	 	uint(size=32) iNumParts = (1<<(pps_slice_granularity<<1)),
	 	uint(size=32) iReqBitsOuter := 0,
	 	uint(size=32) iReqBitsInner := 0
   	do	
   		while iNumCUs   > (1 << iReqBitsOuter) do iReqBitsOuter := iReqBitsOuter + 1; end
  		while iNumParts > (1 << iReqBitsInner) do iReqBitsInner := iReqBitsInner + 1; end
		vld_u_name(  1, fifo, res, "first_slice_in_pic_flag                 ");
		if res[0] = 0 then
			vld_u_name( iReqBitsOuter+iReqBitsInner , fifo, res, "slice_address                           "); slice_slice_address := res[0];
		end
		vld_se_name(    fifo, res, "slice_qp                                "); slice_slice_qp                    := res[0];
		vld_u_name(  1, fifo, res, "loop_filter_disable                     "); slice_loop_filter_disable         := res[0];
		if slice_slice_type = B_SLICE then
			vld_u_name(  1, fifo, res, "collocated_from_l0_flag                 "); slice_collocated_from_l0_flag := res[0];
		end
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_4
	 *************************************************************************/	
	 procedure initWpScaling()
	 begin
		foreach uint(size=8) e in 0 .. 1 do
			foreach uint(size=8) i in 0 .. MAX_NUM_REF-1 do
				foreach uint(size=8) yuv in 0 .. 2 do
					if wp[e][i][yuv][WP_PRESENT_FLAG] = 1 then
						wp[e][i][yuv][WP_I_WEIGHT] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]);
						wp[e][i][yuv][WP_I_OFFSET] := 0;
					end
					wp[e][i][yuv][WP_W]     := wp[e][i][yuv][WP_I_WEIGHT];
					wp[e][i][yuv][WP_O]     := wp[e][i][yuv][WP_I_OFFSET] * (1);
					wp[e][i][yuv][WP_SHIFT] := wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM];
					if wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM] >= 1 then
						wp[e][i][yuv][WP_ROUND] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]) - 1;
					else
						wp[e][i][yuv][WP_ROUND] := 0;
					end
				end
			end
		end
	end
   	read_SliceHeader.se_idx_4.useWP : action ==>
	guard
		se_idx = 4 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and 
		(pps_weighted_pred_flag  = 1 and slice_slice_type = P_SLICE) or 
		(pps_weighted_bipred_idc = 1 and slice_slice_type = B_SLICE)
	var
		 int(size=32) res[1],
		uint(size=32) uiLog2WeightDenomLuma[1],
		uint(size=32) uiLog2WeightDenomChroma[1],
		uint(size= 2) iRefIdxMax
   	do	
		vld_ue_name(    fifo, uiLog2WeightDenomLuma,   "luma_log2_weight_denom                  ");
		vld_ue_name(    fifo, uiLog2WeightDenomChroma, "chroma_log2_weight_denom                ");
		foreach uint(size=8) iNumRef in 0 .. slice_slice_type do
			iRefIdxMax := slice_num_ref_idx_l0_active_minus1;
			if iNumRef = REF_PIC_LIST_1 then
				iRefIdxMax := slice_num_ref_idx_l1_active_minus1;
			end
			foreach uint(size=8) iRefIdx in 0 .. iRefIdxMax do
				wp[iNumRef][iRefIdx][0][WP_LOG2_WEIGHT_DENOM] := uiLog2WeightDenomLuma[0];
	       		wp[iNumRef][iRefIdx][1][WP_LOG2_WEIGHT_DENOM] := uiLog2WeightDenomChroma[0];
	       		wp[iNumRef][iRefIdx][2][WP_LOG2_WEIGHT_DENOM] := uiLog2WeightDenomChroma[0];
				vld_u_name(  1, fifo, res, "luma_weight_l0_flag                     ");
				wp[iNumRef][iRefIdx][0][WP_PRESENT_FLAG] := res[0];
				if res[0] = 1 then
					vld_se_name(    fifo, res, "luma_weight_l0                          ");
					wp[iNumRef][iRefIdx][0][WP_I_WEIGHT]:= res[0];
					vld_se_name(    fifo, res, "luma_offset_l0                          ");
					wp[iNumRef][iRefIdx][0][WP_I_OFFSET]:= res[0];				
				else
					wp[iNumRef][iRefIdx][0][WP_I_WEIGHT] := (1 << uiLog2WeightDenomLuma[0]);
					wp[iNumRef][iRefIdx][0][WP_I_OFFSET] := 0;
				end
				vld_u_name(  1, fifo, res, "chroma_weight_l0_flag                   ");
				wp[iNumRef][iRefIdx][1][WP_PRESENT_FLAG] := res[0];
				wp[iNumRef][iRefIdx][2][WP_PRESENT_FLAG] := res[0];
				if res[0] = 1 then
					foreach uint(size=8) i in 1 .. 2 do
						vld_se_name(    fifo, res, "luma_weight_l0                          ");
						wp[iNumRef][iRefIdx][i][WP_I_WEIGHT]:= res[0];
						vld_se_name(    fifo, res, "luma_offset_l0                          ");
						wp[iNumRef][iRefIdx][i][WP_I_OFFSET]:= res[0];
					end
				else
					foreach uint(size=8) i in 1 .. 2 do
						wp[iNumRef][iRefIdx][i][WP_I_WEIGHT] := (1 << uiLog2WeightDenomChroma[0]);
						wp[iNumRef][iRefIdx][i][WP_I_OFFSET] := 0;
					end
				end
     		end
			foreach uint(size=8) iRefIdx in 0 .. MAX_NUM_REF-1 do
				wp[iNumRef][iRefIdx][0][WP_PRESENT_FLAG] := 0;
				wp[iNumRef][iRefIdx][1][WP_PRESENT_FLAG] := 0;
				wp[iNumRef][iRefIdx][2][WP_PRESENT_FLAG] := 0;
			end
		end
		initWpScaling();
	    se_idx := se_idx + 1;
	end
	read_SliceHeader.se_idx_4.noUseWP : action ==>
	guard
		se_idx = 4 and 
		(pps_weighted_pred_flag  != 1 or slice_slice_type != P_SLICE) and 
		(pps_weighted_bipred_idc != 1 or slice_slice_type != B_SLICE)
   	do	
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_5
	 *************************************************************************/	
	read_SliceHeader.se_idx_5 : action ==>
	guard
		se_idx = 5 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do	
 		slice_tileMarkerFlag := 0;
   		if slice_lightweight_slice_flag = 0 then
 			vld_u_name(  1, fifo, res, "symbolMode                              "); slice_symbolMode     := res[0];
 			vld_u_name(  1, fifo, res, "drbFlag                                 "); slice_drbFlag        := res[0];
 			if res[0] = 0 then
	 			vld_u_name(  2, fifo, res, "erbIndex                                "); slice_erbIndex   := res[0];
 			end
 			if sps_tile_boundary_independence_idc = 1 then
 				vld_u_name(  1, fifo, res, "tileMarkerFlag                          "); slice_tileMarkerFlag := res[0];
 			end
 		end
 		if pps_entropy_coding_synchro = 1 then
 			foreach uint(size=8) ui in 0 .. pps_num_substreams_minus1 do
 				vld_u_name(  2, fifo, res, "substreamByteSizes");
 				if res[0] > 3 then
 					println("Error in parseSliceHeader");
 				else
 					vld_u_name(  8<<res[0], fifo, res, "substreamSizes[ ]                    "); slice_puiSubstreamSizes[ui] := res[0]; 				
 				end
 				
 			end
 		end
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_6
	 *************************************************************************/
	read_SliceHeader.se_idx_6 : action ==>
	guard
		se_idx = 6 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		 int(size= 5) iLastSize,
         int(size= 5) iCurDiff,
        uint(size= 1) iSign
   	do	
   		if slice_lightweight_slice_flag = 0 then
   			if sps_tile_boundary_independence_idc = 1 then
 				vld_u_name(  1, fifo, res, "tileLocationInformationInSliceHeaderFlag");
 				if res[0] = 1 then
	 				vld_u_name(  5, fifo, res, "tileLocationCount_minus1                "); slice_tileLocationCount_minus1 := res[0];
	 				vld_u_name(  5, fifo, res, "bitsUsedByDiff_minus1                   "); slice_bitsUsedByDiff_minus1    := res[0];
	 				iLastSize := 0;
	 				foreach uint(size=8) uiIdx in 0 .. slice_tileLocationCount_minus1 do
	 					if uiIdx = 0 then
			 				vld_u_name(  slice_bitsUsedByDiff_minus1, fifo, res, "tileLocation                            ");
			 				slice_tileLocation[uiIdx] := res[0];
			 				iCurDiff  := res[0];
            				iLastSize := res[0];
	 					else
	 						vld_u_name(  1, fifo, res, "sign                                    "); iSign := res[0];	 					
	 						vld_u_name(  slice_bitsUsedByDiff_minus1, fifo, res, "tileLocation                            ");
	 						if iSign = 1 then iCurDiff  := -res[0]; else iCurDiff := res[0]; end 
            				iLastSize := iLastSize + iCurDiff;
			 				slice_tileLocation[uiIdx] := slice_tileLocation[uiIdx-1] + iLastSize;
	 					end
	 				end
 				end
 			end
 		end
 		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader_done
	 *************************************************************************/	
	read_SliceHeader_done : action ==>
	guard
		se_idx = 7
	end 	
	
	/**************************************************************************
	 **************************************************************************
	 ********        undefined                            *********************
	 **************************************************************************
	 *************************************************************************/
  	bool actorNotFinished := true;
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("Algo_Parser doesn't manage this case yet");
		actorNotFinished := false;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        schedule                             *********************
	 **************************************************************************
	 *************************************************************************/
  	schedule fsm start_code:
		// byte align
		byte_align          			( byte_align_a						) --> start_code;
		// search start code
		start_code          			( start_code.search					) --> start_code;
		start_code			            ( start_code.done					) --> read_Nal_unit_header;
		// read Nal Unit header
		read_Nal_unit_header			( read_nal_unit_header				) --> find_header;
		find_header	  					( look_for.SPS_header	  			) --> read_SPS_Header;
		find_header	  					( look_for.PPS_header	  			) --> read_PPS_Header;
		find_header	  					( look_for.Slice_header	  			) --> read_SliceHeader;
		find_header	  					( look_for_other_header				) --> byte_align;
		// read SPS header
		read_SPS_Header	  				( read_SPS_Header	    			) --> read_SPS_Header;
		read_SPS_Header	  				( read_SPS_Header_done    			) --> byte_align;
		// read PPS header
		read_PPS_Header 				( read_PPS_Header   				) --> read_PPS_Header;
		read_PPS_Header	  				( read_PPS_Header_done    			) --> byte_align;
		// read_SliceHeader
		read_SliceHeader				( read_SliceHeader					) --> read_SliceHeader;
		read_SliceHeader				( read_SliceHeader_done				) --> byte_align;
		
		
		
		
		// undefined
		undefined	  					( undefined		    				) --> undefined;
	end
	
	/**************************************************************************
	 * priority
	 *************************************************************************/
	priority
		look_for        > look_for_other_header;
	end
end