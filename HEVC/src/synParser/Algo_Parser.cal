package synParser;

import  common.BitstreamReadUtils.*;
import  synParser.Algo_ParserUtils.*;

actor Algo_Parser () 
				uint(size= 8) byte
				==>
:
	bool DEBUG = true;
	uint(size= 8) se_idx;
	uint(size=32) cnt_i;
	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
	uint(size= 8) fifo[FIFO_SIZE];
	uint(size= 8) fifo_idx            :=  0;
	uint(size= 8) bit_read_cnt[1]     := [0];
	uint(size=24) startCode           :=  0;
	bool          searchStartCodeFlag := true;
	/* */
 	action byte:[ b ] ==>
	guard 
		(searchStartCodeFlag = false and bit_read_cnt[0] <= (FIFO_SIZE-1)<<3 ) or
		(searchStartCodeFlag = true  and bit_read_cnt[0] <  24)
	var
		uint(size=4) fifo_idx2 = (fifo_idx-2) & (FIFO_SIZE-1),
		uint(size=4) fifo_idx1 = (fifo_idx-1) & (FIFO_SIZE-1)
	do
		if fifo[fifo_idx2] != 0 or fifo[fifo_idx1] != 0 or b != EPR_VALUE then
			fifo[fifo_idx]  := b;
			bit_read_cnt[0] := bit_read_cnt[0] + 8;
			if DEBUG then
				println("fifo["+fifo_idx+"] := "+b+" \t: "+bit_read_cnt[0]);
			end
			fifo_idx        := (fifo_idx+1) & (FIFO_SIZE-1);
		end
		startCode           := ((startCode << 8) + b) & 0x00FFFFFF;
	end
	/**************************************************************************
	 **************************************************************************
	 ********        NAL UNTI                             *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		startCode != START_CODE_VALUE and searchStartCodeFlag = true and bit_read_cnt[0] > 23
   	do
		flushBits(bit_read_cnt, 8);
		if DEBUG then		
   			println("start_code.search : "+startCode);
   		end
	end
	start_code.done: action ==>
	guard
		startCode = START_CODE_VALUE and searchStartCodeFlag = true and bit_read_cnt[0] > 23
	do
		flushBits(bit_read_cnt, 24);
		searchStartCodeFlag := false;
		if DEBUG then
			println("start_code.done : "+startCode);
		end
	end
	/**************************************************************************
	 * read_nal_unit_header
	 *************************************************************************/
	uint(size=6) nal_unit_type;
	uint(size=1) nal_ref_flag;
	uint(size=3) temporal_id;
	uint(size=1) output_flag;
	
	read_nal_unit_header : action ==>
	var
		uint(size=32) res[1]
	do
		flushBits(bit_read_cnt, 1);
		vld_u(bit_read_cnt, 2, fifo, fifo_idx, res);
		nal_ref_flag  := res[0];
		vld_u(bit_read_cnt, 5, fifo, fifo_idx, res);
		nal_unit_type := res[0];
		temporal_id   := 0;
		output_flag   := 1; 
		if DEBUG then
			println("=========== NAL_UNIT ===========");
			println("          reserved_zero_1bits                      u(1) : 0");
			println("          nal_ref_flag                             u(2) : "+nal_ref_flag);
			println("          nal_unit_type                            u(8) : "+nal_unit_type);
		end
	end
	/**************************************************************************
	 * look_for.SPS_header
	 *************************************************************************/
	look_for.SPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_SPS
	do
		se_idx := 1;
		if DEBUG then
			println("=========== Sequence Parameter Set ID    ===========");
		end
	end
	/**************************************************************************
	 * look_for.PPS_header
	 *************************************************************************/
	look_for.PPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_PPS
	do
		se_idx := 1;
		if DEBUG then
			println("=========== Picture Parameter Set ID    ===========");
		end
	end
	/**************************************************************************
	 * look_for.Slice_header
	 *************************************************************************/
	look_for.Slice_header: action ==>
	guard
		(nal_unit_type = NAL_UNIT_NON_IDR_AND_NON_CRA or
		 nal_unit_type = NAL_UNIT_CRA                 or
		 nal_unit_type = NAL_UNIT_IDR)
	var
		uint(size=32) res[1]
	do
		vld_u(bit_read_cnt, 3, fifo, fifo_idx, res);
		temporal_id  := res[0];
		vld_u(bit_read_cnt, 1, fifo, fifo_idx, res);
		output_flag := res[0];
		flushBits(bit_read_cnt, 4);
		if DEBUG then
			println("          temporal_id                              u(3) : "+temporal_id);
			println("          output_flag                              u(1) : "+output_flag);
			println("          reserved_zero_4bits                      u(4) : 0");
			println("=========== Slice ===========");
		end
	end
	/**************************************************************************
	 * look_for_other_header
	 *************************************************************************/
	look_for_other_header: action ==>
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Sequence Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) sps_profile_idc;
	uint(size= 8) sps_level_idc;
	uint(size= 8) sps_sps_id;
	uint(size= 8) sps_max_temporal_layers_minus1;
	uint(size=16) sps_pic_width_in_luma_samples;
	uint(size=16) sps_pic_height_in_luma_samples;
	uint(size= 3) sps_bit_depth_luma_minus8;
	uint(size= 3) sps_bit_depth_chroma_minus8;
	uint(size= 4) sps_pcm_bit_depth_luma_minus1; 
	uint(size= 4) sps_pcm_bit_depth_chroma_minus1;
	uint(size= 1) sps_disableInter4x4;
	uint(size= 8) sps_log2_min_coding_block_size_minus3;
	uint(size= 8) sps_log2_diff_max_min_coding_block_size;	
	uint(size=32) sps_log2_min_transform_block_size_minus2;
	uint(size=32) sps_log2_diff_max_min_transform_block_size;
	uint(size=32) sps_log2_min_pcm_coding_block_size_minus3;
	uint(size=32) sps_max_transform_hierarchy_depth_inter;
	uint(size=32) sps_max_transform_hierarchy_depth_intra;
	uint(size= 1) sps_chroma_pred_from_luma_enabled_flag;
	uint(size= 1) sps_loop_filter_across_slice_flag;
	uint(size= 1) sps_sample_adaptive_offset_enabled_flag;
	uint(size= 1) sps_adaptive_loop_filter_enabled_flag;
	uint(size= 1) sps_pcm_loop_filter_disable_flag;
	uint(size= 1) sps_cu_qp_delta_enabled_flag;
	uint(size= 1) sps_temporal_id_nesting_flag;
	uint(size=32) sps_padX;
	uint(size=32) sps_padY;
	uint(size= 1) sps_useLDC;
	uint(size= 1) sps_useMRG;
	uint(size= 1) sps_amvpMode[MAX_TLAYER];
	uint(size=32) sps_maxNumRefFrames;
	uint(size= 1) sps_uniform_spacing_idc;
	uint(size= 1) sps_tile_boundary_independence_idc;
	uint(size= 1) sps_num_tile_columns_minus1;
	uint(size= 1) sps_num_tile_rows_minus1;	
	uint(size=32) sps_column_width[32];
	uint(size=32) sps_row_height[32];

	/**************************************************************************
	 * read_SPS_Header.se_idx_1
	 *************************************************************************/
	read_SPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1
	var
		uint(size=32) res[1]
	do
		vld_u( bit_read_cnt,  8, fifo, fifo_idx, res); sps_profile_idc                := res[0];
		flushBits(bit_read_cnt, 8);
		vld_u( bit_read_cnt,  8, fifo, fifo_idx, res); sps_level_idc                  := res[0];
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_sps_id                     := res[0]; // getBits(10) max
		vld_u( bit_read_cnt,  3, fifo, fifo_idx, res); sps_max_temporal_layers_minus1 := res[0];
		vld_u( bit_read_cnt, 16, fifo, fifo_idx, res); sps_pic_width_in_luma_samples  := res[0];
		se_idx := se_idx + 1;
		if DEBUG then
			println("          profile_idc                              u(8) : "+sps_profile_idc);
			println("          reserved_zero_8bits                      u(8) : 0");
			println("          level_idc                                u(8) : "+sps_level_idc);
			println("          seq_parameter_set_id                     u(v) : "+sps_sps_id);
			println("          max_temporal_layers_minus1               u(3) : "+sps_max_temporal_layers_minus1);
			println("          pic_width_in_luma_samples                u(16) : "+sps_pic_width_in_luma_samples );
		end
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_2
	 *************************************************************************/
	read_SPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2
	var
		uint(size=32) res[1]
   	do
		vld_u( bit_read_cnt, 16, fifo, fifo_idx, res); sps_pic_height_in_luma_samples := res[0];
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_bit_depth_luma_minus8      := res[0]; // getBits(5) max
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_bit_depth_chroma_minus8    := res[0]; // getBits(5) max
		vld_u( bit_read_cnt,  4, fifo, fifo_idx, res); sps_pcm_bit_depth_luma_minus1  := res[0];
		vld_u( bit_read_cnt,  4, fifo, fifo_idx, res); sps_pcm_bit_depth_chroma_minus1:= res[0];		
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_disableInter4x4            := res[0];		
		se_idx := se_idx + 1;
		if DEBUG then
			println("          pic_height_in_luma_samples               u(16) : "+sps_pic_height_in_luma_samples );
			println("          bit_depth_luma_minus8                    u(v) : "+sps_bit_depth_luma_minus8 );
			println("          bit_depth_chroma_minus8                  u(v) : "+sps_bit_depth_chroma_minus8 );
			println("          pcm_bit_depth_luma_minus1                u(4) : "+sps_pcm_bit_depth_luma_minus1 );
			println("          pcm_bit_depth_chroma_minus1              u(4) : "+sps_pcm_bit_depth_chroma_minus1 );
		end
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_3
	 *************************************************************************/
	read_SPS_Header.se_idx_3 : action ==>
	guard
		se_idx = 3
	var
		uint(size=32) res[1]
   	do
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_log2_min_coding_block_size_minus3      := res[0]; // getBits(7) max
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_log2_diff_max_min_coding_block_size    := res[0]; // getBits(32) max ?????
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_log2_min_transform_block_size_minus2   := res[0]; // getBits(32) max ?????
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_log2_diff_max_min_transform_block_size := res[0]; // getBits(32) max ?????
		se_idx := se_idx + 1;
		if DEBUG then
			println("          log2_min_coding_block_size_minus3        u(v) : "+sps_log2_min_coding_block_size_minus3 );
			println("          log2_diff_max_min_coding_block_size      u(v) : "+sps_log2_diff_max_min_coding_block_size );
			println("          log2_min_transform_block_size_minus2     u(v) : "+sps_log2_min_transform_block_size_minus2 );
			println("          log2_diff_max_min_transform_block_size   u(v) : "+sps_log2_diff_max_min_transform_block_size );
		end
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_4
	 *************************************************************************/	
	read_SPS_Header.se_idx_4 : action ==>
	guard
		se_idx = 4
	var
		uint(size=32) res[1]
   	do
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_log2_min_pcm_coding_block_size_minus3 := res[0]; // getBits(32) max ?????
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_max_transform_hierarchy_depth_inter   := res[0]; // getBits(32) max ?????
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_max_transform_hierarchy_depth_intra   := res[0]; // getBits(32) max ?????
		se_idx := se_idx + 1;
		if DEBUG then
			println("          log2_min_pcm_coding_block_size_minus3    u(v) : "+sps_log2_min_pcm_coding_block_size_minus3 );
			println("          max_transform_hierarchy_depth_inter      u(v) : "+sps_max_transform_hierarchy_depth_inter );
			println("          max_transform_hierarchy_depth_intra      u(v) : "+sps_max_transform_hierarchy_depth_intra );
		end
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_5
	 *************************************************************************/	
	read_SPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5
	var
		uint(size=32) res[1]
   	do
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_chroma_pred_from_luma_enabled_flag  := res[0];
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_loop_filter_across_slice_flag       := res[0];
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_sample_adaptive_offset_enabled_flag := res[0];
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_adaptive_loop_filter_enabled_flag   := res[0];
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_pcm_loop_filter_disable_flag        := res[0];
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_cu_qp_delta_enabled_flag            := res[0];
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_temporal_id_nesting_flag            := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
		if DEBUG then
			println("          chroma_pred_from_luma_enabled_flag       u(1) : "+sps_chroma_pred_from_luma_enabled_flag );
			println("          loop_filter_across_slice_flag            u(1) : "+sps_loop_filter_across_slice_flag );
			println("          sample_adaptive_offset_enabled_flag      u(1) : "+sps_sample_adaptive_offset_enabled_flag );
			println("          adaptive_loop_filter_enabled_flag        u(1) : "+sps_adaptive_loop_filter_enabled_flag );
			println("          pcm_loop_filter_disable_flag             u(1) : "+sps_pcm_loop_filter_disable_flag );
			println("          cu_qp_delta_enabled_flag                 u(1) : "+sps_cu_qp_delta_enabled_flag );
			println("          temporal_id_nesting_flag                 u(1) : "+sps_temporal_id_nesting_flag );
		end
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_6
	 *************************************************************************/
	read_SPS_Header.se_idx_6 : action ==>
	guard
		se_idx = 6
	var
		uint(size= 8) uiAddCUDepth := 0,
		uint(size=32) maxCUWidth,
		uint(size= 8) maxCUDepth,
		uint(size=32) res[1]
   	do
		maxCUWidth  := 1<<(sps_log2_min_coding_block_size_minus3 + 3 + sps_log2_diff_max_min_coding_block_size);
  		while( ( maxCUWidth >> sps_log2_diff_max_min_coding_block_size ) > ( 1 << ( sps_log2_min_transform_block_size_minus2 + 2 + uiAddCUDepth )  ) ) 
  		do
  			uiAddCUDepth := uiAddCUDepth + 1;
  		end    
  		maxCUDepth := sps_log2_diff_max_min_coding_block_size + uiAddCUDepth;


		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_padX                := res[0]; // getBits(32) max ?????
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_padY                := res[0]; // getBits(32) max ?????
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_useLDC              := res[0];
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_useMRG              := res[0];

   		foreach uint(size=8) i in 0 .. maxCUDepth - 1 do
   			vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_amvpMode[i]     := res[0];
			if DEBUG then
				//println("          amvpMode["+i+"]                              u(1) : "+sps_amvpMode[i] );
			end
		end
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res);
		if res[0] = 1 then
			vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_maxNumRefFrames := res[0]; // getBits(32) max ?????
			if DEBUG then
				//println("          maxNumRefFrames                              u(1) : "+maxNumRefFrames );
			end
		end
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_7
	 *************************************************************************/	
	read_SPS_Header.se_idx_7 : action ==>
	guard
		se_idx = 7
	var
		uint(size=32) res[1]
   	do
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_uniform_spacing_idc            := res[0];
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); sps_tile_boundary_independence_idc := res[0];
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_num_tile_columns_minus1        := res[0];
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_num_tile_rows_minus1           := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
		if DEBUG then
			println("          uniform_spacing_idc                      u(1) : "+sps_uniform_spacing_idc );
			println("          tile_boundary_independence_idc           u(1) : "+sps_tile_boundary_independence_idc );
			println("          num_tile_columns_minus1                  u(v) : "+sps_num_tile_columns_minus1 );
			println("          num_tile_rows_minus1                     u(v) : "+sps_num_tile_rows_minus1 );
		end
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_8
	 *************************************************************************/	
	read_SPS_Header.se_idx_8.loop : action ==>
	guard
		se_idx = 8 and sps_uniform_spacing_idc = 1 and cnt_i <= sps_num_tile_columns_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_column_width[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
		if DEBUG then
			println("          column_width["+cnt_i+"]                          u(v) : "+sps_column_width[cnt_i] );
		end
	end 
	read_SPS_Header.se_idx_8.loopEnd : action ==>
	guard
		se_idx = 8 and sps_uniform_spacing_idc = 1 and cnt_i > sps_num_tile_columns_minus1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_SPS_Header.se_idx_8.noLoop : action ==>
	guard
		se_idx = 8 and sps_uniform_spacing_idc = 0
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_9
	 *************************************************************************/	
	read_SPS_Header.se_idx_9.loop : action ==>
	guard
		se_idx = 9 and sps_uniform_spacing_idc = 1 and cnt_i <= sps_num_tile_rows_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); sps_row_height[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
		if DEBUG then
			println("          row_height["+cnt_i+"]                          u(v) : "+sps_row_height[cnt_i] );
		end
	end 
	read_SPS_Header.se_idx_9.loopEnd : action ==>
	guard
		se_idx = 9 and sps_uniform_spacing_idc = 1 and cnt_i > sps_num_tile_rows_minus1
   	do
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header_done
	 *************************************************************************/	
	read_SPS_Header_done : action ==>
	guard
		se_idx = 10
	do
		byte_align(bit_read_cnt);
		searchStartCodeFlag := true;
	end 
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size=32) pps_pps_id;
	uint(size=32) pps_sps_id;
	uint(size= 1) pps_entropy_coding_mode_flag;
	uint(size=32) pps_entropy_coding_synchro;
	uint(size= 1) pps_cabac_istate_reset;
	uint(size=32) pps_num_substreams_minus1;
	uint(size= 8) pps_num_temporal_layer_switching_point_flags;
	uint(size= 1) pps_temporal_layer_switching_point_flag[MAX_TLAYER];
	uint(size= 1) pps_constrained_intra_pred_flag;
	uint(size= 2) pps_slice_granularity;
	uint(size=32) pps_max_cu_qp_delta_depth;
	uint(size= 1) pps_weighted_pred_flag;
	uint(size= 2) pps_weighted_bipred_idc;
	uint(size= 1) pps_tile_info_present_flag;
	uint(size= 1) pps_uniform_spacing_idc;
	uint(size= 1) pps_tile_boundary_independence_idc;
	uint(size=32) pps_num_tile_columns_minus1;
	uint(size=32) pps_num_tile_rows_minus1;
	uint(size=32) pps_column_width[32];
	uint(size=32) pps_row_height[32];
	/**************************************************************************
	 * read_PPS_Header.se_idx_1
	 *************************************************************************/	
	read_PPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1
	var
		uint(size=32) res[1]
   	do
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); pps_pps_id                     := res[0];
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); pps_sps_id                     := res[0];
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); pps_entropy_coding_mode_flag   := res[0];
		if DEBUG then
			println("          pic_parameter_set_id                     u(v) : "+pps_pps_id );
			println("          seq_parameter_set_id                     u(v) : "+pps_sps_id );
			println("          pps_entropy_coding_mode_flag             u(1) : "+pps_entropy_coding_mode_flag );
		end
		if pps_entropy_coding_mode_flag = 1 then
			vld_ue(bit_read_cnt,     fifo, fifo_idx, res); pps_entropy_coding_synchro := res[0];
			vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); pps_cabac_istate_reset     := res[0];
			if DEBUG then
				println("          entropy_coding_synchro                   u(v) : "+pps_entropy_coding_synchro );
				println("          pps_cabac_istate_reset                   u(1) : "+pps_cabac_istate_reset );
			end
			if pps_entropy_coding_synchro != 0 then
				vld_ue(bit_read_cnt,     fifo, fifo_idx, res); pps_entropy_coding_synchro := res[0];
				if DEBUG then
					println("          num_substreams_minus1                    u(v) : "+pps_num_substreams_minus1 );
				end
			end
		end
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); pps_num_temporal_layer_switching_point_flags := res[0];
		if DEBUG then
			println("          num_temporal_layer_switching_point_flags     u(v) : "+pps_num_temporal_layer_switching_point_flags );
		end
		foreach uint(size=8) i in 0 .. pps_num_temporal_layer_switching_point_flags - 1 do
			vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); pps_temporal_layer_switching_point_flag[i]     := res[0];
			if DEBUG then
				println("          pps_temporal_layer_switching_point_flag["+i+"]   u(v) : "+pps_temporal_layer_switching_point_flag[i] );
			end		
		end	
		se_idx := se_idx + 1;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_2
	 *************************************************************************/	
	read_PPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2
	var
		uint(size=32) res[1]
   	do
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); pps_constrained_intra_pred_flag   := res[0];
		vld_u( bit_read_cnt,  2, fifo, fifo_idx, res); pps_slice_granularity             := res[0];
		if DEBUG then
			println("          constrained_intra_pred_flag             u(1) : "+pps_constrained_intra_pred_flag );
			println("          slice_granularity                       u(2) : "+pps_slice_granularity );
		end
		if sps_cu_qp_delta_enabled_flag = 1 then
			vld_ue(bit_read_cnt,     fifo, fifo_idx, res); pps_max_cu_qp_delta_depth := res[0];
			if DEBUG then
				println("          max_cu_qp_delta_depth                   u(v) : "+pps_max_cu_qp_delta_depth );
			end
		end
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); pps_weighted_pred_flag     := res[0];
		vld_u( bit_read_cnt,  2, fifo, fifo_idx, res); pps_weighted_bipred_idc    := res[0];
		vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); pps_tile_info_present_flag := res[0];
		if DEBUG then
			println("          weighted_pred_flag                      u(1) : "+pps_weighted_pred_flag );
			println("          weighted_bipred_idc                     u(2) : "+pps_weighted_bipred_idc );
			println("          tile_info_present_flag                  u(2) : "+pps_tile_info_present_flag );
		end
		pps_uniform_spacing_idc := 0;
		if pps_tile_info_present_flag = 1 then
			vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); pps_uniform_spacing_idc            := res[0];
			vld_u( bit_read_cnt,  1, fifo, fifo_idx, res); pps_tile_boundary_independence_idc := res[0];
			vld_ue(bit_read_cnt,     fifo, fifo_idx, res); pps_num_tile_columns_minus1        := res[0];
			vld_ue(bit_read_cnt,     fifo, fifo_idx, res); pps_num_tile_rows_minus1           := res[0];
			if DEBUG then
				println("          uniform_spacing_idc                     u(1) : "+pps_uniform_spacing_idc );
				println("          tile_boundary_independence_idc          u(1) : "+pps_tile_boundary_independence_idc );
				println("          num_tile_columns_minus1                 u(v) : "+pps_num_tile_columns_minus1 );
				println("          num_tile_rows_minus1                    u(v) : "+pps_num_tile_rows_minus1 );
			end	
		end
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_3
	 *************************************************************************/	
  	read_PPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3 and pps_uniform_spacing_idc = 1 and cnt_i <= pps_num_tile_columns_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); pps_column_width[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
		if DEBUG then
			println("          column_width["+cnt_i+"]                          u(v) : "+pps_column_width[cnt_i] );
		end
	end 
	read_PPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3 and pps_uniform_spacing_idc = 1 and cnt_i > pps_num_tile_columns_minus1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_PPS_Header.se_idx_3.noLoop : action ==>
	guard
		se_idx = 3 and pps_uniform_spacing_idc = 0
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_4
	 *************************************************************************/	
	read_SPS_Header.se_idx_4.loop : action ==>
	guard
		se_idx = 4 and pps_uniform_spacing_idc = 1 and cnt_i <= pps_num_tile_rows_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue(bit_read_cnt,     fifo, fifo_idx, res); pps_row_height[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
		if DEBUG then
			println("          row_height["+cnt_i+"]                          u(v) : "+pps_row_height[cnt_i] );
		end
	end 
	read_SPS_Header.se_idx_4.loopEnd : action ==>
	guard
		se_idx = 4 and pps_uniform_spacing_idc = 1 and cnt_i > pps_num_tile_rows_minus1
   	do
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_PPS_Header_done
	 *************************************************************************/	
	read_PPS_Header_done : action ==>
	guard
		se_idx = 5
	end 	
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	read_SliceHeader : action ==>
	end
	
	/**************************************************************************
	 **************************************************************************
	 ********        undefined                            *********************
	 **************************************************************************
	 *************************************************************************/
  	bool actorNotFinished := true;
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("Algo_Parser doesn't manage this case yet");
		actorNotFinished := false;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        schedule                             *********************
	 **************************************************************************
	 *************************************************************************/
  	schedule fsm start_code:
		// search start code
		start_code          			( start_code.search					) --> start_code;
		start_code			            ( start_code.done					) --> read_Nal_unit_header;
		// read Nal Unit header
		read_Nal_unit_header			( read_nal_unit_header				) --> find_header;
		find_header	  					( look_for.SPS_header	  			) --> read_SPS_Header;
		find_header	  					( look_for.PPS_header	  			) --> read_PPS_Header;
		find_header	  					( look_for.Slice_header	  			) --> read_SliceHeader;
		find_header	  					( look_for_other_header				) --> read_Nal_unit_header;
		// read SPS header
		read_SPS_Header	  				( read_SPS_Header	    			) --> read_SPS_Header;
		read_SPS_Header	  				( read_SPS_Header_done    			) --> start_code;
		// read PPS header
		read_PPS_Header 				( read_PPS_Header   				) --> read_PPS_Header;
		read_PPS_Header	  				( read_PPS_Header_done    			) --> undefined;
		// read_SliceHeader
		read_SliceHeader				( read_SliceHeader					) --> undefined;
		
		
		
		
		// undefined
		undefined	  					( undefined		    				) --> undefined;
	end
	
	/**************************************************************************
	 * priority
	 *************************************************************************/
	priority
		look_for        > look_for_other_header;
	end
end