package synParser;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  synParser.Algo_ParserUtils.*;

actor Algo_Parser () 
				uint(size= 8) byte
				==>
:
	bool DEBUG_BITSTREAM = true;
	uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL];
	uint(size= 2) zeroByte := 0;
	uint(size= 8) se_idx;
	uint(size=32) cnt_i;
	uint(size= 5) nalUnit[NAL_UNIT_STRUCT_SIZE];
	uint(size=32) sps[NB_MAX_SPS][SPS_STRUCT_SIZE];
	uint(size=10) sps_id;
	uint(size=32) pps[NB_MAX_PPS][PPS_STRUCT_SIZE];
	uint(size=10) pps_id;
	 int(size=32) slice[SLICE_STRUCT_SIZE];
	uint(size=32) wp[2][MAX_NUM_REF][3][WP_MAX_STRUCT];
	 
	/**************************************************************************
	 **************************************************************************
	 ********        Bitstream Reader                     *********************
	 **************************************************************************
	 *************************************************************************/
	
	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
 	action byte:[ b ] ==>
	guard 
		fifo[FIFO_CPT_BITS] <= (FIFO_SIZE-1)<<3
	var
		uint(size=4) fifo_idx  =  fifo[FIFO_IDX]
	do
		if b != EPR_VALUE or zeroByte != 3 then
			if b = START_CODE_VALUE and zeroByte = 3 then
				fifo[fifo_idx]      := b + START_CODE_FLAG;
			else
				fifo[fifo_idx]      := b;
			end
			fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] + 8;
			if DEBUG_BITSTREAM then
				println("fifo["+fifo_idx+"] := "+b+" \t "+fifo[FIFO_CPT_BITS]);
			end
			fifo[FIFO_IDX]      := (fifo_idx+1) & (FIFO_SIZE-1);
		end
		if b = 0 then
			zeroByte := ((zeroByte << 1) + 1) & 0x3;
		else
			zeroByte := 0;
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        NAL UNTI                             *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * byte_align_a
	 *************************************************************************/	
	byte_align_a : action ==>
	do
		byte_align(fifo);
	end 	
	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		not IsStartCode(fifo) and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
   	do
		flushBits( 8, fifo );
		if DEBUG_BITSTREAM then		
  			println("start_code.search");
   		end
	end
	start_code.done: action ==>
	guard
		IsStartCode(fifo) and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then
			println("start_code.done");
		end
	end
	/**************************************************************************
	 * read_nal_unit_header
	 *************************************************************************/	
	read_nal_unit_header : action ==>
	var
		uint(size=32) res[1]
	do
		if DEBUG_BITSTREAM then
			println("=========== NAL_UNIT ===========");
			flushBits_name( 1, fifo,   "reserved_zero_1bits                     ");
			vld_u_name(  1, fifo, res, "nal_ref_flag                            "); nalUnit[NAL_REF_FLAG]  := res[0];
			vld_u_name(  6, fifo, res, "nal_unit_type                           "); nalUnit[NAL_UNIT_TYPE] := res[0];
		else
			flushBits( 1, fifo );
			vld_u(  1, fifo, res); nalUnit[NAL_REF_FLAG]  := res[0];
			vld_u(  6, fifo, res); nalUnit[NAL_UNIT_TYPE] := res[0];
		end
		if DEBUG_BITSTREAM then
			vld_u_name(  3, fifo, res, "temporal_id                             "); nalUnit[TEMPORAL_ID]		:= res[0];
			flushBits_name( 5, fifo,   "reserved_zero_5bits                     ");
		else
			vld_u(  3, fifo, res); nalUnit[TEMPORAL_ID] := res[0];
			flushBits( 5, fifo  );
		end
		nalUnit[OUTPUT_FLAG] := 1;
		se_idx := 1;
	end
	/**************************************************************************
	 * look_for.SPS_header
	 *************************************************************************/
	look_for.SPS_header: action ==>
	guard
		nalUnit[NAL_UNIT_TYPE] = NAL_UNIT_SPS
	do
		if DEBUG_PARSER then
			println("=========== Sequence Parameter Set ID    ===========");
		end
	end
	/**************************************************************************
	 * look_for.PPS_header
	 *************************************************************************/
	look_for.PPS_header: action ==>
	guard
		nalUnit[NAL_UNIT_TYPE] = NAL_UNIT_PPS
	do
		if DEBUG_PARSER then
			println("=========== Picture Parameter Set ID    ===========");
		end
	end
	/**************************************************************************
	 * look_for.Slice_header
	 *************************************************************************/
	look_for.Slice_header: action ==>
	guard
		(nalUnit[NAL_UNIT_TYPE] = NAL_UNIT_NON_IDR_AND_NON_CRA or
		 nalUnit[NAL_UNIT_TYPE] = NAL_UNIT_CRA                 or
		 nalUnit[NAL_UNIT_TYPE] = NAL_UNIT_IDR)
	var
		uint(size=32) res[1]
	do
		if DEBUG_PARSER then
			println("=========== Slice ===========");
		end
		slice[NUM_REF_IDX_L0_ACTIVE] := 1;
		slice[NUM_REF_IDX_L1_ACTIVE] := 1;
		vld_u_name(  1, fifo, res, "lightweight_slice_flag                  "); slice[LIGHTWEIGHT_SLICE_FLAG]	:= res[0];
	end
	/**************************************************************************
	 * look_for_other_header
	 *************************************************************************/
	look_for_other_header: action ==>
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Sequence Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * read_SPS_Header.se_idx_1
	 *************************************************************************/
	read_SPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size= 8) profile_idc,
		uint(size= 8) level_idc,
		uint(size= 8) chroma_idc
	do
		vld_u_name(  8, fifo, res, "profile_idc                                "); profile_idc								:= res[0];
		flushBits_name( 8, fifo,   "reserved_zero_8bits                        ");
		vld_u_name(  8, fifo, res, "level_idc                                  "); level_idc								:= res[0];
		vld_ue_name(    fifo, res, "seq_parameter_set_id                       "); sps_id									:= res[0]; // getBits(10) max
		vld_ue_name(    fifo, res, "chroma_idc                                 "); chroma_idc								:= res[0];
		if (chroma_idc = 3) then
			vld_u_name(  1, fifo, res, "separate_colour_plane_flag                 ");
		end
		vld_u_name(  3, fifo, res, "max_temporal_layers_minus1                 "); sps[sps_id][MAX_TEMPORAL_LAYERS]		:= res[0] + 1;
		vld_ue_name(    fifo, res, "pic_width_in_luma_samples                  "); sps[sps_id][PIC_WIDTH_IN_LUMA_SAMPLES]	:= res[0];
		sps[sps_id][PROFILE_IDC]	:= profile_idc;
		sps[sps_id][LEVEL_IDC]		:= level_idc;
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_2
	 *************************************************************************/
	read_SPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=1)  pic_cropping_flag
	do
		vld_ue_name(    fifo, res, "pic_height_in_luma_samples                 "); sps[sps_id][PIC_HEIGHT_IN_LUMA_SAMPLES]			:= res[0];
		vld_u_name(  1, fifo, res, "pic_cropping_flag                          "); pic_cropping_flag                               := res[0];
		if pic_cropping_flag=1 then
		vld_ue_name(    fifo, res, "pic_cropping_left_offset                   "); 
		vld_ue_name(    fifo, res, "pic_cropping_right_offset                  "); 
		vld_ue_name(    fifo, res, "pic_cropping_top_offset                    "); 
		vld_ue_name(    fifo, res, "pic_cropping_bottom_offset                 "); 
		end
		vld_ue_name(    fifo, res, "bit_depth_luma_minus8                      "); sps[sps_id][BIT_DEPTH_LUMA]						:= res[0] + 8; // getBits(5) max
		vld_ue_name(    fifo, res, "bit_depth_chroma_minus8                    "); sps[sps_id][BIT_DEPTH_CHROMA]					:= res[0] + 8; // getBits(5) max
		vld_u_name(  1, fifo, res, "pcm_enabled_flag                           ");  sps[sps_id][PCM_ENABLE_FLAG]            		:= res[0];
		if sps[sps_id][PCM_ENABLE_FLAG] = 1 then
			vld_u_name(  4, fifo, res, "pcm_bit_depth_luma_minus1                  "); sps[sps_id][PCM_BIT_DEPTH_LUMA]					:= res[0] + 1;
			vld_u_name(  4, fifo, res, "pcm_bit_depth_chroma_minus1                "); sps[sps_id][PCM_BIT_DEPTH_CHROMA]				:= res[0] + 1;
		end
		vld_u_name(  1, fifo, res, "qpprime_y_zero_transquant_bypass_flag      "); 	
		vld_ue_name(    fifo, res, "log2_max_pic_order_cnt_lsb_minus4          "); sps[sps_id][LOG2_MAX_PIC_ORDER_CNT_LSB]			:= res[0] + 4;
		se_idx := se_idx + 1;
		cnt_i := 0;
	end

	/**************************************************************************
	 * read_SPS_Header.se_idx_3
	 *************************************************************************/
	read_SPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		cnt_i <= sps[sps_id][MAX_TEMPORAL_LAYERS] - 1
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "max_dec_ref_buffering                      "); 
		vld_ue_name(    fifo, res, "num_reorder_pics                           "); 
		vld_ue_name(    fifo, res, "max_latency_increase                       "); 
		cnt_i := cnt_i + 1;
	end 

	read_SPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3 and cnt_i = sps[sps_id][MAX_TEMPORAL_LAYERS]
	do
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_4
	 *************************************************************************/
	read_SPS_Header.se_idx_4 : action ==>
	guard
		se_idx = 4 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=1)  restricted_ref_pic_lists_flag
	do
		vld_u_name(  1, fifo, res, "restricted_ref_pic_lists_flag              "); restricted_ref_pic_lists_flag					:= res[0];
		if restricted_ref_pic_lists_flag = 1 then
			vld_u_name(  1, fifo, res, "list_modification_present_flag             ");
		end
		vld_ue_name(    fifo, res, "log2_min_coding_block_size_minus3          "); sps[sps_id][LOG2_MIN_CODING_BLOCK_SIZE]				:= res[0] + 3; // getBits(7) max
		vld_ue_name(    fifo, res, "log2_diff_max_min_coding_block_size        "); sps[sps_id][LOG2_DIFF_MAX_MIN_CODING_BLOCK_SIZE]	:= res[0]; // getBits(32) max ?????
		vld_ue_name(    fifo, res, "log2_min_transform_block_size_minus2       "); sps[sps_id][LOG2_MIN_TRANSFORM_BLOCK_SIZE]			:= res[0] + 2; // getBits(32) max ?????
		vld_ue_name(    fifo, res, "log2_diff_max_min_transform_block_size     "); sps[sps_id][LOG2_DIFF_MAX_MIN_TRANSFORM_BLOCK_SIZE]	:= res[0]; // getBits(32) max ?????
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_5
	 *************************************************************************/	
	read_SPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		if sps[sps_id][LOG2_MIN_CODING_BLOCK_SIZE] = 3 then
			vld_u(  1, fifo, res); sps[sps_id][DISABLEINTER4X4]                   := res[0];		
		end
		if sps[sps_id][PCM_ENABLE_FLAG] = 1 then
			vld_ue_name(    fifo, res, "log2_min_pcm_coding_block_size_minus3      "); sps[sps_id][LOG2_MIN_PCM_CODING_BLOCK_SIZE]			:= res[0] + 3; // getBits(32) max ?????
			vld_ue_name(    fifo, res, "log2_diff_max_min_pcm_coding_block_size    "); 
		end
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_inter        "); sps[sps_id][MAX_TRANSFORM_HIERARCHY_DEPTH_INTER]	:= res[0]; // getBits(32) max ?????
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_intra        "); sps[sps_id][MAX_TRANSFORM_HIERARCHY_DEPTH_INTRA]	:= res[0]; // getBits(32) max ?????
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_6
	 *************************************************************************/	
	read_SPS_Header.se_idx_6 : action ==>
	guard
		se_idx = 6 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do
		vld_u_name(  1, fifo, res, "scaling_list_enable_flag                   ");
		vld_u_name(  1, fifo, res, "chroma_pred_from_luma_enabled_flag         "); sps[sps_id][CHROMA_PRED_FROM_LUMA_ENABLED_FLAG]		:= res[0];
		vld_u_name(  1, fifo, res, "deblocking_filter_in_aps_enabled_flag      "); 
		vld_u_name(  1, fifo, res, "seq_loop_filter_across_slices_enabled_flag "); 
		vld_u_name(  1, fifo, res, "asymmetric_motion_partitions_enabled_flag  "); 
		vld_u_name(  1, fifo, res, "non_square_quadtree_enabled_flag           "); 
		vld_u_name(  1, fifo, res, "sample_adaptive_offset_enabled_flag        "); sps[sps_id][SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG]	:= res[0];
		vld_u_name(  1, fifo, res, "adaptive_loop_filter_enabled_flag          "); sps[sps_id][ADAPTIVE_LOOP_FILTER_ENABLED_FLAG]		:= res[0];
		if sps[sps_id][ADAPTIVE_LOOP_FILTER_ENABLED_FLAG] = 1 then
			vld_u_name(  1, fifo, res, "alf_coef_in_slice_flag                     ");
		end
		if sps[sps_id][PCM_ENABLE_FLAG] = 1 then
		vld_u_name(  1, fifo, res, "pcm_loop_filter_disable_flag               "); sps[sps_id][PCM_LOOP_FILTER_DISABLE_FLAG]			:= res[0];
		end
		vld_u_name(  1, fifo, res, "temporal_id_nesting_flag                   "); sps[sps_id][TEMPORAL_ID_NESTING_FLAG]				:= res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_7
	 *************************************************************************/
	read_SPS_Header.se_idx_7 : action ==>
	guard
		se_idx = 7 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size= 8) uiAddCUDepth := 0
   	do
		sps[sps_id][MAXCUWIDTH]  := 1<<(sps[sps_id][LOG2_MIN_CODING_BLOCK_SIZE] + sps[sps_id][LOG2_DIFF_MAX_MIN_CODING_BLOCK_SIZE]);
  		while( ( sps[sps_id][MAXCUWIDTH] >> sps[sps_id][LOG2_DIFF_MAX_MIN_CODING_BLOCK_SIZE] ) > ( 1 << ( sps[sps_id][LOG2_MIN_TRANSFORM_BLOCK_SIZE] + uiAddCUDepth )  ) ) 
  		do
  			uiAddCUDepth := uiAddCUDepth + 1;
  		end    
  		sps[sps_id][MAXCUDEPTH] := sps[sps_id][LOG2_DIFF_MAX_MIN_CODING_BLOCK_SIZE] + uiAddCUDepth;

		//vld_ue_name(    fifo, res, "padX                                    "); sps[sps_id][PADX]                := res[0]; // getBits(32) max ?????
		vld_ue(    fifo, res); sps[sps_id][PADX]                := res[0]; // getBits(32) max ?????
		//vld_ue_name(    fifo, res, "padY                                    "); sps[sps_id][PADY]                := res[0]; // getBits(32) max ?????
		vld_ue(    fifo, res); sps[sps_id][PADY]                := res[0]; // getBits(32) max ?????
		//vld_u_name(  1, fifo, res, "useMRG                                  "); sps[sps_id][USEMRG]              := res[0];
   		vld_u(  1, fifo, res); sps[sps_id][USEMRG]              := res[0];
   		foreach uint(size=8) i in 0 .. sps[sps_id][MAXCUDEPTH] - 1 do
   			//vld_u_name(  1, fifo, res, "amvpMode[ ]                             "); sps[sps_id][AMVPMODE+i]     := res[0];
   			vld_u(  1, fifo, res); sps[sps_id][AMVPMODE+i]     := res[0];
		end
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_8
	 *************************************************************************/	
	read_SPS_Header.se_idx_8 : action ==>
	guard
		se_idx = 7 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "uniform_spacing_idc                     "); sps[sps_id][UNIFORM_SPACING_IDC]			:= res[0];
		vld_u_name(  1, fifo, res, "tile_boundary_independence_idc          "); sps[sps_id][TILE_BOUNDARY_INDEPENDENCE_IDC]	:= res[0];
		vld_ue_name(    fifo, res, "num_tile_columns_minus1                 "); sps[sps_id][NUM_TILE_COLUMNS]				:= res[0] + 1;
		vld_ue_name(    fifo, res, "num_tile_rows_minus1                    "); sps[sps_id][NUM_TILE_ROWS]					:= res[0] + 1;
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_9
	 *************************************************************************/	
	read_SPS_Header.se_idx_9.loop : action ==>
	guard
		se_idx = 9  and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and 
		sps[sps_id][UNIFORM_SPACING_IDC] = 1 and cnt_i <= sps[sps_id][NUM_TILE_COLUMNS]-1
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "column_width[ ]                         "); sps[sps_id][COLUMN_WIDTH+cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_9.loopEnd : action ==>
	guard
		se_idx = 9 and sps[sps_id][UNIFORM_SPACING_IDC] = 1 and cnt_i > sps[sps_id][NUM_TILE_COLUMNS] - 1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_SPS_Header.se_idx_9.noLoop : action ==>
	guard
		se_idx = 9 and sps[sps_id][UNIFORM_SPACING_IDC] = 0
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_10
	 *************************************************************************/	
	read_SPS_Header.se_idx_10.loop : action ==>
	guard
		se_idx = 10  and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		sps[sps_id][UNIFORM_SPACING_IDC] = 1 and cnt_i <= sps[sps_id][NUM_TILE_ROWS] - 1
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "row_height[ ]                           "); sps[sps_id][ROW_HEIGHT+cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_10.loopEnd : action ==>
	guard
		se_idx = 10 and sps[sps_id][UNIFORM_SPACING_IDC] = 1 and cnt_i > sps[sps_id][NUM_TILE_ROWS] - 1
   	do
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header_done
	 *************************************************************************/	
	read_SPS_Header_done : action ==>
	guard
		se_idx = 11
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "enable_nsqt                             "); sps[sps_id][ENABLE_NSQT] := res[0];
		vld_u_name(  1, fifo, res, "enable_amp                              "); sps[sps_id][ENABLE_AMP]  := res[0];	
	end 
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER         *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * read_PPS_Header.se_idx_1
	 *************************************************************************/	
	read_PPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "pic_parameter_set_id                    "); pps_id										:= res[0];
		vld_ue_name(    fifo, res, "seq_parameter_set_id                    "); sps_id										:= res[0];
		vld_ue_name(    fifo, res, "num_short_term_ref_pic_sets             "); pps[pps_id][NUM_SHORT_TERM_REF_PIC_SETS]	:= res[0];
		pps[pps_id][SPS_ID] := sps_id;
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_2
	 *************************************************************************/
	uint(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE];	
	read_PPS_Header.se_idx_2.loop : action ==>
	guard
		se_idx = 2 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		cnt_i < pps[pps_id][NUM_SHORT_TERM_REF_PIC_SETS]
   	do
   		parseShortTermRefPicSet(cnt_i, fifo, pcRPS);
		cnt_i := cnt_i + 1;
 	end
 	read_PPS_Header.se_idx_2.loopEnd : action ==>
	guard
		se_idx = 2 and cnt_i = pps[pps_id][NUM_SHORT_TERM_REF_PIC_SETS]
   	do
		se_idx := se_idx + 2;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_PPS_Header.se_idx_4
	 *************************************************************************/	
	read_PPS_Header.se_idx_4 : action ==>
	guard
		se_idx = 4 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do
		vld_u_name(  1, fifo, res, "long_term_ref_pics_present_flag         "); pps[pps_id][LONG_TERM_REF_PICS_PRESENT_FLAG]	:= res[0];
		vld_u_name(  1, fifo, res, "entropy_coding_mode_flag                "); pps[pps_id][ENTROPY_CODING_MODE_FLAG]			:= res[0];
		if pps[pps_id][ENTROPY_CODING_MODE_FLAG] = 1 then
			vld_ue_name(    fifo, res, "entropy_coding_synchro                  "); pps[pps_id][ENTROPY_CODING_SYNCHRO]			:= res[0];
			vld_u_name(  1, fifo, res, "cabac_istate_reset                      "); pps[pps_id][CABAC_ISTATE_RESET]      		:= res[0];
			if pps[pps_id][ENTROPY_CODING_SYNCHRO] != 0 then
				vld_ue_name(    fifo, res, "num_substreams_minus1                   "); pps[pps_id][ENTROPY_CODING_SYNCHRO]		:= res[0];
			end
		end
		vld_ue_name(    fifo, res, "num_temporal_layer_switching_point_flags"); pps[pps_id][NUM_TEMPORAL_LAYER_SWITCHING_POINT_FLAGS]	:= res[0];
		if res[0] != 0 then
			foreach uint(size=8) i in 0 .. pps[pps_id][NUM_TEMPORAL_LAYER_SWITCHING_POINT_FLAGS] - 1 do
				vld_u_name(  1, fifo, res, "temporal_layer_switching_point_flag[ ]  "); pps[pps_id][TEMPORAL_LAYER_SWITCHING_POINT_FLAG+i]	:= res[0];
			end
		end	
		vld_u_name(  1, fifo, res, "constrained_intra_pred_flag             "); pps[pps_id][CONSTRAINED_INTRA_PRED_FLAG]				:= res[0];
		vld_u_name(  2, fifo, res, "slice_granularity                       "); pps[pps_id][SLICE_GRANULARITY]							:= res[0];
		if sps[sps_id][CU_QP_DELTA_ENABLED_FLAG] = 1 then
			vld_ue_name(    fifo, res, "max_cu_qp_delta_depth                   "); pps[pps_id][MAX_CU_QP_DELTA_DEPTH]			:= res[0];
		end
		vld_u_name(  1, fifo, res, "weighted_pred_flag                      "); pps[pps_id][WEIGHTED_PRED_FLAG]					:= res[0];
		vld_u_name(  2, fifo, res, "weighted_bipred_idc                     "); pps[pps_id][WEIGHTED_BIPRED_IDC]				:= res[0];
		vld_u_name(  1, fifo, res, "tile_info_present_flag                  "); pps[pps_id][TILE_INFO_PRESENT_FLAG]				:= res[0];
		pps[pps_id][UNIFORM_SPACING_IDC] := 0;
		if pps[pps_id][TILE_INFO_PRESENT_FLAG] = 1 then
			vld_u_name(  1, fifo, res, "uniform_spacing_idc                     "); pps[pps_id][UNIFORM_SPACING_IDC]			:= res[0];
			vld_u_name(  1, fifo, res, "tile_boundary_independence_idc          "); pps[pps_id][TILE_BOUNDARY_INDEPENDENCE_IDC]	:= res[0];
			vld_ue_name(    fifo, res, "num_tile_columns_minus1                 "); pps[pps_id][NUM_TILE_COLUMNS]				:= res[0] + 1;
			vld_ue_name(    fifo, res, "num_tile_rows_minus1                    "); pps[pps_id][NUM_TILE_ROWS]					:= res[0] + 1;
		end
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_5
	 *************************************************************************/	
  	read_PPS_Header.se_idx_5.loop : action ==>
	guard
		se_idx = 5  and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		pps[pps_id][UNIFORM_SPACING_IDC] = 1 and cnt_i <= pps[pps_id][NUM_TILE_COLUMNS] - 1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "column_width[ ]                         "); pps[pps_id][COLUMN_WIDTH+cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end 
	read_PPS_Header.se_idx_5.loopEnd : action ==>
	guard
		se_idx = 5 and pps[pps_id][UNIFORM_SPACING_IDC] = 1 and cnt_i > pps[pps_id][NUM_TILE_COLUMNS] - 1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_PPS_Header.se_idx_5.noLoop : action ==>
	guard
		se_idx = 5 and pps[pps_id][UNIFORM_SPACING_IDC] = 0
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_6
	 *************************************************************************/	
	read_SPS_Header.se_idx_6.loop : action ==>
	guard
		se_idx = 6 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		pps[pps_id][UNIFORM_SPACING_IDC] = 1 and cnt_i <= pps[pps_id][NUM_TILE_ROWS] - 1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "row_height[ ]                          "); pps[pps_id][ROW_HEIGHT+cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_6.loopEnd : action ==>
	guard
		se_idx = 6 and pps[pps_id][UNIFORM_SPACING_IDC] = 1 and cnt_i > pps[pps_id][NUM_TILE_ROWS] - 1
   	do
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_PPS_Header_done
	 *************************************************************************/	
	read_PPS_Header_done : action ==>
	guard
		se_idx = 7
	end 	
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * read_SliceHeader.se_idx_1
	 *************************************************************************/	
	read_SliceHeader.se_idx_1.read : action ==>
	guard
		se_idx = 1 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		slice[LIGHTWEIGHT_SLICE_FLAG] = 0
	var
		uint(size=32) res[1],
		uint(size=32) prev := 0,
		uint(size=32) j
   	do	
		vld_ue_name(    fifo, res, "slice_type                              "); slice[SLICE_TYPE]							:= res[0]; // getBits(3) max
		vld_ue_name(    fifo, res, "pic_parameter_set_id                    "); pps_id										:= res[0];
		sps_id := pps[pps_id][SPS_ID];
		if nalUnit[NAL_UNIT_TYPE] = NAL_UNIT_IDR then
		    vld_ue_name(    fifo, res, "idr_pic_id                              ");
   			vld_u_name(  1, fifo, res, "no_output_of_prior_pics_flag            ");
		else
			vld_u_name( sps[sps_id][LOG2_MAX_PIC_ORDER_CNT_LSB], fifo, res, "pic_order_cnt_lsb                       "); slice[PIC_ORDER_CNT_LSB]	:= res[0];
			vld_u_name(  1, fifo, res, "short_term_ref_pic_set_pps_flag         ");
			if res[0] = 0 then
		   		parseShortTermRefPicSet(pps_id, fifo, pcRPS);
			end
			if pps[pps_id][LONG_TERM_REF_PICS_PRESENT_FLAG] = 1 then
				vld_ue_name(    fifo, res, "num_long_term_pics                      "); pcRPS[pps_id][NUM_LONG_TERM_PICS]	:= res[0];
			   	j := res[0] + pcRPS[pps_id][NUM_PICS]-1;
			  	if res[0] > 2 then
			   		foreach uint(size=8) i in 0 .. res[0]-2 do
			    		vld_ue_name(    fifo, res, "delta_poc_lsb_lt_minus1                 "); prev := prev + res[0] + 1;
						pcRPS[j][POC] := pcRPS[pps_id][POC] - prev;
						vld_u_name(  1, fifo, res, "used_by_curr_pic_lt_flag                "); pcRPS[pps_id][USED+i]		:= res[0];
					end
				end
				pcRPS[pps_id][NUM_PICS] := pcRPS[pps_id][NUM_PICS] + pcRPS[pps_id][NUM_LONG_TERM_PICS];
			end
		end
		if sps[sps_id][SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG] = 1 or sps[sps_id][ADAPTIVE_LOOP_FILTER_ENABLED_FLAG] = 1 then
			vld_ue_name(    fifo, res, "aps_id                                  "); slice[APS_ID]							:= res[0];
		end
		if slice[SLICE_TYPE] != I_SLICE then
			vld_u_name(  1, fifo, res, "num_ref_idx_active_override_flag        ");
			if res[0] = 1 then
				vld_u_name(  3, fifo, res, "num_ref_idx_l0_active_minus1            "); slice[NUM_REF_IDX_L0_ACTIVE]		:= res[0] + 1;
				if slice[SLICE_TYPE] = B_SLICE then
					vld_u_name(  3, fifo, res, "num_ref_idx_l1_active_minus1            "); slice[NUM_REF_IDX_L1_ACTIVE] 	:= res[0] + 1;
				end
			end
		end
	    se_idx := se_idx + 1;
	end
	read_SliceHeader.se_idx_1.bypass : action ==>
	guard
		se_idx = 1 and slice[LIGHTWEIGHT_SLICE_FLAG] = 1
   	do
   		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_2
	 *************************************************************************/	
	read_SliceHeader.se_idx_2.read : action ==>
	guard
		se_idx = 2 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		slice[LIGHTWEIGHT_SLICE_FLAG] = 0
	var
		uint(size=32) res[1],
		uint(size=32) i := 0,
		uint(size=32) list_modification_idc := 0
   	do
		slice[REF_PIC_LIST_MODIFICATION_FLAG_L0] 		:= 0;
		slice[NUM_REF_PIC_LIST_MODIFICATION_FLAG_L0] 	:= 0;
		if slice[SLICE_TYPE] != I_SLICE then
			vld_u_name(  1, fifo, res, "ref_pic_list_modification_flag_l0       "); slice[REF_PIC_LIST_MODIFICATION_FLAG_L0] 	:= res[0];		
      		if res[0] = 1 then
        		i := 0;
        		list_modification_idc := 0;
        		while list_modification_idc != 3 do 
       				vld_ue_name(    fifo, res, "list_modification_idc[ ]                "); slice[LIST_MODIFICATION_IDC_L0+i]	:= res[0];
          			list_modification_idc := res[0];
          			if res[0] != 3 then
            			vld_ue_name(    fifo, res, "ref_pic_set_idx[ ]                      "); slice[REF_PIC_SET_IDX_L0+i]		:= res[0];
          			end
          			i := i + 1;
        		end
        		slice[NUM_REF_PIC_LIST_MODIFICATION_FLAG_L0] 	:= i-1;
        	end
   		end
  		slice[REF_PIC_LIST_MODIFICATION_FLAG_L1] 		:= 0;
		slice[NUM_REF_PIC_LIST_MODIFICATION_FLAG_L1] 	:= 0;
   		if slice[SLICE_TYPE] = B_SLICE then
			vld_u_name(  1, fifo, res, "ref_pic_list_modification_flag_l1       "); slice[REF_PIC_LIST_MODIFICATION_FLAG_L1] 	:= res[0];		
      		if res[0] = 1 then
        		i := 0;
        		list_modification_idc := 0;
        		while list_modification_idc != 3 do 
       				vld_ue_name(    fifo, res, "list_modification_idc[ ]                "); slice[LIST_MODIFICATION_IDC_L1+i]	:= res[0];
          			list_modification_idc := res[0];
          			if res[0] != 3 then
            			vld_ue_name(    fifo, res, "ref_pic_set_idx[ ]                      "); slice[REF_PIC_SET_IDX_L1+i]		:= res[0];
          			end
          			i := i + 1;
        		end
        		slice[NUM_REF_PIC_LIST_MODIFICATION_FLAG_L1] 	:= i-1;
        	end
        end
		se_idx := se_idx + 1;
	end
	read_SliceHeader.se_idx_2.bypass : action ==>
	guard
		se_idx = 2 and slice[LIGHTWEIGHT_SLICE_FLAG] = 1
   	do
   		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_3
	 *************************************************************************/	
	read_SliceHeader.se_idx_3 : action ==>
	guard
		se_idx = 3 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do	
   		slice[REF_PIC_LIST_COMBINATION_FLAG]     := 0;
   		slice[REF_PIC_LIST_MODIFICATION_FLAG_LC] := 0;
		if slice[SLICE_TYPE] = B_SLICE then
			vld_u_name(  1, fifo, res, "ref_pic_list_combination_flag           "); slice[REF_PIC_LIST_COMBINATION_FLAG]			:= res[0];
			if slice[REF_PIC_LIST_COMBINATION_FLAG] = 1 then
				vld_ue_name(    fifo, res, "num_ref_idx_lc_active_minus1            "); slice[NUM_REF_IDX_LC_ACTIVE]				:= res[0] + 1;
				vld_u_name(  1, fifo, res, "ref_pic_list_modification_flag_lc       "); slice[REF_PIC_LIST_MODIFICATION_FLAG_LC]	:= res[0];
				if res[0] = 1 then
		   			foreach uint(size=8) i in 0 .. slice[NUM_REF_IDX_LC_ACTIVE] - 1 do
						vld_u_name(  1, fifo, res, "pic_from_list_0_flag[ ]                 "); slice[PIC_FROM_LIST_0_FLAG+i]		:= res[0];
						vld_ue_name(    fifo, res, "ref_idx_list_curr[ ]                    "); slice[REF_IDX_LIST_CURR+i]			:= res[0];
		   			end
		   		end
			end
		end
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_4
	 *************************************************************************/	
	read_SliceHeader.se_idx_4 : action ==>
	guard
		se_idx = 4 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=32) iNumCUs = ( (sps[sps_id][PIC_WIDTH_IN_LUMA_SAMPLES]  + sps[sps_id][MAXCUWIDTH] - 1) / sps[sps_id][MAXCUWIDTH] ) * 
	 							( (sps[sps_id][PIC_HEIGHT_IN_LUMA_SAMPLES] + sps[sps_id][MAXCUDEPTH] - 1) / sps[sps_id][MAXCUDEPTH]),
	 	uint(size=32) iNumParts = (1<<(pps[pps_id][SLICE_GRANULARITY]<<1)),
	 	uint(size=32) iReqBitsOuter := 0,
	 	uint(size=32) iReqBitsInner := 0
   	do	
   		while iNumCUs   > (1 << iReqBitsOuter) do iReqBitsOuter := iReqBitsOuter + 1; end
  		while iNumParts > (1 << iReqBitsInner) do iReqBitsInner := iReqBitsInner + 1; end
		vld_u_name(  1, fifo, res, "first_slice_in_pic_flag                 ");
		if res[0] = 0 then
			vld_u_name( iReqBitsOuter+iReqBitsInner , fifo, res, "slice_address                           "); slice[SLICE_ADDRESS]	:= res[0];
		end
		vld_se_name(    fifo, res, "slice_qp                                "); slice[SLICE_QP]										:= res[0];
		vld_u_name(  1, fifo, res, "loop_filter_disable                     "); slice[LOOP_FILTER_DISABLE]							:= res[0];
		if slice[SLICE_TYPE] = B_SLICE then
			vld_u_name(  1, fifo, res, "collocated_from_l0_flag                 "); slice[COLLOCATED_FROM_L0_FLAG]					:= res[0];
		end
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_5
	 *************************************************************************/	
	 procedure initWpScaling()
	 begin
		foreach uint(size=8) e in 0 .. 1 do
			foreach uint(size=8) i in 0 .. MAX_NUM_REF-1 do
				foreach uint(size=8) yuv in 0 .. 2 do
					if wp[e][i][yuv][WP_PRESENT_FLAG] = 1 then
						wp[e][i][yuv][WP_I_WEIGHT] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]);
						wp[e][i][yuv][WP_I_OFFSET] := 0;
					end
					wp[e][i][yuv][WP_W]     := wp[e][i][yuv][WP_I_WEIGHT];
					wp[e][i][yuv][WP_O]     := wp[e][i][yuv][WP_I_OFFSET] * (1);
					wp[e][i][yuv][WP_SHIFT] := wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM];
					if wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM] >= 1 then
						wp[e][i][yuv][WP_ROUND] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]) - 1;
					else
						wp[e][i][yuv][WP_ROUND] := 0;
					end
				end
			end
		end
	end
   	read_SliceHeader.se_idx_5.useWP : action ==>
	guard
		se_idx = 5 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and 
		(pps[pps_id][WEIGHTED_PRED_FLAG]  = 1 and slice[SLICE_TYPE] = P_SLICE) or 
		(pps[pps_id][WEIGHTED_BIPRED_IDC] = 1 and slice[SLICE_TYPE] = B_SLICE)
	var
		 int(size=32) res[1],
		uint(size=32) uiLog2WeightDenomLuma[1],
		uint(size=32) uiLog2WeightDenomChroma[1],
		uint(size= 2) iRefIdxMax
   	do	
		vld_ue_name(    fifo, uiLog2WeightDenomLuma,   "luma_log2_weight_denom                  ");
		vld_ue_name(    fifo, uiLog2WeightDenomChroma, "chroma_log2_weight_denom                ");
		foreach uint(size=8) iNumRef in 0 .. slice[SLICE_TYPE] do
			iRefIdxMax := slice[NUM_REF_IDX_L0_ACTIVE] - 1;
			if iNumRef = REF_PIC_LIST_1 then
				iRefIdxMax := slice[NUM_REF_IDX_L1_ACTIVE] - 1;
			end
			foreach uint(size=8) iRefIdx in 0 .. iRefIdxMax do
				wp[iNumRef][iRefIdx][0][WP_LOG2_WEIGHT_DENOM] := uiLog2WeightDenomLuma[0];
	       		wp[iNumRef][iRefIdx][1][WP_LOG2_WEIGHT_DENOM] := uiLog2WeightDenomChroma[0];
	       		wp[iNumRef][iRefIdx][2][WP_LOG2_WEIGHT_DENOM] := uiLog2WeightDenomChroma[0];
				vld_u_name(  1, fifo, res, "luma_weight_l0_flag                     ");
				wp[iNumRef][iRefIdx][0][WP_PRESENT_FLAG] := res[0];
				if res[0] = 1 then
					vld_se_name(    fifo, res, "luma_weight_l0                          ");
					wp[iNumRef][iRefIdx][0][WP_I_WEIGHT]:= res[0];
					vld_se_name(    fifo, res, "luma_offset_l0                          ");
					wp[iNumRef][iRefIdx][0][WP_I_OFFSET]:= res[0];				
				else
					wp[iNumRef][iRefIdx][0][WP_I_WEIGHT] := (1 << uiLog2WeightDenomLuma[0]);
					wp[iNumRef][iRefIdx][0][WP_I_OFFSET] := 0;
				end
				vld_u_name(  1, fifo, res, "chroma_weight_l0_flag                   ");
				wp[iNumRef][iRefIdx][1][WP_PRESENT_FLAG] := res[0];
				wp[iNumRef][iRefIdx][2][WP_PRESENT_FLAG] := res[0];
				if res[0] = 1 then
					foreach uint(size=8) i in 1 .. 2 do
						vld_se_name(    fifo, res, "luma_weight_l0                          ");
						wp[iNumRef][iRefIdx][i][WP_I_WEIGHT]:= res[0];
						vld_se_name(    fifo, res, "luma_offset_l0                          ");
						wp[iNumRef][iRefIdx][i][WP_I_OFFSET]:= res[0];
					end
				else
					foreach uint(size=8) i in 1 .. 2 do
						wp[iNumRef][iRefIdx][i][WP_I_WEIGHT] := (1 << uiLog2WeightDenomChroma[0]);
						wp[iNumRef][iRefIdx][i][WP_I_OFFSET] := 0;
					end
				end
     		end
			foreach uint(size=8) iRefIdx in 0 .. MAX_NUM_REF-1 do
				wp[iNumRef][iRefIdx][0][WP_PRESENT_FLAG] := 0;
				wp[iNumRef][iRefIdx][1][WP_PRESENT_FLAG] := 0;
				wp[iNumRef][iRefIdx][2][WP_PRESENT_FLAG] := 0;
			end
		end
		initWpScaling();
	    se_idx := se_idx + 1;
	end
	read_SliceHeader.se_idx_5.noUseWP : action ==>
	guard
		se_idx = 5 and 
		(pps[pps_id][WEIGHTED_PRED_FLAG]  != 1 or slice[SLICE_TYPE] != P_SLICE) and 
		(pps[pps_id][WEIGHTED_BIPRED_IDC] != 1 or slice[SLICE_TYPE] != B_SLICE)
   	do	
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_6
	 *************************************************************************/	
	read_SliceHeader.se_idx_6 : action ==>
	guard
		se_idx = 6 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do	
   		if slice[LIGHTWEIGHT_SLICE_FLAG] = 0 then
 			//vld_u_name(  1, fifo, res, "drbFlag                                 "); slice[DRBFLAG]				:= res[0];
 			vld_u(  1, fifo, res); slice[DRBFLAG]				:= res[0];
 			if res[0] = 0 then
	 			//vld_u_name(  2, fifo, res, "erbIndex                                "); slice[ERBINDEX]			:= res[0];
	 			vld_u(  2, fifo, res); slice[ERBINDEX]			:= res[0];
 			end
 		end
 		vld_ue_name(    fifo, res, "MaxNumMergeCand                         "); slice[MAXNUMMERGECAND]			:= MRG_MAX_NUM_CANDS - res[0];
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader_done
	 *************************************************************************/	
	read_SliceHeader_done : action ==>
	guard
		se_idx = 7
	end 	
	
	/**************************************************************************
	 **************************************************************************
	 ********        undefined                            *********************
	 **************************************************************************
	 *************************************************************************/
  	bool actorNotFinished := true;
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("Algo_Parser doesn't manage this case yet");
		actorNotFinished := false;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        schedule                             *********************
	 **************************************************************************
	 *************************************************************************/
  	schedule fsm start_code:
		// byte align
		byte_align          			( byte_align_a						) --> start_code;
		// search start code
		start_code          			( start_code.search					) --> start_code;
		start_code			            ( start_code.done					) --> read_Nal_unit_header;
		// read Nal Unit header
		read_Nal_unit_header			( read_nal_unit_header				) --> find_header;
		find_header	  					( look_for.SPS_header	  			) --> read_SPS_Header;
		find_header	  					( look_for.PPS_header	  			) --> read_PPS_Header;
		find_header	  					( look_for.Slice_header	  			) --> read_SliceHeader;
		find_header	  					( look_for_other_header				) --> byte_align;
		// read SPS header
		read_SPS_Header	  				( read_SPS_Header	    			) --> read_SPS_Header;
		read_SPS_Header	  				( read_SPS_Header_done    			) --> byte_align;
		// read PPS header
		read_PPS_Header 				( read_PPS_Header   				) --> read_PPS_Header;
		read_PPS_Header	  				( read_PPS_Header_done    			) --> byte_align;
		// read_SliceHeader
		read_SliceHeader				( read_SliceHeader					) --> read_SliceHeader;
		read_SliceHeader				( read_SliceHeader_done				) --> byte_align;
		
		
		
		
		// undefined
		undefined	  					( undefined		    				) --> undefined;
	end
	
	/**************************************************************************
	 * priority
	 *************************************************************************/
	priority
		look_for        > look_for_other_header;
	end
end