package synParser;

import  std.util.Math.*;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  synParser.Algo_ParserUtils.*;
import  common.CabacDecodeBinFunction.*;
import  common.CabacContextConstantHEVC.*;
import  common.CabacContextFunctionHEVC.*;
import  common.CabacParserFunctionHEVC.*;

actor Algo_Parser () 
				uint(size= 8) byte
				==>
:
	bool DEBUG_BITSTREAM = false;
	uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL];
	uint(size= 2) zeroByte := 0;
	uint(size= 8) se_idx;
	uint(size=32) cnt_i;
	uint(size=10) sps_id;
	uint(size=10) pps_id;
	uint(size=32) wp[2][MAX_NUM_REF][3][WP_MAX_STRUCT];
	
	/**************************************************************************
	 * GLOBAL Sps_unit variables
 	 *************************************************************************/
	uint(size= 1) pcm_enabled_flag;
	uint(size= 4) max_temporal_layers_minus1;
	uint(size=16) pic_width_in_luma_samples;
	uint(size=16) pic_height_in_luma_samples;
	uint(size= 8) log2_min_coding_block_size_minus3;
	uint(size= 8) log2_diff_max_min_coding_block_size;
	uint(size= 8) num_short_term_ref_pic_sets;
	uint(size=16) sps_column_width[COLUMN_WIDTH_MAX];
	uint(size=16) sps_row_height[COLUMN_WIDTH_MAX];
	
	/**************************************************************************
	 **************************************************************************
	 ********        Bitstream Reader                     *********************
	 **************************************************************************
	 *************************************************************************/
	
	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
 	action byte:[ b ] ==>
	guard 
		fifo[FIFO_CPT_BITS] <= (FIFO_SIZE-1)<<3
	var
		uint(size=4) fifo_idx  =  fifo[FIFO_IDX]
	do
		if b != EPR_VALUE or zeroByte != 3 then
			if b = START_CODE_VALUE and zeroByte = 3 then
				fifo[fifo_idx]      := b + START_CODE_FLAG;
			else
				fifo[fifo_idx]      := b;
			end
			fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] + 8;
			if DEBUG_BITSTREAM then
				println("fifo["+fifo_idx+"] := "+b+" \t "+fifo[FIFO_CPT_BITS]);
			end
			fifo[FIFO_IDX]      := (fifo_idx+1) & (FIFO_SIZE-1);
		end
		if b = 0 then
			zeroByte := ((zeroByte << 1) + 1) & 0x3;
		else
			zeroByte := 0;
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        NAL UNTI                             *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * byte_align_a
	 *************************************************************************/	
	byte_align_a : action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
		byte_align(fifo);
	end 	
	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		not IsStartCode(fifo) and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
   	do
		flushBits( 8, fifo );
		if DEBUG_BITSTREAM then		
  			println("start_code.search");
   		end
	end
	start_code.done: action ==>
	guard
		IsStartCode(fifo) and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then
			println("start_code.done");
		end
	end
	/**************************************************************************
	 * read_nal_unit_header
	 *************************************************************************/	
	uint(size= 6) nal_unit_type;
	uint(size= 8) chroma_format_idc;
	uint(size= 2) tile_or_entropy_coding_sync_idc[NB_MAX_SPS];
	uint(size= 8) num_tile_columns_minus1;
	uint(size= 8) num_tile_rows_minus1;
	uint(size= 1) uniform_spacing_flag;
	uint(size= 8) maxCUWidth;
	uint(size= 8) addCUDepth;
	uint(size= 8) maxCUDepth;
	uint(size= 1) separate_colour_plane_flag[NB_MAX_SPS];
	uint(size= 8) log2_max_pic_order_cnt_lsb_minus4[NB_MAX_SPS];
	uint(size= 1) long_term_ref_pics_present_flag[NB_MAX_SPS];
	uint(size= 1) sample_adaptive_offset_enabled_flag[NB_MAX_SPS];
	uint(size= 1) chroma_pred_from_luma_enabled_flag[NB_MAX_SPS];
	uint(size= 1) deblocking_filter_in_aps_enabled_flag[NB_MAX_SPS];
	uint(size= 1) adaptive_loop_filter_enabled_flag[NB_MAX_SPS];
	uint(size= 1) lists_modification_present_flag[NB_MAX_SPS];
	
	uint(size= 8) num_ref_idx_lc_active_minus1;
	uint(size= 8) num_ref_idx_l0_active_minus1;
	uint(size= 8) num_ref_idx_l1_active_minus1;
		
	read_nal_unit_header : action ==>
	var
		uint(size=32) res[1]
	do
		if DEBUG_BITSTREAM then
			println("=========== NAL_UNIT ===========");
			flushBits_name( 1, fifo,   "reserved_zero_1bits                     ");
			vld_u_name(  1, fifo, res, "nal_ref_flag                            "); 
			vld_u_name(  6, fifo, res, "nal_unit_type                           "); 
			nal_unit_type := res[0];
		else
			flushBits( 1, fifo );
			vld_u(  1, fifo, res);
			vld_u(  6, fifo, res); nal_unit_type := res[0];
		end
		if DEBUG_BITSTREAM then
			vld_u_name(  3, fifo, res, "temporal_id                             "); 
			flushBits_name( 5, fifo,   "reserved_zero_5bits                     ");
		else
			vld_u(  3, fifo, res); 
			flushBits( 5, fifo  );
		end
		se_idx := 1;
	end
	/**************************************************************************
	 * look_for.SPS_header
	 *************************************************************************/
	look_for.SPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_SPS
	do
		if DEBUG_PARSER then
			println("=========== Sequence Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.PPS_header
	 *************************************************************************/
	look_for.PPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_PPS
	do
		if DEBUG_PARSER then
			println("=========== Picture Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.Slice_header
	 *************************************************************************/
	look_for.Slice_header: action ==>
	guard
		(nal_unit_type = NAL_UNIT_NON_IDR_AND_NON_CRA or
		 nal_unit_type = NAL_UNIT_CRA                 or
		 nal_unit_type = NAL_UNIT_IDR)
	do
		if DEBUG_PARSER then
			println("=========== Slice ===========");
		end
	end
	/**************************************************************************
	 * look_for.APS_header
	 *************************************************************************/
	look_for.APS_header: action ==>
	guard
		(nal_unit_type = NAL_UNIT_APS)
	do
		if DEBUG_PARSER then
			println("=========== Adaptation Parameter Set ===========");
		end
	end
	/**************************************************************************
	 * look_for_other_header
	 *************************************************************************/
	look_for_other_header: action ==>
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Sequence Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) log2_min_transform_block_size_minus2;
	uint(size= 8) log2_diff_max_min_transform_block_size;
	uint(size= 8) max_transform_hierarchy_depth_inter;
	uint(size= 8) max_transform_hierarchy_depth_intra;
	 
	/**************************************************************************
	 * read_SPS_Header.se_idx_1
	 *************************************************************************/
	read_SPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "profile_idc                             "); 
		flushBits_name( 8, fifo,   "reserved_zero_8bits                     ");
		vld_u_name(  8, fifo, res, "level_idc                               "); 
		vld_ue_name(    fifo, res, "seq_parameter_set_id                    ");
		sps_id := res[0];
		vld_ue_name(    fifo, res, "chroma_format_idc                       ");
		chroma_format_idc := res[0];
		if (chroma_format_idc = 3) then
			vld_u_name(  1, fifo, res, "separate_colour_plane_flag              ");
			separate_colour_plane_flag[sps_id]:=res[0];
		end
		vld_u_name(  3, fifo, res, "max_temporal_layers_minus1              ");
		max_temporal_layers_minus1 := res[0];
		vld_ue_name(    fifo, res, "pic_width_in_luma_samples               ");
		pic_width_in_luma_samples := res[0];
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_2
	 *************************************************************************/
	read_SPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=1)  pic_cropping_flag
	do
		vld_ue_name(    fifo, res, "pic_height_in_luma_samples              "); 
		pic_height_in_luma_samples := res[0];
		vld_u_name(  1, fifo, res, "pic_cropping_flag                       "); pic_cropping_flag                               := res[0];
		if pic_cropping_flag=1 then
			vld_ue_name(    fifo, res, "pic_cropping_left_offset                "); 
			vld_ue_name(    fifo, res, "pic_cropping_right_offset               "); 
			vld_ue_name(    fifo, res, "pic_cropping_top_offset                 "); 
			vld_ue_name(    fifo, res, "pic_cropping_bottom_offset              "); 
		end
		vld_ue_name(    fifo, res, "bit_depth_luma_minus8                   ");
		vld_ue_name(    fifo, res, "bit_depth_chroma_minus8                 ");
		vld_u_name(  1, fifo, res, "pcm_enabled_flag                        ");
		if pcm_enabled_flag = 1 then
			vld_u_name(  4, fifo, res, "pcm_bit_depth_luma_minus1               ");
			vld_u_name(  4, fifo, res, "pcm_bit_depth_chroma_minus1             ");
		end
		vld_u_name(  1, fifo, res, "qpprime_y_zero_transquant_bypass_flag   ");
		vld_ue_name(    fifo, res, "log2_max_pic_order_cnt_lsb_minus4       ");
		log2_max_pic_order_cnt_lsb_minus4[sps_id]:=res[0];
		se_idx := se_idx + 1;
		cnt_i := 0;
	end

	/**************************************************************************
	 * read_SPS_Header.se_idx_3
	 *************************************************************************/
	read_SPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		cnt_i <= max_temporal_layers_minus1
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "max_dec_pic_buffering                   "); 
		vld_ue_name(    fifo, res, "num_reorder_pics                        "); 
		vld_ue_name(    fifo, res, "max_latency_increase                    "); 
		cnt_i := cnt_i + 1;
	end 

	read_SPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3 and cnt_i = max_temporal_layers_minus1 + 1
	do
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_4
	 *************************************************************************/
	read_SPS_Header.se_idx_4 : action ==>
	guard
		se_idx = 4 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size= 1) restricted_ref_pic_lists_flag
	do
		vld_u_name(  1, fifo, res, "restricted_ref_pic_lists_flag           "); 
		restricted_ref_pic_lists_flag := res[0];
		if restricted_ref_pic_lists_flag = 1 then
			vld_u_name(  1, fifo, res, "lists_modification_present_flag         ");
			lists_modification_present_flag[sps_id] := res[0];
		else
			lists_modification_present_flag[sps_id] := 0;
		end
		vld_ue_name(    fifo, res, "log2_min_coding_block_size_minus3       ");
		log2_min_coding_block_size_minus3 := res[0];
		vld_ue_name(    fifo, res, "log2_diff_max_min_coding_block_size     ");
		log2_diff_max_min_coding_block_size := res[0];
		vld_ue_name(    fifo, res, "log2_min_transform_block_size_minus2    ");
		log2_min_transform_block_size_minus2 := res[0];
		vld_ue_name(    fifo, res, "log2_diff_max_min_transform_block_size  ");
		log2_diff_max_min_transform_block_size := res[0];
		maxCUWidth := 1 << (log2_min_coding_block_size_minus3 + 3 + log2_diff_max_min_coding_block_size); 
    	addCUDepth := 0;
    	while ( ( maxCUWidth >> log2_diff_max_min_coding_block_size ) > 
    		( 1 << ( log2_min_transform_block_size_minus2 + 2 + log2_diff_max_min_coding_block_size )  )
    	)
    	do
        	addCUDepth := addCUDepth + 1;
    	end
    	maxCUDepth := log2_diff_max_min_coding_block_size + addCUDepth; 
		
		
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_5
	 *************************************************************************/	
	read_SPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		if log2_min_coding_block_size_minus3 = 0 then
			vld_u_name(  1, fifo, res, "inter_4x4_enabled_flag                  "); //TBC
		end
		if pcm_enabled_flag = 1 then
			vld_ue_name(    fifo, res, "log2_min_pcm_coding_block_size_minus3   ");
			vld_ue_name(    fifo, res, "log2_diff_max_min_pcm_coding_block_size ");
		end
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_inter     ");
		max_transform_hierarchy_depth_inter := res[0];
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_intra     ");
		max_transform_hierarchy_depth_intra := res[0];
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_6
	 *************************************************************************/	
	read_SPS_Header.se_idx_6 : action ==>
	guard
		se_idx = 6 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do
		vld_u_name(  1, fifo, res, "scaling_list_enabled_flag               ");
		vld_u_name(  1, fifo, res, "chroma_pred_from_luma_enabled_flag      "); 
		chroma_pred_from_luma_enabled_flag[sps_id] := res[0];
		vld_u_name(  1, fifo, res, "deblocking_filter_in_aps_enabled_flag   "); 
		deblocking_filter_in_aps_enabled_flag[sps_id] := res[0];
		vld_u_name(  1, fifo, res, "loop_filter_across_slice_flag           "); 
		vld_u_name(  1, fifo, res, "asymmetric_motion_partitions_enabled_flag"); 
		vld_u_name(  1, fifo, res, "non_square_quadtree_enabled_flag        "); 
		vld_u_name(  1, fifo, res, "sample_adaptive_offset_enabled_flag     ");
		sample_adaptive_offset_enabled_flag[sps_id] := res[0];
		vld_u_name(  1, fifo, res, "adaptive_loop_filter_enabled_flag       ");
		adaptive_loop_filter_enabled_flag[sps_id] := res[0];
		if adaptive_loop_filter_enabled_flag[sps_id] = 1 then
			vld_u_name(  1, fifo, res, "alf_coef_in_slice_flag                  ");
		end
		if pcm_enabled_flag = 1 then
			vld_u_name(  1, fifo, res, "pcm_loop_filter_disable_flag            ");
		end
		vld_u_name(  1, fifo, res, "temporal_id_nesting_flag                ");
		vld_ue_name(    fifo, res, "num_short_term_ref_pic_sets             "); 
		num_short_term_ref_pic_sets := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_7
	 *************************************************************************/
	uint(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE];	
	read_SPS_Header.se_idx_7.loop : action ==>
	guard
		se_idx = 7 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		cnt_i < num_short_term_ref_pic_sets
   	do
   		parseShortTermRefPicSet(cnt_i, fifo, pcRPS);
		cnt_i := cnt_i + 1;
 	end
 	read_SPS_Header.se_idx_7.loopEnd : action ==>
	guard
		se_idx = 7 and cnt_i = num_short_term_ref_pic_sets
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_8
	 *************************************************************************/	
	read_SPS_Header.se_idx_8 : action ==>
	guard
		se_idx = 8 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "long_term_ref_pics_present_flag         "); 
		long_term_ref_pics_present_flag[sps_id] := res[0];
		foreach int i in 0 .. maxCUDepth do
			vld_u_name(  1, fifo, res, "xxxx                                    "); 
		end
		vld_u_name(  2, fifo, res, "tile_or_entropy_coding_sync_idc         "); 
		if tile_or_entropy_coding_sync_idc[sps_id] = 1 then
			vld_ue_name(    fifo, res, "num_tile_columns_minus1                 "); 
			num_tile_columns_minus1 := res[0];
			vld_ue_name(    fifo, res, "num_tile_rows_minus1                    ");
			num_tile_rows_minus1 := res[0];
			vld_u_name ( 1, fifo, res, "uniform_spacing_flag                    ");
			uniform_spacing_flag:=res[0];
		else
			num_tile_columns_minus1 := 0;
			num_tile_rows_minus1 := 0;
			uniform_spacing_flag := 0;
		end
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_9
	 *************************************************************************/	
  	read_SPS_Header.se_idx_9.loop : action ==>
	guard
		se_idx = 9  and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		uniform_spacing_flag = 1 and cnt_i <= num_tile_columns_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "column_width[ ]                         "); 
		sps_column_width[cnt_i] := res[0];
		if cnt_i >= COLUMN_WIDTH_MAX then
			println("Error read_SPS_Header.se_idx_9.loop : "+cnt_i+" >= "+COLUMN_WIDTH_MAX);
		end
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_9.loopEnd : action ==>
	guard
		se_idx = 9 and uniform_spacing_flag = 1 and cnt_i > num_tile_columns_minus1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_SPS_Header.se_idx_9.noLoop : action ==>
	guard
		se_idx = 9 and uniform_spacing_flag = 0
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx10
	 *************************************************************************/	
	read_SPS_Header.se_idx_10.loop : action ==>
	guard
		se_idx = 10 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		uniform_spacing_flag = 1 and cnt_i <= num_tile_rows_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "row_height[ ]                           ");
		sps_row_height[cnt_i] := res[0];
		if cnt_i >= COLUMN_WIDTH_MAX then
			println("Error read_SPS_Header.se_idx_10.loop : "+cnt_i+" >= "+COLUMN_WIDTH_MAX);
		end
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_10.loopEnd : action ==>
	guard
		se_idx = 10 and uniform_spacing_flag = 1 and cnt_i > num_tile_rows_minus1
   	do
		se_idx := se_idx + 1;
	end 
	
	/**************************************************************************
	 * read_SPS_Header_done
	 *************************************************************************/	
	read_SPS_Header_done : action ==>
	guard
		se_idx = 11
	var
		uint(size=32) res[1],
		uint(size= 1) sps_extension_flag
	do
		vld_u_name(  1, fifo, res, "sps_extension_flag                      ");
		sps_extension_flag := res[0];
		if sps_extension_flag = 1 then
			println("moreRBSP data SPS");
		end
	end 
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER         *********************
	 **************************************************************************
	 *************************************************************************/
	 uint(size= 8) pps_sps_id[NB_MAX_PPS];
	 uint(size= 1) output_flag_present_flag[NB_MAX_PPS];
	 uint(size=16) max_cu_qp_delta_depth;
	 uint(size= 1) tile_control_present_flag;
	 uint(size= 1) cabac_init_present_flag[NB_MAX_PPS];
	 uint(size= 1) deblocking_filter_control_present_flag[NB_MAX_PPS];
	 uint(size=32) poc;
	 uint(size= 2) SliceGranularity[NB_MAX_PPS];
	  int(size=32) pic_init_qp_minus26;
	 uint(size=16) pps_column_width[COLUMN_WIDTH_MAX];
	 uint(size=16) pps_row_height[COLUMN_WIDTH_MAX];
	  
	/**************************************************************************
	 * read_PPS_Header.se_idx_1
	 *************************************************************************/	
	read_PPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "pic_parameter_set_id                    "); 
		pps_id := res[0];
		vld_ue_name(    fifo, res, "seq_parameter_set_id                    "); 
		pps_sps_id[pps_id] := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end

	/**************************************************************************
	 * read_PPS_Header.se_idx_2
	 *************************************************************************/	
	read_PPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size= 1) sign_data_hiding_flag
   	do
		vld_u_name(  1, fifo, res, "sign_data_hiding_flag                   ");
		sign_data_hiding_flag := res[0];
		if sign_data_hiding_flag = 1 then
			vld_u_name(  4, fifo, res, "sign_hiding_threshold                   ");
		end
		vld_u_name(  1, fifo, res, "cabac_init_present_flag                 ");
		cabac_init_present_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "entropy_coding_mode_flag                ");
		vld_se_name(    fifo, res, "pic_init_qp_minus26                     ");
		pic_init_qp_minus26 := res[0]; 
		vld_u_name(  1, fifo, res, "constrained_intra_pred_flag             ");
		vld_u_name(  1, fifo, res, "enable_temporal_mvp_flag                ");
		vld_u_name(  2, fifo, res, "slice_granularity                       ");
		SliceGranularity[pps_id] := res[0] * 2;
		vld_ue_name(    fifo, res, "max_cu_qp_delta_depth                   ");
		max_cu_qp_delta_depth := res[0];
		vld_se_name(    fifo, res, "chroma_qp_offset                        ");
		vld_se_name(    fifo, res, "chroma_qp_offset_2nd                    ");
		vld_u_name(  1, fifo, res, "weighted_pred_flag                      ");
		vld_u_name(  2, fifo, res, "weighted_bipred_idc                     ");
		vld_u_name(  1, fifo, res, "output_flag_present_flag                ");
		output_flag_present_flag[pps_id]:=res[0];
		if tile_or_entropy_coding_sync_idc[sps_id] = 1 then
			vld_u_name(  1, fifo, res, "tile_info_present_flag                  ");
			vld_u_name(  1, fifo, res, "tile_control_present_flag               ");
			tile_control_present_flag := res[0];
			if tile_or_entropy_coding_sync_idc[sps_id] = 1 then
				vld_ue_name(    fifo, res, "num_tile_columns_minus1                 "); 
				num_tile_columns_minus1 := res[0];
				vld_ue_name(    fifo, res, "num_tile_rows_minus1                    ");
				num_tile_rows_minus1 := res[0];
				vld_u_name ( 1, fifo, res, "uniform_spacing_flag                    ");
				uniform_spacing_flag:=res[0];
			else
				num_tile_columns_minus1 := 0;
				num_tile_rows_minus1 := 0;
				uniform_spacing_flag := 0;
			end
		end
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_3
	 *************************************************************************/	
  	read_PPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3  and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		uniform_spacing_flag = 1 and cnt_i <= num_tile_columns_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "column_width[ ]                         ");
		pps_column_width[cnt_i] := res[0];
		if cnt_i >= COLUMN_WIDTH_MAX then
			println("Error read_PPS_Header.se_idx_3.loop : "+cnt_i+" >= "+COLUMN_WIDTH_MAX);
		end		
		cnt_i := cnt_i + 1;
	end 
	read_PPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3 and uniform_spacing_flag = 1 and cnt_i > num_tile_columns_minus1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_PPS_Header.se_idx_3.noLoop : action ==>
	guard
		se_idx = 3 and uniform_spacing_flag = 0
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_PPS_Header.se_idx4
	 *************************************************************************/	
	read_PPS_Header.se_idx_4.loop : action ==>
	guard
		se_idx = 4 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		uniform_spacing_flag = 1 and cnt_i <= num_tile_rows_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "row_height[ ]                           ");
		pps_row_height[cnt_i] := res[0];
		if cnt_i >= COLUMN_WIDTH_MAX then
			println("Error read_PPS_Header.se_idx_4.loop : "+cnt_i+" >= "+COLUMN_WIDTH_MAX);
		end
		cnt_i := cnt_i + 1;
	end 
	read_PPS_Header.se_idx_4.loopEnd : action ==>
	guard
		se_idx = 4 and uniform_spacing_flag = 1 and cnt_i > num_tile_rows_minus1
   	do
		se_idx := se_idx + 1;
	end 
	
	/**************************************************************************
	 * read_PPS_Header.se_idx5
	 *************************************************************************/	
	read_PPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5
	var
		uint(size=32) res[1],
		uint(size= 1) pps_extension_flag
   	do
		if (tile_or_entropy_coding_sync_idc[sps_id] = 1) then
			if tile_control_present_flag = 1 then
				vld_u_name(  1, fifo, res, "loop_filter_across_tiles_enabled_flag   ");
			end
			else if (tile_or_entropy_coding_sync_idc[sps_id] = 2) then
				vld_ue_name(    fifo, res, "num_substreams_minus1                   ");
			end
		end
		vld_u_name(  1, fifo, res, "deblocking_filter_control_present_flag  ");
		deblocking_filter_control_present_flag[pps_id] := res[0];
		vld_ue_name(    fifo, res, "log2_parallel_merge_level_minus2        ");
		vld_u_name(  1, fifo, res, "pps_extension_flag                      ");
		pps_extension_flag := res[0];
		if pps_extension_flag = 1 then
			println("moreRBSP data PPS");
		end
		se_idx := se_idx + 1;
	end 

	/**************************************************************************
	 * read_PPS_Header_done
	 *************************************************************************/	
	read_PPS_Header_done : action ==>
	guard
		se_idx = 6
	end 	
	/**************************************************************************
	 **************************************************************************
	 ********        APS HEADER                           *********************
	 **************************************************************************
	 *************************************************************************/
	read_APS_Header.se_idx_1.read : action ==>
	guard
		se_idx = 1
	var 
		uint(size=32) res[1],
		uint(size= 1) aps_scaling_list_data_present_flag,
		uint(size= 1) aps_deblocking_filter_flag,
		uint(size= 1) disable_deblocking_filter_flag,
		uint(size= 1) aps_sao_interleaving_flag,
		uint(size= 1) aps_sample_adaptive_offset_flag,
		uint(size= 1) aps_adaptive_loop_filter_flag,
		uint(size= 1) aps_extension_flag
	do
		vld_ue_name(    fifo, res, "aps_id                                  ");
		vld_u_name(  1, fifo, res, "aps_scaling_list_data_present_flag      ");
		aps_scaling_list_data_present_flag := res[0];
		if aps_scaling_list_data_present_flag = 1 then
			println("TODO scaling_list_param( )");
		end
		vld_u_name(  1, fifo, res, "aps_deblocking_filter_flag              ");
		aps_deblocking_filter_flag:=res[0];
		if(aps_deblocking_filter_flag = 1) then	
			vld_u_name(  1, fifo, res, "disable_deblocking_filter_flag          ");
			disable_deblocking_filter_flag := res[0];
			if( disable_deblocking_filter_flag = 0) then	
				vld_se_name(    fifo, res, "beta_offset_div2                        ");
				vld_se_name(    fifo, res, "tc_offset_div2                          ");
			end
		end
		vld_u_name(  1, fifo, res, "aps_sao_interleaving_flag               ");
		aps_sao_interleaving_flag := res[0];
		if( aps_sao_interleaving_flag = 0) then	
			vld_u_name(  1, fifo, res, "aps_sample_adaptive_offset_flag         ");
			aps_sample_adaptive_offset_flag	:= res[0];
			if( aps_sample_adaptive_offset_flag = 1) then	
				println("TODO aps_sao_param( )");
			end	
		end
		vld_u_name(  1, fifo, res, "aps_adaptive_loop_filter_flag           ");
		aps_adaptive_loop_filter_flag	:= res[0];
		if( aps_adaptive_loop_filter_flag = 1) then	
			println("TODO alf_param( )");	
		end
		aps_sample_adaptive_offset_flag	:= res[0];
		vld_u_name(  1, fifo, res, "aps_extension_flag                      ");
		aps_extension_flag := res[0];
		if(aps_extension_flag = 1) then 
			println("APS moreDataflag");
		end
		se_idx := se_idx + 1;
	end
	read_APS_Header_done : action ==>
	guard
		se_idx = 2
	end 	

	/**************************************************************************
	 **************************************************************************
	 ********        Slice HEADER                         *********************
	 **************************************************************************
	 *************************************************************************/
		uint(size= 3) slice_type;
		uint(size= 1) entropy_slice_flag;
		uint(size=32) slice_address;
		 int(size=32) slice_qp;
		uint(size= 1) slice_sao_interleaving_flag;
		uint(size= 1) slice_sample_adaptive_offset_flag;
		uint(size= 1) sao_cb_enable_flag; 
		uint(size= 1) sao_cr_enable_flag;
		uint(size= 8) MaxNumMergeCand;

	/**************************************************************************
	 * read_SliceHeader.se_idx_1
	 *************************************************************************/
	 procedure compute_POC(int pic_order_cnt_lsb)
     var
	     int iPOClsb = pic_order_cnt_lsb,
	     int iPrevPOC = poc,
	     int iMaxPOClsb := 1 << (log2_max_pic_order_cnt_lsb_minus4[pps_id] + 4),
	     int iPrevPOClsb,
	     int iPrevPOCmsb,
	     int iPOCmsb
	begin
		iPrevPOClsb := iPrevPOC mod iMaxPOClsb;
		iPrevPOCmsb := iPrevPOC-iPrevPOClsb;
	    if( (iPOClsb < iPrevPOClsb) and ( (iPrevPOClsb - iPOClsb) >= (iMaxPOClsb / 2) ) ) then
	    	iPOCmsb := iPrevPOCmsb + iMaxPOClsb;
	    else 
	    	if( (iPOClsb > iPrevPOClsb)  and ( (iPOClsb - iPrevPOClsb) > (iMaxPOClsb / 2) ) ) then
	 			iPOCmsb := iPrevPOCmsb - iMaxPOClsb;
	   		else
				iPOCmsb := iPrevPOCmsb;
			end
		end
	    poc:= iPOCmsb+iPOClsb;
	end
	
	read_SliceHeader.se_idx_1.read : action ==>
	guard
		se_idx = 1 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=32) prev := 0,
		uint(size=32) j,
		uint(size= 1) first_slice_in_pic_flag
   	do	
		vld_u_name(  1, fifo, res, "first_slice_in_pic_flag                 ");
		first_slice_in_pic_flag := res[0];
		if first_slice_in_pic_flag = 0 then
			vld_ue_name(    fifo, res, "slice_address                           ");
			slice_address := res[0];
		else
			slice_address := 0;
		end
		vld_ue_name(    fifo, res, "slice_type                              ");
		slice_type:=res[0];
		vld_u_name(  1, fifo, res, "entropy_slice_flag                      ");
		if entropy_slice_flag = 0 then
			vld_ue_name(    fifo, res, "pic_parameter_set_id                    "); 
			pps_id := res[0];
			sps_id := pps_sps_id[pps_id];
			if(output_flag_present_flag[pps_id] = 1) then	
				vld_u_name(  1, fifo, res, "pic_output_flag                         ");
			end
			if(separate_colour_plane_flag[sps_id] = 1) then
			vld_u_name(  2, fifo, res, "colour_plane_id                         ");
			end
			if nal_unit_type = NAL_UNIT_IDR then
			    vld_ue_name(    fifo, res, "idr_pic_id                              ");
	   			vld_u_name(  1, fifo, res, "no_output_of_prior_pics_flag            ");
	   			poc:=0;
			else
				vld_u_name( log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4, fifo, res, "pic_order_cnt_lsb                       "); 

				//compute the number of POC
				compute_POC(res[0]);
				
				vld_u_name(  1, fifo, res, "short_term_ref_pic_set_pps_flag         ");
				if res[0] = 0 then
			   		parseShortTermRefPicSet(pps_id, fifo, pcRPS);
		   		else
				    vld_ue_name(    fifo, res, "short_term_ref_pic_set_idx              ");
				end
				if long_term_ref_pics_present_flag[sps_id] = 1 then
					vld_ue_name(    fifo, res, "num_long_term_pics                      "); pcRPS[pps_id][NUM_LONG_TERM_PICS]	:= res[0];
				   	j := res[0] + pcRPS[pps_id][NUM_PICS]-1;
			   		foreach uint(size=8) i in 0 .. res[0]-2 do
			    		vld_ue_name(    fifo, res, "delta_poc_lsb_lt                        "); prev := prev + res[0] + 1;
						pcRPS[j][POC] := pcRPS[pps_id][POC] - prev;
						vld_u_name(  1, fifo, res, "delta_poc_msb_present_flag              ");
						if res[0] = 1 then
			    			vld_ue_name(    fifo, res, "delta_poc_msb_cycle_lt_minus1                "); 
						end
						vld_u_name(  1, fifo, res, "used_by_curr_pic_lt_flag                "); pcRPS[pps_id][USED+i]		:= res[0];
					end
					pcRPS[pps_id][NUM_PICS] := pcRPS[pps_id][NUM_PICS] + pcRPS[pps_id][NUM_LONG_TERM_PICS];
				end
			end
			if( sample_adaptive_offset_enabled_flag[sps_id] = 1) then
				vld_u_name(  1, fifo, res, "slice_sao_interleaving_flag             ");
				slice_sao_interleaving_flag := res[0];
				vld_u_name(  1, fifo, res, "slice_sample_adaptive_offset_flag       "); 
				slice_sample_adaptive_offset_flag:=res[0];
				if( slice_sao_interleaving_flag = 1 &&
					slice_sample_adaptive_offset_flag = 1) then
					vld_u_name(  1, fifo, res, "sao_cb_enable_flag                      "); 
					sao_cb_enable_flag := res[0];
					vld_u_name(  1, fifo, res, "sao_cr_enable_flag                      "); 
					sao_cr_enable_flag := res[0];
				end
			end
			vld_ue_name(    fifo, res, "aps_id                                  "); 
		end
	    se_idx := se_idx + 1;
	end

	/**************************************************************************
	 * read_SliceHeader.se_idx_2
	 *************************************************************************/	
	read_SliceHeader.se_idx_2.read : action ==>
	guard
		se_idx = 2 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do
		if entropy_slice_flag = 0 then
			if slice_type = P_SLICE or slice_type = B_SLICE then
				vld_u_name(  1, fifo, res, "num_ref_idx_active_override_flag        ");		
	      		if res[0] = 1 then
					vld_ue_name(    fifo, res, "num_ref_idx_l0_active_minus1            ");
					if slice_type = B_SLICE then
						vld_ue_name(    fifo, res, "num_ref_idx_l1_active_minus1            ");
					end
	      		end
	        end
		    if (lists_modification_present_flag[sps_id] = 1) then
		    	println("TODO ref_pic_list_modification( )");
		    	println("TODO ref_pic_list_combination( )");
		    end
		    if slice_type = B_SLICE then
				vld_u_name(  1, fifo, res, "mvd_l1_zero_flag                        ");		
			end	    
	    end
		se_idx := se_idx + 1;
	end

	/**************************************************************************
	 * read_SliceHeader.se_idx_3
	 *************************************************************************/	
	read_SliceHeader.se_idx_3 : action ==>
	guard
		se_idx = 3 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size= 1) inherit_dbl_params_from_aps_flag := 0,
		uint(size= 1) disable_deblocking_filter_flag
   	do	
	if( cabac_init_present_flag[pps_id] = 1  and  slice_type  !=  I_SLICE )	then
		vld_u_name(  1, fifo, res, "cabac_init_flag                         ");		
	end
	if(entropy_slice_flag = 0) then
		vld_se_name(    fifo, res, "slice_qp_delta                          ");
		slice_qp := pic_init_qp_minus26 + 26 +res[0];
		if(deblocking_filter_control_present_flag[pps_id] = 1) then	
 			if(deblocking_filter_in_aps_enabled_flag[sps_id] = 1) then
				vld_u_name(  1, fifo, res, "inherit_dbl_params_from_aps_flag        ");
				inherit_dbl_params_from_aps_flag := res[0];	
			end
			if(inherit_dbl_params_from_aps_flag = 0) then
				vld_u_name(  1, fifo, res, "disable_deblocking_filter_flag          ");
				if( disable_deblocking_filter_flag = 0) then
					vld_se_name(    fifo, res, "beta_offset_div2                        ");
					vld_se_name(    fifo, res, "tc_offset_div2                          ");
				end
			end
		end	
		if( slice_type = B_SLICE ) then	
			vld_u_name(  1, fifo, res, "collocated_from_l0_flag                 ");
		end
/* 		if( slice_type != I  &&  
			((collocated_from_l0_flag  &&	num_ref_idx_l0_active_minus1 > 0)  | |
			  (!collocated_from_l0_flag  &&  num_ref_idx_l1_active_minus1 > 0) )	
			collocated_ref_idx	ue(v)
		if( ( weighted_pred_flag  &&   slice_type = = P)  | |
			 ( weighted_bipred_idc  = =  1  &&  slice_type  = =  B ) )	
			pred_weight_table( )	
*/	
	end	
	vld_ue_name(    fifo, res, "five_minus_max_num_merge_cand           ");
	MaxNumMergeCand := 5 - res[0];
/* 	if( adaptive_loop_filter_enabled_flag ) {	
		slice_adaptive_loop_filter_flag	u(1)
		if( slice_adaptive_loop_filter_flag  &&  alf_coef_in_slice_flag )	
			alf_param( )	
		if( slice_adaptive_loop_filter_flag  &&  !alf_coef_in_slice_flag )	
			alf_cu_control_param( )	
	}	
*/	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_4
	 *************************************************************************/	
	read_SliceHeader.se_idx_4 : action ==>
	guard
		se_idx = 4 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_5
	 *************************************************************************/	
	 procedure initWpScaling()
	 begin
		foreach uint(size=8) e in 0 .. 1 do
			foreach uint(size=8) i in 0 .. MAX_NUM_REF-1 do
				foreach uint(size=8) yuv in 0 .. 2 do
					if wp[e][i][yuv][WP_PRESENT_FLAG] = 1 then
						wp[e][i][yuv][WP_I_WEIGHT] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]);
						wp[e][i][yuv][WP_I_OFFSET] := 0;
					end
					wp[e][i][yuv][WP_W]     := wp[e][i][yuv][WP_I_WEIGHT];
					wp[e][i][yuv][WP_O]     := wp[e][i][yuv][WP_I_OFFSET] * (1);
					wp[e][i][yuv][WP_SHIFT] := wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM];
					if wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM] >= 1 then
						wp[e][i][yuv][WP_ROUND] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]) - 1;
					else
						wp[e][i][yuv][WP_ROUND] := 0;
					end
				end
			end
		end
	end
   	read_SliceHeader.se_idx_5 : action ==>
	guard
		se_idx = 5 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_6
	 *************************************************************************/	
	read_SliceHeader.se_idx_6 : action ==>
	guard
		se_idx = 6 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
   	do	
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader_done
	 *************************************************************************/	
	read_SliceHeader_done : action ==>
	guard
		se_idx = 7
	do
		println(" ---- POC :"+poc);
		sliceData_idx := 1;
	end 	

	/**************************************************************************
	 **************************************************************************
	 ********        Slice Data                           *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 9) codIRange[1];
	uint(size=16) codIOffset[1];
	uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX];
	uint(size=32) SliceCtbAddrRS;
	uint(size=32) SliceCbAddrZS;
	uint(size= 8) sliceData_idx;

	uint(size= 8) Log2CtbSize;
	uint(size= 8) Log2MinCbSize;
	uint(size=16) PicWidthInCtbs;
	uint(size=16) PicHeightInCtbs;
	uint(size=16) PicWidthInMinCbs;
	uint(size=16) PicHeightInMinCbs;
	uint(size= 8) Log2MinTrafoSize;
	uint(size= 8) Log2MaxTrafoSize;
	uint(size= 8) Log2MinTrafoSizeC;
	uint(size=16) ColumnWidth[COLUMN_WIDTH_MAX];
	uint(size=16) RowHeight[COLUMN_WIDTH_MAX];
	uint(size=16) ColBd[COLUMN_WIDTH_MAX];
	uint(size=16) RowBd[COLUMN_WIDTH_MAX];
	uint(size=16) CtbAddrTS[CTB_ADDR_TS_MAX];
	uint(size=16) MinCbAddrZS[CTB_ADDR_TS_MAX][CTB_ADDR_TS_MAX];
	
	uint(size= 1) skip_flag[CTB_ADDR_TS_MAX][CTB_ADDR_TS_MAX];
	uint(size= 1) inter_pred_flag[CTB_ADDR_TS_MAX][CTB_ADDR_TS_MAX];
	uint(size= 1) merge_flag[CTB_ADDR_TS_MAX][CTB_ADDR_TS_MAX];
	
	 int(size=16) AlfCuFlagIdx;
	uint(size= 1) moreDataFlag;
	uint(size= 8) xCtb;
	uint(size= 8) yCtb;
	uint(size= 8) NumPCMBlock;
	
	read_SliceData.init: action ==>
	guard
		sliceData_idx = 1
	var
		uint(size=16) tileX,
		uint(size=16) tileY,
		uint(size=16) tbX,
		uint(size=16) tbY,
		uint(size=16) ctbAddrRS,
		uint(size=16) m
	do
		println("******** SliceData ********");
		decodeStart(codIRange, codIOffset, fifo);
		contextInit(slice_qp, slice_type, ctxTable);
		//
		SliceCtbAddrRS    := slice_address >> SliceGranularity[pps_id];
		SliceCbAddrZS  	  := slice_address << ( ( log2_diff_max_min_coding_block_size - SliceGranularity[pps_id] ) <<1 );
		//
		Log2MinCbSize     := log2_min_coding_block_size_minus3 + 3;
		Log2CtbSize       := Log2MinCbSize + log2_diff_max_min_coding_block_size;
		PicWidthInCtbs    := ( pic_width_in_luma_samples  + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
		PicHeightInCtbs   := ( pic_height_in_luma_samples + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
		PicWidthInMinCbs  := pic_width_in_luma_samples  >> Log2MinCbSize;
		PicHeightInMinCbs := pic_height_in_luma_samples >> Log2MinCbSize;
		Log2MinTrafoSize  := log2_min_transform_block_size_minus2 + 2;
		Log2MaxTrafoSize  := Log2MinTrafoSize + log2_diff_max_min_transform_block_size;
		Log2MinTrafoSizeC := if chroma_format_idc = 1 or chroma_format_idc = 2 then max(Log2MinTrafoSize-1, 2) else Log2MinTrafoSize end;
		
		skip_flag		  := [[0	: for int j in 0 .. CTB_ADDR_TS_MAX-1]	: for int i in 0 .. CTB_ADDR_TS_MAX-1];	
		inter_pred_flag   := [[0	: for int j in 0 .. CTB_ADDR_TS_MAX-1]	: for int i in 0 .. CTB_ADDR_TS_MAX-1];
		merge_flag		  := [[0	: for int j in 0 .. CTB_ADDR_TS_MAX-1]	: for int i in 0 .. CTB_ADDR_TS_MAX-1];
		
		if num_tile_columns_minus1 >= COLUMN_WIDTH_MAX then
			println("Error read_SliceData.init : ColumnWidth : "+num_tile_columns_minus1+" >= "+COLUMN_WIDTH_MAX);
		end
		foreach int i in 0 .. num_tile_columns_minus1 do
			if uniform_spacing_flag = 1 then
				ColumnWidth[ i ] := ((i + 1)*PicWidthInCtbs) / (num_tile_columns_minus1+1) - (i*PicWidthInCtbs) / (num_tile_columns_minus1+1);
			else
				ColumnWidth[ i ] := sps_column_width[ i ];
			end
			//ColumnWidthInLumaSamples[ i ] := ColumnWidth[ i ] << Log2CtbSize;
		end
		if num_tile_rows_minus1 >= COLUMN_WIDTH_MAX then
			println("Error read_SliceData.init : RowHeight : "+num_tile_rows_minus1+" >= "+COLUMN_WIDTH_MAX);
		end
		foreach int i in 0 .. num_tile_rows_minus1 do
			if uniform_spacing_flag = 1 then
				RowHeight[ i ] := ((i+1)*PicHeightInCtbs) / (num_tile_rows_minus1+1) - (i*PicHeightInCtbs) / (num_tile_rows_minus1+1);
			else
				RowHeight[ i ] := sps_row_height[ i ];
			end
		end
		ColBd[ 0 ] := 0;
		foreach int i in 0 .. num_tile_columns_minus1 do
			ColBd[ i + 1 ] := ColBd[ i ] + ColumnWidth[ i ];
		end
		RowBd[ 0 ] := 0;
		foreach int i in 0 .. num_tile_rows_minus1 do
			RowBd[ i + 1 ] := RowBd[ i ] + RowHeight[ i ];
		end
		if PicHeightInCtbs * PicWidthInCtbs >= CTB_ADDR_TS_MAX then
			println("Error read_SliceData.init : CtbAddrTS : "+(PicHeightInCtbs * PicWidthInCtbs)+" >= "+CTB_ADDR_TS_MAX);
		end
		foreach int ctbAddrRS_v in 0 .. PicHeightInCtbs * PicWidthInCtbs - 1 do
			tbX := ctbAddrRS_v mod PicWidthInCtbs;
			tbY := ctbAddrRS_v / PicWidthInCtbs;
			foreach int j in 0 .. num_tile_columns_minus1 do
				if tbX < ColBd[j+1] then
					tileX := j;
				end
			end
			foreach int i in 0 .. num_tile_rows_minus1 do
				if tbY < RowBd[i+1] then
					tileY := i;
				end
			end
			CtbAddrTS[ ctbAddrRS_v ] := ctbAddrRS_v - tbX;
			foreach int i in 0 .. tileX-1 do
				CtbAddrTS[ctbAddrRS_v] := CtbAddrTS[ctbAddrRS_v] + RowHeight[ tileY ] * ColumnWidth[ i ];
			end
			CtbAddrTS[ctbAddrRS_v] := CtbAddrTS[ctbAddrRS_v] + ( tbY - RowBd[tileY] ) * ColumnWidth[tileY] + tbX - ColBd[tileX];
		end
		
		if PicHeightInMinCbs >= CTB_ADDR_TS_MAX then
			println("Error read_SliceData.init : MinCbAddrZS y : "+PicHeightInMinCbs+" >= "+CTB_ADDR_TS_MAX);
		end
		if PicWidthInMinCbs >= CTB_ADDR_TS_MAX then
			println("Error read_SliceData.init : MinCbAddrZS x : "+PicWidthInMinCbs+" >= "+CTB_ADDR_TS_MAX);
		end
		foreach int y in 0 .. PicHeightInMinCbs-1 do
			foreach int x in 0 .. PicWidthInMinCbs-1 do
				tbX := ( x << Log2MinCbSize ) >> Log2CtbSize;
				tbY := ( y << Log2MinCbSize ) >> Log2CtbSize;
				ctbAddrRS := PicWidthInCtbs * tbY + tbX;
				MinCbAddrZS[ x ][ y ] := CtbAddrTS[ctbAddrRS]  << log2_diff_max_min_coding_block_size;
				foreach int i in 0 .. Log2CtbSize - Log2MinCbSize - 1 do
					m := 1 << i;
					if (m & x) != 0 then
						MinCbAddrZS[x][y] := MinCbAddrZS[x][y] + (1<< (i<<1)); // MinCbAddrZS[x][y] += m*m 
					end
					if (m & y) != 0 then
						MinCbAddrZS[x][y] := MinCbAddrZS[x][y] + ((1<< (i<<1))<<1); // MinCbAddrZS[x][y] += 2*m*m
					end
				end
			end
		end
		//
//		if adaptive_loop_filter_flag = 1 and alf_cu_control_flag = 1 then
//			AlfCuFlagIdx := -1;
//		end
		moreDataFlag  := 1;
		sliceData_idx := 2;
	end
	read_SliceData_gotoCodingTree: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		sliceData_idx = 2 and moreDataFlag = 1
	var
		uint(size=32) CtbAddrInSlice = 0,
		uint(size=32) AddrUp = 0,
		uint(size= 1) slice_loop_filter_across_slices_enabled_flag = 0
	do
		xCtb := 0;
		yCtb := 0;
		NumPCMBlock := 0;
		if slice_sao_interleaving_flag = 1 then
			if slice_sample_adaptive_offset_flag = 1 then 
				sao_unit_cabac( xCtb, yCtb, 0 ,codIRange, codIOffset, ctxTable, fifo,
								CtbAddrInSlice, AddrUp, slice_loop_filter_across_slices_enabled_flag
				);
			end
			if sao_cb_enable_flag = 1 then
				sao_unit_cabac( xCtb, yCtb, 1 ,codIRange, codIOffset, ctxTable, fifo,
								CtbAddrInSlice, AddrUp, slice_loop_filter_across_slices_enabled_flag
				);
			end
			if sao_cr_enable_flag = 1 then
				sao_unit_cabac( xCtb, yCtb, 2 ,codIRange, codIOffset, ctxTable, fifo,
								CtbAddrInSlice, AddrUp, slice_loop_filter_across_slices_enabled_flag
				);
			end
		end
		sliceData_idx         := 3;
		ct_x0         := xCtb;
		ct_y0         := yCtb;
		ct_log2CbSize := Log2CtbSize;
		ct_cbDepth    := 0;
		ct_idx        := 1;
	end
	read_SliceData_end: action ==>
	guard
		sliceData_idx = 2 and moreDataFlag = 0
	do		
	end
	read_SliceData.loopEnd: action ==>
	guard
		sliceData_idx = 3
	do
	/*
		CtbAddrTS++
		if( moreDataFlag && ( ( tiles_or_entropy_coding_sync_idc = = 1 &&
			TileId[ CtbAddrTS ] != TileId[ CtbAddrTS − 1 ] ) | |
			( 	tiles_or_entropy_coding_sync_idc = = 2 &&
				num_substream_minus1 > 0 &&
				CtbAddrTS / PicWidthInCtbs <= num_substream_minus1 &&
				CtbAddrTS % PicWidthInCtbs = = 0 ) ) ) {
			rbsp_trailing_bits( )
		if( nextbits(24) = = 0x000002 ) {
			entry_point_marker_two_3bytes f(24)
			tile_idx_minus_1 u(v)
		}
	 */
		sliceData_idx := 2;
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Coding Tree                          *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) ct_idx;	 
	uint(size= 8) ct_x0;
	uint(size= 8) ct_y0;
	uint(size= 8) ct_x1;
	uint(size= 8) ct_y1;
	uint(size= 8) ct_log2CbSize;
	uint(size= 8) ct_cbDepth;
	uint(size= 1) split_coding_unit;
	uint(size= 1) IsCuQpDeltaCoded;
	
	read_CodingTree.start : action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		ct_idx = 1
	var
		uint(size=32) res[1]
	do
		split_coding_unit := 0;
		if	ct_x0 + ( 1 << ct_log2CbSize ) <= pic_width_in_luma_samples and
			ct_y0 + ( 1 << ct_log2CbSize ) <= pic_height_in_luma_samples and
			MinCbAddrZS[ ct_x0 >> Log2MinCbSize ][ ct_y0 >> Log2MinCbSize ] >= SliceCbAddrZS and
			ct_log2CbSize > Log2MinCbSize and
			NumPCMBlock = 0 then
			get_SPLIT_CODING_UNIT_FLAG(codIRange, codIOffset, ctxTable, fifo, res,
										0, false, 0, false, 0);
			split_coding_unit := res[0];
		end
		IsCuQpDeltaCoded := 1;
/*
		if( adaptive_loop_filter_flag and alf_cu_control_flag and
			cbDepth <= alf_cu_control_max_depth and
			( cbDepth = = alf_cu_control_max_depth or
				split_coding_unit_flag[ x0 ][ y0 ] =0 ) ) {
			AlfCuFlagIdx++
		if( (max_cu_qp_delta_depth > 0 ) && log2CbSize >= log2MinCUDQPSize )
			IsCuQpDeltaCoded := 0
*/		
		if split_coding_unit = 1 then
			ct_x1 := ct_x0 + ( ( 1 << ct_log2CbSize ) >> 1 );
			ct_y1 := ct_y0 + ( ( 1 << ct_log2CbSize ) >> 1 );
			ct_idx := 2;
		else
			ct_idx := 6;
//			if(adaptive_loop_filter_flag && alf_cu_control_flag )
//				AlfCuFlag[ x0 ][ y0 ] = alf_cu_flag[ AlfCuFlagIdx ]		
		end
	end
	read_CodingTree_case.case1 : action ==>
	guard
		ct_idx = 2,
		MinCbAddrZS[ct_x1>>Log2MinCbSize][ct_y0>>Log2MinCbSize] > SliceCbAddrZS 
	do
		ct_x0         := ct_x0;
		ct_y0         := ct_y0;
		ct_log2CbSize := ct_log2CbSize - 1;
		ct_cbDepth    := ct_cbDepth + 1;
		ct_idx        := 3;
	end
	read_CodingTree.noCase1 : action ==>
	guard
		ct_idx = 2,
		MinCbAddrZS[ct_x1>>Log2MinCbSize][ct_y0>>Log2MinCbSize] <= SliceCbAddrZS 
	do
		ct_idx := 3;
	end
	read_CodingTree_case.case2 : action ==>
	guard
		ct_idx = 3,
		moreDataFlag   = 1 and
		MinCbAddrZS[ ct_x0 >> Log2MinCbSize ][ ct_y1 >> Log2MinCbSize ] > SliceCbAddrZS and
		ct_x1 < pic_width_in_luma_samples
	do
		ct_x0         := ct_x1;
		ct_y0         := ct_y0;
		ct_log2CbSize := ct_log2CbSize - 1;
		ct_cbDepth    := ct_cbDepth + 1;
		ct_idx        := 4;
	end
	read_CodingTree.noCase2 : action ==>
	guard
		ct_idx = 3,
		moreDataFlag   = 0 or
		MinCbAddrZS[ ct_x0 >> Log2MinCbSize ][ ct_y1 >> Log2MinCbSize ] <= SliceCbAddrZS or
		ct_x1 >= pic_width_in_luma_samples
	do
		ct_idx := 4;
	end
	read_CodingTree_case.case3 : action ==>
	guard
		ct_idx = 4,
		moreDataFlag   = 1 and
		MinCbAddrZS[ ct_x1 >> Log2MinCbSize ][ ct_y1 >> Log2MinCbSize ] > SliceCbAddrZS and
		ct_y1 < pic_height_in_luma_samples
	do
		ct_x0         := ct_x0;
		ct_y0         := ct_y1;
		ct_log2CbSize := ct_log2CbSize - 1;
		ct_cbDepth    := ct_cbDepth + 1;
		ct_idx        := 5;
	end
	read_CodingTree.noCase3 : action ==>
	guard
		ct_idx = 4,
		moreDataFlag   = 0 or
		MinCbAddrZS[ ct_x1 >> Log2MinCbSize ][ ct_y1 >> Log2MinCbSize ] <= SliceCbAddrZS or
		ct_y1 >= pic_height_in_luma_samples
	do
		ct_idx := 5;
	end
	read_CodingTree_case.case4 : action ==>
	guard
		ct_idx = 5,
		moreDataFlag   = 1 and
		ct_x1 < pic_width_in_luma_samples and
		ct_y1 < pic_height_in_luma_samples
	do
		ct_x0         := ct_x1;
		ct_y0         := ct_y1;
		ct_log2CbSize := ct_log2CbSize - 1;
		ct_cbDepth    := ct_cbDepth + 1;
		ct_idx        := 7;
	end
	read_CodingTree.noCase4 : action ==>
	guard
		ct_idx = 5,
		moreDataFlag   = 0 or
		ct_x1 >= pic_width_in_luma_samples or
		ct_y1 >= pic_height_in_luma_samples
	do
		ct_idx := 7;
	end
	read_CodingTree_gotoCodingUnit : action ==>
	guard
		ct_idx = 6,
		NumPCMBlock = 0
	do
		ct_idx			:= 7;
		cu_idx			:= 1;
		cu_x0			:= ct_x0;
		cu_y0			:= ct_y0;
		cu_log2CbSize	:= ct_log2CbSize;
	end
	read_CodingTree_gotoPCMSample : action ==>
	guard
		ct_idx = 6,
		NumPCMBlock   != 0
	do
		ct_idx := 7;
	end
	read_CodingTree_end : action ==>
	guard
		ct_idx = 7
	var
		uint(size=32) res[1]
	do
		if split_coding_unit = 1 then
 			if	( (ct_x0 + (1<<ct_log2CbSize) ) & (1<<SliceGranularity[pps_id]) ) != 0 and
				( (ct_y0 + (1<<ct_log2CbSize) ) & (1<<SliceGranularity[pps_id]) ) != 0 and
				NumPCMBlock = 0 then
//				end_of_slice_flag
				moreDataFlag := 1 - res[0];
			end
		end
	
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Coding Unit                          *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) cu_idx;
	uint(size= 8) cu_x0;
	uint(size= 8) cu_y0;
	uint(size= 8) cu_x1;
	uint(size= 8) cu_y1;
	uint(size= 8) cu_x2;
	uint(size= 8) cu_y2;
	uint(size= 8) cu_x3;
	uint(size= 8) cu_y3;
	uint(size= 8) cu_log2CbSize;
	uint(size= 8) predMode;
	uint(size= 8) partMode;
	read_CodingUnit.start : action ==>
	guard 
		cu_idx = 1
	do
		predMode := MODE_INTRA;
		if slice_type != I_SLICE then
			// get skip_flag
		end
		cu_idx := 2; 
	end
	read_CodingUnit_gotoPredictionUnit.goto1 : action ==>
	guard 
		cu_idx = 2,
		skip_flag[ct_x0][ct_y0] != 0
	do
		cu_idx			:= 8; 
		pu_idx			:= 1;
		pu_x0			:= cu_x0;
		pu_y0			:= cu_y0;
		pu_log2CbSize	:= cu_log2CbSize;
		predMode		:= MODE_SKIP;
	end
	read_CodingUnit.noGoto1 : action ==>
	guard 
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		cu_idx = 2,
		skip_flag[ct_x0][ct_y0] = 0//,
		//slice_type != I_SLICE or cu_log2CbSize = Log2MinCbSize
	var
		uint(size=32) res[1]
	do
		partMode := PART_2Nx2N;
		if slice_type != I_SLICE then
			get_PRED_MODE_FLAG(codIRange, codIOffset, ctxTable, fifo, res, slice_type = I_SLICE);
			predMode := res[0];
		end
		if predMode != MODE_INTRA or cu_log2CbSize = Log2MinCbSize then
			get_PART_SIZE(codIRange, codIOffset, ctxTable, fifo, res);
			partMode := res[0];
		end
		cu_x1  := cu_x0 + ( ( 1 << cu_log2CbSize ) >> 1 );
		cu_y1  := cu_y0 + ( ( 1 << cu_log2CbSize ) >> 1 );
		cu_x2  := cu_x1 - ( ( 1 << cu_log2CbSize ) >> 2 );
		cu_y2  := cu_y1 - ( ( 1 << cu_log2CbSize ) >> 2 );
		cu_x3  := cu_x1 + ( ( 1 << cu_log2CbSize ) >> 2 );
		cu_y3  := cu_y1 + ( ( 1 << cu_log2CbSize ) >> 2 );
		cu_idx := 3;
	end
	read_CodingUnit_gotoPredictionUnit.goto2 : action ==>
	guard 
		cu_idx = 3 or cu_idx = 4 or
		cu_idx = 5 or cu_idx = 6
	do
		pu_idx		  := 1;
		pu_x0		  := cu_x0;
		pu_y0		  := cu_y0;
		pu_log2CbSize := cu_log2CbSize;
		if cu_idx = 3 then
			cu_idx    := 4;
			if partMode = PART_2Nx2N then
				cu_idx := 7;
			end
		elsif cu_idx = 4 then
			cu_idx := 7;
			if partMode = PART_2NxN then
				pu_y0 := cu_y1;
			elsif partMode = PART_Nx2N then
				pu_x0 := cu_x1;
			elsif partMode = PART_2NxnU then
				pu_y0 := cu_y2;
			elsif partMode = PART_2NxnD then
				pu_y0 := cu_y3;
			elsif partMode = PART_nLx2N then
				pu_x0 := cu_x2;
			elsif partMode = PART_nRx2N then
				pu_x0 := cu_x3;
			else /* PART_NxN */
				cu_idx := 5;
				pu_x0  := cu_x1;
			end
		elsif cu_idx = 5 then
			cu_idx := 6;
			pu_y0  := cu_y1;
		else
			cu_idx := 7;
			pu_x0  := cu_x1;
			pu_y0  := cu_y1;
		end
	end
	read_CodingUnit_gotoTransformTree : action ==>
	guard 
		cu_idx = 7 and pcm_enabled_flag = 0
	do
		cu_idx							:= 8;
		ttStack_idx						:= 0;
		ttStack[0][TT_idx]				:= 1;
		ttStack[0][TT_x0]				:= cu_x0;
		ttStack[0][TT_y0]				:= cu_y0;
		ttStack[0][TT_xC]				:= cu_x0;
		ttStack[0][TT_yC]				:= cu_y0;
		ttStack[0][TT_log2CbSize]		:= cu_log2CbSize;
		ttStack[0][TT_log2TrafoWidth]	:= cu_log2CbSize;
		ttStack[0][TT_log2TrafoHeight]	:= cu_log2CbSize;
		ttStack[0][TT_trafoDepth]		:= 0;
		ttStack[0][TT_blkIdx]			:= 0;
	end
	read_CodingUnit_end : action ==>
	guard 
		(cu_idx = 7 and pcm_enabled_flag = 1) or
		 cu_idx = 8
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Prediction Unit                      *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) pu_idx;
	uint(size= 8) pu_x0;
	uint(size= 8) pu_y0;
	uint(size= 8) pu_log2CbSize;
	uint(size= 1) pcm_flag;
	
	read_PredictionUnit.start : action ==>
	guard 
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		pu_idx = 1
	var
		uint(size=32) res[1],
		uint(size= 8) Log2MinIPCMCUSize = log2_min_coding_block_size_minus3 + 3,
		uint(size= 8) Log2MaxIPCMCUSize = log2_min_coding_block_size_minus3 + 3
	do
		pu_idx := 7;
		if ( skip_flag[pu_x0][pu_y0] = 1) then
			if( MaxNumMergeCand > 1 ) then
				//merge_idx[ x0 ][ y0 ]
			end
			pu_idx := 7;
		elsif( predMode = MODE_INTRA ) then
 			pcm_flag := 0;
			if( partMode = PART_2Nx2N && pcm_enabled_flag = 1 &&
				pu_log2CbSize >= Log2MinIPCMCUSize &&
				pu_log2CbSize <= Log2MaxIPCMCUSize ) then
				//pcm_flag := res[0]
			end
			if( pcm_flag = 1) then
				//num_subsequent_pcm
				// NumPCMBlock = res[0] + 1
				byte_align(fifo);
				pu_idx := 2;
			else 
				get_PREV_INTRA_LUMA_PRED_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
				//prev_intra_luma_pred_flag[pu_x0][pu_y0] := res[0];
				if res[0] = 1 then
					get_MPM_IDX(codIRange, codIOffset, ctxTable, fifo, res);
				else
					get_PREV_INTRA_LUMA_PRED(codIRange, codIOffset, ctxTable, fifo, res);
				end
				get_INTRA_CHROMA_PRED_MODE(codIRange, codIOffset, ctxTable, fifo, res, chroma_pred_from_luma_enabled_flag[sps_id]);
				//intra_chroma_pred_mode[pu_x0][pu_y0] := res[0]
/*
 				SignalledAsChromaDC = ( chroma_pred_from_luma_enabled_flag ?
						intra_chroma_pred_mode[pu_x0][pu_y0] = 3 :
						intra_chroma_pred_mode[pu_x0][pu_y0] = 2 )
*/
				pu_idx := 7;
			end
		else /* MODE_INTER */
			//merge_flag[pu_x0][pu_y0] := res[0]
			if res[0] = 1 then
				if MaxNumMergeCand > 1 then
					//merge_idx[pu_x0][pu_y0] := res[0]
				end
				pu_idx := 7;
			else
				inter_pred_flag[pu_x0][pu_y0] := Pred_L0;
				if( slice_type = B_SLICE ) then
					//inter_pred_flag[pu_x0][pu_y0] := res[0];
				end
				if( inter_pred_flag[pu_x0][pu_y0] = Pred_LC ) then
					if( num_ref_idx_lc_active_minus1 > 0 ) then
						//ref_idx_lc[ x0 ][ y0 ]
					end
				else // Pred_L0 or Pred_BI
					if( num_ref_idx_l0_active_minus1 > 0 ) then
						//ref_idx_l0[ x0 ][ y0 ]
					end
				end	
				pu_idx := 3;
			end
		end
	end
	read_PredictionUnit_gotoPCMSample: action ==>
	guard 
		pu_idx = 2
	do
		PCMSample_x0	:= pu_x0;
		PCMSample_y0	:= pu_y0;
		pu_idx			:= 7;
	end
	read_PredictionUnit.retMVDcoding_goto1: action ==>
	guard 
		pu_idx = 4
	do
		if( inter_pred_flag[pu_x0][pu_y0] = Pred_LC ) then
			//mvp_lc_flag[ x0 ][ y0 ];
		else // Pred_L0 or Pred_BI
			//mvp_l0_flag[ x0 ][ y0 ]
		end	
		pu_idx := 7;
		if( inter_pred_flag[pu_x0][pu_y0] = Pred_BI ) then
			if( num_ref_idx_l1_active_minus1 > 0 ) then
				//ref_idx_l1[ x0 ][ y0 ]
			end
			if( /*mvd_l1_zero_flag*/ true ) then
				//mvd_l1[ x0 ][ y0 ][ 0 ] = 0
				//mvd_l1[ x0 ][ y0 ][ 1 ] = 0
				pu_idx := 6;
			else
				pu_idx := 5;
			end
		end
	end
	read_PredictionUnit_gotoMVDCoding: action ==>
	guard 
		pu_idx = 3 or pu_idx = 5
	do
		pu_idx := pu_idx + 1;
	end
	read_PredictionUnit.retMVDcoding_goto2: action ==>
	guard 
		pu_idx = 6
	do
		//mvp_l1_flag[ x0 ][ y0 ]
		pu_idx := 7;
	end
	read_PredictionUnit_end: action ==>
	guard 
		pu_idx = 7
	end
	/**************************************************************************
	 **************************************************************************
	 ********        MVD Coding                           *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) mvd_x;
	uint(size= 8) mvd_y;
	read_MVDCoding.start : action ==>		
	do
		println("read_MVDCoding");
	end
	/**************************************************************************
	 **************************************************************************
	 ********        PCM Sample                           *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) PCMSample_x0;
	uint(size= 8) PCMSample_y0;
	read_PCMSample.start : action ==>		
	do
		println("read_PCMSample");
	end
	read_PCMSample2.start : action ==>		
	do
		println("read_PCMSample2");
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Transform Tree                       *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) ttStack_idx;
	uint(size= 8) ttStack[10][TT_STRUCT_SIZE];
	uint(size= 1) split_transform_flag[256][256][256];
	uint(size= 1) cbf_cb[256][256][256];
	uint(size= 1) cbf_cr[256][256][256];
	uint(size= 1) cbf_luma[256][256][256];
	
	
	function getInterTUSplitDirection(uint(size= 8) log2TrafoSize) --> uint(size= 3) :
		if( ( ( log2TrafoSize = Log2MaxTrafoSize or ( log2TrafoSize < Log2MaxTrafoSize and ttStack[ttStack_idx][TT_trafoDepth] = 0 ) )
			and log2TrafoSize > ( Log2MinTrafoSize + 1 )
			and ( partMode = PART_2NxN or partMode = PART_2NxnU or partMode = PART_2NxnD ) )
			or ( log2TrafoSize = ( Log2MinTrafoSize + 1 )
			and ttStack[ttStack_idx][TT_log2TrafoWidth] < ttStack[ttStack_idx][TT_log2TrafoHeight] ) ) then
			0
		elsif( ( ( log2TrafoSize = Log2MaxTrafoSize or ( log2TrafoSize < Log2MaxTrafoSize and ttStack[ttStack_idx][TT_trafoDepth] =  0 ) )
			and log2TrafoSize > ( Log2MinTrafoSize + 1 )
			and ( partMode = PART_Nx2N or partMode = PART_nLx2N or partMode = PART_nRx2N ) )
			or  ( log2TrafoSize = ( Log2MinTrafoSize + 1 )
			and ttStack[ttStack_idx][TT_log2TrafoWidth] > ttStack[ttStack_idx][TT_log2TrafoHeight] ) ) then
			1
		else
			2
		end
	end
	read_TransformTree.start : action ==>
	guard 
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		ttStack[ttStack_idx][TT_idx] = 1
	var
		uint(size=32) res[1] := [0],
		uint(size= 1) IntraSplitFlag = if predMode = MODE_INTRA and partMode = PART_NxN then 1 else 0 end,
		uint(size= 8) log2TrafoSize,
		uint(size= 1) intraSplitFlag,
		uint(size= 1) interSplitFlag,
		uint(size= 8) maxDepth,
		uint(size= 8) xBase,
		uint(size= 8) yBase,
		uint(size= 1) firstChromaCbf,
		bool 		   readCbf,
		uint(size=3)  InterTUSplitDirection
	do
		println("==================== read_TransformTree.start : "+ttStack_idx+" : "+ttStack[ttStack_idx][TT_blkIdx]+" ====================");
		ttStack[ttStack_idx][TT_idx] := 7;
		if( ttStack[ttStack_idx][TT_trafoDepth] = 0 and IntraSplitFlag = 0 and predMode != MODE_INTRA and
			not (partMode = PART_2Nx2N and merge_flag[ttStack[ttStack_idx][TT_x0]][ttStack[ttStack_idx][TT_y0]] = 1) ) then
				//no_residual_data_flag
		end
		if( /*no_residual_data_flag*/ res[0] = 0 ) then
			log2TrafoSize  := ( ttStack[ttStack_idx][TT_log2TrafoWidth] + ttStack[ttStack_idx][TT_log2TrafoHeight] ) >> 1;
			intraSplitFlag := if IntraSplitFlag = 1 and ttStack[ttStack_idx][TT_trafoDepth] = 0 then 1 else 0 end;
			interSplitFlag := if max_transform_hierarchy_depth_inter = 0 and
								 predMode = MODE_INTER && partMode != PART_2Nx2N and
								 ttStack[ttStack_idx][TT_trafoDepth] = 0 then 1 else 0 end;
			maxDepth 	   := if predMode = MODE_INTRA then
							 	 max_transform_hierarchy_depth_intra + intraSplitFlag
							  else
								 max_transform_hierarchy_depth_inter + interSplitFlag
							  end;
			xBase := ttStack[ttStack_idx][TT_x0] - ( ttStack[ttStack_idx][TT_x0] & ( 1 << ttStack[ttStack_idx][TT_log2TrafoWidth] ) );
			yBase := ttStack[ttStack_idx][TT_y0] - ( ttStack[ttStack_idx][TT_y0] & ( 1 << ttStack[ttStack_idx][TT_log2TrafoHeight] ) );
			split_transform_flag[ttStack[ttStack_idx][TT_x0]][ttStack[ttStack_idx][TT_y0]][ttStack[ttStack_idx][TT_trafoDepth]] := 0;
/*
  			if log2TrafoSize <= Log2MaxTrafoSize and log2TrafoSize > Log2MinTrafoSize and
			   ttStack[ttStack_idx][TT_trafoDepth] < maxDepth and intraSplitFlag = 0 and interSplitFlag = 0 then
*/
			if ttStack_idx = 0 then
				get_SPLIT_TRANSFORM_FLAG(codIRange, codIOffset, ctxTable, fifo, res, 1 /*ct_cbDepth + ttStack[ttStack_idx][TT_trafoDepth]*/ );
				split_transform_flag[ttStack[ttStack_idx][TT_x0]][ttStack[ttStack_idx][TT_y0]][ttStack[ttStack_idx][TT_trafoDepth]] := res[0];				
			end
			if log2TrafoSize <= Log2MaxTrafoSize  then
				firstChromaCbf := if log2TrafoSize = Log2MaxTrafoSize or ttStack[ttStack_idx][TT_trafoDepth] = 0 then 1 else 0 end;
				if firstChromaCbf = 1 or log2TrafoSize > Log2MinTrafoSize then
					if firstChromaCbf = 1 or cbf_cb[ xBase ][ yBase ][ ttStack[ttStack_idx][TT_trafoDepth] - 1 ] = 1 then
						readCbf := true;
						if ttStack[ttStack_idx][TT_blkIdx] = 3 && log2TrafoSize < Log2MaxTrafoSize then
							readCbf := cbf_cb[ xBase ][ yBase ][ ttStack[ttStack_idx][TT_trafoDepth] ] = 1 or
									   cbf_cb[ xBase + ( 1 << ttStack[ttStack_idx][TT_log2TrafoWidth] ) ][ yBase ][ ttStack[ttStack_idx][TT_trafoDepth] ] = 1 or
									   cbf_cb[ xBase ][ yBase + ( 1 << ttStack[ttStack_idx][TT_log2TrafoHeight] ) ][ ttStack[ttStack_idx][TT_trafoDepth] ] = 1;
						end
						if( not readCbf ) then
							cbf_cb[ ttStack[ttStack_idx][TT_x0] ][ ttStack[ttStack_idx][TT_y0] ][ ttStack[ttStack_idx][TT_trafoDepth] ] := 1;
						else
							get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res, ttStack[ttStack_idx][TT_trafoDepth]);
							cbf_cb[ ttStack[ttStack_idx][TT_x0] ][ ttStack[ttStack_idx][TT_y0] ][ ttStack[ttStack_idx][TT_trafoDepth] ] := res[0];
						end
					end
					if firstChromaCbf = 1 or cbf_cr[ xBase ][ yBase ][ ttStack[ttStack_idx][TT_trafoDepth] - 1 ] = 1 then
						readCbf := true;
						if( ttStack[ttStack_idx][TT_blkIdx] = 3 && log2TrafoSize < Log2MaxTrafoSize ) then
							readCbf := cbf_cr[ xBase ][ yBase ][ ttStack[ttStack_idx][TT_trafoDepth] ] = 1 or
									   cbf_cr[ xBase + ( 1 << ttStack[ttStack_idx][TT_log2TrafoWidth] ) ][ yBase ][ ttStack[ttStack_idx][TT_trafoDepth] ] = 1 or
									   cbf_cr[ xBase ][ yBase + ( 1 << ttStack[ttStack_idx][TT_log2TrafoHeight] ) ][ ttStack[ttStack_idx][TT_trafoDepth] ] = 1;
						end
						if( not readCbf ) then
							cbf_cr[ ttStack[ttStack_idx][TT_x0] ][ ttStack[ttStack_idx][TT_y0] ][ ttStack[ttStack_idx][TT_trafoDepth] ] := 1;
						else
							get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res, ttStack[ttStack_idx][TT_trafoDepth]);
							cbf_cr[ ttStack[ttStack_idx][TT_x0] ][ ttStack[ttStack_idx][TT_y0] ][ ttStack[ttStack_idx][TT_trafoDepth] ] := res[0];
						end
					end
				end
			end			
			if split_transform_flag[ttStack[ttStack_idx][TT_x0]][ttStack[ttStack_idx][TT_y0]][ttStack[ttStack_idx][TT_trafoDepth]] = 1 then
				InterTUSplitDirection := getInterTUSplitDirection(log2TrafoSize);
				if InterTUSplitDirection = 2 then
					ttStack[ttStack_idx][TT_x1] := ttStack[ttStack_idx][TT_x0] + ( ( 1 << ttStack[ttStack_idx][TT_log2TrafoWidth] ) >> 1 );
					ttStack[ttStack_idx][TT_y1] := ttStack[ttStack_idx][TT_y0];
					ttStack[ttStack_idx][TT_x2] := ttStack[ttStack_idx][TT_x0];
					ttStack[ttStack_idx][TT_y2] := ttStack[ttStack_idx][TT_y0] + ( ( 1 << ttStack[ttStack_idx][TT_log2TrafoHeight] ) >> 1 );
					ttStack[ttStack_idx][TT_x3] := ttStack[ttStack_idx][TT_x1];
					ttStack[ttStack_idx][TT_y3] := ttStack[ttStack_idx][TT_y2];
				else
					ttStack[ttStack_idx][TT_x1] := ttStack[ttStack_idx][TT_x0] + ( ( 1 << ttStack[ttStack_idx][TT_log2TrafoWidth] ) >> 2 ) * InterTUSplitDirection;
					ttStack[ttStack_idx][TT_y1] := ttStack[ttStack_idx][TT_y0] + ( ( 1 << ttStack[ttStack_idx][TT_log2TrafoHeight]) >> 2 ) * ( 1 - InterTUSplitDirection );
					ttStack[ttStack_idx][TT_x2] := ttStack[ttStack_idx][TT_x1] + ( ( 1 << ttStack[ttStack_idx][TT_log2TrafoWidth] ) >> 2 ) * InterTUSplitDirection;
					ttStack[ttStack_idx][TT_y2] := ttStack[ttStack_idx][TT_y1] + ( ( 1 << ttStack[ttStack_idx][TT_log2TrafoHeight]) >> 2 ) * ( 1 - InterTUSplitDirection );
					ttStack[ttStack_idx][TT_x3] := ttStack[ttStack_idx][TT_x2] + ( ( 1 << ttStack[ttStack_idx][TT_log2TrafoWidth] ) >> 2 ) * InterTUSplitDirection;
					ttStack[ttStack_idx][TT_y3] := ttStack[ttStack_idx][TT_y2] + ( ( 1 << ttStack[ttStack_idx][TT_log2TrafoHeight]) >> 2 ) * ( 1 - InterTUSplitDirection );
					ttStack[ttStack_idx][TT_log2TrafoHeight] := ttStack[ttStack_idx][TT_log2TrafoHeight] + 2 * InterTUSplitDirection - 1;
					ttStack[ttStack_idx][TT_log2TrafoWidth] := ttStack[ttStack_idx][TT_log2TrafoWidth] - 2 * InterTUSplitDirection + 1;
				end
				ttStack[ttStack_idx][TT_idx] := 2;
			else
				if predMode = MODE_INTRA or ttStack[ttStack_idx][TT_trafoDepth] != 0 or
				   cbf_cb[ ttStack[ttStack_idx][TT_x0] ][ ttStack[ttStack_idx][TT_y0] ][ ttStack[ttStack_idx][TT_trafoDepth] ] = 1 or
				   cbf_cr[ ttStack[ttStack_idx][TT_x0] ][ ttStack[ttStack_idx][TT_y0] ][ ttStack[ttStack_idx][TT_trafoDepth] ] = 1 then
					readCbf := true;
					if ttStack[ttStack_idx][TT_blkIdx] = 3 and predMode != MODE_INTRA and
						( ttStack[ttStack_idx][TT_log2CbSize] <= Log2MaxTrafoSize+1 or log2TrafoSize < Log2MaxTrafoSize ) then
						readCbf := cbf_luma[ xBase ][ yBase ][ ttStack[ttStack_idx][TT_trafoDepth] ] = 1 or
								   cbf_luma[ xBase + ( 1 << ttStack[ttStack_idx][TT_log2TrafoWidth] ) ][ yBase ][ ttStack[ttStack_idx][TT_trafoDepth] ] = 1 or
								   cbf_luma[ xBase ][ yBase + ( 1 << ttStack[ttStack_idx][TT_log2TrafoHeight] ) ][ ttStack[ttStack_idx][TT_trafoDepth] ] = 1 or
								   cbf_cb[ xBase ][ yBase ][ ttStack[ttStack_idx][TT_trafoDepth] - 1] = 1 or
								   cbf_cr[ xBase ][ yBase ][ ttStack[ttStack_idx][TT_trafoDepth] - 1] = 1;
					end
					if not readCbf then
						cbf_luma[ ttStack[ttStack_idx][TT_x0] ][ ttStack[ttStack_idx][TT_y0] ][ ttStack[ttStack_idx][TT_trafoDepth] ] := 1;
					else
						get_CBF_LUMA(codIRange, codIOffset, ctxTable, fifo, res, 0/*if ttStack[ttStack_idx][TT_trafoDepth] = 0 or log2TrafoSize = Log2MaxTrafoSize then 1 else 0 end*/);
						cbf_luma[ ttStack[ttStack_idx][TT_x0] ][ ttStack[ttStack_idx][TT_y0] ][ ttStack[ttStack_idx][TT_trafoDepth] ] := res[0];
					end
					ttStack[ttStack_idx][TT_idx] := 6;
				end
			end	
		end
	end
	read_TransformTree.gotoTransformTree : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 2 or ttStack[ttStack_idx][TT_idx] = 3 or
		ttStack[ttStack_idx][TT_idx] = 4 or ttStack[ttStack_idx][TT_idx] = 5
	do
		if ttStack[ttStack_idx][TT_idx] = 2 then
			ttStack_idx 								:= ttStack_idx + 1;
			ttStack[ttStack_idx-1][TT_idx]				:= 3;
			ttStack[ttStack_idx][TT_idx]				:= 1;
			ttStack[ttStack_idx][TT_x0]					:= ttStack[ttStack_idx-1][TT_x0];
			ttStack[ttStack_idx][TT_y0]					:= ttStack[ttStack_idx-1][TT_y0];
			ttStack[ttStack_idx][TT_xC]					:= ttStack[ttStack_idx-1][TT_x0];
			ttStack[ttStack_idx][TT_yC]					:= ttStack[ttStack_idx-1][TT_y0];
			ttStack[ttStack_idx][TT_log2CbSize]			:= ttStack[ttStack_idx-1][TT_log2CbSize];
			ttStack[ttStack_idx][TT_log2TrafoWidth]		:= ttStack[ttStack_idx-1][TT_log2TrafoWidth]  - 1;
			ttStack[ttStack_idx][TT_log2TrafoHeight]	:= ttStack[ttStack_idx-1][TT_log2TrafoHeight] - 1;
			ttStack[ttStack_idx][TT_trafoDepth]			:= ttStack[ttStack_idx-1][TT_trafoDepth] + 1;
			ttStack[ttStack_idx][TT_blkIdx]				:= 0;
		elsif ttStack[ttStack_idx][TT_idx] = 3 then
			ttStack_idx 								:= ttStack_idx + 1;
			ttStack[ttStack_idx-1][TT_idx]				:= 4;
			ttStack[ttStack_idx][TT_idx]				:= 1;
			ttStack[ttStack_idx][TT_x0]					:= ttStack[ttStack_idx-1][TT_x1];
			ttStack[ttStack_idx][TT_y0]					:= ttStack[ttStack_idx-1][TT_y1];
			ttStack[ttStack_idx][TT_blkIdx]				:= 1;
		elsif ttStack[ttStack_idx][TT_idx] = 4 then
			ttStack_idx 								:= ttStack_idx + 1;
			ttStack[ttStack_idx-1][TT_idx]				:= 5;
			ttStack[ttStack_idx][TT_idx]				:= 1;
			ttStack[ttStack_idx][TT_x0]					:= ttStack[ttStack_idx-1][TT_x2];
			ttStack[ttStack_idx][TT_y0]					:= ttStack[ttStack_idx-1][TT_y2];
			ttStack[ttStack_idx][TT_blkIdx]				:= 2;
		else
			ttStack_idx 								:= ttStack_idx + 1;
			ttStack[ttStack_idx-1][TT_idx]				:= 7;
			ttStack[ttStack_idx][TT_idx]				:= 1;
			ttStack[ttStack_idx][TT_x0]					:= ttStack[ttStack_idx-1][TT_x3];
			ttStack[ttStack_idx][TT_y0]					:= ttStack[ttStack_idx-1][TT_y3];
			ttStack[ttStack_idx][TT_blkIdx]				:= 3;
		end
	end
	read_TransformTree_gotoTransformUnit : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 6
	do
		ttStack[ttStack_idx][TT_idx]	:= 7;
		tu_idx							:= 1;
		tu_x0							:= ttStack[ttStack_idx][TT_x0];
		tu_y0							:= ttStack[ttStack_idx][TT_y0];
		tu_xC							:= ttStack[ttStack_idx][TT_xC];
		tu_yC							:= ttStack[ttStack_idx][TT_yC];
		tu_log2TrafoWidth				:= ttStack[ttStack_idx][TT_log2TrafoWidth];
		tu_log2TrafoHeight				:= ttStack[ttStack_idx][TT_log2TrafoHeight];
		tu_trafoDepth					:= ttStack[ttStack_idx][TT_trafoDepth];
		tu_blkIdx						:= ttStack[ttStack_idx][TT_blkIdx];
	end
	read_TransformTree_end : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 7 and ttStack_idx = 0 
	do
	end
	read_TransformTree.endCall : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 7 and ttStack_idx != 0 
	do
		ttStack_idx := ttStack_idx - 1;
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Transform Unit                       *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) tu_idx;
	uint(size= 8) tu_x0;
	uint(size= 8) tu_y0;
	uint(size= 8) tu_xC;
	uint(size= 8) tu_yC;
	uint(size= 8) tu_log2TrafoWidth;
	uint(size= 8) tu_log2TrafoHeight;
	uint(size= 8) tu_trafoDepth;
	uint(size= 8) tu_blkIdx;
	uint(size= 2) scanIdx;
	uint(size= 2) scanIdxC;
	
	read_TransformUnit.start : action ==>
	guard 
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		tu_idx = 1
	var
		uint(size=32) res[1],
		uint(size= 8) log2TrafoSize
	do
		tu_idx := 7;
		if  cbf_luma[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 or
			cbf_cb[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 or
			cbf_cr[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 then
			if max_cu_qp_delta_depth > 0  and IsCuQpDeltaCoded = 0 then
				//cu_qp_delta
				IsCuQpDeltaCoded := 1;
			end
			log2TrafoSize  := ( tu_log2TrafoWidth + tu_log2TrafoHeight ) >> 1;
			if predMode = MODE_INTRA then
				scanIdx  := ScanType[ log2TrafoSize - 2 ][ 0/*IntraPredMode*/ ];
				scanIdxC := ScanType[ log2TrafoSize - 2 ][ 0/*IntraPredModeC*/ ];
			else
				scanIdx  := 0;
				scanIdxC := 0;
			end
			tu_idx := 3;
			if cbf_luma[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 then
				tu_idx 				:= 2;
				rc_idx 				:= 1;
				rc_x0 				:= tu_x0;
				rc_y0 				:= tu_y0;
				rc_log2TrafoWidth	:= tu_log2TrafoWidth;
				rc_log2TrafoHeight	:= tu_log2TrafoHeight;
				rc_scanIdx			:= scanIdx;
				rc_cIdx				:= 0;
			end
		end
	end
	read_TransformUnit.retLuma : action ==>
	guard 
		tu_idx = 3
	var
		uint(size= 8) log2TrafoSize  = ( tu_log2TrafoWidth + tu_log2TrafoHeight ) >> 1,
		uint(size= 8) log2TrafoSizeC = if log2TrafoSize = Log2MinTrafoSizeC then log2TrafoSize else log2TrafoSize - 1 end
	do
		tu_idx 				:= 7;
		rc_idx 				:= 1;
		rc_log2TrafoWidth	:= log2TrafoSizeC;
		rc_log2TrafoHeight	:= tu_trafoDepth;
		rc_scanIdx			:= scanIdxC;
		rc_cIdx				:= 1;
		if log2TrafoSize > Log2MinTrafoSize then
			tu_idx := 5;
			if cbf_cb[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 then
				tu_idx 	:= 4;
				rc_x0 	:= tu_x0;
				rc_y0 	:= tu_y0;
			end
		elsif tu_blkIdx = 3 then
			tu_idx := 5;
			if cbf_cb[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 then
				tu_idx 	:= 4;
				rc_x0 	:= tu_xC;
				rc_y0 	:= tu_yC;
			end
		end
	end
	read_TransformUnit.retCb : action ==>
	guard 
		tu_idx = 5
	var
		uint(size= 8) log2TrafoSize  = ( tu_log2TrafoWidth + tu_log2TrafoHeight ) >> 1
	do	
		tu_idx	:= 7;
		rc_idx 	:= 1;
		rc_cIdx	:= 2;
		if log2TrafoSize > Log2MinTrafoSize then
			if cbf_cr[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 then
				tu_idx := 6;
			end
		elsif tu_blkIdx = 3 then
			if cbf_cr[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 then
				tu_idx := 6;
			end
		end
	end
	read_TransformUnit_gotoResidualCoding : action ==>
	guard 
		tu_idx = 2 or tu_idx = 4 or tu_idx = 6
	do	
		tu_idx := tu_idx + 1;
	end
	read_TransformUnit_end : action ==>
	guard 
		tu_idx = 7	
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Residual Coding                      *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) rc_idx;
	uint(size= 8) rc_x0;
	uint(size= 8) rc_y0;
	uint(size= 8) rc_log2TrafoWidth;
	uint(size= 8) rc_log2TrafoHeight;
	uint(size= 8) rc_scanIdx;
	uint(size= 8) rc_cIdx;
	
	uint(size= 8) DiagScan[BLW_WIDTH_MAX][BLW_HEIGHT_MAX];
	uint(size= 8) ScanOrder[3][BLW_WIDTH_MAX][BLW_HEIGHT_MAX];
	uint(size= 1) significant_coeff_flag[BLW_WIDTH_MAX][BLW_HEIGHT_MAX];
	uint(size= 1) significant_coeff_group_flag[BLW_WIDTH_MAX][BLW_HEIGHT_MAX];
	
	read_ResidualCoding.start : action ==>
	guard 
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		rc_idx = 1
	var
		uint(size=32) res[1],
		uint(size= 8) LastSignificantCoeffX,
		uint(size= 8) LastSignificantCoeffY,
		uint(size= 8) xC		:= 0,
		uint(size= 8) yC		:= 0,
		uint(size= 8) numCoeff := 0,
		uint(size= 8) numLastSubset,
		uint(size= 8) xCG,
		uint(size= 8) yCG,
		uint(size= 1) implicitNonZeroCoeff,
		uint(size= 8) offset,
		uint(size= 8) ctxCG := 0
	do	
		get_LAST_SIGNIFICANT_COEFF_X_PREFIX(codIRange, codIOffset, ctxTable, fifo, res, rc_log2TrafoWidth, rc_cIdx);
		LastSignificantCoeffX := res[0];
		get_LAST_SIGNIFICANT_COEFF_Y_PREFIX(codIRange, codIOffset, ctxTable, fifo, res, rc_log2TrafoHeight, rc_cIdx);
		LastSignificantCoeffY := res[0];
		if LastSignificantCoeffX > 3 then
			get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(codIRange, codIOffset, ctxTable, fifo, res, LastSignificantCoeffX);
			LastSignificantCoeffX := (1 << ((LastSignificantCoeffX >> 1) - 1)) *
									 (2  +  (LastSignificantCoeffX & 1 )) + res[0];			
		end
		if LastSignificantCoeffY > 3 then 
			get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(codIRange, codIOffset, ctxTable, fifo, res, LastSignificantCoeffY);
			LastSignificantCoeffY := (1 << ((LastSignificantCoeffY >> 1) - 1)) *
									 (2  +  (LastSignificantCoeffY & 1 )) + res[0];
		end
		if rc_scanIdx = 2 then
			res[0] 				  := LastSignificantCoeffX;
			LastSignificantCoeffX := LastSignificantCoeffY;
			LastSignificantCoeffY := res[0];
		end
		InitScanningArray(1<<rc_log2TrafoWidth, 1<<rc_log2TrafoHeight, DiagScan, ScanOrder);
		while  xC != LastSignificantCoeffX or yC != LastSignificantCoeffY do
			xC := ScanOrder[ rc_scanIdx ][ numCoeff ][ 0 ]; 
			yC := ScanOrder[ rc_scanIdx ][ numCoeff ][ 1 ]; 
			numCoeff := numCoeff + 1;
		end 
		numLastSubset := (numCoeff - 1) >> 4;
  		foreach int i in 0 .. numLastSubset do 
      		offset := (numLastSubset-i) << 4;
      		if rc_scanIdx = 1 and rc_log2TrafoWidth = 3 and rc_log2TrafoHeight = 3 then 
      			xCG := 0;
      			yCG := (numLastSubset-i);
      		elsif rc_scanIdx = 2 and rc_log2TrafoWidth = 3 and rc_log2TrafoHeight = 3 then 
      			xCG := (numLastSubset-i);
      			yCG := 0;
      		else 
				InitScanningArray(1<<(rc_log2TrafoWidth-2), 1<<(rc_log2TrafoHeight-2), DiagScan, ScanOrder);
      			xCG := ScanOrder[ rc_scanIdx ][ (numLastSubset-i) ][ 0 ];
          		yCG := ScanOrder[ rc_scanIdx ][ (numLastSubset-i) ][ 1 ]; 
			end
            implicitNonZeroCoeff := 0; 
            if i < numLastSubset and i > 0 then 
            	//significant_coeff_group_flag[ xCG ][ yCG ] := res[0]; 
              	implicitNonZeroCoeff := 1; 
            end
			InitScanningArray(1<<rc_log2TrafoWidth, 1<<rc_log2TrafoHeight, DiagScan, ScanOrder);
  			foreach int n in 0 .. 15 do  
				xC := ScanOrder[ rc_scanIdx ][ (15-n) + offset ][ 0 ]; 
				yC := ScanOrder[ rc_scanIdx ][ (15-n) + offset ][ 1 ];
				if  (15-n + offset) < (numCoeff - 1) and significant_coeff_group_flag[ xCG ][ yCG ] = 1 and 
					( 15-n > 0 or implicitNonZeroCoeff = 0 ) then
                    //significant_coeff_flag[ xC ][ yC ] := res[0];
					if significant_coeff_flag[ xC ][ yC ] = 1 then 
                    	implicitNonZeroCoeff := 0;
                 	end
				end
			end
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        undefined                            *********************
	 **************************************************************************
	 *************************************************************************/
  	bool actorNotFinished := true;
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("Algo_Parser doesn't manage this case yet");
		actorNotFinished := false;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        schedule                             *********************
	 **************************************************************************
	 *************************************************************************/
  	schedule fsm start_code:
		// byte align
		byte_align          			( byte_align_a						) --> start_code;
		// search start code
		start_code          			( start_code.search					) --> start_code;
		start_code			            ( start_code.done					) --> read_Nal_unit_header;
		// read Nal Unit header
		read_Nal_unit_header			( read_nal_unit_header				) --> find_header;
		find_header	  					( look_for.SPS_header	  			) --> read_SPS_Header;
		find_header	  					( look_for.PPS_header	  			) --> read_PPS_Header;
		find_header	  					( look_for.Slice_header	  			) --> read_SliceHeader;
		find_header	  					( look_for.APS_header				) --> read_APS_Header;
		find_header	  					( look_for_other_header				) --> byte_align;
		// read SPS header
		read_SPS_Header	  				( read_SPS_Header	    			) --> read_SPS_Header;
		read_SPS_Header	  				( read_SPS_Header_done    			) --> byte_align;
		// read PPS header
		read_PPS_Header 				( read_PPS_Header   				) --> read_PPS_Header;
		read_PPS_Header	  				( read_PPS_Header_done    			) --> byte_align;
		// read_SliceHeader
		read_SliceHeader				( read_SliceHeader					) --> read_SliceHeader;
		read_SliceHeader				( read_SliceHeader_done				) --> read_SliceData;
		// read_SliceData
		read_SliceData				    ( read_SliceData	  				) --> read_SliceData;
		read_SliceData				    ( read_SliceData_gotoCodingTree		) --> read_CodingTree;
		read_SliceData				    ( read_SliceData_end	  			) --> byte_align;
		// read_CodingTree
		read_CodingTree				    ( read_CodingTree	  				) --> read_CodingTree;
		read_CodingTree				    ( read_CodingTree_case 				) --> undefined;
		read_CodingTree				    ( read_CodingTree_gotoCodingUnit	) --> read_CodingUnit;
		read_CodingTree				    ( read_CodingTree_gotoPCMSample		) --> read_PCMSample;
		read_CodingTree				    ( read_CodingTree_end	 			) --> read_SliceData;
		// read_CodingUint
		read_CodingUnit				    ( read_CodingUnit	  				) --> read_CodingUnit;
		read_CodingUnit				    ( read_CodingUnit_gotoPredictionUnit) --> read_PredictionUnit;
		read_CodingUnit				    ( read_CodingUnit_gotoTransformTree ) --> read_TransformTree;
		read_CodingUnit				    ( read_CodingUnit_end				) --> read_CodingTree;
		// read_PredictionUnit
		read_PredictionUnit			    ( read_PredictionUnit	  			) --> read_PredictionUnit;
		read_PredictionUnit			    ( read_PredictionUnit_gotoPCMSample ) --> read_PCMSample2;
		read_PredictionUnit			    ( read_PredictionUnit_gotoMVDCoding ) --> read_MVDCoding;
		read_PredictionUnit			    ( read_PredictionUnit_end			) --> read_CodingUnit;
		// read_MVDCoding
		read_MVDCoding				    ( read_MVDCoding	  				) --> undefined;//read_PredictionUnit;
		// read_PCMSample
		read_PCMSample				    ( read_PCMSample	  				) --> undefined;//read_CodingTree;
		read_PCMSample2				    ( read_PCMSample2	  				) --> undefined;//read_PredictionUnit;
		// read_TransformTree
		read_TransformTree			    ( read_TransformTree	  			) --> read_TransformTree;
		read_TransformTree			    ( read_TransformTree_gotoTransformUnit) --> read_TransformUnit;
		read_TransformTree			    ( read_TransformTree_end	  		) --> read_CodingUnit;
		// read_TransformUnit
		read_TransformUnit			    ( read_TransformUnit	  			) --> read_TransformUnit;
		read_TransformUnit			    ( read_TransformUnit_gotoResidualCoding) --> read_ResidualCoding;
		read_TransformUnit			    ( read_TransformUnit_end			) --> read_TransformTree;
		// read_ResidualCoding
		read_ResidualCoding				( read_ResidualCoding				) --> read_TransformUnit;
		// read_APS_Header
		read_APS_Header				    ( read_APS_Header					) --> read_APS_Header;
		read_APS_Header				    ( read_APS_Header_done				) --> byte_align;
		
		
		
		// undefined
		undefined	  					( undefined		    				) --> undefined;
	end
	
	/**************************************************************************
	 * priority
	 *************************************************************************/
	priority
		look_for        > look_for_other_header;
	end
end