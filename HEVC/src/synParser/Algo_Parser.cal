package synParser;

import  org.mpeg4.part10.cbp.MacroBlockInfo.*;
import  synParser.Algo_ParserUtils.*;

actor Algo_Parser () 
				uint(size= 8) byte
				==>
:
	bool DEBUG_BITSTREAM = false;
	bool DEBUG_PARSER    = true;
	uint(size= 8) se_idx;
	 int(size=32) res;
	uint(size=32) cnt_i;
	/**************************************************************************
	 **************************************************************************
	 ********        Bitstream Reader                     *********************
	 **************************************************************************
	 *************************************************************************/
	
	/**************************************************************************
	 * function getFifoIdx
	 *************************************************************************/
  	function getFifoIdx (uint(size=4) cptBits) --> uint(size=4)
  		var 
  			uint(size=4) fifo_idx =  fifo[FIFO_IDX]
  		:
  		if (cptBits & (FIFO_SIZE - 1)) != 0 then
	    	(fifo_idx - 1 - (cptBits>>3)) & (FIFO_SIZE-1)
	    else
	    	(fifo_idx - (cptBits>>3)) & (FIFO_SIZE-1)
	    end
  	end
	/**************************************************************************
	 * function IsStartCode
	 *************************************************************************/
  	function IsStartCode () --> bool
  		var 
  		uint(size=4) cptBits = fifo[FIFO_CPT_BITS],
  		uint(size=4) idx     = getFifoIdx(cptBits)
  		:
  		if (fifo[idx] & 0x100) != 0 then
	    	true
	    else
	    	false
	    end
  	end
	/**************************************************************************
	 * procedure flushBits
	 *************************************************************************/
 	procedure flushBits_name (uint(size= 8) nb, String name)
  	begin
  		flushBits( nb );
  		if DEBUG_PARSER then
			println("          "+name+" u("+nb+") : 0");
		end
  	end
  	procedure flushBits (uint(size= 8) nb)
  	begin
	    fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] - nb;
  	end
  	/**************************************************************************
	 * procedure byte_align
	 *************************************************************************/
  	procedure byte_align ()
  	var 
  		uint(size=4) cptBits = fifo[FIFO_CPT_BITS]
   	begin
	    fifo[FIFO_CPT_BITS] := cptBits - (cptBits & 0x7);
  	end
	/**************************************************************************
	 * procedure vld_u
	 *************************************************************************/
  	procedure vld_u_name (uint(size= 8) nb, String name)
  	begin
  		vld_u(nb);
  		if DEBUG_PARSER then
			println("          "+name+" u("+nb+") : "+res);
		end
	end
  	procedure vld_u (uint(size= 8) nb)
  	var
  		uint(size=8) nb_v    := nb,
  		uint(size=4) cptBits := fifo[FIFO_CPT_BITS],
  		uint(size=4) idx     := getFifoIdx(cptBits),
  		uint(size=4) cpt     := cptBits & (FIFO_SIZE - 1)
  	begin
  		if nb > cptBits then println(" Error vld_u : out of range !!!"); end
  		res := 0;
	    while nb_v != 0
	    do
	    	if cpt = 0 then cpt := FIFO_SIZE; end
	    	if nb_v > cpt then
	    		res     := (res<<cpt) + (fifo[idx] & ((1<<cpt)-1) );
	    		cptBits := cptBits - cpt;
	    		nb_v    := nb_v - cpt;
	    		idx     := (idx + 1) & (FIFO_SIZE-1); 
	    	else
	    		cpt     := cpt - nb_v;
	    		res     := (res<<nb_v) + ( (fifo[idx]>>cpt) & ((1<<nb_v)-1) );
	    		cptBits := cptBits - nb_v;	    		
	    		nb_v    := 0;
	    	end
	    	cpt := cptBits & (FIFO_SIZE - 1);
	  	end
	  	fifo[FIFO_CPT_BITS] := cptBits;
  	end
	/**************************************************************************
	 * procedure vld_ue
	 *************************************************************************/
  	procedure vld_ue_name (String name)
  	begin
  		vld_ue();
  		if DEBUG_PARSER then
			println("          "+name+" u(v) : "+res);
		end
	end
	procedure vld_ue ()
  	var
  		uint(size=4) cptBits := fifo[FIFO_CPT_BITS],
  		uint(size=4) idx     := getFifoIdx(cptBits),
  		uint(size=4) cpt     := (cptBits-1) & (FIFO_SIZE - 1),
  		uint(size=4) cptSave :=  cptBits,
  		uint codeLen
  	begin
		while ((fifo[idx] >> cpt) & 0x1) = 0
		do
	  		if cptBits = 0 then println(" Error vld_ue : out of range !!!"); end
			cptBits := cptBits - 1;
			idx     := getFifoIdx(cptBits);
			cpt     := (cpt - 1) & (FIFO_SIZE - 1);
		end
		codeLen := cptSave - cptBits;
		fifo[FIFO_CPT_BITS] := cptBits - 1;
		vld_u(codeLen);
		res     := (1 << codeLen) + res - 1;
  	end
	/**************************************************************************
	 * vld_se
 	 *************************************************************************/
 	procedure vld_se_name (String name)
  	begin
  		vld_se();
  		if DEBUG_PARSER then
			println("          "+name+" s(v) : "+res);
		end
	end
	procedure vld_se()
	begin
		vld_ue();
		if (res & 1) = 0 then
			res := -(res >> 1);
		else
			res :=  (res >> 1) + 1;
		end
	end
	/**************************************************************************
	 * vld_me
 	 *************************************************************************/
 	procedure vld_me_name (uint(size= 2) chroma_format_idc[32],
					 uint(size= 5) sps_id,
					 uint(size= 6) mb_type,
					 String name)
  	begin
  		vld_me(chroma_format_idc, sps_id, mb_type);
  		if DEBUG_PARSER then
			println("          "+name+" m(v) : "+res);
		end
	end
 	procedure vld_me(uint(size= 2) chroma_format_idc[32],
					 uint(size= 5) sps_id,
					 uint(size= 6) mb_type)
	begin
		vld_ue();
		if chroma_format_idc[sps_id] = 0 then 
			res := CBP_Table[res][if Is_Intra_NxN(mb_type) then 0 else 1 end];
		else
			res := CBP_Table[16 + res][if Is_Intra_NxN(mb_type) then 0 else 1 end]; 
		end 
	end
	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
	uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL];
	uint(size= 2) zeroByte := 0;
	/* */
 	action byte:[ b ] ==>
	guard 
		fifo[FIFO_CPT_BITS] <= (FIFO_SIZE-1)<<3
	var
		uint(size=4) fifo_idx  =  fifo[FIFO_IDX],
		uint(size=4) fifo_idx1 = (fifo[FIFO_IDX]-1) & (FIFO_SIZE-1),
		uint(size=4) fifo_idx2 = (fifo[FIFO_IDX]-2) & (FIFO_SIZE-1)
	do
		if fifo[fifo_idx2] != 0 or fifo[fifo_idx1] != 0 or b != EPR_VALUE then
			if b = START_CODE_VALUE and zeroByte = 3 then
				fifo[fifo_idx]      := b + START_CODE_FLAG;
			else
				fifo[fifo_idx]      := b;
			end
			fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] + 8;
			if DEBUG_BITSTREAM then
				println("fifo["+fifo_idx+"] := "+b+" \t "+fifo[FIFO_CPT_BITS]);
			end
			fifo[FIFO_IDX]      := (fifo_idx+1) & (FIFO_SIZE-1);
		end
		if b = 0 then
			zeroByte := ((zeroByte << 1) + 1) & 0x3;
		else
			zeroByte := 0;
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        NAL UNTI                             *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		not IsStartCode()
   	do
		flushBits( 8 );
		if DEBUG_BITSTREAM then		
  			println("start_code.search");
   		end
	end
	start_code.done: action ==>
	guard
		IsStartCode()
	do
		flushBits( 8 );
		if DEBUG_BITSTREAM then
			println("start_code.done");
		end
	end
	/**************************************************************************
	 * read_nal_unit_header
	 *************************************************************************/
	uint(size=6) nal_unit_type;
	uint(size=1) nal_ref_flag;
	uint(size=3) temporal_id;
	uint(size=1) output_flag;
	
	read_nal_unit_header : action ==>
	do
		if DEBUG_BITSTREAM then
			println("=========== NAL_UNIT ===========");
			flushBits_name( 1,  "reserved_zero_1bits                     ");
			vld_u_name(  2, "nal_ref_flag                            "); nal_ref_flag  := res;
			vld_u_name(  5, "nal_unit_type                           "); nal_unit_type := res;
		else
			flushBits( 1 );
			vld_u(  2 ); nal_ref_flag  := res;
			vld_u(  5 ); nal_unit_type := res;
		end
		temporal_id   := 0;
		output_flag   := 1; 
		se_idx := 1;
	end
	/**************************************************************************
	 * look_for.SPS_header
	 *************************************************************************/
	look_for.SPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_SPS
	do
		if DEBUG_PARSER then
			println("=========== Sequence Parameter Set ID    ===========");
		end
	end
	/**************************************************************************
	 * look_for.PPS_header
	 *************************************************************************/
	look_for.PPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_PPS
	do
		if DEBUG_PARSER then
			println("=========== Picture Parameter Set ID    ===========");
		end
	end
	/**************************************************************************
	 * look_for.Slice_header
	 *************************************************************************/
	look_for.Slice_header: action ==>
	guard
		(nal_unit_type = NAL_UNIT_NON_IDR_AND_NON_CRA or
		 nal_unit_type = NAL_UNIT_CRA                 or
		 nal_unit_type = NAL_UNIT_IDR)
	do
		if DEBUG_BITSTREAM then
			vld_u_name(  3,    "temporal_id                             "); temporal_id := res;
			vld_u_name(  1,    "output_flag                             "); output_flag := res;
			flushBits_name( 4, "reserved_zero_4bits                     ");
		else
			vld_u(  3 ); temporal_id := res;
			vld_u(  1 ); output_flag := res;
			flushBits( 4 );
		end
		if DEBUG_PARSER then
			println("=========== Slice ===========");
		end
	end
	/**************************************************************************
	 * look_for_other_header
	 *************************************************************************/
	look_for_other_header: action ==>
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Sequence Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) sps_profile_idc;
	uint(size= 8) sps_level_idc;
	uint(size= 8) sps_sps_id;
	uint(size= 8) sps_max_temporal_layers_minus1;
	uint(size=16) sps_pic_width_in_luma_samples;
	uint(size=16) sps_pic_height_in_luma_samples;
	uint(size= 3) sps_bit_depth_luma_minus8;
	uint(size= 3) sps_bit_depth_chroma_minus8;
	uint(size= 4) sps_pcm_bit_depth_luma_minus1; 
	uint(size= 4) sps_pcm_bit_depth_chroma_minus1;
	uint(size= 1) sps_disableInter4x4;
	uint(size= 8) sps_log2_min_coding_block_size_minus3;
	uint(size= 8) sps_log2_diff_max_min_coding_block_size;	
	uint(size=32) sps_log2_min_transform_block_size_minus2;
	uint(size=32) sps_log2_diff_max_min_transform_block_size;
	uint(size=32) sps_log2_min_pcm_coding_block_size_minus3;
	uint(size=32) sps_max_transform_hierarchy_depth_inter;
	uint(size=32) sps_max_transform_hierarchy_depth_intra;
	uint(size= 1) sps_chroma_pred_from_luma_enabled_flag;
	uint(size= 1) sps_loop_filter_across_slice_flag;
	uint(size= 1) sps_sample_adaptive_offset_enabled_flag;
	uint(size= 1) sps_adaptive_loop_filter_enabled_flag;
	uint(size= 1) sps_pcm_loop_filter_disable_flag;
	uint(size= 1) sps_cu_qp_delta_enabled_flag;
	uint(size= 1) sps_temporal_id_nesting_flag;
	uint(size=32) sps_padX;
	uint(size=32) sps_padY;
	uint(size= 1) sps_useLDC;
	uint(size= 1) sps_useMRG;
	uint(size= 1) sps_amvpMode[MAX_TLAYER];
	uint(size= 1) sps_useNewRefSetting;
	uint(size=32) sps_maxNumRefFrames;
	uint(size= 1) sps_uniform_spacing_idc;
	uint(size= 1) sps_tile_boundary_independence_idc;
	uint(size= 1) sps_num_tile_columns_minus1;
	uint(size= 1) sps_num_tile_rows_minus1;	
	uint(size=32) sps_column_width[32];
	uint(size=32) sps_row_height[32];
	/* */
	uint(size=32) sps_maxCUWidth;
	uint(size= 8) sps_maxCUDepth;

	/**************************************************************************
	 * read_SPS_Header.se_idx_1
	 *************************************************************************/
	read_SPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1
	do
		vld_u_name(  8,    "profile_idc                             "); sps_profile_idc                := res;
		flushBits_name( 8, "reserved_zero_8bits                     ");
		vld_u_name(  8,    "level_idc                               "); sps_level_idc                  := res;
		vld_ue_name(       "seq_parameter_set_id                    "); sps_sps_id                     := res; // getBits(10) max
		vld_u_name(  3,    "max_temporal_layers_minus1              "); sps_max_temporal_layers_minus1 := res;
		vld_u_name( 16,    "pic_width_in_luma_samples               "); sps_pic_width_in_luma_samples  := res;
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_2
	 *************************************************************************/
	read_SPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2
	do
		vld_u_name( 16, "pic_height_in_luma_samples              "); sps_pic_height_in_luma_samples := res;
		vld_ue_name(    "bit_depth_luma_minus8                   "); sps_bit_depth_luma_minus8      := res; // getBits(5) max
		vld_ue_name(    "bit_depth_chroma_minus8                 "); sps_bit_depth_chroma_minus8    := res; // getBits(5) max
		vld_u_name(  4, "pcm_bit_depth_luma_minus1               "); sps_pcm_bit_depth_luma_minus1  := res;
		vld_u_name(  4, "pcm_bit_depth_chroma_minus1             "); sps_pcm_bit_depth_chroma_minus1:= res;		
		vld_u_name(  1, "disableInter4x4                         "); sps_disableInter4x4            := res;		
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_3
	 *************************************************************************/
	read_SPS_Header.se_idx_3 : action ==>
	guard
		se_idx = 3
	do
		vld_ue_name(    "log2_min_coding_block_size_minus3       "); sps_log2_min_coding_block_size_minus3      := res; // getBits(7) max
		vld_ue_name(    "log2_diff_max_min_coding_block_size     "); sps_log2_diff_max_min_coding_block_size    := res; // getBits(32) max ?????
		vld_ue_name(    "log2_min_transform_block_size_minus2    "); sps_log2_min_transform_block_size_minus2   := res; // getBits(32) max ?????
		vld_ue_name(    "log2_diff_max_min_transform_block_size  "); sps_log2_diff_max_min_transform_block_size := res; // getBits(32) max ?????
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_4
	 *************************************************************************/	
	read_SPS_Header.se_idx_4 : action ==>
	guard
		se_idx = 4
	do
		vld_ue_name(    "log2_min_pcm_coding_block_size_minus3   "); sps_log2_min_pcm_coding_block_size_minus3 := res; // getBits(32) max ?????
		vld_ue_name(    "max_transform_hierarchy_depth_inter     "); sps_max_transform_hierarchy_depth_inter   := res; // getBits(32) max ?????
		vld_ue_name(    "max_transform_hierarchy_depth_intra     "); sps_max_transform_hierarchy_depth_intra   := res; // getBits(32) max ?????
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_5
	 *************************************************************************/	
	read_SPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5
   	do
		vld_u_name(  1, "chroma_pred_from_luma_enabled_flag      "); sps_chroma_pred_from_luma_enabled_flag  := res;
		vld_u_name(  1, "loop_filter_across_slice_flag           "); sps_loop_filter_across_slice_flag       := res;
		vld_u_name(  1, "sample_adaptive_offset_enabled_flag     "); sps_sample_adaptive_offset_enabled_flag := res;
		vld_u_name(  1, "adaptive_loop_filter_enabled_flag       "); sps_adaptive_loop_filter_enabled_flag   := res;
		vld_u_name(  1, "pcm_loop_filter_disable_flag            "); sps_pcm_loop_filter_disable_flag        := res;
		vld_u_name(  1, "cu_qp_delta_enabled_flag                "); sps_cu_qp_delta_enabled_flag            := res;
		vld_u_name(  1, "temporal_id_nesting_flag                "); sps_temporal_id_nesting_flag            := res;
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_6
	 *************************************************************************/
	read_SPS_Header.se_idx_6 : action ==>
	guard
		se_idx = 6
	var
		uint(size= 8) uiAddCUDepth := 0
   	do
		sps_maxCUWidth  := 1<<(sps_log2_min_coding_block_size_minus3 + 3 + sps_log2_diff_max_min_coding_block_size);
  		while( ( sps_maxCUWidth >> sps_log2_diff_max_min_coding_block_size ) > ( 1 << ( sps_log2_min_transform_block_size_minus2 + 2 + uiAddCUDepth )  ) ) 
  		do
  			uiAddCUDepth := uiAddCUDepth + 1;
  		end    
  		sps_maxCUDepth := sps_log2_diff_max_min_coding_block_size + uiAddCUDepth;


		vld_ue_name(    "padX                                    "); sps_padX                := res; // getBits(32) max ?????
		vld_ue_name(    "padY                                    "); sps_padY                := res; // getBits(32) max ?????
		vld_u_name(  1, "useLDC                                  "); sps_useLDC              := res;
		vld_u_name(  1, "useMRG                                  "); sps_useMRG              := res;
   		foreach uint(size=8) i in 0 .. sps_maxCUDepth - 1 do
   			vld_u_name(  1, "amvpMode[ ]                             "); sps_amvpMode[i]     := res;
		end
		vld_u_name(  1, "useNewRefSetting                        "); sps_useNewRefSetting    := res;
   		if sps_useNewRefSetting = 1 then
			vld_ue_name(    "maxNumRefFrames                         "); sps_maxNumRefFrames := res; // getBits(32) max ?????
		end
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_7
	 *************************************************************************/	
	read_SPS_Header.se_idx_7 : action ==>
	guard
		se_idx = 7
	do
		vld_u_name(  1, "uniform_spacing_idc                     "); sps_uniform_spacing_idc            := res;
		vld_u_name(  1, "tile_boundary_independence_idc          "); sps_tile_boundary_independence_idc := res;
		vld_ue_name(    "num_tile_columns_minus1                 "); sps_num_tile_columns_minus1        := res;
		vld_ue_name(    "num_tile_rows_minus1                    "); sps_num_tile_rows_minus1           := res;
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_8
	 *************************************************************************/	
	read_SPS_Header.se_idx_8.loop : action ==>
	guard
		se_idx = 8 and sps_uniform_spacing_idc = 1 and cnt_i <= sps_num_tile_columns_minus1
	do
		vld_ue_name(    "column_width[ ]                         "); sps_column_width[cnt_i] := res;
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_8.loopEnd : action ==>
	guard
		se_idx = 8 and sps_uniform_spacing_idc = 1 and cnt_i > sps_num_tile_columns_minus1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_SPS_Header.se_idx_8.noLoop : action ==>
	guard
		se_idx = 8 and sps_uniform_spacing_idc = 0
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_9
	 *************************************************************************/	
	read_SPS_Header.se_idx_9.loop : action ==>
	guard
		se_idx = 9 and sps_uniform_spacing_idc = 1 and cnt_i <= sps_num_tile_rows_minus1
	do
		vld_ue_name(    "row_height[ ]                           "); sps_row_height[cnt_i] := res;
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_9.loopEnd : action ==>
	guard
		se_idx = 9 and sps_uniform_spacing_idc = 1 and cnt_i > sps_num_tile_rows_minus1
   	do
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header_done
	 *************************************************************************/	
	read_SPS_Header_done : action ==>
	guard
		se_idx = 10
	do
		byte_align();
	end 
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size=32) pps_pps_id;
	uint(size=32) pps_sps_id;
	uint(size= 1) pps_entropy_coding_mode_flag;
	uint(size=32) pps_entropy_coding_synchro;
	uint(size= 1) pps_cabac_istate_reset;
	uint(size=32) pps_num_substreams_minus1;
	uint(size= 8) pps_num_temporal_layer_switching_point_flags;
	uint(size= 1) pps_temporal_layer_switching_point_flag[MAX_TLAYER];
	uint(size= 1) pps_constrained_intra_pred_flag;
	uint(size= 2) pps_slice_granularity;
	uint(size=32) pps_max_cu_qp_delta_depth;
	uint(size= 1) pps_weighted_pred_flag;
	uint(size= 2) pps_weighted_bipred_idc;
	uint(size= 1) pps_tile_info_present_flag;
	uint(size= 1) pps_uniform_spacing_idc;
	uint(size= 1) pps_tile_boundary_independence_idc;
	uint(size=32) pps_num_tile_columns_minus1;
	uint(size=32) pps_num_tile_rows_minus1;
	uint(size=32) pps_column_width[32];
	uint(size=32) pps_row_height[32];
	/**************************************************************************
	 * read_PPS_Header.se_idx_1
	 *************************************************************************/	
	read_PPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1
   	do
		vld_ue_name(    "pic_parameter_set_id                    "); pps_pps_id                     := res;
		vld_ue_name(    "seq_parameter_set_id                    "); pps_sps_id                     := res;
		vld_u_name(  1, "entropy_coding_mode_flag                "); pps_entropy_coding_mode_flag   := res;
		if pps_entropy_coding_mode_flag = 1 then
			vld_ue_name(    "entropy_coding_synchro                  "); pps_entropy_coding_synchro := res;
			vld_u_name(  1, "cabac_istate_reset                      "); pps_cabac_istate_reset     := res;
			if pps_entropy_coding_synchro != 0 then
				vld_ue_name(    "num_substreams_minus1                   "); pps_entropy_coding_synchro := res;
			end
		end
		vld_ue_name(    "num_temporal_layer_switching_point_flags"); pps_num_temporal_layer_switching_point_flags := res;
		foreach uint(size=8) i in 0 .. pps_num_temporal_layer_switching_point_flags - 1 do
			vld_u_name(  1, "temporal_layer_switching_point_flag[ ]  "); pps_temporal_layer_switching_point_flag[i]     := res;
		end	
		se_idx := se_idx + 1;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_2
	 *************************************************************************/	
	read_PPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2
   	do
		vld_u_name(  1, "constrained_intra_pred_flag             "); pps_constrained_intra_pred_flag   := res;
		vld_u_name(  2, "slice_granularity                       "); pps_slice_granularity             := res;
		if sps_cu_qp_delta_enabled_flag = 1 then
			vld_ue_name(    "max_cu_qp_delta_depth                   "); pps_max_cu_qp_delta_depth := res;
		end
		vld_u_name(  1, "weighted_pred_flag                      "); pps_weighted_pred_flag     := res;
		vld_u_name(  2, "weighted_bipred_idc                     "); pps_weighted_bipred_idc    := res;
		vld_u_name(  1, "tile_info_present_flag                  "); pps_tile_info_present_flag := res;
		pps_uniform_spacing_idc := 0;
		if pps_tile_info_present_flag = 1 then
			vld_u_name(  1, "uniform_spacing_idc                     "); pps_uniform_spacing_idc            := res;
			vld_u_name(  1, "tile_boundary_independence_idc          "); pps_tile_boundary_independence_idc := res;
			vld_ue_name(    "num_tile_columns_minus1                 "); pps_num_tile_columns_minus1        := res;
			vld_ue_name(    "num_tile_rows_minus1                    "); pps_num_tile_rows_minus1           := res;
		end
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_3
	 *************************************************************************/	
  	read_PPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3 and pps_uniform_spacing_idc = 1 and cnt_i <= pps_num_tile_columns_minus1
   	do
		vld_ue_name(    "column_width[ ]                         "); pps_column_width[cnt_i] := res;
		cnt_i := cnt_i + 1;
	end 
	read_PPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3 and pps_uniform_spacing_idc = 1 and cnt_i > pps_num_tile_columns_minus1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_PPS_Header.se_idx_3.noLoop : action ==>
	guard
		se_idx = 3 and pps_uniform_spacing_idc = 0
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_4
	 *************************************************************************/	
	read_SPS_Header.se_idx_4.loop : action ==>
	guard
		se_idx = 4 and pps_uniform_spacing_idc = 1 and cnt_i <= pps_num_tile_rows_minus1
   	do
		vld_ue_name(    "row_height[ ]                          "); pps_row_height[cnt_i] := res;
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_4.loopEnd : action ==>
	guard
		se_idx = 4 and pps_uniform_spacing_idc = 1 and cnt_i > pps_num_tile_rows_minus1
   	do
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_PPS_Header_done
	 *************************************************************************/	
	read_PPS_Header_done : action ==>
	guard
		se_idx = 5
	do
		byte_align();
	end 	
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 1) slice_lightweight_slice_flag;
	uint(size= 2) slice_slice_type;
	uint(size= 8) slice_pps_id;
	uint(size=32) slice_aps_id;
	uint(size=10) slice_pic_order_cnt_lsb;
	uint(size= 3) slice_num_ref_idx_l0_active_minus1;
	uint(size= 3) slice_num_ref_idx_l1_active_minus1;
	uint(size= 1) slice_ref_pic_list_combination_flag;
	uint(size=32) slice_num_ref_idx_lc_active_minus1;
	uint(size= 1) slice_ref_pic_list_modification_flag_lc;
	uint(size= 1) slice_pic_from_list_0_flag[MAX_NUM_REF_LC];
	uint(size= 1) slice_ref_idx_list_curr[MAX_NUM_REF_LC];
	uint(size=32) slice_slice_address;
	 int(size=32) slice_slice_qp;
	uint(size= 1) slice_loop_filter_disable;
	uint(size= 1) slice_collocated_from_l0_flag;

	/**************************************************************************
	 * read_SliceHeader.se_idx_1
	 *************************************************************************/	
	read_SliceHeader.se_idx_1 : action ==>
	guard
		se_idx = 1
   	do	
		slice_num_ref_idx_l0_active_minus1 := 0;
		slice_num_ref_idx_l1_active_minus1 := 0;
		vld_u_name(  1, "lightweight_slice_flag                  "); slice_lightweight_slice_flag       := res;
		if slice_lightweight_slice_flag = 0 then
			vld_ue_name(    "slice_type                              "); slice_slice_type               := res; // getBits(3) max
			vld_ue_name(    "pic_parameter_set_id                    "); slice_pps_id                   := res;
			if sps_sample_adaptive_offset_enabled_flag = 1 or sps_adaptive_loop_filter_enabled_flag = 1 then
				vld_ue_name(    "aps_id                                  "); slice_aps_id               := res;
			end
			vld_u_name( 10, "pic_order_cnt_lsb                       "); slice_pic_order_cnt_lsb            := res;
			if slice_slice_type = I_SLICE then
				vld_u_name(  1, "num_ref_idx_active_override_flag        ");
				if res = 1 then
					vld_u_name(  3, "num_ref_idx_l0_active_minus1            "); slice_num_ref_idx_l0_active_minus1 := res;
					if slice_slice_type = B_SLICE then
						vld_u_name(  3, "num_ref_idx_l1_active_minus1            "); slice_num_ref_idx_l1_active_minus1 := res;
					end
				end
			end
		end	
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_2
	 *************************************************************************/	
	read_SliceHeader.se_idx_2 : action ==>
	guard
		se_idx = 2
   	do	
   		slice_ref_pic_list_combination_flag     := 0;
   		slice_ref_pic_list_modification_flag_lc := 0;
		if slice_slice_type = B_SLICE then
			vld_u_name(  1, "ref_pic_list_combination_flag           "); slice_ref_pic_list_combination_flag         := res;
			if slice_ref_pic_list_combination_flag = 1 then
				vld_ue_name(    "num_ref_idx_lc_active_minus1            "); slice_num_ref_idx_lc_active_minus1      := res;
				vld_u_name(  1, "ref_pic_list_modification_flag_lc       "); slice_ref_pic_list_modification_flag_lc := res;
				if slice_ref_pic_list_modification_flag_lc = 1 then
		   			foreach uint(size=8) i in 0 .. slice_num_ref_idx_lc_active_minus1 do
						vld_u_name(  1, "pic_from_list_0_flag                    "); slice_pic_from_list_0_flag[i]   := res;
						vld_ue_name(    "ref_idx_list_curr                       "); slice_ref_idx_list_curr[i]      := res;
		   			end
		   		end
			end
		end
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_3
	 *************************************************************************/	
	read_SliceHeader.se_idx_3 : action ==>
	guard
		se_idx = 3
	var
		uint(size=32) iNumCUs = ( (sps_pic_width_in_luma_samples  + sps_maxCUWidth - 1) / sps_maxCUWidth ) * 
	 							( (sps_pic_height_in_luma_samples + sps_maxCUDepth - 1) / sps_maxCUDepth),
	 	uint(size=32) iNumParts = (1<<(pps_slice_granularity<<1)),
	 	uint(size=32) iReqBitsOuter := 0,
	 	uint(size=32) iReqBitsInner := 0
   	do	
   		while iNumCUs   > (1 << iReqBitsOuter) do iReqBitsOuter := iReqBitsOuter + 1; end
  		while iNumParts > (1 << iReqBitsInner) do iReqBitsInner := iReqBitsInner + 1; end
		vld_u_name(  1, "first_slice_in_pic_flag                 ");
		if res = 0 then
			vld_u_name( iReqBitsOuter+iReqBitsInner , "slice_address                           "); slice_slice_address := res;
		end
		vld_se_name(    "slice_qp                                "); slice_slice_qp                    := res;
		vld_u_name(  1, "loop_filter_disable                     "); slice_loop_filter_disable         := res;
		if slice_slice_type = B_SLICE then
			vld_u_name(  1, "collocated_from_l0_flag                 "); slice_collocated_from_l0_flag := res;
		end
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader_done
	 *************************************************************************/	
	read_SliceHeader_done : action ==>
	guard
		se_idx = 4
	do
		byte_align();
	end 	
	
	/**************************************************************************
	 **************************************************************************
	 ********        undefined                            *********************
	 **************************************************************************
	 *************************************************************************/
  	bool actorNotFinished := true;
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("Algo_Parser doesn't manage this case yet");
		actorNotFinished := false;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        schedule                             *********************
	 **************************************************************************
	 *************************************************************************/
  	schedule fsm start_code:
		// search start code
		start_code          			( start_code.search					) --> start_code;
		start_code			            ( start_code.done					) --> read_Nal_unit_header;
		// read Nal Unit header
		read_Nal_unit_header			( read_nal_unit_header				) --> find_header;
		find_header	  					( look_for.SPS_header	  			) --> read_SPS_Header;
		find_header	  					( look_for.PPS_header	  			) --> read_PPS_Header;
		find_header	  					( look_for.Slice_header	  			) --> read_SliceHeader;
		find_header	  					( look_for_other_header				) --> start_code;
		// read SPS header
		read_SPS_Header	  				( read_SPS_Header	    			) --> read_SPS_Header;
		read_SPS_Header	  				( read_SPS_Header_done    			) --> start_code;
		// read PPS header
		read_PPS_Header 				( read_PPS_Header   				) --> read_PPS_Header;
		read_PPS_Header	  				( read_PPS_Header_done    			) --> start_code;
		// read_SliceHeader
		read_SliceHeader				( read_SliceHeader					) --> read_SliceHeader;
		read_SliceHeader				( read_SliceHeader_done				) --> undefined;
		
		
		
		
		// undefined
		undefined	  					( undefined		    				) --> undefined;
	end
	
	/**************************************************************************
	 * priority
	 *************************************************************************/
	priority
		look_for        > look_for_other_header;
	end
end