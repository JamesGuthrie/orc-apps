package synParser;

import  std.util.Math.*;
import  std.stdio.Source.*;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  synParser.Algo_ParserUtils.*;
import  common.CommonConstantHEVC.*;
import  common.CabacDecodeBinFunction.*;
import  common.CabacContextConstantHEVC.*;
import  common.CabacContextFunctionHEVC.*;
import  common.CabacParserFunctionHEVC.*;

actor Algo_Parser () 
				uint(size= 8) byte
				==>
				uint(size=16) CUInfo,
				uint(size= 6) IntraPredMode,
				//FIXME default value
				uint(size=16) SliceAddr,

				uint(size=16) MaxPocLsb,
				uint(size= 8) NaluType,
				uint(size= 4) PartMode,
				uint(size=16) PictSize,
				uint(size=16) Poc,
				uint(size= 2) SliceType,
				bool          Cbf, //Token generation fits with Dbf, it should be modified when residual will be integrated.
				bool          SplitTransform,
				uint(size= 8) TUSize,
				 int(size=16) Coeff,
				 bool 		  StrongIntraSmoothing
				 
:
	uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL];
	uint(size= 2) zeroByte := 0;
	uint(size= 8) se_idx;
	uint(size=32) cnt_i;
	uint(size=10) sps_id;
	uint(size=10) pps_id;
	uint(size=32) wp[2][MAX_NUM_REF][3][WP_MAX_STRUCT];
	
	
	/**************************************************************************
	 **************************************************************************
	 ********        Bitstream Reader                     *********************
	 **************************************************************************
	 *************************************************************************/
	
	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
 	action byte:[ b ] ==>
	guard 
		not isFifoFull(fifo)
	var
		uint(size=4) fifo_idx  =  fifo[FIFO_IDX]
	do
		if b != EPR_VALUE or zeroByte != 3 then
			if b = START_CODE_VALUE and zeroByte = 3 then
				fifo[fifo_idx]      := b + START_CODE_FLAG;
			else
				fifo[fifo_idx]      := b;
			end
			fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] + 8;
			if DEBUG_BITSTREAM then
				println("fifo["+fifo_idx+"] := "+b+" \t "+fifo[FIFO_CPT_BITS]);
			end
			fifo[FIFO_IDX]      := (fifo_idx+1) & (FIFO_SIZE-1);
		end
		if b = 0 then
			zeroByte := ((zeroByte << 1) + 1) & 0x3;
		else
			zeroByte := 0;
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        NAL UNIT                             *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * byte_align_a
	 *************************************************************************/	
	byte_align_a : action ==>
	guard
		isFifoFull(fifo)
	do
		byte_align(fifo);
	end 	
	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		not IsStartCode(fifo) and isFifoFull(fifo)
   	do
		flushBits( 8, fifo );
		if DEBUG_BITSTREAM then		
  			println("start_code.search");
   		end
	end
	start_code.done: action ==>
	guard
		IsStartCode(fifo) and isFifoFull(fifo)
	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then
			println("start_code.done");
		end
	end
	/**************************************************************************
	 * read_nal_unit_header
	 *************************************************************************/		
	uint(size= 6) nal_unit_type;
	
	read_nal_unit_header : action ==> NaluType:[nal_unit_type]
	var
		uint(size=32) res[1]
	do
		if DEBUG_BITSTREAM then
			println("=========== NAL_UNIT ===========");
			flushBits_name( 1, fifo,   "reserved_zero_1bits                     ");
			vld_u_name(  6, fifo, res, "nal_unit_type                           "); 
			nal_unit_type := res[0];
			flushBits_name( 6, fifo,   "reserved_zero_5bits                     ");
			vld_u_name(  3, fifo, res, "temporal_id                             "); 
		else
			flushBits( 1, fifo );
			vld_u(  6, fifo, res);
			nal_unit_type := res[0];
			flushBits( 6, fifo  );
			vld_u(  3, fifo, res); 
		end
		se_idx := 1;
	end
	/**************************************************************************
	 * look_for.VPS_header
	 *************************************************************************/
	look_for.VPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_VPS
	do
		if DEBUG_PARSER then
			println("=========== Video Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.SEI_header
	 *************************************************************************/
	look_for.SEI_header: action ==>
	guard
		nal_unit_type = PREFIX_SEI or nal_unit_type = SUFFIX_SEI
	do
		if DEBUG_PARSER then
			println("=========== SEI message ===========");
		end
	end
	/**************************************************************************
	 * look_for.SPS_header
	 *************************************************************************/
	look_for.SPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_SPS
	do
		if DEBUG_PARSER then
			println("=========== Sequence Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.PPS_header
	 *************************************************************************/
	look_for.PPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_PPS
	do
		if DEBUG_PARSER then
			println("=========== Picture Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.Slice_header
	 *************************************************************************/
	look_for.Slice_header: action ==>
	guard
		(nal_unit_type = NAL_IDR_W_DLP or
		 nal_unit_type = NAL_UNIT_TRAIL_R or
		 nal_unit_type = NAL_UNIT_TRAIL_N)
	do
		if DEBUG_PARSER then
			println("=========== Slice ===========");
		end
	end
	/**************************************************************************
	 * look_for_other_header
	 *************************************************************************/
	look_for_other_header: action ==>
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Video Parameter Set HEADER           *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_VPS_Header.se_idx_1
	 *************************************************************************/
	uint(size= 3) vps_max_sub_layers_minus1;
	 
	read_VPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  4, fifo, res, "video_parameter_set_id                  ");
		vld_u_name(  1, fifo, res, "vps_temporal_id_nesting_flag            ");
		flushBits_name(2, fifo,    "vps_reserved_zero_2bits                 ");
		flushBits_name(6, fifo,    "vps_reserved_zero_6bits                 ");
		vld_u_name(  3, fifo, res, "vps_max_sub_layers_minus1               ");
		vps_max_sub_layers_minus1 := res[0];
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_2
	 *************************************************************************/
	read_VPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		bool profile_present_flag = true,
		uint(size = 32) res[1]
	do
		if (profile_present_flag) then
		
			vld_u_name(  2, fifo, res, "general_profile_space                   ");
			vld_u_name(  1, fifo, res, "general_tier_flag                       ");
			vld_u_name(  5, fifo, res, "general_profile_idc                     ");
	        foreach int i in 0 .. 31 do
				vld_u_name(  1, fifo, res, "general_profile_compatibility_flag[i]   ");
			end
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_3
	 *************************************************************************/
	read_VPS_Header.se_idx_3 : action ==>
	guard
		se_idx = 3 and isFifoFull(fifo)
	var
		bool profile_present_flag = true,
		uint(size = 32) res[1],
		bool sub_layer_profile_present_flag[7],
		bool sub_layer_level_present_flag[7]
	do
		if (profile_present_flag) then
			flushBits_name(16, fifo,   "general_reserved_zero_16bits            ");
		end
		vld_u_name(  8, fifo, res, "general_level_idc                       ");
		foreach int i in 0 .. vps_max_sub_layers_minus1 - 1 do
			vld_u_name(  1, fifo, res, "sub_layer_profile_present_flag[i]       ");
			sub_layer_profile_present_flag[i] := (res[0] = 1);
			vld_u_name(  1, fifo, res, "sub_layer_level_present_flag[i]         ");
			sub_layer_level_present_flag[i] := (res[0] = 1);
	        if (profile_present_flag and sub_layer_profile_present_flag[i]) then
				vld_u_name(  2, fifo, res, "sub_layer_profile_space[i]              ");
				vld_u_name(  1, fifo, res, "sub_layer_tier_flag[i]                  ");
				vld_u_name(  5, fifo, res, "sub_layer_profile_idc[i]                ");
				foreach int j in 0 .. 31 do
					vld_u_name(  1, fifo, res, "sub_layer_profile_compatibility_flags[i][j]");
				end
				flushBits_name(16, fifo,    "sub_layer_reserved_zero_16bits[i]         ");
			end
	       	if (sub_layer_level_present_flag[i]) then
				vld_u_name(  1, fifo, res, "sub_layer_level_idc[i]                  ");
	       	end
	    end
		se_idx := se_idx + 1;
	end

	/**************************************************************************
	 * read_VPS_Header.se_idx_4
	 *************************************************************************/
	read_VPS_Header.se_idx_4.loop : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo)
	do
		se_idx := se_idx + 1;
		flushBits_name(12, fifo      , "vps_reserved_zero_12bits                ");
		cnt_i  := 0;
	end

	/**************************************************************************
	 * read_VPS_Header.se_idx_4
	 *************************************************************************/
	read_VPS_Header.se_idx_5.loop : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo),
		cnt_i <= vps_max_sub_layers_minus1		
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "vps_max_dec_pic_buffering[i]            ");
		vld_ue_name(    fifo, res, "vps_num_reorder_pics[i]                 ");
		vld_ue_name(    fifo, res, "vps_max_latency_increase[i]             ");
		cnt_i := cnt_i + 1;
	end
	read_VPS_Header.se_idx_5.loopEnd : action ==>
	guard
		se_idx = 5,
		cnt_i = vps_max_sub_layers_minus1 + 1
	do
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header_done
	 *************************************************************************/	
	read_VPS_Header_done : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "vps_num_hrd_parameters                  ");
		vld_u_name(  1, fifo, res, "vps_extension_flag                      ");
		if res[0] = 1 then
			println("moreRBSP data VPS");
		end
	end 	
	/**************************************************************************
	 **************************************************************************
	 ********        SEI message                          *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_SEI_Header.se_idx_1
	 *************************************************************************/
 	uint(size=16) sei_payloadType;
 	uint(size=16) sei_payloadSize;
 	uint(size=16) sei_payloadPosition;
 	uint(size= 8) sei_idx;
	/**************************************************************************
	 * read_SEI_Header.init
	 *************************************************************************/
	read_SEI_Header.init : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	do
		sei_payloadType     := 0;
		sei_payloadSize     := 0;
		sei_payloadPosition := 0;
		se_idx              := se_idx + 1;
		sei_idx             := 1;
	end
	/**************************************************************************
	 * read_SEI_Header.payload_type
	 *************************************************************************/
	read_SEI_Header.payload_type : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "payload_type                            ");
		sei_payloadType := sei_payloadType + res[0];
		if res[0] != 0xFF then
			se_idx := se_idx + 1;
		end
	end
	/**************************************************************************
	 * read_SEI_Header.payload_size
	 *************************************************************************/
	read_SEI_Header.payload_size : action ==>
	guard
		se_idx = 3 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "payload_size                            ");
		sei_payloadSize := sei_payloadSize + res[0];
		if res[0] != 0xFF then
			// sei_payload( payloadType, payloadSize )
			se_idx := se_idx + 1;
		end
	end
	/**************************************************************************
	 * read_SEI_Header.decoded_picture_hash
	 *************************************************************************/
 	uint(size= 8) sei_cIdx;
 	uint(size= 8) sei_i;
 	uint(size= 8) sei_hash_type;
	read_SEI_Header.decoded_picture_hash.init : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo),
		sei_idx = 1 and sei_payloadType = 256
	var
		uint(size=32) res[1]
	do
		if DEBUG_PARSER then
			println("=========== Decoded picture hash SEI message ===========");
		end
		vld_u_name(  8, fifo, res, "hash_type                               ");
		sei_payloadPosition := sei_payloadPosition + 8;			
		sei_hash_type       := res[0];
		sei_cIdx            := 0;
		sei_i               := 0;
		sei_idx             := sei_idx + 1;
	end
	read_SEI_Header.decoded_picture_hash.loop : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo),
		sei_idx = 2 and sei_payloadType = 256,
		sei_cIdx < 3, /*if sps_chroma_format_idc[sps_id] = 0 then 1 else 3 end,*/
		sei_i    < 16
	var
		uint(size=32) res[1]
	do
		if sei_hash_type = 0 then
			vld_u_name(  8, fifo, res, "picture_md5                             ");
			sei_payloadPosition := sei_payloadPosition +  8;
			sei_i               := sei_i + 1;		
		elsif sei_hash_type = 1 then
			vld_u_name( 16, fifo, res, "picture_crc                             ");
			sei_payloadPosition := sei_payloadPosition + 16;			
			sei_i               := 16;		
		elsif sei_hash_type = 2 then
			vld_u_name( 32, fifo, res, "picture_checksum                        ");
			sei_payloadPosition := sei_payloadPosition + 32;			
			sei_i               := 16;		
		end
		if sei_i = 16 then
		    sei_i := 0;
			sei_cIdx := sei_cIdx + 1;
			if sei_cIdx = 3/*if sps_chroma_format_idc[sps_id] = 0 then 1 else 3 end*/ then
				se_idx := se_idx + 1;
			end
		end 
	end
	/**************************************************************************
	 * read_SEI_Header.sei_payload_end
	 *************************************************************************/
	read_SEI_Header.sei_payload_end : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		if not(isByteAlign(fifo) and sei_payloadPosition = (sei_payloadSize << 3)) then
//			if payload_extension_present( ) then
//				reserved_payload_extension_data
//			end
			vld_u_name(  1, fifo, res, "bit_equal_to_one                        ");			
			while not isByteAlign(fifo) do
				vld_u_name(  1, fifo, res, "bit_equal_to_zero                       ");			
			end
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SEI_Header.done
	 *************************************************************************/
//	read_SEI_Header.done : action ==>
//	guard
//		se_idx = 6 and isFifoFull(fifo)
//	do
//	end
	read_SEI_Header_done : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo)
	do
	end
	
	/**************************************************************************
	 **************************************************************************
	 ********        Sequence Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_SPS_Header.se_idx_1
	 *************************************************************************/
	uint(size= 4) sps_max_sub_layers_minus1[NB_MAX_SPS];
	uint(size=16) sps_chroma_format_idc[NB_MAX_SPS];
	uint(size=16) sps_pic_width_in_luma_samples[NB_MAX_SPS];

	read_SPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  4, fifo, res, "vps_id                                  "); 
		vld_u_name(  3, fifo, res, "sps_max_sub_layers_minus1               "); 
		sps_max_sub_layers_minus1[sps_id] := res[0];
		flushBits_name(1 , fifo,   "sps_reserved_zero_bit                   ");
		se_idx := 20;
	end

	read_SPS_Header.se_idx_20 : action ==>
	guard
		se_idx = 20 and isFifoFull(fifo)
	var
		bool profile_present_flag = true,
		uint(size = 32) res[1]
	do
		if (profile_present_flag) then
		
			vld_u_name(  2, fifo, res, "general_profile_space                   ");
			vld_u_name(  1, fifo, res, "general_tier_flag                       ");
			vld_u_name(  5, fifo, res, "general_profile_idc                     ");
	        foreach int i in 0 .. 31 do
				vld_u_name(  1, fifo, res, "general_profile_compatibility_flag[i]   ");
			end
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_21
	 *************************************************************************/
	read_SPS_Header.se_idx_21 : action ==>
	guard
		se_idx = 21 and isFifoFull(fifo)
	var
		bool profile_present_flag = true,
		uint(size = 32) res[1],
		bool sub_layer_profile_present_flag[7],
		bool sub_layer_level_present_flag[7]
	do
		if (profile_present_flag) then
			flushBits_name(16, fifo,   "general_reserved_zero_16bits            ");
		end
		vld_u_name(  8, fifo, res, "general_level_idc                       ");
		foreach int i in 0 .. vps_max_sub_layers_minus1 - 1 do
			vld_u_name(  1, fifo, res, "sub_layer_profile_present_flag[i]       ");
			sub_layer_profile_present_flag[i] := (res[0] = 1);
			vld_u_name(  1, fifo, res, "sub_layer_level_present_flag[i]         ");
			sub_layer_level_present_flag[i] := (res[0] = 1);
	        if (profile_present_flag and sub_layer_profile_present_flag[i]) then
				vld_u_name(  2, fifo, res, "sub_layer_profile_space[i]              ");
				vld_u_name(  1, fifo, res, "sub_layer_tier_flag[i]                  ");
				vld_u_name(  5, fifo, res, "sub_layer_profile_idc[i]                ");
				foreach int j in 0 .. 31 do
					vld_u_name(  1, fifo, res, "sub_layer_profile_compatibility_flags[i][j]");
				end
				flushBits_name(16, fifo,    "sub_layer_reserved_zero_16bits[i]         ");
			end
	       	if (sub_layer_level_present_flag[i]) then
				vld_u_name(  1, fifo, res, "sub_layer_level_idc[i]                  ");
	       	end
	    end
		se_idx := 11;
	end

	read_SPS_Header.se_idx_1_1 : action ==>
	guard
		se_idx = 11 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "seq_parameter_set_id                    ");
		sps_id := res[0];
		vld_ue_name(    fifo, res, "chroma_format_idc                       ");
		sps_chroma_format_idc[sps_id] := res[0];
		vld_ue_name(    fifo, res, "pic_width_in_luma_samples               ");
		sps_pic_width_in_luma_samples[sps_id] := res[0];
		se_idx := 2;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_2
	 *************************************************************************/
	uint(size=16) sps_pic_height_in_luma_samples[NB_MAX_SPS];
	uint(size= 1) sps_bit_depth_luma_minus8[NB_MAX_SPS];
	uint(size= 1) sps_bit_depth_chroma_minus8[NB_MAX_SPS];
	uint(size= 1) sps_pcm_enabled_flag[NB_MAX_SPS];
	uint(size= 8) sps_log2_max_pic_order_cnt_lsb_minus4[NB_MAX_SPS];
	uint(size=16) max_poc_lsb[NB_MAX_SPS];
	
	read_SPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size=1)  pic_cropping_flag
	do
		vld_ue_name(    fifo, res, "pic_height_in_luma_samples              "); 
		sps_pic_height_in_luma_samples[sps_id] := res[0];
		vld_u_name(  1, fifo, res, "pic_cropping_flag                       ");
		pic_cropping_flag := res[0];
		if pic_cropping_flag=1 then
			vld_ue_name(    fifo, res, "pic_crop_left_offset                    "); 
			vld_ue_name(    fifo, res, "pic_crop_right_offset                   "); 
			vld_ue_name(    fifo, res, "pic_crop_top_offset                     "); 
			vld_ue_name(    fifo, res, "pic_crop_bottom_offset                  "); 
		end
		vld_ue_name(    fifo, res, "bit_depth_luma_minus8                   ");
		sps_bit_depth_luma_minus8[sps_id] := res[0];
		vld_ue_name(    fifo, res, "bit_depth_chroma_minus8                 ");
		sps_bit_depth_chroma_minus8[sps_id] := res[0];
		vld_u_name(  1, fifo, res, "pcm_enabled_flag                        ");
		sps_pcm_enabled_flag[sps_id] := res[0];
		if sps_pcm_enabled_flag[sps_id] = 1 then
			vld_u_name(  4, fifo, res, "pcm_bit_depth_luma_minus1                      ");
			vld_u_name(  4, fifo, res, "pcm_bit_depth_chroma_minus1                    ");
		end
		vld_ue_name(    fifo, res, "log2_max_pic_order_cnt_lsb_minus4       ");
		sps_log2_max_pic_order_cnt_lsb_minus4[sps_id]:=res[0];
		max_poc_lsb[sps_id] := 1 << (sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4);
		se_idx := se_idx + 1;
		cnt_i := 0;
	end

	/**************************************************************************
	 * read_SPS_Header.se_idx_3
	 *************************************************************************/
	read_SPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3 and isFifoFull(fifo),
		cnt_i <= sps_max_sub_layers_minus1[sps_id]
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "max_dec_pic_buffering                   "); 
		vld_ue_name(    fifo, res, "num_reorder_pics                        "); 
		vld_ue_name(    fifo, res, "max_latency_increase                    "); 
		cnt_i := cnt_i + 1;
	end 

	read_SPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3,
		cnt_i = sps_max_sub_layers_minus1[sps_id] + 1
	do
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_4
	 *************************************************************************/
	uint(size= 1) sps_lists_modification_present_flag[NB_MAX_SPS];
	uint(size= 8) sps_log2_min_coding_block_size_minus3[NB_MAX_SPS];
	uint(size= 8) sps_log2_diff_max_min_coding_block_size[NB_MAX_SPS];
	uint(size= 8) sps_log2_min_transform_block_size_minus2[NB_MAX_SPS];
	uint(size= 8) sps_log2_diff_max_min_transform_block_size[NB_MAX_SPS];
	uint(size=16) sps_maxCUWidth[NB_MAX_SPS];
	uint(size=16) sps_addCUDepth[NB_MAX_SPS];
	uint(size=16) sps_maxCUDepth[NB_MAX_SPS];

	read_SPS_Header.se_idx_4 : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 1) restricted_ref_pic_lists_flag
	do
		vld_u_name(  1, fifo, res, "restricted_ref_pic_lists_flag           "); 
		restricted_ref_pic_lists_flag := res[0];
		if restricted_ref_pic_lists_flag = 1 then
			vld_u_name(  1, fifo, res, "lists_modification_present_flag         ");
			sps_lists_modification_present_flag[sps_id] := res[0];
		else
			sps_lists_modification_present_flag[sps_id] := 1;
		end
		vld_ue_name(    fifo, res, "log2_min_coding_block_size_minus3       ");
		sps_log2_min_coding_block_size_minus3[sps_id] := res[0];
		vld_ue_name(    fifo, res, "log2_diff_max_min_coding_block_size     ");
		sps_log2_diff_max_min_coding_block_size[sps_id] := res[0];
		vld_ue_name(    fifo, res, "log2_min_transform_block_size_minus2    ");
		sps_log2_min_transform_block_size_minus2[sps_id] := res[0];
		vld_ue_name(    fifo, res, "log2_diff_max_min_transform_block_size  ");
		sps_log2_diff_max_min_transform_block_size[sps_id] := res[0];
		sps_maxCUWidth[sps_id] := 1 << (Log2MinCbSize + sps_log2_diff_max_min_coding_block_size[sps_id]); 
    	sps_addCUDepth[sps_id] := 0;
    	while ( ( sps_maxCUWidth[sps_id] >> sps_log2_diff_max_min_coding_block_size[sps_id] ) > 
    		( 1 << ( sps_log2_min_transform_block_size_minus2[sps_id] + 2 + sps_log2_diff_max_min_coding_block_size[sps_id] )  )
    	)
    	do
        	sps_addCUDepth[sps_id] := sps_addCUDepth[sps_id] + 1;
    	end
    	sps_maxCUDepth[sps_id] := sps_log2_diff_max_min_coding_block_size[sps_id] + sps_addCUDepth[sps_id]; 
				
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_5
	 *************************************************************************/	 	
	uint(size= 8) sps_max_transform_hierarchy_depth_inter[NB_MAX_SPS];
	uint(size= 8) sps_max_transform_hierarchy_depth_intra[NB_MAX_SPS];
	
	read_SPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		if sps_pcm_enabled_flag[sps_id] = 1 then
			vld_ue_name(    fifo, res, "log2_min_pcm_coding_block_size_minus3   ");
			vld_ue_name(    fifo, res, "log2_diff_max_min_pcm_coding_block_size ");
		end
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_inter     ");
		sps_max_transform_hierarchy_depth_inter[sps_id] := res[0];
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_intra     ");
		sps_max_transform_hierarchy_depth_intra[sps_id] := res[0];
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_6
	 *************************************************************************/
	uint(size= 1) sps_scaling_list_enabled_flag[NB_MAX_SPS];
	uint(size= 1) sps_sample_adaptive_offset_enabled_flag[NB_MAX_SPS];
	uint(size= 8) sps_num_short_term_ref_pic_sets[NB_MAX_SPS];
	
	read_SPS_Header.se_idx_6 : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
   	do
		vld_u_name(  1, fifo, res, "scaling_list_enabled_flag               ");
		sps_scaling_list_enabled_flag[sps_id] := res[0];
		vld_u_name(  1, fifo, res, "amp_enabled_flag                        "); 
		vld_u_name(  1, fifo, res, "sample_adaptive_offset_enabled_flag     ");
		sps_sample_adaptive_offset_enabled_flag[sps_id] := res[0];
		if sps_pcm_enabled_flag[sps_id] = 1 then
			vld_u_name(  1, fifo, res, "pcm_loop_filter_disable_flag            ");
		end
		vld_u_name(  1, fifo, res, "temporal_id_nesting_flag                ");
		vld_ue_name(    fifo, res, "num_short_term_ref_pic_sets             "); 
		sps_num_short_term_ref_pic_sets[sps_id] := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_7
	 *************************************************************************/
	int(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE];	

	read_SPS_Header.se_idx_7.loop : action ==>
	guard
		se_idx = 7 and isFifoFull(fifo),
		cnt_i < sps_num_short_term_ref_pic_sets[sps_id]
   	do
   		parseShortTermRefPicSet(cnt_i, sps_num_short_term_ref_pic_sets[sps_id], fifo, pcRPS);
		cnt_i := cnt_i + 1;
 	end
 	read_SPS_Header.se_idx_7.loopEnd : action ==>
	guard
		se_idx = 7,
		cnt_i = sps_num_short_term_ref_pic_sets[sps_id]
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_8
	 *************************************************************************/	
	uint(size= 1) sps_long_term_ref_pics_present_flag[NB_MAX_SPS];
	uint(size= 1) sps_temporal_mvp_enable_flag[NB_MAX_SPS];
	bool          sps_strong_intra_smoothing_enable_flag[NB_MAX_SPS];
	
	read_SPS_Header.se_idx_8 : action ==>
	guard
		se_idx = 8 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "long_term_ref_pics_present_flag         "); 
		sps_long_term_ref_pics_present_flag[sps_id] := res[0];
		vld_u_name(  1, fifo, res, "sps_temporal_mvp_enable_flag            ");
		sps_temporal_mvp_enable_flag[sps_id] := res[0];
		vld_u_name(  1, fifo, res, "sps_strong_intra_smoothing_enable_flag  ");
		sps_strong_intra_smoothing_enable_flag[sps_id] := res[0] = 1;
		vld_u_name(  1, fifo, res, "vui_parameters_present_flag             "); 
		se_idx := se_idx + 1;
	end 
	
	/**************************************************************************
	 * read_SPS_Header_done
	 *************************************************************************/	
	read_SPS_Header_done : action ==>
	guard
		se_idx = 9 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 1) sps_extension_flag
	do
		vld_u_name(  1, fifo, res, "sps_extension_flag                      ");
		sps_extension_flag := res[0];
		if sps_extension_flag = 1 then
			println("moreRBSP data SPS");
		end
	end 
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER         *********************
	 **************************************************************************
	 *************************************************************************/
	  
	/**************************************************************************
	 * read_PPS_Header.se_idx_1
	 *************************************************************************/	
	uint(size= 8) pps_sps_id[NB_MAX_PPS];
	uint(size= 2) pps_tiles_enabled_flag[NB_MAX_PPS];

	read_PPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "pic_parameter_set_id                    "); 
		pps_id := res[0];
		vld_ue_name(    fifo, res, "seq_parameter_set_id                    "); 
		sps_id := res[0];
		pps_sps_id[pps_id] := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_2
	 *************************************************************************/
	uint(size= 1) pps_dependent_slice_segments_enabled_flag[NB_MAX_PPS];
	uint(size= 1) pps_sign_data_hiding_flag[NB_MAX_PPS];
	uint(size= 1) pps_cabac_init_present_flag[NB_MAX_PPS];
	uint(size= 8) pps_num_ref_idx_l0_default_active_minus1[NB_MAX_PPS];
	uint(size= 8) pps_num_ref_idx_l1_default_active_minus1[NB_MAX_PPS];
	 int(size=32) pps_pic_init_qp_minus26[NB_MAX_PPS];
	uint(size= 1) pps_transform_skip_enabled_flag[NB_MAX_PPS];
	uint(size= 2) pps_SliceGranularity[NB_MAX_PPS];
	uint(size=16) pps_diff_cu_qp_delta_depth[NB_MAX_PPS];
	uint(size=16) pps_cb_qp_offset[NB_MAX_PPS];
	uint(size=16) pps_cr_qp_offset[NB_MAX_PPS];
	uint(size= 1) pps_slicelevel_chroma_qp_flag[NB_MAX_PPS];
	uint(size= 1) pps_output_flag_present_flag[NB_MAX_PPS];
	uint(size= 1) pps_transquant_bypass_enable_flag[NB_MAX_PPS];
	uint(size= 1) pps_tile_control_present_flag[NB_MAX_PPS];
	uint(size= 8) pps_num_tile_columns_minus1[NB_MAX_PPS];
	uint(size= 8) pps_num_tile_rows_minus1[NB_MAX_PPS];
	uint(size= 1) pps_uniform_spacing_flag[NB_MAX_PPS];

	read_PPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
   	do
		vld_u_name(  1, fifo, res, "dependent_slice_segments_enabled_flag   ");
		pps_dependent_slice_segments_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "sign_data_hiding_flag                   ");
		pps_sign_data_hiding_flag[pps_id] := res[0];
		if pps_sign_data_hiding_flag[pps_id] = 1 then
			//FIXME vld_u_name(  4, fifo, res, "sign_hiding_threshold                   ");
		end
		vld_u_name(  1, fifo, res, "cabac_init_present_flag                 ");
		pps_cabac_init_present_flag[pps_id] := res[0];
		vld_ue_name(    fifo, res, "num_ref_idx_l0_default_active_minus1    ");
		pps_num_ref_idx_l0_default_active_minus1[pps_id] := res[0];
		vld_ue_name(    fifo, res, "num_ref_idx_l1_default_active_minus1    ");
		pps_num_ref_idx_l1_default_active_minus1[pps_id] := res[0];
		vld_se_name(    fifo, res, "pic_init_qp_minus26                     ");
		pps_pic_init_qp_minus26[pps_id] := res[0]; 
		vld_u_name(  1, fifo, res, "constrained_intra_pred_flag             ");
		vld_u_name(  1, fifo, res, "transform_skip_enabled_flag             ");
		pps_transform_skip_enabled_flag[pps_id] := res[0];
//		vld_u_name(  2, fifo, res, "slice_granularity                       ");
//		pps_SliceGranularity[pps_id] := res[0] * 2;
		vld_u_name(  1, fifo, res, "cu_qp_delta_enabled_flag                ");
		if res[0] = 1 then
			vld_ue_name(    fifo, res, "diff_cu_qp_delta_depth                  ");
			pps_diff_cu_qp_delta_depth[pps_id] := res[0];
		else
			pps_diff_cu_qp_delta_depth[pps_id] := 0;
		end
		vld_se_name(    fifo, res, "cb_qp_offset                            ");
		pps_cb_qp_offset[pps_id] := res[0];
		vld_se_name(    fifo, res, "cr_qp_offset                            ");
		pps_cr_qp_offset[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "slicelevel_chroma_qp_flag               ");
		pps_slicelevel_chroma_qp_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "weighted_pred_flag                      ");
		vld_u_name(  1, fifo, res, "weighted_bipred_flag                    ");
		vld_u_name(  1, fifo, res, "output_flag_present_flag                ");
		pps_output_flag_present_flag[pps_id]:=res[0];
		vld_u_name(  1, fifo, res, "transquant_bypass_enable_flag           ");
		pps_transquant_bypass_enable_flag[pps_id]:=res[0];
		vld_u_name(  1, fifo, res, "tiles_enabled_flag                      ");
		pps_tiles_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "entropy_coding_sync_enabled_flag        ");
		pps_num_tile_columns_minus1[pps_id] := 0;
		pps_num_tile_rows_minus1[pps_id]    := 0;
		pps_uniform_spacing_flag[pps_id]    := 1;
		if pps_tiles_enabled_flag[pps_id] = 1 then
			vld_ue_name(    fifo, res, "num_tile_columns_minus1                 "); 
			pps_num_tile_columns_minus1[pps_id] := res[0];
			vld_ue_name(    fifo, res, "num_tile_rows_minus1                    ");
			pps_num_tile_rows_minus1[pps_id] := res[0];
			vld_u_name ( 1, fifo, res, "uniform_spacing_flag                    ");
			pps_uniform_spacing_flag[pps_id] :=res[0];
		end
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_3
	 *************************************************************************/	
	uint(size=16) pps_column_width[NB_MAX_PPS][COLUMN_WIDTH_MAX];

  	read_PPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3  and isFifoFull(fifo),
		pps_uniform_spacing_flag[pps_id] = 0 and cnt_i <= pps_num_tile_columns_minus1[pps_id]
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "column_width[ ]                         ");
		pps_column_width[pps_id][cnt_i] := res[0];
		if cnt_i >= COLUMN_WIDTH_MAX then
			println("Error read_PPS_Header.se_idx_3.loop : "+cnt_i+" >= "+COLUMN_WIDTH_MAX);
		end		
		cnt_i := cnt_i + 1;
	end 
	read_PPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3,
		pps_uniform_spacing_flag[pps_id] = 0 and cnt_i > pps_num_tile_columns_minus1[pps_id]
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_PPS_Header.se_idx_3.noLoop : action ==>
	guard
		se_idx = 3,
		pps_uniform_spacing_flag[pps_id] = 1
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_PPS_Header.se_idx4
	 *************************************************************************/	
	uint(size=16) pps_row_height[NB_MAX_PPS][COLUMN_WIDTH_MAX];
	
	read_PPS_Header.se_idx_4.loop : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo),
		pps_uniform_spacing_flag[pps_id] = 0 and cnt_i <= pps_num_tile_rows_minus1[pps_id]
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "row_height[ ]                           ");
		pps_row_height[pps_id][cnt_i] := res[0];
		if cnt_i >= COLUMN_WIDTH_MAX then
			println("Error read_PPS_Header.se_idx_4.loop : "+cnt_i+" >= "+COLUMN_WIDTH_MAX);
		end
		cnt_i := cnt_i + 1;
	end 
	read_PPS_Header.se_idx_4.loopEnd : action ==>
	guard
		se_idx = 4,
		pps_uniform_spacing_flag[pps_id] = 0 and cnt_i > pps_num_tile_rows_minus1[pps_id]
   	do
		se_idx := se_idx + 1;
	end 
	
	/**************************************************************************
	 * read_PPS_Header.se_idx5
	 *************************************************************************/	
	uint(size= 1) pps_deblocking_filter_control_present_flag[NB_MAX_PPS];
	uint(size =1) deblocking_filter_override_enabled_flag[NB_MAX_PPS];
	uint(size= 1) pps_loop_filter_across_slice_enabled_flag[NB_MAX_PPS];

	read_PPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 1) pps_extension_flag
   	do
   		if (pps_tiles_enabled_flag[pps_id] = 1) then
			if pps_tile_control_present_flag[pps_id] = 1 then
				vld_u_name(  1, fifo, res, "loop_filter_across_tiles_enabled_flag   ");
			end
		end
		vld_u_name(  1, fifo, res, "loop_filter_across_slices_enabled_flag  ");
		pps_loop_filter_across_slice_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "deblocking_filter_control_present_flag  ");
		pps_deblocking_filter_control_present_flag[pps_id] := res[0];
		if pps_deblocking_filter_control_present_flag[pps_id] = 1 then
			vld_u_name(  1, fifo, res, "pps_deblocking_filter_flag              ");
			deblocking_filter_override_enabled_flag[pps_id] := res[0];
		else
			deblocking_filter_override_enabled_flag[pps_id] := 0;
		end
		vld_u_name(  1, fifo, res, "pps_scaling_list_data_present_flag      ");
		vld_ue_name(    fifo, res, "log2_parallel_merge_level_minus2        ");
		vld_u_name(  1, fifo, res, "slice_header_extension_present_flag     ");
		vld_u_name(  1, fifo, res, "pps_extension_flag                      ");
		pps_extension_flag := res[0];
		if pps_extension_flag = 1 then
			println("moreRBSP data PPS");
		end
		se_idx := se_idx + 1;
	end 

	/**************************************************************************
	 * read_PPS_Header_done
	 *************************************************************************/	
	read_PPS_Header_done : action ==>
	guard
		se_idx = 6
	end 	

	/**************************************************************************
	 **************************************************************************
	 ********        Slice HEADER                         *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_SliceHeader.se_idx_1
	 *************************************************************************/
	uint(size=32) poc;
	uint(size= 3) slice_type;
	uint(size= 1) entropy_slice_flag;
	uint(size=32) slice_address;
	uint(size= 1) slice_sample_adaptive_offset_flag[3];
	
	procedure compute_POC(int pic_order_cnt_lsb)
	var
	     int iPOClsb = pic_order_cnt_lsb,
	     int iPrevPOC = poc,
	     int iMaxPOClsb := max_poc_lsb[sps_id],
	     int iPrevPOClsb,
	     int iPrevPOCmsb,
	     int iPOCmsb
	begin
		iPrevPOClsb := iPrevPOC mod iMaxPOClsb;
		iPrevPOCmsb := iPrevPOC-iPrevPOClsb;
	    if( (iPOClsb < iPrevPOClsb) and ( (iPrevPOClsb - iPOClsb) >= (iMaxPOClsb / 2) ) ) then
	    	iPOCmsb := iPrevPOCmsb + iMaxPOClsb;
	    else 
	    	if( (iPOClsb > iPrevPOClsb)  and ( (iPOClsb - iPrevPOClsb) > (iMaxPOClsb / 2) ) ) then
	 			iPOCmsb := iPrevPOCmsb - iMaxPOClsb;
	   		else
				iPOCmsb := iPrevPOCmsb;
			end
		end
	    poc:= iPOCmsb+iPOClsb;
	end
	
	read_SliceHeader.se_idx_1.read : action ==> PictSize:[pictSize] repeat 2,
		SliceType:[slice_type], PartMode:[PART_MODE_PICT]/*, IsNewPictOrSlc:[true]*/
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size=32) prev := 0,
		uint(size=32) j,
		uint(size= 1) first_slice_in_pic_flag,
		uint(size= 1) dependent_slice_segment_flag,
		uint(size=16) pictSize[2]
   	do	
		vld_u_name(  1, fifo, res, "first_slice_in_pic_flag                 ");
		first_slice_in_pic_flag := res[0];
		if nal_unit_type >= 16 and nal_unit_type <= 23 then
			vld_u_name(  1, fifo, res, "no_output_of_prior_pics_flag            ");
		end
		vld_ue_name(    fifo, res, "pic_parameter_set_id                    "); 
		pps_id := res[0];
		sps_id := pps_sps_id[pps_id];
		dependent_slice_segment_flag := pps_dependent_slice_segments_enabled_flag[pps_id];
		if first_slice_in_pic_flag = 0 then
			if (pps_dependent_slice_segments_enabled_flag[pps_id] = 1) then
				vld_u_name(  1, fifo, res, "dependent_slice_segment_flag                    ");
				dependent_slice_segment_flag := res[0];
			end
			vld_ue_name(    fifo, res, "slice_address                           ");
			slice_address := res[0];
		else
			slice_address := 0;
		end
		if dependent_slice_segment_flag = 0 then
//			for ( i = 0; i < num_extra_slice_header_bits; i++ )
//				slice_reserved_undetermined_flag[ i ]    u(1)
			vld_ue_name(    fifo, res, "slice_type                              ");
			slice_type := res[0];
			if(pps_output_flag_present_flag[pps_id] = 1) then	
				vld_u_name(  1, fifo, res, "pic_output_flag                         ");
			end
//			if( separate_colour_plane_flag == 1 )
//				colour_plane_id 		u(2)

			if nal_unit_type = NAL_IDR_W_DLP then
				poc:=0;
			else
				vld_u_name( sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4, fifo, res, "pic_order_cnt_lsb                       "); 

				//compute the number of POC
				compute_POC(res[0]);
				
				vld_u_name(  1, fifo, res, "short_term_ref_pic_set_sps_flag         ");
				if res[0] = 0 then
			   		parseShortTermRefPicSet(pps_id, sps_num_short_term_ref_pic_sets[sps_id], fifo, pcRPS);
		   		else
				    vld_ue_name(    fifo, res, "short_term_ref_pic_set_idx              ");
				end
				if sps_long_term_ref_pics_present_flag[sps_id] = 1 then
//					if( num_long_term_ref_pics_sps > 0 )
//						num_long_term_sps		ue(v)
				
					vld_ue_name(    fifo, res, "num_long_term_pics                      "); pcRPS[pps_id][NUM_LONG_TERM_PICS]	:= res[0];
//					for( i = 0; i < num_long_term_sps + num_long_term_pics; i++ ) {
//						if( i < num_long_term_sps )
//							lt_idx_sps[ i ]						u(v)
//						else {
//							poc_lsb_lt[ i ] u(v)
//							used_by_curr_pic_lt_flag[ i ] 		u(1)
//							delta_poc_msb_present_flag[ i ] 	u(1)
//						}
//						if( delta_poc_msb_present_flag[ i ] )
//							delta_poc_msb_cycle_lt[ i ]			ue(v)
//					}
					
				   	j := res[0] + pcRPS[pps_id][NUM_PICS]-1;
			   		foreach uint(size=8) i in 0 .. res[0]-2 do
			    		vld_ue_name(    fifo, res, "delta_poc_lsb_lt                        "); prev := prev + res[0] + 1;
						pcRPS[j][POC] := pcRPS[pps_id][POC] - prev;
						vld_u_name(  1, fifo, res, "delta_poc_msb_present_flag              ");
						if res[0] = 1 then
			    			vld_ue_name(    fifo, res, "delta_poc_msb_cycle_lt_minus1                "); 
						end
						vld_u_name(  1, fifo, res, "used_by_curr_pic_lt_flag                "); pcRPS[pps_id][USED+i]		:= res[0];
					end
					pcRPS[pps_id][NUM_PICS] := pcRPS[pps_id][NUM_PICS] + pcRPS[pps_id][NUM_LONG_TERM_PICS];
				end
			end
			if( sps_sample_adaptive_offset_enabled_flag[sps_id] = 1) then
				//FIXME vld_u_name(  1, fifo, res, "slice_sao_interleaving_flag             ");
				//FIXME slice_sao_interleaving_flag := res[0];
				vld_u_name(  1, fifo, res, "slice_sao_luma_flag                     "); 
				slice_sample_adaptive_offset_flag[0] := res[0];
				vld_u_name(  1, fifo, res, "slice_sao_chroma_flag                   ");
				slice_sample_adaptive_offset_flag[1] := res[0];
				slice_sample_adaptive_offset_flag[2] := res[0];
			end
		end
		pictSize[0] := sps_pic_width_in_luma_samples[sps_id];
		pictSize[1] := sps_pic_height_in_luma_samples[sps_id];
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_2
	 *************************************************************************/
	uint(size= 8) num_ref_idx_l0_active_minus1;
	uint(size= 8) num_ref_idx_l1_active_minus1;
	uint(size= 1) temporal_mvp_enable_flag;
	uint(size= 1) mvd_l1_zero_flag;
	read_SliceHeader.se_idx_2.read : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
   	do
	   	num_ref_idx_l0_active_minus1 := pps_num_ref_idx_l0_default_active_minus1[pps_id];
	   	num_ref_idx_l1_active_minus1 := pps_num_ref_idx_l1_default_active_minus1[pps_id];
	   	temporal_mvp_enable_flag     := 0;
	   	mvd_l1_zero_flag             := 0;
		if sps_temporal_mvp_enable_flag[sps_id] = 1 and nal_unit_type != NAL_IDR_W_DLP then
			vld_u_name(  1, fifo, res, "temporal_mvp_enable_flag                ");	
			temporal_mvp_enable_flag := res[0];
		end	
		if entropy_slice_flag = 0 then
			if slice_type = P_SLICE or slice_type = B_SLICE then
				vld_u_name(  1, fifo, res, "num_ref_idx_active_override_flag        ");		
	      		if res[0] = 1 then
					vld_ue_name(    fifo, res, "num_ref_idx_l0_active_minus1            ");
					num_ref_idx_l0_active_minus1 := res[0];
					if slice_type = B_SLICE then
						vld_ue_name(    fifo, res, "num_ref_idx_l1_active_minus1            ");
						num_ref_idx_l1_active_minus1 := res[0];
					end
	      		end
			    if (sps_lists_modification_present_flag[sps_id] = 1) then
			    	println("TODO ref_pic_list_modification( )");
			    	println("TODO ref_pic_list_combination( )");
			    end
			    if slice_type = B_SLICE then
					vld_u_name(  1, fifo, res, "mvd_l1_zero_flag                        ");
					mvd_l1_zero_flag := res[0];		
				end	    
	        end
	    end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_3
	 *************************************************************************/
	 int(size=32) slice_qp;
	 int(size=32) slice_cb_qp_offset;
	 int(size=32) slice_cr_qp_offset;
	uint(size=16) MaxNumMergeCand;
	uint(size= 1) cabac_init_flag;
	 	
	read_SliceHeader.se_idx_3 : action ==>
	guard
		se_idx = 3 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 1) deblocking_filter_override_flag := 0,
		uint(size= 1) slice_header_disable_deblocking_filter_flag := 0
   	do	
   		cabac_init_flag := 0;
		if(entropy_slice_flag = 0) then
			if slice_type = P_SLICE or slice_type = B_SLICE then
				if( pps_cabac_init_present_flag[pps_id] = 1  and  slice_type  !=  I_SLICE )	then
					vld_u_name(  1, fifo, res, "cabac_init_flag                         ");	
					cabac_init_flag := res[0];
				end
				if temporal_mvp_enable_flag = 1 then
					res[0] := 1;
					if( slice_type = B_SLICE ) then	
						vld_u_name(  1, fifo, res, "collocated_from_l0_flag                 ");
					end
					if ( /*collocated_from_l0_flag*/ res[0] = 1 and num_ref_idx_l0_active_minus1 > 0 ) or ( /*!collocated_from_l0_flag*/ res[0]  =  0 and num_ref_idx_l1_active_minus1 > 0 ) then
						vld_ue_name(    fifo, res, "collocated_ref_idx                      ");
					end
				end
				vld_ue_name(    fifo, res, "5_minus_max_num_merge_cand              ");
				MaxNumMergeCand := 5 - res[0];
			end
			vld_se_name(    fifo, res, "slice_qp_delta                          ");
			slice_qp := pps_pic_init_qp_minus26[pps_id] + 26 +res[0];
			slice_cb_qp_offset := 0;
			slice_cr_qp_offset := 0;
			if pps_slicelevel_chroma_qp_flag[pps_id] = 1 then
				vld_se_name(    fifo, res, "slice_cb_qp_offset                      ");
				vld_se_name(    fifo, res, "slice_cr_qp_offset                      ");
			end
			if(pps_deblocking_filter_control_present_flag[pps_id] = 1) then	
	 			if(deblocking_filter_override_enabled_flag[pps_id] = 1) then
					vld_u_name(  1, fifo, res, "deblocking_filter_override_flag        ");
					deblocking_filter_override_flag := res[0];	
				end
				if(deblocking_filter_override_flag = 0) then
					vld_u_name(  1, fifo, res, "slice_header_disable_deblocking_filter_flag          ");
					if( slice_header_disable_deblocking_filter_flag = 0) then
						vld_se_name(    fifo, res, "beta_offset_div2                        ");
						vld_se_name(    fifo, res, "tc_offset_div2                          ");
					end
				end
			end	
		end	
	 	if( pps_loop_filter_across_slice_enabled_flag[sps_id] = 1  and  (
	 		slice_sample_adaptive_offset_flag[0] = 1 
	 		or slice_sample_adaptive_offset_flag[1] = 1 
		 	or slice_header_disable_deblocking_filter_flag = 0)) then
			vld_u_name( 1,  fifo, res, "slice_loop_filter_across_slices_enabled_flag");
 		end
 		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader_done
	 *************************************************************************/	
	 procedure initWpScaling()
	 begin
		foreach uint(size=8) e in 0 .. 1 do
			foreach uint(size=8) i in 0 .. MAX_NUM_REF-1 do
				foreach uint(size=8) yuv in 0 .. 2 do
					if wp[e][i][yuv][WP_PRESENT_FLAG] = 1 then
						wp[e][i][yuv][WP_I_WEIGHT] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]);
						wp[e][i][yuv][WP_I_OFFSET] := 0;
					end
					wp[e][i][yuv][WP_W]     := wp[e][i][yuv][WP_I_WEIGHT];
					wp[e][i][yuv][WP_O]     := wp[e][i][yuv][WP_I_OFFSET] * (1);
					wp[e][i][yuv][WP_SHIFT] := wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM];
					if wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM] >= 1 then
						wp[e][i][yuv][WP_ROUND] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]) - 1;
					else
						wp[e][i][yuv][WP_ROUND] := 0;
					end
				end
			end
		end
	end
	uint(size=16) sliceCbAddrZs;
	read_SliceHeader_done : action ==> Poc:[poc], MaxPocLsb:[max_poc_lsb[sps_id]], 
		StrongIntraSmoothing:[sps_strong_intra_smoothing_enable_flag[sps_id]]
	guard
		se_idx = 4
	do
		if 	source_isMaxLoopsReached() then
			source_exit(0);
		end
		if DEBUG_CABAC or CHECK_CABAC then
			println("\tPOC: "+poc);
		end
		sliceData_idx := 1;
		sliceCbAddrZs := 0;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Slice Data                           *********************
	 **************************************************************************
	 *************************************************************************/
		
	uint(size= 9) codIRange[1];
	uint(size=16) codIOffset[1];
	uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX];
	uint(size= 8) sliceData_idx;

	/**************************************************************************
	 * read_SliceData.init
	 *************************************************************************/	
	uint(size= 8) Log2CtbSize;
	uint(size= 8) Log2MinCbSize;
	uint(size=16) PicWidthInCtbsY;
	
	uint(size= 8) Log2MinTrafoSize;
	uint(size= 8) Log2MaxTrafoSize;
	uint(size=16) ctbAddrRStoTS[CTB_ADDR_TS_MAX];
	uint(size=16) ctbAddrTStoRS[CTB_ADDR_TS_MAX];
	uint(size=16) TileId[CTB_ADDR_TS_MAX];
	uint(size=16) MinCbAddrZS[CTB_ADDR_TS_MAX][CTB_ADDR_TS_MAX];
	
	uint(size= 1) skip_flag_tab[CTB_ADDR_TS_MAX][CTB_ADDR_TS_MAX];
	
	uint(size= 8) intraPredMode[CTB_ADDR_TS_MAX][CTB_ADDR_TS_MAX];

	read_SliceData.init: action ==> SliceAddr:[0, 0]
	guard
		sliceData_idx = 1
	var
		uint(size=16) PicHeightInCtbsY,
		uint(size=16) PicWidthInMinCbs,
		uint(size=16) PicHeightInMinCbs,
		uint(size=16) PicSizeInCtbsY,
		uint(size=16) column_width[COLUMN_WIDTH_MAX]= [pps_column_width[pps_id][ i ] : for int i in 0 .. COLUMN_WIDTH_MAX-1],
		uint(size=16) row_height[COLUMN_WIDTH_MAX]	= [pps_row_height[pps_id][ i ] : for int i in 0 .. COLUMN_WIDTH_MAX-1],
		uint(size= 8) num_tile_columns_minus1		= pps_num_tile_columns_minus1[pps_id],
		uint(size= 8) num_tile_rows_minus1			= pps_num_tile_rows_minus1[pps_id],
		uint(size= 1) uniform_spacing_flag			= pps_uniform_spacing_flag[pps_id],
		uint(size=16) colWidth[COLUMN_WIDTH_MAX],
		uint(size=16) rowHeight[COLUMN_WIDTH_MAX],
		uint(size=16) ColBd[COLUMN_WIDTH_MAX],
		uint(size=16) RowBd[COLUMN_WIDTH_MAX],
		uint(size=16) tileX,
		uint(size=16) tileY,
		uint(size=16) val,
		uint(size=16) tbX,
		uint(size=16) tbY,
		uint(size=16) tIdx,
		uint(size=16) ctbAddrRS,
		uint(size=16) m,
		uint(size=16) p
	do
		Log2MinCbSize     := sps_log2_min_coding_block_size_minus3[sps_id] + 3;
		Log2CtbSize       := Log2MinCbSize + sps_log2_diff_max_min_coding_block_size[sps_id];
		PicWidthInCtbsY   := ( sps_pic_width_in_luma_samples[sps_id]  + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
		PicHeightInCtbsY  := ( sps_pic_height_in_luma_samples[sps_id] + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
		PicWidthInMinCbs  := sps_pic_width_in_luma_samples[sps_id] >> Log2MinCbSize;
		PicHeightInMinCbs := sps_pic_height_in_luma_samples[sps_id] >> Log2MinCbSize;
		PicSizeInCtbsY    := PicWidthInCtbsY * PicHeightInCtbsY;
		
		Log2MinTrafoSize  := sps_log2_min_transform_block_size_minus2[sps_id] + 2;
		Log2MaxTrafoSize  := Log2MinTrafoSize + sps_log2_diff_max_min_transform_block_size[sps_id];
		
		skip_flag_tab	  := [[0	: for int j in 0 .. CTB_ADDR_TS_MAX-1]	: for int i in 0 .. CTB_ADDR_TS_MAX-1];
		
		
		if num_tile_columns_minus1 >= COLUMN_WIDTH_MAX then
			println("Error read_SliceData.init : ColumnWidth : "+num_tile_columns_minus1+" >= "+COLUMN_WIDTH_MAX);
		end
		if uniform_spacing_flag = 1 then
			foreach int i in 0 .. num_tile_columns_minus1 do
				colWidth[ i ] := ((i + 1)*PicWidthInCtbsY) / (num_tile_columns_minus1+1) - (i*PicWidthInCtbsY) / (num_tile_columns_minus1+1);
			end
		else
			colWidth[ num_tile_columns_minus1 ] := PicWidthInCtbsY;
			foreach int i in 0 .. num_tile_columns_minus1 do
				colWidth[ i ] := column_width[ i ];
				colWidth[ num_tile_columns_minus1 ] := colWidth[ num_tile_columns_minus1 ] - colWidth[ i ];
			end
		end
		if num_tile_rows_minus1 >= COLUMN_WIDTH_MAX then
			println("Error read_SliceData.init : RowHeight : "+num_tile_rows_minus1+" >= "+COLUMN_WIDTH_MAX);
		end
		if uniform_spacing_flag = 1 then
			foreach int i in 0 .. num_tile_rows_minus1 do
				rowHeight[ i ] := ((i+1)*PicHeightInCtbsY) / (num_tile_rows_minus1+1) - (i*PicHeightInCtbsY) / (num_tile_rows_minus1+1);
			end
		else
			rowHeight[ num_tile_rows_minus1 ] := PicHeightInCtbsY;
			foreach int i in 0 .. num_tile_rows_minus1 do
				rowHeight[ i ] := row_height[ i ];
				rowHeight[ num_tile_rows_minus1 ] := rowHeight[ num_tile_columns_minus1 ] - rowHeight[ i ];
			end
		end
		ColBd[ 0 ] := 0;
		foreach int i in 0 .. num_tile_columns_minus1 do
			ColBd[ i + 1 ] := ColBd[ i ] + colWidth[ i ];
		end
		RowBd[ 0 ] := 0;
		foreach int i in 0 .. num_tile_rows_minus1 do
			RowBd[ i + 1 ] := RowBd[ i ] + rowHeight[ i ];
		end
		/*********************************************************************
		 * 6.5 Conversion process for coding tree block address 
		 * in coding tree block raster order to tile scan order
		 ********************************************************************/
		if PicHeightInCtbsY * PicWidthInCtbsY >= CTB_ADDR_TS_MAX then
			println("Error read_SliceData.init : CtbAddrTS : "+(PicHeightInCtbsY * PicWidthInCtbsY)+" >= "+CTB_ADDR_TS_MAX);
		end
		foreach int ctbAddrRS_v in 0 .. PicSizeInCtbsY - 1 do
			tbX   := ctbAddrRS_v mod PicWidthInCtbsY;
			tbY   := ctbAddrRS_v / PicWidthInCtbsY;
			tileX := 0;
			tileY := 0;
			foreach int i in 0 .. num_tile_columns_minus1 do
				if tbX < ColBd[i] then
					tileX := i;
				end
			end
			foreach int j in 0 .. num_tile_rows_minus1 do
				if tbY < RowBd[j] then
					tileY := j;
				end
			end
			val := 0;
			foreach int i in 0 .. tileX-1 do
				val := val + rowHeight[ tileY ] * colWidth[ i ];
			end
			foreach int j in 0 .. tileY-1 do
				val := val + PicWidthInCtbsY * rowHeight[ j ];
			end
			val 						 := val + ( tbY - RowBd[tileY] ) * colWidth[tileY] + tbX - ColBd[tileX];
			ctbAddrRStoTS[ ctbAddrRS_v ] := val;
			ctbAddrTStoRS[ val ] 		 := ctbAddrRS_v;			
		end
		
		tIdx := 0;
		foreach int j in 0 .. num_tile_rows_minus1 do
			foreach int i in 0 .. num_tile_columns_minus1 do
				foreach int y in RowBd[ j ] .. RowBd[ j + 1 ] - 1 do
					foreach int x in ColBd[ i ] .. ColBd[ i + 1 ] - 1 do
						TileId[ ctbAddrRStoTS[ y*PicWidthInCtbsY + x ] ] := tIdx;						
					end
				end
				tIdx := tIdx + 1;
			end
		end
		
		if PicHeightInMinCbs >= CTB_ADDR_TS_MAX then
			println("Error read_SliceData.init : MinCbAddrZS y : "+PicHeightInMinCbs+" >= "+CTB_ADDR_TS_MAX);
		end
		if PicWidthInMinCbs >= CTB_ADDR_TS_MAX then
			println("Error read_SliceData.init : MinCbAddrZS x : "+PicWidthInMinCbs+" >= "+CTB_ADDR_TS_MAX);
		end
		foreach int y in 0 .. PicHeightInMinCbs-1 do
			foreach int x in 0 .. PicWidthInMinCbs-1 do
				tbX := ( x << Log2MinCbSize ) >> Log2CtbSize;
				tbY := ( y << Log2MinCbSize ) >> Log2CtbSize;
				ctbAddrRS := PicWidthInCtbsY * tbY + tbX;
				p := ctbAddrRStoTS[ctbAddrRS] << ( (Log2CtbSize - Log2MinCbSize) * 2 );
				foreach int i in 0 .. Log2CtbSize - Log2MinCbSize - 1 do
					m := 1 << i;
					p := p + if (m & x) != 0 then m*m else 0 end + if (m & y) != 0 then 2 * m * m else 0 end;
				end
				MinCbAddrZS[x][y] := p;	
			end
		end
		intraPredMode := [[INTRA_DC	: for int j in 0 .. CTB_ADDR_TS_MAX-1]	: for int i in 0 .. CTB_ADDR_TS_MAX-1];
		//
		sliceData_idx := 2;
	end
	/**************************************************************************
	 * read_SliceData.start
	 *************************************************************************/	
	uint(size=32) CtbAddrRS;
	uint(size=32) CtbAddrTS;
	uint(size= 1) end_of_slice_flag;
	 
	read_SliceData.start : action ==>
	guard
		sliceData_idx = 2
	var
		uint(size=32) SliceCtbAddrRS = ( slice_address >> pps_SliceGranularity[pps_id] )
	do
		decodeStart(codIRange, codIOffset, fifo);
		contextInit(slice_qp, slice_type, ctxTable, cabac_init_flag);
		//
		CtbAddrRS     := SliceCtbAddrRS;
		CtbAddrTS     := ctbAddrRStoTS[CtbAddrRS];
		end_of_slice_flag  := 0;
		sliceData_idx := 3;
	end
	/**************************************************************************
	 * read_SliceData_gotoCodingTree
	 *************************************************************************/	
	read_SliceData_gotoCodingTree : action ==>
	guard
		sliceData_idx = 3
	do
		sliceData_idx  := 4;
		codingTree_idx := 1;
	end
	/**************************************************************************
	 * read_SliceData.retCodingTree
	 *************************************************************************/	
	read_SliceData.retCodingTree : action ==>
	guard
		sliceData_idx = 4 and isFifoFull(fifo)
	var
		uint(size=32) res[1] := [0]
	do
		get_END_OF_SLICE_FLAG(codIRange, codIOffset, fifo, res);
		end_of_slice_flag := res[0];
		CtbAddrTS := CtbAddrTS + 1;
		CtbAddrRS := ctbAddrTStoRS[CtbAddrTS];
		if( end_of_slice_flag = 0 and ( 
			( pps_tiles_enabled_flag[pps_id] = 1 and TileId[ CtbAddrTS ] != TileId[ CtbAddrTS - 1 ] ) or
			((CtbAddrTS mod PicWidthInCtbsY) = 0 ) 
			) ) then
//			rbsp_trailing_bits( )
			showBits (24, fifo, res);
			if( res[0] = 0x000002 ) then
				flushBits(24, fifo);
			end
	 	end
	 	if end_of_slice_flag = 0 then
			sliceData_idx := 3;
		else
			sliceData_idx := 5;
		end
	end
	/**************************************************************************
	 * read_SliceData_end
	 *************************************************************************/	
	read_SliceData_end: action ==>
	guard
		sliceData_idx = 5	
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Coding Tree                          *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size=16) xCtb;
	uint(size=16) yCtb;
	uint(size= 8) NumPCMBlock;
	uint(size=32) CtbAddrInSlice;
	uint(size= 8) codingTree_idx;
	uint(size= 8) ctStack_idx;
	uint(size=16) ctStack[5][CT_STRUCT_SIZE];
	
	/**************************************************************************
	 * read_CodingTree.start
	 *************************************************************************/	
	read_CodingTree.start : action ==>
	guard
		codingTree_idx = 1
	var
		uint(size=32) CtbSize        = 1 << Log2CtbSize
	do
//		println("read_CodingTree.start");
		NumPCMBlock    := 0;
		xCtb           := InverseRasterScan( CtbAddrRS, CtbSize, CtbSize, sps_pic_width_in_luma_samples[sps_id], 0 );
		yCtb           := InverseRasterScan( CtbAddrRS, CtbSize, CtbSize, sps_pic_width_in_luma_samples[sps_id], 1 );
		println("CtbAddrRS = "+CtbAddrRS+", CtbSize = "+CtbSize+", pic_width_in_luma_samples = "+sps_pic_width_in_luma_samples[sps_id]+", x_ctb = "+xCtb+", y_ctb = "+yCtb+", log2_ctb_size = "+Log2CtbSize);
		
		CtbAddrInSlice := CtbAddrRS - ( slice_address >> pps_SliceGranularity[pps_id] );
		codingTree_idx := 2;
	end
	/**************************************************************************
	 * read_CodingTree_gotoSaoParam
	 *************************************************************************/	
	read_CodingTree_gotoSaoParam : action ==>
	guard
		codingTree_idx = 2,
		slice_sample_adaptive_offset_flag[0] = 1 or slice_sample_adaptive_offset_flag[1] = 1
	do
		codingTree_idx	:= 3;
		sao_idx			:= 1;
		sao_rx			:= xCtb >> Log2CtbSize;
		sao_ry			:= yCtb >> Log2CtbSize;
		sao_cIdx		:= 0;
	end
	read_CodingTree.noGotoSaoParam : action ==>
	guard
		codingTree_idx = 2,
		slice_sample_adaptive_offset_flag[0] = 0 and slice_sample_adaptive_offset_flag[1] = 0
	do
		codingTree_idx := 3;
	end
	/**************************************************************************
	 * read_CodingTree_gotoCodingQuadTree
	 *************************************************************************/	
	read_CodingTree_gotoCodingQuadTree : action ==> 
	guard
		codingTree_idx = 3
	do
		codingTree_idx				:= 4;
		ctStack_idx					:= 0;
		ctStack[0][CT_idx]			:= 1;
		ctStack[0][CT_x0]			:= xCtb;
		ctStack[0][CT_y0]			:= yCtb;
		ctStack[0][CT_log2CbSize]	:= Log2CtbSize;
		ctStack[0][CT_ctDepth]		:= 0;
	end
	/**************************************************************************
	 * read_CodingTree_end
	 *************************************************************************/	
	read_CodingTree_end : action ==>
	guard
		codingTree_idx = 4
	end
	/**************************************************************************
	 **************************************************************************
	 ********        sao_param                            *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 3) sao_cIdx;
	uint(size=16) sao_rx;
	uint(size=16) sao_ry;
	uint(size= 8) sao_idx;
	/**************************************************************************
	 * read_SaoParam.start
	 *************************************************************************/	
	read_SaoParam.start : action ==>
	guard
		sao_idx = 1 and isFifoFull(fifo)
	var
		 int(size=32) res[1],
		bool		  leftCtbInSlice,
		bool		  leftCtbInTile,
		bool		  upCtbInSlice,
		bool		  upCtbInTile,
		uint(size= 1) sao_merge_left_flag	:= 0,
		uint(size= 1) sao_merge_up_flag		:= 0
	do
		println("sao_param ("+sao_rx+", "+sao_ry+") : "+CtbAddrInSlice);
		if sao_rx > 0 then
			leftCtbInSlice := CtbAddrInSlice > 0;
			leftCtbInTile  := true; //(TileId[ CtbAddrTS ] = TileId[ ctbAddrRStoTS[ CtbAddrRS - 1 ] ]);
			if leftCtbInSlice and leftCtbInTile then
				get_SAO_MERGE_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
				sao_merge_left_flag := res[0];
			end
		end
		if sao_ry > 0 and sao_merge_left_flag = 0 then
			upCtbInSlice   := true; //(( CtbAddrTS - ctbAddrRStoTS[CtbAddrRS - PicWidthInCtbsY] ) <= CtbAddrInSlice);
			upCtbInTile    := true; //(TileId[ CtbAddrTS ] = TileId[ ctbAddrRStoTS[ CtbAddrRS - PicWidthInCtbsY ] ]);
			if upCtbInSlice and upCtbInTile then
				get_SAO_MERGE_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
				sao_merge_up_flag := res[0];
			end
		end
		sao_idx  := 2;
		if sao_merge_left_flag = 0 and sao_merge_up_flag = 0 then
			sao_cIdx := 0;
		else 
			sao_cIdx := 3;
		end		
	end		
	/**************************************************************************
	 * read_SaoParam.loop
	 *************************************************************************/	
	uint(size= 8) sao_typeIdx;
	read_SaoParam.loop : action ==>
	guard
		sao_idx  = 2 and isFifoFull(fifo),
		sao_cIdx < 3 and slice_sample_adaptive_offset_flag[sao_cIdx] = 1
	var
		uint(size= 8) offsetTh = (1<<3)-1,
		 int(size=16) offset[4],
		 int(size=32) res[1] := [0]
	do
		if sao_cIdx != 2 then
			get_SAO_TYPE_IDX(codIRange, codIOffset, ctxTable, fifo, res);
			sao_typeIdx := res[0];
        end
		if sao_typeIdx != SAO_NOT_APPLIED then
			foreach int i in 0 .. 3 do
				get_SAO_OFFSET_ABS(offsetTh, codIRange, codIOffset, fifo, res);
				offset[i] := res[0]; 
			end
			if sao_typeIdx = SAO_BAND then
				foreach int i in 0 .. 3 do
					if offset[i] != 0 then
						get_SAO_OFFSET_SIGN(codIRange, codIOffset, fifo, res);
						if res[0] != 0 then
							offset[i] := -offset[i];
						end 
					end
				end
				get_SAO_BAND_POSITION(codIRange, codIOffset, fifo, res);
			else
				if sao_cIdx != 2 then
					get_SAO_EO(codIRange, codIOffset, fifo, res);
				end
			end
		end 
		sao_cIdx := sao_cIdx + 1;
	end
	read_SaoParam.nextLoop : action ==>
	guard
		sao_idx  = 2 ,
		sao_cIdx < 3 and slice_sample_adaptive_offset_flag[sao_cIdx] = 0
	do
		sao_cIdx := sao_cIdx + 1;
	end
	read_SaoParam_endLoop : action ==>
	guard
		sao_idx  = 2 ,
		sao_cIdx = 3
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Coding quadTree                      *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 1) IsCuQpDeltaCoded;
	
	/**************************************************************************
	 * read_CodingQuadTree.start
	 *************************************************************************/	
	read_CodingQuadTree.start : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size=16) ct_x0			= ctStack[ctStack_idx][CT_x0],
		uint(size=16) ct_y0			= ctStack[ctStack_idx][CT_y0],
		uint(size= 8) ct_ctDepth	= ctStack[ctStack_idx][CT_ctDepth],
		uint(size= 8) ct_log2CbSize = ctStack[ctStack_idx][CT_log2CbSize],
		uint(size= 8) top_ctDepth	= cu_top_ctDepth[ct_x0 >> Log2MinCbSize],
		uint(size= 8) left_ctDepth	= cu_left_ctDepth[ct_y0 >> Log2MinCbSize],
		uint(size= 1) split_coding_unit_flag,
		uint(size= 8) Log2MinCuQpDeltaSize = Log2CtbSize - pps_diff_cu_qp_delta_depth[pps_id] - pps_SliceGranularity[pps_id]
	do
		if DEBUG_CABAC and DEBUG_TRACE1 then
			println("read_CodingTree.start ("+ct_x0+", "+ct_y0+", "+(1<<ct_log2CbSize)+", "+ctStack[ctStack_idx][CT_ctDepth]+")");
		elsif DEBUG_CABAC then
			println("read_CodingTree.start");
		end
		
		if	ct_x0 + ( 1 << ct_log2CbSize ) <= sps_pic_width_in_luma_samples[sps_id] and
			ct_y0 + ( 1 << ct_log2CbSize ) <= sps_pic_height_in_luma_samples[sps_id] and
			MinCbAddrZS[ct_x0>>Log2MinCbSize][ct_y0>>Log2MinCbSize] >= sliceCbAddrZs and
			ct_log2CbSize > Log2MinCbSize and NumPCMBlock = 0 then
			get_SPLIT_CODING_UNIT_FLAG(codIRange, codIOffset, ctxTable, fifo, res, ct_ctDepth, ct_x0 > 0, left_ctDepth, ct_y0 > 0, top_ctDepth);
			split_coding_unit_flag := res[0];
		else
			split_coding_unit_flag := if ct_log2CbSize > Log2MinCbSize then 1 else 0 end;
		end
		IsCuQpDeltaCoded := 1;

		if( (pps_diff_cu_qp_delta_depth[pps_id] > 0 ) and ct_log2CbSize >= Log2MinCuQpDeltaSize ) then
			IsCuQpDeltaCoded := 0;
//			CuQpDelta        := 0;
		end

		if split_coding_unit_flag = 1 then
			ctStack[ctStack_idx][CT_x1]  := ct_x0 + ( ( 1 << ct_log2CbSize ) >> 1 );
			ctStack[ctStack_idx][CT_y1]  := ct_y0 + ( ( 1 << ct_log2CbSize ) >> 1 );
			ctStack[ctStack_idx][CT_idx] := 2;
		else
			ctStack[ctStack_idx][CT_idx] := 6;
		end
	end

	/**************************************************************************
	 * read_CodingQuadTree.case1
	 *************************************************************************/	
	read_CodingQuadTree.case1 : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 2
	var
		uint(size= 8) idx =  ctStack_idx
	do
		ctStack[ctStack_idx][CT_idx]        := 3;
		ctStack_idx							:= ctStack_idx + 1;
		ctStack[ctStack_idx][CT_idx]        := 1;
		ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x0];
		ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y0];
		ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
		ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
	end

	/**************************************************************************
	 * read_CodingQuadTree.case2
	 *************************************************************************/		
	read_CodingQuadTree.case2 : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 3,
		ctStack[ctStack_idx][CT_x1] < sps_pic_width_in_luma_samples[sps_id]
	var
		uint(size= 8) idx =  ctStack_idx
	do
		ctStack[ctStack_idx][CT_idx]        := 4;
		ctStack_idx							:= ctStack_idx + 1;
		ctStack[ctStack_idx][CT_idx]        := 1;
		ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x1];
		ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y0];
		ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
		ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
	end
	read_CodingQuadTree.noCase2 : action ==> CUInfo:[cuInfo] repeat 5,
		 PartMode:[PART_2Nx2N]
	guard
		ctStack[ctStack_idx][CT_idx] = 3,
		ctStack[ctStack_idx][CT_x1] >= sps_pic_width_in_luma_samples[sps_id]
	var
		uint(size=16) cuInfo[5] = [MODE_NONE,
			ctStack[ctStack_idx][CT_x1], ctStack[ctStack_idx][CT_y0],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)]
	do
		ctStack[ctStack_idx][CT_idx]        := 4;
	end
	/**************************************************************************
	 * read_CodingQuadTree.case3
	 *************************************************************************/	
	read_CodingQuadTree.case3 : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 4,
		ctStack[ctStack_idx][CT_y1] < sps_pic_height_in_luma_samples[sps_id]
	var
		uint(size= 8) idx =  ctStack_idx
	do
		ctStack[ctStack_idx][CT_idx]        := 5;
		ctStack_idx							:= ctStack_idx + 1;
		ctStack[ctStack_idx][CT_idx]        := 1;
		ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x0];
		ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y1];
		ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
		ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
	end
	read_CodingQuadTree.noCase3 : action ==> CUInfo:[cuInfo] repeat 5,
		 PartMode:[PART_2Nx2N]
	guard
		ctStack[ctStack_idx][CT_idx] = 4,
		ctStack[ctStack_idx][CT_y1] >= sps_pic_height_in_luma_samples[sps_id]
	var
		uint(size=16) cuInfo[5] = [MODE_NONE,
			ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y1],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)]
	do
		ctStack[ctStack_idx][CT_idx]        := 5;
	end
	/**************************************************************************
	 * read_CodingQuadTree.case4
	 *************************************************************************/	
	read_CodingQuadTree.case4 : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 5,
		ctStack[ctStack_idx][CT_x1] < sps_pic_width_in_luma_samples[sps_id],
		ctStack[ctStack_idx][CT_y1] < sps_pic_height_in_luma_samples[sps_id]		
	var
		uint(size= 8) idx =  ctStack_idx
	do
		ctStack[ctStack_idx][CT_idx]        := 7;
		ctStack_idx							:= ctStack_idx + 1;
		ctStack[ctStack_idx][CT_idx]        := 1;
		ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x1];
		ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y1];
		ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
		ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
	end
	read_CodingQuadTree.noCase4 : action ==> CUInfo:[cuInfo] repeat 5,
		 PartMode:[PART_2Nx2N]
	guard
		ctStack[ctStack_idx][CT_idx] = 5,
		ctStack[ctStack_idx][CT_x1] >= sps_pic_width_in_luma_samples[sps_id] or
		ctStack[ctStack_idx][CT_y1] >= sps_pic_height_in_luma_samples[sps_id]
	var
		uint(size=16) cuInfo[5] = [MODE_NONE,
			ctStack[ctStack_idx][CT_x1], ctStack[ctStack_idx][CT_y1],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)]
	do
		ctStack[ctStack_idx][CT_idx]        := 7;
	end
	/**************************************************************************
	 * read_CodingQuadTree_gotoCodingUnit
	 *************************************************************************/	
	read_CodingQuadTree_gotoCodingUnit : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 6,
		NumPCMBlock = 0
	do
		ctStack[ctStack_idx][CT_idx]        := 7;
		cu_idx			:= 1;
		cu_x0			:= ctStack[ctStack_idx][CT_x0];
		cu_y0			:= ctStack[ctStack_idx][CT_y0];
		cu_log2CbSize	:= ctStack[ctStack_idx][CT_log2CbSize];
		cu_ctDepth		:= ctStack[ctStack_idx][CT_ctDepth];
	end
	/**************************************************************************
	 * read_CodingQuadTree_gotoPCMSample
	 *************************************************************************/	
	read_CodingQuadTree_gotoPCMSample : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 6,
		NumPCMBlock   != 0
	do
		PCMSample_log2CbSize 		 := ctStack[ctStack_idx][CT_log2CbSize];
		ctStack[ctStack_idx][CT_idx] := 7;
	end
	/**************************************************************************
	 * read_CodingQuadTree_end
	 *************************************************************************/
	read_CodingQuadTree.noEnd : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 7,
		ctStack_idx != 0
	do
		ctStack_idx := ctStack_idx - 1;
//		println("read_CodingTree_end");
	end
	read_CodingQuadTree_end : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 7,
		ctStack_idx = 0
	do
//		println("read_CodingTree_end");
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Coding Unit                          *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) cu_idx;
	uint(size=16) cu_x0;
	uint(size=16) cu_y0;
	uint(size= 8) cu_log2CbSize;
	uint(size= 8) cu_ctDepth;
	uint(size= 8) predMode;
	uint(size= 8) partMode;
	uint(size= 1) IntraSplitFlag;
	uint(size= 8) MaxTrafoDepth;
	uint(size= 1) cu_transquant_bypass_flag;
	uint(size= 8) cu_top_ctDepth[CTB_ADDR_TS_MAX];
	uint(size= 8) cu_left_ctDepth[CTB_ADDR_TS_MAX];
	uint(size= 1) skip_flag;
	uint(size= 1) merge_flag;
	uint(size=6) intraChrPredModIdx;
	uint(size=6) intraPredModeC[5][5] =
		[[34,  0,  0,  0,  0],
		 [26, 34, 26, 26, 26],
		 [10, 10, 34, 10, 10],
		 [ 1,  1,  1, 34,  1],
		 [0, 26, 10, 1, 0]];

	
	/**************************************************************************
	 * read_CodingUnit.start
	 *************************************************************************/
	read_CodingUnit.start : action ==>
	guard 
		cu_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 8) length 		 = (1 << cu_log2CbSize) >> Log2MinCbSize,
		uint(size=16) x_cb 			 = cu_x0 >> Log2MinCbSize,
    	uint(size=16) y_cb 			 = cu_y0 >> Log2MinCbSize//,
//		uint(size=16) CurrCbAddrTS = MinCbAddrZS[ cu_x0 >> Log2MinCbSize ][ cu_y0 >> Log2MinCbSize ]
	do
		skip_flag  := 0;
		merge_flag := 0;
		intra_pred_mode := [1 : for int i in 0 .. 3];
		if DEBUG_CABAC and DEBUG_TRACE1 then
			println("read_CodingUnit.start ("+cu_x0+", "+cu_y0+", "+cu_log2CbSize+")");
		elsif DEBUG_CABAC then
			println("read_CodingUnit.start");
	 	end
		predMode := MODE_INTRA;
		if pps_transquant_bypass_enable_flag[pps_id] != 0 then
			//cu_transquant_bypass_flag
		end
		if slice_type != I_SLICE then
			predMode := MODE_SKIP;
			get_SKIP_FLAG(codIRange, codIOffset, ctxTable, fifo, res, skip_flag_tab, x_cb, y_cb);
			skip_flag := res[0];
			foreach uint x  in 0 .. length-1 do
				foreach uint y  in 0 .. length-1 do
					skip_flag_tab[x_cb+x][y_cb+y] := skip_flag;
    			end
			end
		end
		cu_idx := 2; 
	end
	/**************************************************************************
	 * read_CodingUnit_gotoPredictionUnit.goto1
	 *************************************************************************/
	read_CodingUnit_gotoPredictionUnit.goto1 : action ==> CUInfo:[cuInfo] repeat 5,
		 PartMode:[PART_2Nx2N], SplitTransform:[false], Cbf:[false]
	guard 
		cu_idx = 2,
		skip_flag != 0
	var
		uint(size=16) cuInfo[5] = [MODE_SKIP,
		ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0],
		1<<cu_log2CbSize, 1<<cu_log2CbSize]
	do
		cu_idx		:= 10; 
		pu_idx		:= 1;
		pu_x0		:= cu_x0;
		pu_y0		:= cu_y0;
		pu_PbW		:= cu_nCbS;
		pu_PbH		:= cu_nCbS;
	end
	/**************************************************************************
	 * read_CodingUnit.noGoto1
	 *************************************************************************/
	uint(size= 8) intra_pred_mode[4];
	uint(size= 8) intra_pred_mode_c;
	uint(size= 8) cu_nCbS;
	read_CodingUnit_noGoto1 : action ==> PartMode:[partMode]
	guard 
		cu_idx = 2 and isFifoFull(fifo),
		skip_flag = 0
	var
		uint(size= 1) prev_intra_luma_pred_flag[4],
		uint(size= 8) intra_chroma_table[4] = [0, 26, 10, 1],
		uint(size=32) res[1],
		uint(size= 8) Log2MinIPCMCUSize = Log2MinCbSize,
		uint(size= 8) Log2MaxIPCMCUSize = Log2MinCbSize,
		uint(size= 8) pbOffset,
		uint(size= 8) pbEnd
	do
		partMode		:= PART_2Nx2N;
		IntraSplitFlag	:= 0;
		cu_nCbS			:= ( 1 << cu_log2CbSize );
		if slice_type != I_SLICE then
			get_PRED_MODE_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			predMode := res[0];
		end
		if predMode != MODE_INTRA or cu_log2CbSize = Log2MinCbSize then
			get_PART_SIZE(codIRange, codIOffset, ctxTable, fifo, res, predMode = MODE_INTRA, cu_log2CbSize, Log2MinCbSize);
			partMode := res[0];
		end
		cu_idx := 4;
		if( predMode = MODE_INTRA ) then
 			pcm_flag := 0;
			if  partMode = PART_2Nx2N and sps_pcm_enabled_flag[sps_id] = 1 and
				cu_log2CbSize >= Log2MinIPCMCUSize and
				cu_log2CbSize <= Log2MaxIPCMCUSize then
				get_PCM_FLAG(codIRange, codIOffset, fifo, res);
			end
			if( pcm_flag = 1) then
				get_NUM_SUBSEQUENT_PCM(codIRange, codIOffset, fifo, res);
				NumPCMBlock := res[0] + 1;
				byte_align(fifo);
				cu_idx := 3;
			else 
				pbOffset := if partMode = PART_NxN then cu_nCbS>>1 else cu_nCbS end;
				pbEnd    := if partMode = PART_NxN then 1 else 0 end;
				foreach int i in 0 .. pbEnd do
					foreach int j in 0 .. pbEnd do 
						get_PREV_INTRA_LUMA_PRED_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
						prev_intra_luma_pred_flag[ (i<<1) + j ] := res[0];
					end
				end
				foreach int i in 0 .. pbEnd do
					foreach int j in 0 .. pbEnd do
						if prev_intra_luma_pred_flag[ (i<<1) + j ] = 1 then
							get_MPM_IDX(codIRange, codIOffset, fifo, res);
						else
							get_REM_INTRA_LUMA_PRED_MODE(codIRange, codIOffset, fifo, res);
						end
						luma_intra_pred_mode(cu_x0 + j*pbOffset, cu_y0 + i*pbOffset, pbOffset, prev_intra_luma_pred_flag[ (i<<1) + j ], res[0], res, Log2MinIPCMCUSize-1 ,Log2CtbSize, intraPredMode);
						intra_pred_mode[ (i<<1) + j ] := res[0];
					end
				end
				get_INTRA_CHROMA_PRED_MODE(codIRange, codIOffset, ctxTable, fifo, res);
				intraChrPredModIdx := res[0];
				if res[0] != 4 then
        			if intra_pred_mode[0] = intra_chroma_table[res[0]] then
            			intra_pred_mode_c := 34;
        			else
	            		intra_pred_mode_c := intra_chroma_table[res[0]];
        			end
    			else
	        		intra_pred_mode_c := intra_pred_mode[0];
    			end    			
				cu_idx := 8;
			end
		end
	end

	sendIntraPredMode.skip: action ==>
	guard
		predMode != MODE_INTRA
	end

	sendIntraPredMode.part2Nx2N: action ==> IntraPredMode:[intra_pred_mode[0], predMode_v]
	guard
		partModeToNumPart[partMode] = 1 and predMode = MODE_INTRA
	var
		uint(size=6) predMode_v,
		uint(size=3) idx
	do	
		if(intraChrPredModIdx=4) then
			predMode_v := intra_pred_mode[0];
		else
			idx :=
				if(intra_pred_mode[0] = 0) then
					0
				else if(intra_pred_mode[0] = 26) then
					1
				else if(intra_pred_mode[0] = 10) then
					2
				else if(intra_pred_mode[0] = 1) then
					3
				else
					4
				end end end end;
			predMode_v := intraPredModeC[intraChrPredModIdx][idx];
		end
	end

	sendIntraPredMode.partNxN: action ==> IntraPredMode:[intraPredMode] repeat 8
	guard
		partModeToNumPart[partMode] != 1 and predMode = MODE_INTRA
	var
		uint(size=6) intraPredMode[8],
		uint(size=3) idx
	do
		foreach uint i in 0 .. 3
		do
			intraPredMode[2*i] := intra_pred_mode[i];

			if(intraChrPredModIdx=4) then
				intraPredMode[2*i+1] := intra_pred_mode[i];
			else
				idx :=
					if(intra_pred_mode[i] = 0) then
						0
					else if(intra_pred_mode[i] = 26) then
						1
					else if(intra_pred_mode[i] = 10) then
						2
					else if(intra_pred_mode[i] = 1) then
						3
					else
						4
					end end end end;
				intraPredMode[2*i+1] := intraPredModeC[intraChrPredModIdx][idx];
		end
		end
	end

	sendCUInfo.has1Part: action ==> CUInfo:[cuInfo] repeat 5
	guard
		partModeToNumPart[partMode] = 1
	var
		uint(size=16) cuInfo[5] =
			[predMode, ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0],
				1<<cu_log2CbSize, 1<<cu_log2CbSize]
	end

	sendCUInfo.has2Part: action ==> CUInfo:[cuInfo] repeat 10
	guard
		partModeToNumPart[partMode] = 2
	var
		uint(size=16) cuInfo[10] =
			[predMode, ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0], 4242, 4242,
			 predMode, 4242, 4242, 4242, 4242]
	end

	sendCUInfo.has4Part: action ==> CUInfo:[cuInfo] repeat 20
	guard
		partModeToNumPart[partMode] = 4
	var
		uint(size=7) CUSize = (1<<(cu_log2CbSize-1)),
		uint(size=16) cuInfo[20] =
			[predMode, ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0], CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]+CUSize, ctStack[ctStack_idx][CT_y0], CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0]+CUSize, CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]+CUSize, ctStack[ctStack_idx][CT_y0]+CUSize, CUSize, CUSize]
	end
	/**************************************************************************
	 * read_CodingUnit_gotoPCMSample
	 *************************************************************************/
	read_CodingUnit_gotoPCMSample : action ==>
	guard 
		cu_idx = 3
	do
		PCMSample_log2CbSize := cu_log2CbSize;
		cu_idx				 := 8;
	end
	/**************************************************************************
	 * read_CodingUnit_gotoPredictionUnit.goto2
	 *************************************************************************/
	read_CodingUnit_gotoPredictionUnit.goto2 : action ==>
	guard 
		cu_idx = 4 or cu_idx = 5 or
		cu_idx = 6 or cu_idx = 7
	var
		uint(size= 8) nCbS_2   = cu_nCbS >> 1,
		uint(size= 8) nCbS_4   = cu_nCbS >> 2,
		uint(size= 8) nCbS_3_4 = cu_nCbS - nCbS_4
	do
	
		pu_idx := 1;
		pu_x0  := cu_x0;
		pu_y0  := cu_y0;
		pu_PbW := cu_nCbS;
		pu_PbH := cu_nCbS;
		if partMode = PART_2Nx2N then
			//prediction_unit( x0, y0, nCbS, nCbS )
			cu_idx    := 8;
		elsif partMode = PART_2NxN then
			pu_PbH := nCbS_2;
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS, nCbS / 2 )
				cu_idx := 5;
			else
				//prediction_unit( x0, y0 + ( nCbS / 2 ), nCbS, nCbS / 2 )
				pu_y0  := cu_y0 + nCbS_2;
				cu_idx := 8;
			end
		elsif partMode = PART_Nx2N then
			pu_PbW := nCbS_2;
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS / 2, nCbS )
				cu_idx := 5;
			else
				//prediction_unit( x0 + ( nCbS / 2 ), y0, nCbS / 2, nCbS )
				pu_x0  := cu_x0 + nCbS_2;
				cu_idx := 8;
			end
		elsif partMode = PART_2NxnU then
			pu_PbH := nCbS_4;
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS, nCbS / 4 )
				cu_idx := 5;
			else
				//prediction_unit( x0, y0 + ( nCbS / 4 ), nCbS, nCbS *3 / 4 )
				pu_y0  := cu_y0 + nCbS_4;
				pu_PbH := nCbS_3_4;
				cu_idx := 8;
			end
		elsif partMode = PART_2NxnD then
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS, nCbS *3 / 4 )
				pu_PbH := nCbS_3_4;
				cu_idx := 5;
			else
				//prediction_unit( x0, y0 + ( nCbS * 3 / 4 ), nCbS, nCbS / 4 )
				pu_y0  := cu_y0 + nCbS_3_4;
				pu_PbH := nCbS_4;
				cu_idx := 8;
			end
		elsif partMode = PART_nLx2N then
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS /4, nCbS )
				pu_PbW := nCbS_4;
				cu_idx := 5;
			else
				//prediction_unit( x0 + ( nCbS / 4 ), y0, nCbS *3 / 4, nCbS)
				pu_x0  := cu_x0 + nCbS_4;
				pu_PbW := nCbS_3_4;
				cu_idx := 8;
			end
		elsif partMode = PART_nRx2N then
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS *3 / 4, nCbS )
				pu_PbW := nCbS_3_4;
				cu_idx := 5;
			else
				//prediction_unit( x0 + ( nCbS * 3 / 4 ), y0, nCbS / 4, nCbS )
				pu_x0  := cu_x0 + nCbS_3_4;
				pu_PbW := nCbS_4;
				cu_idx := 8;
			end
		else /* PART_NxN */
			pu_PbW := nCbS_2;
			pu_PbH := nCbS_2;
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS / 2, nCbS / 2)
				cu_idx := 5;
			elsif cu_idx = 5 then
				//prediction_unit( x0 + ( nCbS / 2 ), y0, nCbS / 2, nCbS / 2 )
				pu_x0  := cu_x0 + nCbS_2;
				cu_idx := 6;
			elsif cu_idx = 6 then
				//prediction_unit( x0, y0 + ( nCbS / 2 ), nCbS / 2, nCbS / 2 )
				pu_y0  := cu_y0 + nCbS_2;
				cu_idx := 5;
			else
				//prediction_unit( x0 + ( nCbS / 2 ), y0 + ( nCbS / 2 ), nCbS / 2, nCbS / 2 )
				pu_x0  := cu_x0 + nCbS_2;
				pu_y0  := cu_y0 + nCbS_2;
				cu_idx := 8;
			end
		end
	end
	/**************************************************************************
	 * read_CodingUnit.endFunction
	 *************************************************************************/
	read_CodingUnit.endFunction : action ==>
	guard 
		cu_idx = 8
	var
		uint(size=32) res[1] := [1]
	do
		cu_idx := 10;
		if pcm_flag = 0 then
			if( predMode != MODE_INTRA and not(partMode = PART_2Nx2N and merge_flag = 1) ) then
				get_NO_RESIDUAL_SYNTAX_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
				//no_residual_data_flag
			end
			if res[0] != 0 then
				MaxTrafoDepth := if predMode = MODE_INTRA then
									sps_max_transform_hierarchy_depth_intra[sps_id] + IntraSplitFlag
								else
									sps_max_transform_hierarchy_depth_inter[sps_id]
								end;
				cu_idx	:= 9;				
				//transform_tree( x0, y0, x0, y0, x0, y0, log2CbSize, log2CbSize, log2CbSize, 0, 0 )
			end
		end
	end
	/**************************************************************************
	 * read_CodingUnit_gotoTransformTree
	 *************************************************************************/
	read_CodingUnit_gotoTransformTree : action ==>
	guard 
		cu_idx = 9
	do
		cu_idx							:= 10;
		ttStack_idx						:=  0;
		ttStack[0][TT_idx]				:=  1;
		ttStack[0][TT_x0]				:=  cu_x0;
		ttStack[0][TT_y0]				:=  cu_y0;
		ttStack[0][TT_xBase]			:=  cu_x0;
		ttStack[0][TT_yBase]			:=  cu_y0;
		ttStack[0][TT_log2TrafoSize]	:=  cu_log2CbSize;
		ttStack[0][TT_trafoDepth]		:=  0;
		ttStack[0][TT_blkIdx]			:=  0;
	end
	/**************************************************************************
	 * read_CodingUnit_end
	 *************************************************************************/
	read_CodingUnit_end : action ==>
	guard 
		 cu_idx = 10
	var
		uint(size= 8) length = (1 << cu_log2CbSize) >> Log2MinCbSize,
		uint(size=16) x_cb = cu_x0 >> Log2MinCbSize,
    	uint(size=16) y_cb = cu_y0 >> Log2MinCbSize
	do
//		println("read_CodingUnit_end ");
    	foreach uint i  in 0 .. length-1 do
    		cu_top_ctDepth[x_cb + i]  := cu_ctDepth;
    		cu_left_ctDepth[y_cb + i] := cu_ctDepth;
		end
	end
	
	/**************************************************************************
	 **************************************************************************
	 ********        Prediction Unit                      *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) pu_idx;
	uint(size=16) pu_x0;
	uint(size=16) pu_y0;
	uint(size= 8) pu_PbW;
	uint(size= 8) pu_PbH;
	uint(size= 1) pcm_flag;
	uint(size= 8) inter_pred_idc;
	
	/**************************************************************************
	 * read_PredictionUnit.start
	 *************************************************************************/
	read_PredictionUnit.start : action ==>
	guard 
		isFifoFull(fifo),
		pu_idx = 1
	var
		uint(size=32) res[1]
	do
		inter_pred_idc := Pred_L0;
		if ( skip_flag = 1) then
			if( MaxNumMergeCand > 1 ) then
				get_MERGE_IDX(codIRange, codIOffset, ctxTable, fifo, res, MaxNumMergeCand);
			end
			pu_idx := 7;
		else /* MODE_INTER */
			get_MERGE_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			merge_flag := res[0];
			if res[0] = 1 then
				if MaxNumMergeCand > 1 then
					get_MERGE_IDX(codIRange, codIOffset, ctxTable, fifo, res, MaxNumMergeCand);
				end
				pu_idx := 7;
			else
				if( slice_type = B_SLICE ) then
					get_INTER_PRED_IDC(codIRange, codIOffset, ctxTable, fifo, res, partMode, pu_PbW, pu_PbH, cu_ctDepth);
					inter_pred_idc := res[0];
				end
				if( inter_pred_idc != Pred_L1 ) then
					if( num_ref_idx_l0_active_minus1 > 0 ) then
						get_REF_IDX_L0(codIRange, codIOffset, ctxTable, fifo, res, num_ref_idx_l0_active_minus1);
						//ref_idx_l0[ x0 ][ y0 ]
					end
					// goto mvd_coding
					pu_idx := 3;
				else
					pu_idx := 4;
				end	
			end
		end
	end
	/**************************************************************************
	 * read_PredictionUnit.retMVDcoding_goto1
	 *************************************************************************/
	read_PredictionUnit.retMVDcoding_goto1 : action ==>
	guard 
		pu_idx = 4
	var
		uint(size=32) res[1]
	do
		if( inter_pred_idc != Pred_L1 ) then
			get_MVP_LX_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			//mvp_l0_flag[ x0 ][ y0 ];
		end	
		pu_idx := 7;
		if( inter_pred_idc != Pred_L0 ) then
			if( num_ref_idx_l1_active_minus1 > 0 ) then
				get_REF_IDX_L0(codIRange, codIOffset, ctxTable, fifo, res, num_ref_idx_l1_active_minus1);
				//ref_idx_l1[ x0 ][ y0 ]
			end
			if( mvd_l1_zero_flag = 1 and inter_pred_idc = Pred_BI ) then
				//mvd_l1[ x0 ][ y0 ][ 0 ] = 0
				//mvd_l1[ x0 ][ y0 ][ 1 ] = 0
				pu_idx := 6;
			else
				pu_idx := 5;
			end
		end
	end
	/**************************************************************************
	 * read_PredictionUnit_gotoMVDCoding
	 *************************************************************************/
	read_PredictionUnit_gotoMVDCoding : action ==>
	guard 
		pu_idx = 3 or pu_idx = 5
	do
		pu_idx := pu_idx + 1;
	end
	/**************************************************************************
	 * read_PredictionUnit.retMVDcoding_goto2
	 *************************************************************************/
	read_PredictionUnit.retMVDcoding_goto2 : action ==>
	guard 
		pu_idx = 6
	var
		uint(size=32) res[1]
	do
		get_MVP_LX_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
		//mvp_l1_flag[ x0 ][ y0 ]
		pu_idx := 7;
	end
	/**************************************************************************
	 * read_PredictionUnit_end
	 *************************************************************************/
	read_PredictionUnit_end : action ==>
	guard 
		pu_idx = 7
	end
	
	/**************************************************************************
	 **************************************************************************
	 ********        MVD Coding                           *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) mvd_x;
	uint(size= 8) mvd_y;
	read_MVDCoding.start : action ==>
	guard
		isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 1) abs_mvd_greater0_flag_0,
		uint(size= 1) abs_mvd_greater0_flag_1,
		uint(size= 1) abs_mvd_greater1_flag_0,
		uint(size= 1) abs_mvd_greater1_flag_1,
		 int(size=32) abs_mvd_minus2_0 := 0,
		uint(size= 1) mvd_sign_flag_0  := 0,
		 int(size=32) abs_mvd_minus2_1 := 0,
		uint(size= 1) mvd_sign_flag_1  := 0
	do
		get_ABS_MVD_GREATER0_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
		abs_mvd_greater0_flag_0 := res[0];
		get_ABS_MVD_GREATER0_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
		abs_mvd_greater0_flag_1 := res[0];
		if abs_mvd_greater0_flag_0 = 1 then
			get_ABS_MVD_GREATER1_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			abs_mvd_greater1_flag_0 := res[0];
		end
		if abs_mvd_greater0_flag_1 = 1 then
		get_ABS_MVD_GREATER1_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			abs_mvd_greater1_flag_1 := res[0];
		end
		if abs_mvd_greater0_flag_0 = 1 then
			abs_mvd_minus2_0 := -1;
			if abs_mvd_greater1_flag_0 = 1 then
				get_ABS_MVD_MINUS2(codIRange, codIOffset, fifo, res);
				abs_mvd_minus2_0 := res[0];
			end
			get_MVD_SIGN_FLAG(codIRange, codIOffset, fifo, res);
			mvd_sign_flag_0 := res[0];
		end
		if abs_mvd_greater0_flag_1 = 1 then
			if abs_mvd_greater1_flag_1 = 1 then
				get_ABS_MVD_MINUS2(codIRange, codIOffset, fifo, res);
				abs_mvd_minus2_1 := res[0];
			end
			get_MVD_SIGN_FLAG(codIRange, codIOffset, fifo, res);
			mvd_sign_flag_1 := res[0];
		end
		mvd_x := abs_mvd_greater0_flag_0 * ( abs_mvd_minus2_0 + 2 ) * ( 1 - (mvd_sign_flag_0 << 1) );
		mvd_y := abs_mvd_greater0_flag_1 * ( abs_mvd_minus2_1 + 2 ) * ( 1 - (mvd_sign_flag_1 << 1) );
	end

	/**************************************************************************
	 **************************************************************************
	 ********        PCM Sample                           *********************
	 **************************************************************************
	 *************************************************************************/

	uint(size= 8) PCMSample_log2CbSize;
	read_PCMSample.start : action ==>
	guard
		isFifoFull(fifo)
	var
		uint(size=32) res[1]		
	do
		if DEBUG_CABAC then
			println("read_PCMSample");
		end
		foreach int i  in 0 .. 1 << ( PCMSample_log2CbSize << 1 ) do
			vld_u_name(  1, fifo, res, "pcm_sample_luma[i]                      ");
			//pcm_sample_luma[ i ];
		end
		foreach int i  in 0 .. 1 << ( PCMSample_log2CbSize << 1 ) do
			vld_u_name(  1, fifo, res, "pcm_sample_chroma[i]                    ");
			//pcm_sample_chroma[ i ]
		end
		NumPCMBlock := NumPCMBlock - 1;
	end
	read_PCMSample2.start : action ==>		
	var
		uint(size=32) res[1]		
	do
		if DEBUG_CABAC then
			println("read_PCMSample2");
		end
		foreach int i  in 0 .. 1 << ( PCMSample_log2CbSize << 1 ) do
			vld_u_name(  1, fifo, res, "pcm_sample_luma[i]                      ");
			//pcm_sample_luma[ i ];
		end
		foreach int i  in 0 .. 1 << ( PCMSample_log2CbSize << 1 ) do
			vld_u_name(  1, fifo, res, "pcm_sample_chroma[i]                    ");
			//pcm_sample_chroma[ i ]
		end
		NumPCMBlock := NumPCMBlock - 1;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Transform Tree                       *********************
	 **************************************************************************
	 *************************************************************************/

	uint(size= 8) ttStack_idx;
	uint(size=16) ttStack[10][TT_STRUCT_SIZE];
	uint(size= 1) split_transform_flag[CTB_ADDR_TS_MAX][CTB_ADDR_TS_MAX][4];
	bool          lastSplitTransf;
	uint(size= 1) cbf_cb[CTB_ADDR_TS_MAX][CTB_ADDR_TS_MAX][4];
	uint(size= 1) cbf_cr[CTB_ADDR_TS_MAX][CTB_ADDR_TS_MAX][4];
	uint(size= 1) cbf_luma[CTB_ADDR_TS_MAX][CTB_ADDR_TS_MAX][4];
	bool          cbfLumaVal;
	uint(size= 8) cur_intra_pred_mode;
	/**************************************************************************
	 * read_TransformTree.start
	 *************************************************************************/
	 /**************** CLEAN ME !! *************/
	read_TransformTree.start.partNxN : action ==>
	guard 
		isFifoFull(fifo),
		ttStack[ttStack_idx][TT_idx] = 1,
		partMode = PART_NxN and ttStack[ttStack_idx][TT_trafoDepth] = 0
	var
		uint(size=16) x0				= ttStack[ttStack_idx][TT_x0],
		uint(size=16) y0				= ttStack[ttStack_idx][TT_y0],
		uint(size=16) xBase				= ttStack[ttStack_idx][TT_xBase],
		uint(size=16) yBase				= ttStack[ttStack_idx][TT_yBase],
		uint(size= 8) log2TrafoSize	    = ttStack[ttStack_idx][TT_log2TrafoSize],
		uint(size= 8) trafoDepth		= ttStack[ttStack_idx][TT_trafoDepth],
		uint(size=32) res[1] := [0],
		uint(size= 1) IntraSplitFlag   = if predMode = MODE_INTRA and partMode = PART_NxN then 1 else 0 end,
		uint(size= 1) InterSplitFlag   = if sps_max_transform_hierarchy_depth_inter[sps_id] = 0 and predMode = MODE_INTER and partMode != PART_2Nx2N and trafoDepth = 0 then 1 else 0 end
	do	
		if DEBUG_CABAC and DEBUG_TRACE1 then
			println("read_TransformTree.start("+x0+", "+y0+", "+xBase+", "+yBase+", "+log2TrafoSize+", "+trafoDepth+", "+ttStack[ttStack_idx][TT_blkIdx]+")");
		elsif DEBUG_CABAC then
			println("read_TransformTree.start");
		end
		if IntraSplitFlag = 1 then
        	if trafoDepth = 1 then
            	cur_intra_pred_mode := intra_pred_mode[ttStack[ttStack_idx][TT_blkIdx]];
            end
    	else
        	cur_intra_pred_mode := intra_pred_mode[0];
    	end
		split_transform_flag[ x0 ][ y0 ][ trafoDepth ] := 0;
		if( log2TrafoSize <= Log2MaxTrafoSize and log2TrafoSize > Log2MinTrafoSize and
			trafoDepth < MaxTrafoDepth and not(IntraSplitFlag = 1 and trafoDepth = 0) ) then
			get_SPLIT_TRANSFORM_FLAG(codIRange, codIOffset, ctxTable, fifo, res, log2TrafoSize);
			split_transform_flag[ x0 ][ y0 ][ trafoDepth ] := res[0];
		elsif log2TrafoSize > Log2MaxTrafoSize or (IntraSplitFlag = 1 and trafoDepth = 0) or InterSplitFlag = 1 then
			split_transform_flag[ x0 ][ y0 ][ trafoDepth ] := 1;							
		end
		
		cbf_cb[ x0 ][ y0 ][ trafoDepth ] := 0;
		cbf_cr[ x0 ][ y0 ][ trafoDepth ] := 0;
		if trafoDepth = 0 or log2TrafoSize > 2  then
			if trafoDepth = 0 then
				get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res, trafoDepth);
				cbf_cb[ x0 ][ y0 ][ trafoDepth ] := res[0];
				get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res, trafoDepth);
				cbf_cr[ x0 ][ y0 ][ trafoDepth ] := res[0];
			else
				if cbf_cb[ xBase ][ yBase ][ trafoDepth-1 ] = 1 then
					get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res, trafoDepth);
					cbf_cb[ x0 ][ y0 ][ trafoDepth ] := res[0];
				end
				if cbf_cr[ xBase ][ yBase ][ trafoDepth-1 ] = 1 then
					get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res, trafoDepth);
					cbf_cr[ x0 ][ y0 ][ trafoDepth ] := res[0];
				end
			end
		end
		if trafoDepth > 0 and log2TrafoSize = 2  then
			cbf_cb[ x0 ][ y0 ][ trafoDepth ] := cbf_cb[ xBase ][ yBase ][ trafoDepth-1 ];
			cbf_cr[ x0 ][ y0 ][ trafoDepth ] := cbf_cr[ xBase ][ yBase ][ trafoDepth-1 ];
		end
				
		if split_transform_flag[ x0 ][ y0 ][ trafoDepth ] = 1 then
			ttStack[ttStack_idx][TT_x1]  := x0 + ( ( 1 << log2TrafoSize ) >> 1 );
			ttStack[ttStack_idx][TT_y1]  := y0 + ( ( 1 << log2TrafoSize ) >> 1 );
			ttStack[ttStack_idx][TT_idx] := 3;
		else
			cbf_luma[ x0 ][ y0 ][ trafoDepth ] := 1;
			if predMode = MODE_INTRA or trafoDepth != 0 or
				cbf_cb[ x0 ][ y0 ][ trafoDepth ] = 1 or cbf_cr[ x0 ][ y0 ][ trafoDepth ] = 1 then
				get_CBF_LUMA(codIRange, codIOffset, ctxTable, fifo, res, trafoDepth);
				cbf_luma[ x0 ][ y0 ][ trafoDepth ] := res[0];
			end
			ttStack[ttStack_idx][TT_idx] := 2;
		end
	end

	read_TransformTree_start.nonPartNxN : action ==> SplitTransform:[lastSplitTransf]
	guard 
		isFifoFull(fifo),
		ttStack[ttStack_idx][TT_idx] = 1,
		not(partMode = PART_NxN and ttStack[ttStack_idx][TT_trafoDepth] = 0)
	var
		uint(size=16) x0				= ttStack[ttStack_idx][TT_x0],
		uint(size=16) y0				= ttStack[ttStack_idx][TT_y0],
		uint(size=16) xBase				= ttStack[ttStack_idx][TT_xBase],
		uint(size=16) yBase				= ttStack[ttStack_idx][TT_yBase],
		uint(size= 8) log2TrafoSize	    = ttStack[ttStack_idx][TT_log2TrafoSize],
		uint(size= 8) trafoDepth		= ttStack[ttStack_idx][TT_trafoDepth],
		uint(size=32) res[1] := [0],
		uint(size= 1) IntraSplitFlag   = if predMode = MODE_INTRA and partMode = PART_NxN then 1 else 0 end,
		uint(size= 1) InterSplitFlag   = if sps_max_transform_hierarchy_depth_inter[sps_id] = 0 and predMode = MODE_INTER and partMode != PART_2Nx2N and trafoDepth = 0 then 1 else 0 end
	do	
		if DEBUG_CABAC and DEBUG_TRACE1 then
			println("read_TransformTree.start("+x0+", "+y0+", "+xBase+", "+yBase+", "+log2TrafoSize+", "+trafoDepth+", "+ttStack[ttStack_idx][TT_blkIdx]+")");
		elsif DEBUG_CABAC then
			println("read_TransformTree.start");
		end
		if IntraSplitFlag = 1 then
        	if trafoDepth = 1 then
            	cur_intra_pred_mode := intra_pred_mode[ttStack[ttStack_idx][TT_blkIdx]];
            end
    	else
        	cur_intra_pred_mode := intra_pred_mode[0];
    	end
		split_transform_flag[ x0 ][ y0 ][ trafoDepth ] := 0;
		if( log2TrafoSize <= Log2MaxTrafoSize and log2TrafoSize > Log2MinTrafoSize and
			trafoDepth < MaxTrafoDepth and not(IntraSplitFlag = 1 and trafoDepth = 0) ) then
			get_SPLIT_TRANSFORM_FLAG(codIRange, codIOffset, ctxTable, fifo, res, log2TrafoSize);
			split_transform_flag[ x0 ][ y0 ][ trafoDepth ] := res[0];
		elsif log2TrafoSize > Log2MaxTrafoSize or (IntraSplitFlag = 1 and trafoDepth = 0) or InterSplitFlag = 1 then
			split_transform_flag[ x0 ][ y0 ][ trafoDepth ] := 1;							
		end
		
		cbf_cb[ x0 ][ y0 ][ trafoDepth ] := 0;
		cbf_cr[ x0 ][ y0 ][ trafoDepth ] := 0;
		if trafoDepth = 0 or log2TrafoSize > 2  then
			if trafoDepth = 0 then
				get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res, trafoDepth);
				cbf_cb[ x0 ][ y0 ][ trafoDepth ] := res[0];
				get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res, trafoDepth);
				cbf_cr[ x0 ][ y0 ][ trafoDepth ] := res[0];
			else
				if cbf_cb[ xBase ][ yBase ][ trafoDepth-1 ] = 1 then
					get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res, trafoDepth);
					cbf_cb[ x0 ][ y0 ][ trafoDepth ] := res[0];
				end
				if cbf_cr[ xBase ][ yBase ][ trafoDepth-1 ] = 1 then
					get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res, trafoDepth);
					cbf_cr[ x0 ][ y0 ][ trafoDepth ] := res[0];
				end
			end
		end
		if trafoDepth > 0 and log2TrafoSize = 2  then
			cbf_cb[ x0 ][ y0 ][ trafoDepth ] := cbf_cb[ xBase ][ yBase ][ trafoDepth-1 ];
			cbf_cr[ x0 ][ y0 ][ trafoDepth ] := cbf_cr[ xBase ][ yBase ][ trafoDepth-1 ];
		end
				
		if split_transform_flag[ x0 ][ y0 ][ trafoDepth ] = 1 then
			ttStack[ttStack_idx][TT_x1]  := x0 + ( ( 1 << log2TrafoSize ) >> 1 );
			ttStack[ttStack_idx][TT_y1]  := y0 + ( ( 1 << log2TrafoSize ) >> 1 );
			ttStack[ttStack_idx][TT_idx] := 3;
		else
			cbf_luma[ x0 ][ y0 ][ trafoDepth ] := 1;
			if predMode = MODE_INTRA or trafoDepth != 0 or
				cbf_cb[ x0 ][ y0 ][ trafoDepth ] = 1 or cbf_cr[ x0 ][ y0 ][ trafoDepth ] = 1 then
				get_CBF_LUMA(codIRange, codIOffset, ctxTable, fifo, res, trafoDepth);
				cbf_luma[ x0 ][ y0 ][ trafoDepth ] := res[0];
			end
			ttStack[ttStack_idx][TT_idx] := 2;
		end
		lastSplitTransf := split_transform_flag[ x0 ][ y0 ][ trafoDepth ] != 0;
		cbfLumaVal := cbf_luma[ x0 ][ y0 ][ trafoDepth ] != 0;
	end

	send_Cbf.skip: action ==>
	guard
		lastSplitTransf
	end
	
	send_Cbf.launch: action ==> Cbf:[cbfLumaVal]
	guard
		not lastSplitTransf
	end
	/**************************************************************************
	 * read_TransformTree_gotoTransformUnit
	 *************************************************************************/
	read_TransformTree_gotoTransformUnit : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 2
	do
		ttStack[ttStack_idx][TT_idx]	:= 7;
		tu_idx							:= 1;
		tu_x0							:= ttStack[ttStack_idx][TT_x0];
		tu_y0							:= ttStack[ttStack_idx][TT_y0];
		tu_xBase						:= ttStack[ttStack_idx][TT_xBase];
		tu_yBase						:= ttStack[ttStack_idx][TT_yBase];
		tu_log2TrafoSize				:= ttStack[ttStack_idx][TT_log2TrafoSize];
		tu_trafoDepth					:= ttStack[ttStack_idx][TT_trafoDepth];
		tu_blkIdx						:= ttStack[ttStack_idx][TT_blkIdx];
	end
	/**************************************************************************
	 * read_TransformTree.gotoTransformTree
	 *************************************************************************/
	read_TransformTree.gotoTransformTree : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 3 or ttStack[ttStack_idx][TT_idx] = 4 or
		ttStack[ttStack_idx][TT_idx] = 5 or ttStack[ttStack_idx][TT_idx] = 6
	var
		uint(size= 8) idx = ttStack_idx
	do
		ttStack[ttStack_idx][TT_idx]				:= ttStack[ttStack_idx][TT_idx] + 1;
		ttStack_idx 								:= ttStack_idx + 1;
		ttStack[ttStack_idx][TT_idx]				:= 1;
		ttStack[ttStack_idx][TT_x0]					:= ttStack[idx][TT_x0];
		ttStack[ttStack_idx][TT_y0]					:= ttStack[idx][TT_y0];
		ttStack[ttStack_idx][TT_xBase]				:= ttStack[idx][TT_x0];
		ttStack[ttStack_idx][TT_yBase]				:= ttStack[idx][TT_y0];
		ttStack[ttStack_idx][TT_log2TrafoSize]		:= ttStack[idx][TT_log2TrafoSize] - 1;
		ttStack[ttStack_idx][TT_trafoDepth]			:= ttStack[idx][TT_trafoDepth] + 1;
		if ttStack[idx][TT_idx] = 4 then
			ttStack[ttStack_idx][TT_blkIdx]			:= 0;
		elsif ttStack[idx][TT_idx] = 5 then
			ttStack[ttStack_idx][TT_x0]		    	:= ttStack[idx][TT_x1];
			ttStack[ttStack_idx][TT_blkIdx]			:= 1;
		elsif ttStack[idx][TT_idx] = 6 then
			ttStack[ttStack_idx][TT_y0]				:= ttStack[idx][TT_y1];
			ttStack[ttStack_idx][TT_blkIdx]			:= 2;
		else
			ttStack[ttStack_idx][TT_x0]				:= ttStack[idx][TT_x1];
			ttStack[ttStack_idx][TT_y0]				:= ttStack[idx][TT_y1];
			ttStack[ttStack_idx][TT_blkIdx]			:= 3;
		end
	end
	/**************************************************************************
	 * read_TransformTree_end
	 *************************************************************************/
	read_TransformTree_end : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 7 and ttStack_idx = 0 
	end
	read_TransformTree.endCall : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 7 and ttStack_idx != 0 
	do
		ttStack_idx := ttStack_idx - 1;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Transform Unit                       *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) tu_idx;
	uint(size=16) tu_x0;
	uint(size=16) tu_y0;
	uint(size=16) tu_xBase;
	uint(size=16) tu_yBase;
	uint(size= 8) tu_trafoDepth;
	uint(size= 8) tu_blkIdx;
	uint(size= 8) tu_log2TrafoSize;
	
	/**************************************************************************
	 * read_TransformUnit.start
	 *************************************************************************/
	read_TransformUnit.start : action ==>
	guard 
		isFifoFull(fifo),
		tu_idx = 1
	do
		if DEBUG_CABAC and DEBUG_TRACE1 then
			println("read_TransformUnit.start("+tu_x0+", "+tu_y0+", "+tu_xBase+", "+tu_yBase+", "+
					tu_log2TrafoSize+", "+tu_log2TrafoSize+", "+tu_trafoDepth+", "+tu_blkIdx+")");
		elsif DEBUG_CABAC then
			println("read_TransformUnit.start");
		end
		if  cbf_luma[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 or
			cbf_cb[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 or
			cbf_cr[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 then
			if pps_diff_cu_qp_delta_depth[pps_id] > 0  and IsCuQpDeltaCoded = 0 then
				//cu_qp_delta
				IsCuQpDeltaCoded := 1;
			end
		end
		tu_idx				:= 8; // skipResidualCoding
		rc_idx 				:= 1;
		rc_x0 				:= tu_x0;
		rc_y0 				:= tu_y0;
		rc_log2TrafoSize	:= tu_log2TrafoSize;
		rc_scanIdx			:= getScanIdx(predMode, tu_log2TrafoSize, cur_intra_pred_mode);
		rc_cIdx				:= 0;
		rc_TType			:= TEXT_LUMA;
		if cbf_luma[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 then
			tu_idx 			:= 2;
		end
	end
	/**************************************************************************
	 * read_TransformUnit.retLuma
	 *************************************************************************/
	read_TransformUnit.retLuma : action ==>
	guard 
		tu_idx = 3
	do
		tu_idx 				:= 5;
		rc_idx 				:= 1;
		rc_log2TrafoSize	:= tu_log2TrafoSize;
		rc_scanIdx			:= getScanIdx(predMode, rc_log2TrafoSize, intra_pred_mode_c);
		rc_cIdx				:= 1;
		rc_TType			:= TEXT_CHROMA_U;						
		if tu_log2TrafoSize > 2 then
			tu_idx 				:= 10;  // skipResidualCoding
			rc_x0 				:= tu_x0;
			rc_y0 				:= tu_y0;
			rc_log2TrafoSize	:= tu_log2TrafoSize - 1;
			if cbf_cb[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 then
				tu_idx			:= 4;
			end				
		elsif tu_blkIdx = 3 then
			tu_idx 			:= 10;  // skipResidualCoding
			rc_x0    		:= tu_xBase;
			rc_y0 	 		:= tu_yBase;
			if cbf_cb[ tu_xBase ][ tu_yBase ][ tu_trafoDepth ] = 1 then
				tu_idx		:= 4;
			end
		end
	end
	/**************************************************************************
	 * read_TransformUnit.retCb
	 *************************************************************************/
	read_TransformUnit.retCb : action ==>
	guard 
		tu_idx = 5
	do	
		tu_idx	 := 7;
		rc_idx 	 := 1;
		rc_cIdx	 := 2;
		rc_TType := TEXT_CHROMA_V;						
		if tu_log2TrafoSize > 2 then
			tu_idx	 			:= 12;  // skipResidualCoding
			rc_log2TrafoSize	:= tu_log2TrafoSize - 1;
			if cbf_cr[ tu_x0 ][ tu_y0 ][ tu_trafoDepth ] = 1 then
				tu_idx 			:= 6;
			end
		elsif tu_blkIdx = 3 then
			tu_idx	 := 12;  // skipResidualCoding
			if cbf_cr[ tu_xBase ][ tu_yBase ][ tu_trafoDepth ] = 1 then
				tu_idx				:= 6;
			end
		end
	end
	/**************************************************************************
	 * read_TransformUnit_gotoResidualCoding
	 *************************************************************************/
	read_TransformUnit_gotoResidualCoding : action ==>
	guard 
		tu_idx = 2 or tu_idx = 4 or tu_idx = 6
	do	
		tu_idx := tu_idx + 1;
	end
	/**************************************************************************
	 * read_TransformUnit.skipResidualCoding
	 *************************************************************************/
	read_TransformUnit.skipResidualCoding : action ==> TUSize:[1<<rc_log2TrafoSize, 1, 0, 0]
	guard 
		tu_idx = 8 or tu_idx = 10 or tu_idx = 12
	do	
		tu_idx := tu_idx - 5;
/*  		if (DEBUG_COEFF) then
			println("Splitter ACTION: split_"+(1<<rc_log2TrafoSize)+"x"+(1<<rc_log2TrafoSize)+" : "+(if rc_TType = TEXT_LUMA then "Y" elsif rc_TType = TEXT_CHROMA_U then "U" else "V" end));		
			println("--------------------------");		
			println("sizeOfTU = " + (1<<rc_log2TrafoSize));
			foreach int i in 0 .. (1<<rc_log2TrafoSize) * (1<<rc_log2TrafoSize) - 1 do
				println("coeff["+i+"]     = 0");
			end		  
			println("--------------------------");			  
        end
*/	end
	/**************************************************************************
	 * read_TransformUnit_end
	 *************************************************************************/
	read_TransformUnit_end : action ==>
	guard 
		tu_idx = 7
	do
		if DEBUG_CABAC then
			println("read_TransformUnit_end");
		end
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Residual Coding                      *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) rc_idx;
	uint(size=16) rc_x0;
	uint(size=16) rc_y0;
	uint(size= 8) rc_log2TrafoSize;
	uint(size= 8) rc_scanIdx;
	uint(size= 8) rc_cIdx;
	uint(size= 4) rc_TType;
	//
	uint(size= 8) ScanOrder[3][BLW_WIDTH_MAX*BLW_HEIGHT_MAX][2];
	uint(size= 8) ScanOrder2[3][BLW_WIDTH_MAX*BLW_HEIGHT_MAX][2];
	uint(size= 1) significant_coeff_flag[16];
	uint(size= 1) coded_sub_block_flag[8][8];
	uint(size= 8) LastSignificantCoeffX;
	uint(size= 8) LastSignificantCoeffY;
		
	/**************************************************************************
	 * read_ResidualCoding.start
	 *************************************************************************/
	uint(size= 8) rc_lastScanPos;
	 int(size= 8) rc_lastSubBlock;
	 int(size= 8) rc_i;
	 int(size= 16) tabTransCoeffLevel[32*32];
//	uint(size= 1) transform_skip_flag;
	read_ResidualCoding.start : action ==> TUSize:[sz, 0, isDST, transform_skip_flag]
	guard 
		rc_idx = 1 and isFifoFull(fifo)
	var
		 int(size=32) res[1],
		uint(size=16) xS := 0,
		uint(size=16) yS := 0,
		 int(size=16) xC := -1,
		 int(size=16) yC := -1,
		 int sz = 1 << rc_log2TrafoSize,
		 uint(size=1) transform_skip_flag,
		 uint(size=1) isDST = if (predMode = MODE_INTRA and rc_TType = 0 and sz = 4) then 1 else 0 end
	do	
		if DEBUG_CABAC and DEBUG_TRACE1 then
			println("read_ResidualCoding.start "+if rc_TType = TEXT_LUMA then "cbY" elsif rc_TType = TEXT_CHROMA_U then "cbU" else "cbV" end+"("+rc_x0+", "+rc_y0+", "+rc_log2TrafoSize+", "+rc_scanIdx+", "+rc_cIdx+")");
		elsif DEBUG_CABAC then
			println("read_ResidualCoding.start "+if rc_TType = TEXT_LUMA then "cbY" elsif rc_TType = TEXT_CHROMA_U then "cbU" else "cbV" end);
		end
		foreach int i in 0 .. sz * sz - 1 do
			tabTransCoeffLevel[i] := 0;
		end 
		coded_sub_block_flag := [[0	: for int j in 0 .. 7]	: for int i in 0 .. 7];
		if pps_transform_skip_enabled_flag[pps_id] = 1 and cu_transquant_bypass_flag = 0 and
			rc_log2TrafoSize = 2 then
			get_TRANSFORM_SKIP_FLAG(codIRange, codIOffset, ctxTable, fifo, res, rc_TType);
			transform_skip_flag := res[0];
		else
			transform_skip_flag := 0;
		end

		get_LAST_SIGNIFICANT_COEFF_X_PREFIX(codIRange, codIOffset, ctxTable, fifo, res, rc_log2TrafoSize, rc_cIdx);
		LastSignificantCoeffX := res[0];
		get_LAST_SIGNIFICANT_COEFF_Y_PREFIX(codIRange, codIOffset, ctxTable, fifo, res, rc_log2TrafoSize, rc_cIdx);
		LastSignificantCoeffY := res[0];
		if LastSignificantCoeffX > 3 then
			get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(codIRange, codIOffset, fifo, res, LastSignificantCoeffX);
			LastSignificantCoeffX := (1 << ((LastSignificantCoeffX >> 1) - 1)) *
									 (2  +  (LastSignificantCoeffX & 1 )) + res[0];			
		end
		if LastSignificantCoeffY > 3 then 
			get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(codIRange, codIOffset, fifo, res, LastSignificantCoeffY);
			LastSignificantCoeffY := (1 << ((LastSignificantCoeffY >> 1) - 1)) *
									 (2  +  (LastSignificantCoeffY & 1 )) + res[0];
		end
		
		InitScanningArray(rc_log2TrafoSize-2, ScanOrder);
		InitScanningArray(2, ScanOrder2);
		
		if rc_scanIdx = SCAN_VER then
			res[0] := LastSignificantCoeffX;
			LastSignificantCoeffX := LastSignificantCoeffY;
			LastSignificantCoeffY := res[0];
		end
		
		rc_lastScanPos  := 16;
		rc_lastSubBlock := ( 1 << ( rc_log2TrafoSize - 2 ) ) * ( 1 << ( rc_log2TrafoSize - 2 ) ) - 1;
		while  not( xC = LastSignificantCoeffX and yC = LastSignificantCoeffY) do
			if rc_lastScanPos = 0 then
				rc_lastScanPos  := 16;
				rc_lastSubBlock := rc_lastSubBlock - 1;
			end
			rc_lastScanPos := rc_lastScanPos - 1;
			xS := ScanOrder[ rc_scanIdx ][ rc_lastSubBlock ][ 0 ]; 
			yS := ScanOrder[ rc_scanIdx ][ rc_lastSubBlock ][ 1 ]; 
			xC := ( xS << 2 ) + ScanOrder2[ rc_scanIdx ][ rc_lastScanPos ][ 0 ];
			yC := ( yS << 2 ) + ScanOrder2[ rc_scanIdx ][ rc_lastScanPos ][ 1 ];
//			println(xC+", "+LastSignificantCoeffX+" : "+yC+", "+LastSignificantCoeffY+", rc_lastSubBlock = "+rc_lastSubBlock+", rc_lastScanPos = "+rc_lastScanPos);
		end
//		println("LastSignificantCoeffX = "+LastSignificantCoeffX+", LastSignificantCoeffY = "+LastSignificantCoeffY+", rc_lastSubBlock = "+(rc_lastSubBlock)+" rc_scanIdx = "+rc_scanIdx);
		rc_i			 := rc_lastSubBlock;
		rc_idx           := 2;
 	end
	/**************************************************************************
	 * read_ResidualCoding.for_numLastSubset.start
	 *************************************************************************/
	uint(size=16) rc_xS;
	uint(size=16) rc_yS;
	 int(size= 8) m_end;
	read_ResidualCoding.for_numLastSubset.start : action ==>
	guard 
		rc_idx = 2 and isFifoFull(fifo),
		rc_i >= 0
	var
		 int(size=32) res[1],
		uint(size= 8) n,
		uint(size=16) xC,
		uint(size=16) yC,
		uint(size= 1) inferSigCoeffFlag
	do	   
		rc_xS := ScanOrder[ rc_scanIdx ][ rc_i ][ 0 ];
   		rc_yS := ScanOrder[ rc_scanIdx ][ rc_i ][ 1 ]; 
	    inferSigCoeffFlag := 0; 
        if rc_i < rc_lastSubBlock and rc_i > 0 then 
	        get_CODED_SUB_BLOCK_FLAG( codIRange, codIOffset, ctxTable, fifo, res, coded_sub_block_flag, rc_xS, rc_yS, rc_cIdx, rc_log2TrafoSize);
	        coded_sub_block_flag[ rc_xS ][ rc_yS ] := res[0];
           	inferSigCoeffFlag := 1;
        else
        	if (rc_xS = LastSignificantCoeffX>>2 and rc_yS = LastSignificantCoeffY>>2) or (rc_xS = 0 and rc_yS = 0) then
        		coded_sub_block_flag[ rc_xS ][ rc_yS ] := 1;
        	end
        end
 
		significant_coeff_flag := [0	: for int j in 0 .. 15];        
        m_end := if rc_i = rc_lastSubBlock then rc_lastScanPos - 1 else 15 end;
        significant_coeff_flag[ rc_lastScanPos ] := 1;
        foreach int m in 0 .. m_end do
  			n  := m_end - m;  
			xC := ( rc_xS << 2 ) + ScanOrder2[ rc_scanIdx ][ n ][ 0 ]; 
			yC := ( rc_yS << 2 ) + ScanOrder2[ rc_scanIdx ][ n ][ 1 ];			
			if coded_sub_block_flag[ rc_xS ][ rc_yS ] = 1 and ( n > 0 or inferSigCoeffFlag = 0 ) then
				get_SIGNIFICANT_COEFF_FLAG( codIRange, codIOffset, ctxTable, fifo, res, coded_sub_block_flag, xC, yC, rc_cIdx, rc_log2TrafoSize, rc_scanIdx);
                significant_coeff_flag[ n ] := res[0];
				if significant_coeff_flag[ n ] = 1 then 
                   	inferSigCoeffFlag := 0;
               	end
            else
            	significant_coeff_flag[ n ] := 0;
            	if (xC = LastSignificantCoeffX and yC = LastSignificantCoeffY) or
            	   (( (xC&3) = 0 and (yC&3) = 0) and inferSigCoeffFlag = 1 and coded_sub_block_flag[ rc_xS ][ rc_yS ] = 1 ) then
					significant_coeff_flag[ n ] := 1;
            	end
			end
		end
		m_end := if rc_i = rc_lastSubBlock then rc_lastScanPos else 15 end;
		rc_idx := 3;
	end
	/**************************************************************************
	 * read_ResidualCoding_end
	 *************************************************************************/
	read_ResidualCoding_end.xIT4 : action ==>
						Coeff:[[tabTransCoeffLevel[i]: for int i in 0 .. 4 * 4 - 1]] repeat 4 * 4
	guard 
		rc_idx = 2,
		rc_i < 0,
		rc_log2TrafoSize = 2
	var
		uint(size=16) qp_bd_offset_luma = 6 * sps_bit_depth_luma_minus8[sps_id],
		uint(size=16) qp_bd_offset_chroma = 6 * sps_bit_depth_chroma_minus8[sps_id],
		 int qp_y_pred = slice_qp,
         int qp_y      = ((qp_y_pred + /*s->tu.cu_qp_delta +*/ 52 + 2 * qp_bd_offset_luma) mod (52 + qp_bd_offset_luma)) - qp_bd_offset_luma,
        uint(size= 8) qp_c[15] = [ 29, 30, 31, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37],
		 int(size=16) qp,
		 int(size=16) qp_i,
		 int(size=16) offset,
		uint(size= 8) levelScale[6] = [ 40, 45, 51, 57, 64, 72 ],
		uint(size= 8) shift = if rc_cIdx = 0 then sps_bit_depth_luma_minus8[sps_id] + 8 + rc_log2TrafoSize - 5 else sps_bit_depth_chroma_minus8[sps_id] + 8 + rc_log2TrafoSize - 5 end
	do
        if rc_cIdx = 0 then
            qp := qp_y + qp_bd_offset_luma;
        else
            if rc_cIdx = 1 then
                offset := pps_cb_qp_offset[pps_id] + slice_cb_qp_offset;
            else
                offset := pps_cr_qp_offset[pps_id] + slice_cr_qp_offset;
            end
            qp_i := clip_i32(qp_y + offset, - qp_bd_offset_luma, 57);
            if qp_i < 30 then
                qp := qp_i;
            elsif qp_i > 43 then
                qp := qp_i - 6;
            else
                qp := qp_c[qp_i - 30];
            end
	
	        qp := qp + qp_bd_offset_chroma;
	    end
	
		foreach int i in 0 .. (1<<rc_log2TrafoSize) * (1<<rc_log2TrafoSize) - 1 do
			tabTransCoeffLevel[i] := clip_i32(( ( tabTransCoeffLevel[i] * 16 * levelScale[ qp mod 6 ] << (qp/6)) + (1 << (shift - 1 )) ) >> shift, -32768, 32767 );
		end
		if DEBUG_CABAC then
			println("read_ResidualCoding_end");
		end
		if (DEBUG_COEFF) then
			println("Splitter ACTION: split_"+(1<<rc_log2TrafoSize)+"x"+(1<<rc_log2TrafoSize)+" : "+(if rc_TType = TEXT_LUMA then "Y" elsif rc_TType = TEXT_CHROMA_U then "U" else "V" end));		
			println("--------------------------");		
			println("sizeOfTU = " + (1<<rc_log2TrafoSize));
			foreach int i in 0 .. (1<<rc_log2TrafoSize) * (1<<rc_log2TrafoSize) - 1 do
				println("coeff["+i+"]     = "+tabTransCoeffLevel[i]);
			end		  
			println("--------------------------");			  
        end
	end

	read_ResidualCoding_end.xIT8 : action ==> 
						Coeff:[[tabTransCoeffLevel[i]: for int i in 0 .. 8 * 8 - 1]] repeat 8 * 8
	guard 
		rc_idx = 2,
		rc_i < 0,
		rc_log2TrafoSize = 3
	var
		uint(size=16) qp_bd_offset_luma = 6 * sps_bit_depth_luma_minus8[sps_id],
		uint(size=16) qp_bd_offset_chroma = 6 * sps_bit_depth_chroma_minus8[sps_id],
		 int qp_y_pred = slice_qp,
         int qp_y      = ((qp_y_pred + /*s->tu.cu_qp_delta +*/ 52 + 2 * qp_bd_offset_luma) mod (52 + qp_bd_offset_luma)) - qp_bd_offset_luma,
        uint(size= 8) qp_c[15] = [ 29, 30, 31, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37],
		 int(size=16) qp,
		 int(size=16) qp_i,
		 int(size=16) offset,
		uint(size= 8) levelScale[6] = [ 40, 45, 51, 57, 64, 72 ],
		uint(size= 8) shift = if rc_cIdx = 0 then sps_bit_depth_luma_minus8[sps_id] + 8 + rc_log2TrafoSize - 5 else sps_bit_depth_chroma_minus8[sps_id] + 8 + rc_log2TrafoSize - 5 end
	do
        if rc_cIdx = 0 then
            qp := qp_y + qp_bd_offset_luma;
        else
            if rc_cIdx = 1 then
                offset := pps_cb_qp_offset[pps_id] + slice_cb_qp_offset;
            else
                offset := pps_cr_qp_offset[pps_id] + slice_cr_qp_offset;
            end
            qp_i := clip_i32(qp_y + offset, - qp_bd_offset_luma, 57);
            if qp_i < 30 then
                qp := qp_i;
            elsif qp_i > 43 then
                qp := qp_i - 6;
            else
                qp := qp_c[qp_i - 30];
            end
	
	        qp := qp + qp_bd_offset_chroma;
	    end
	
		foreach int i in 0 .. (1<<rc_log2TrafoSize) * (1<<rc_log2TrafoSize) - 1 do
			tabTransCoeffLevel[i] := clip_i32(( ( tabTransCoeffLevel[i] * 16 * levelScale[ qp mod 6 ] << (qp/6)) + (1 << (shift - 1 )) ) >> shift, -32768, 32767 );
		end
		if DEBUG_CABAC then
			println("read_ResidualCoding_end");
		end
		if (DEBUG_COEFF) then
			println("Splitter ACTION: split_"+(1<<rc_log2TrafoSize)+"x"+(1<<rc_log2TrafoSize)+" : "+(if rc_TType = TEXT_LUMA then "Y" elsif rc_TType = TEXT_CHROMA_U then "U" else "V" end));		
			println("--------------------------");		
			println("sizeOfTU = " + (1<<rc_log2TrafoSize));
			foreach int i in 0 .. (1<<rc_log2TrafoSize) * (1<<rc_log2TrafoSize) - 1 do
				println("coeff["+i+"]     = "+tabTransCoeffLevel[i]);
			end		  
			println("--------------------------");			  
        end
	end

	read_ResidualCoding_end.xIT16 : action ==> 
						Coeff:[[tabTransCoeffLevel[i]: for int i in 0 .. 16 * 16 - 1]] repeat 16 * 16
	guard 
		rc_idx = 2,
		rc_i < 0,
		rc_log2TrafoSize = 4
	var
		uint(size=16) qp_bd_offset_luma = 6 * sps_bit_depth_luma_minus8[sps_id],
		uint(size=16) qp_bd_offset_chroma = 6 * sps_bit_depth_chroma_minus8[sps_id],
		 int qp_y_pred = slice_qp,
         int qp_y      = ((qp_y_pred + /*s->tu.cu_qp_delta +*/ 52 + 2 * qp_bd_offset_luma) mod (52 + qp_bd_offset_luma)) - qp_bd_offset_luma,
        uint(size= 8) qp_c[15] = [ 29, 30, 31, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37],
		 int(size=16) qp,
		 int(size=16) qp_i,
		 int(size=16) offset,
		uint(size= 8) levelScale[6] = [ 40, 45, 51, 57, 64, 72 ],
		uint(size= 8) shift = if rc_cIdx = 0 then sps_bit_depth_luma_minus8[sps_id] + 8 + rc_log2TrafoSize - 5 else sps_bit_depth_chroma_minus8[sps_id] + 8 + rc_log2TrafoSize - 5 end
	do
        if rc_cIdx = 0 then
            qp := qp_y + qp_bd_offset_luma;
        else
            if rc_cIdx = 1 then
                offset := pps_cb_qp_offset[pps_id] + slice_cb_qp_offset;
            else
                offset := pps_cr_qp_offset[pps_id] + slice_cr_qp_offset;
            end
            qp_i := clip_i32(qp_y + offset, - qp_bd_offset_luma, 57);
            if qp_i < 30 then
                qp := qp_i;
            elsif qp_i > 43 then
                qp := qp_i - 6;
            else
                qp := qp_c[qp_i - 30];
            end
	
	        qp := qp + qp_bd_offset_chroma;
	    end
	
		foreach int i in 0 .. (1<<rc_log2TrafoSize) * (1<<rc_log2TrafoSize) - 1 do
			tabTransCoeffLevel[i] := clip_i32(( ( tabTransCoeffLevel[i] * 16 * levelScale[ qp mod 6 ] << (qp/6)) + (1 << (shift - 1 )) ) >> shift, -32768, 32767 );
		end
		if DEBUG_CABAC then
			println("read_ResidualCoding_end");
		end
		if (DEBUG_COEFF) then
			println("Splitter ACTION: split_"+(1<<rc_log2TrafoSize)+"x"+(1<<rc_log2TrafoSize)+" : "+(if rc_TType = TEXT_LUMA then "Y" elsif rc_TType = TEXT_CHROMA_U then "U" else "V" end));		
			println("--------------------------");		
			println("sizeOfTU = " + (1<<rc_log2TrafoSize));
			foreach int i in 0 .. (1<<rc_log2TrafoSize) * (1<<rc_log2TrafoSize) - 1 do
				println("coeff["+i+"]     = "+tabTransCoeffLevel[i]);
			end		  
			println("--------------------------");			  
        end
	end

	read_ResidualCoding_end.xIT32 : action ==> 
						Coeff:[[tabTransCoeffLevel[i]: for int i in 0 .. 32 * 32 - 1]] repeat 32 * 32
	guard 
		rc_idx = 2,
		rc_i < 0,
		rc_log2TrafoSize = 5
	var
		uint(size=16) qp_bd_offset_luma = 6 * sps_bit_depth_luma_minus8[sps_id],
		uint(size=16) qp_bd_offset_chroma = 6 * sps_bit_depth_chroma_minus8[sps_id],
		 int qp_y_pred = slice_qp,
         int qp_y      = ((qp_y_pred + /*s->tu.cu_qp_delta +*/ 52 + 2 * qp_bd_offset_luma) mod (52 + qp_bd_offset_luma)) - qp_bd_offset_luma,
        uint(size= 8) qp_c[15] = [ 29, 30, 31, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37],
		 int(size=16) qp,
		 int(size=16) qp_i,
		 int(size=16) offset,
		uint(size= 8) levelScale[6] = [ 40, 45, 51, 57, 64, 72 ],
		uint(size= 8) shift = if rc_cIdx = 0 then sps_bit_depth_luma_minus8[sps_id] + 8 + rc_log2TrafoSize - 5 else sps_bit_depth_chroma_minus8[sps_id] + 8 + rc_log2TrafoSize - 5 end
	do
        if rc_cIdx = 0 then
            qp := qp_y + qp_bd_offset_luma;
        else
            if rc_cIdx = 1 then
                offset := pps_cb_qp_offset[pps_id] + slice_cb_qp_offset;
            else
                offset := pps_cr_qp_offset[pps_id] + slice_cr_qp_offset;
            end
            qp_i := clip_i32(qp_y + offset, - qp_bd_offset_luma, 57);
            if qp_i < 30 then
                qp := qp_i;
            elsif qp_i > 43 then
                qp := qp_i - 6;
            else
                qp := qp_c[qp_i - 30];
            end
	
	        qp := qp + qp_bd_offset_chroma;
	    end
	
		foreach int i in 0 .. (1<<rc_log2TrafoSize) * (1<<rc_log2TrafoSize) - 1 do
			tabTransCoeffLevel[i] := clip_i32(( ( tabTransCoeffLevel[i] * 16 * levelScale[ qp mod 6 ] << (qp/6)) + (1 << (shift - 1 )) ) >> shift, -32768, 32767 );
		end
		if DEBUG_CABAC then
			println("read_ResidualCoding_end");
		end
		if (DEBUG_COEFF) then
			println("Splitter ACTION: split_"+(1<<rc_log2TrafoSize)+"x"+(1<<rc_log2TrafoSize)+" : "+(if rc_TType = TEXT_LUMA then "Y" elsif rc_TType = TEXT_CHROMA_U then "U" else "V" end));		
			println("--------------------------");		
			println("sizeOfTU = " + (1<<rc_log2TrafoSize));
			foreach int i in 0 .. (1<<rc_log2TrafoSize) * (1<<rc_log2TrafoSize) - 1 do
				println("coeff["+i+"]     = "+tabTransCoeffLevel[i]);
			end		  
			println("--------------------------");			  
        end
	end
	/**************************************************************************
	 * read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_GREATER1_FLAG
	 *************************************************************************/
	uint(size= 8) rc_ctxSet[1];
	uint(size= 8) rc_greater1Ctx[1];
	uint(size= 8) rc_firstSigScanPos;
	 int(size= 8) rc_firstGreater1ScanPos;
	uint(size= 8) rc_m;
	uint(size= 8) coeff_abs_level_greater1_flag[16];
	uint(size= 8) coeff_abs_level_greater2_flag[16];
	uint(size= 1) coeff_sign_flag[16];
	uint(size= 1) rc_signHidden;
	read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_GREATER1_FLAG : action ==>
	guard 
		rc_idx = 3 and isFifoFull(fifo)
	var
		 int(size=32) res[1] := [0],
		 int          n,
		 int(size= 8) lastSigScanPos  := -1,
		uint(size= 8) numGreater1Flag :=  0,
		uint(size= 9) ctxIdxInc[1]
	do	
		rc_firstSigScanPos		:= 16;
		rc_firstGreater1ScanPos	:= -1;
		coeff_abs_level_greater1_flag := [ 0 : for int i in 0 .. 15 ];
		coeff_abs_level_greater2_flag := [ 0 : for int i in 0 .. 15 ];

		foreach int m in 0 .. m_end do
  			n  := m_end - m;  
			if significant_coeff_flag[ n ] = 1 then
				if numGreater1Flag < 8 then
					context_93315(rc_cIdx, rc_i, numGreater1Flag = 0, rc_i = rc_lastSubBlock, rc_ctxSet, rc_greater1Ctx, ctxIdxInc);
					get_COEFF_ABS_LEVEL_GREATER1_FLAG( codIRange, codIOffset, ctxTable, fifo, res, ctxIdxInc[0]);
					if res[0] = 1 then
	    				rc_greater1Ctx[0] := 0;
    				elsif rc_greater1Ctx[0] > 0 and rc_greater1Ctx[0] < 3 then
	        			rc_greater1Ctx[0] := rc_greater1Ctx[0] + 1;
    				end
    				coeff_abs_level_greater1_flag[ n ] := res[0];
					numGreater1Flag := numGreater1Flag + 1; 
					if (coeff_abs_level_greater1_flag[ n ] = 1 and rc_firstGreater1ScanPos = -1) then
						rc_firstGreater1ScanPos := n;
					end	
				end
				if lastSigScanPos = -1 then
					lastSigScanPos := n;
				end
				rc_firstSigScanPos := n;
			end
		end
				
		rc_signHidden := if lastSigScanPos - rc_firstSigScanPos > 3 and cu_transquant_bypass_flag = 0 then 1 else 0 end;
		if rc_firstGreater1ScanPos != -1 then 
			get_COEFF_ABS_LEVEL_GREATER2_FLAG(codIRange, codIOffset, ctxTable, fifo, res, rc_cIdx, rc_ctxSet[0]);
			coeff_abs_level_greater2_flag[ rc_firstGreater1ScanPos] := res[0];
		end
		
		foreach int m in 0 .. m_end do
  			n  := m_end - m;  
			if significant_coeff_flag[ n ] = 1 and
				(pps_sign_data_hiding_flag[pps_id] = 0 or rc_signHidden = 0 or n != rc_firstSigScanPos) then
				get_COEFF_SIGN_FLAG(codIRange, codIOffset, fifo, res);
				coeff_sign_flag[ n ] := res[0];
			else
				coeff_sign_flag[ n ] := 0;
			end
		end
		rc_numSigCoeff		:= 0;
		rc_sumAbsLevel		:= 0;
		rc_cLastRiceParam	:= 0;
		rc_m   := 0;
		rc_idx := 4;
	end
	/**************************************************************************
	 * read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL
	 *************************************************************************/
	uint(size= 8) rc_numSigCoeff;
	uint(size= 8) rc_sumAbsLevel;
	uint(size= 8) rc_cLastRiceParam;
	read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL : action ==>
	guard 
		rc_idx = 4 and isFifoFull(fifo),		
		rc_m <= 15//m_end
	var
		 int(size=32) res[1] := [0],
		 int          n       = 15/*m_end*/ - rc_m,
		uint(size=16) coeff_abs_level_remaining := 0,
		uint(size= 8) baseLevel,
		uint(size= 8) cLastAbsLevel,
		 int(size=16) transCoeffLevel := 0,
		 //
		uint(size=16) xC,
		uint(size=16) yC
		 
	do					
		if significant_coeff_flag[ n ] = 1 then 
			xC := ( rc_xS << 2 ) + ScanOrder2[ rc_scanIdx ][ n ][ 0 ]; 
			yC := ( rc_yS << 2 ) + ScanOrder2[ rc_scanIdx ][ n ][ 1 ];			
			baseLevel := 1 + coeff_abs_level_greater1_flag[ n ] + coeff_abs_level_greater2_flag[ n ];
			if baseLevel = ( if rc_numSigCoeff < 8 then if n = rc_firstGreater1ScanPos then 3 else 2 end else 1 end) then
				get_COEFF_ABS_LEVEL(codIRange, codIOffset, fifo, res, rc_cLastRiceParam);				
				coeff_abs_level_remaining := res[0];
				cLastAbsLevel  := baseLevel + coeff_abs_level_remaining;
				rc_cLastRiceParam := min(if cLastAbsLevel> 3 * ( 1 << rc_cLastRiceParam ) then rc_cLastRiceParam + 1 else rc_cLastRiceParam end, 4);			
			end
			transCoeffLevel := ( coeff_abs_level_remaining + baseLevel ) * ( 1 - (coeff_sign_flag[ n ] << 1) );
			if pps_sign_data_hiding_flag[pps_id] = 1 and rc_signHidden = 1 then
				rc_sumAbsLevel := rc_sumAbsLevel + coeff_abs_level_remaining + baseLevel;
				if n = rc_firstSigScanPos and ( rc_sumAbsLevel & 1 ) = 1 then
					transCoeffLevel := - transCoeffLevel;
				end
			end
			tabTransCoeffLevel[xC+(1<<rc_log2TrafoSize)*yC] := transCoeffLevel;
			rc_numSigCoeff := rc_numSigCoeff + 1;
		end

		rc_m := rc_m + 1;		
	end
	
	read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_end : action ==>
	guard 
		rc_idx = 4,
		rc_m > 15//m_end
	do
		rc_i	:= rc_i - 1;
		rc_idx  := 2;
	end
	
	
	/**************************************************************************
	 **************************************************************************
	 ********        undefined                            *********************
	 **************************************************************************
	 *************************************************************************/
  	
  	bool actorNotFinished := true;
	
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("Algo_Parser doesn't manage this case yet");
		actorNotFinished := false;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        schedule                             *********************
	 **************************************************************************
	 *************************************************************************/
  	schedule fsm start_code:
		// byte align
		byte_align          			( byte_align_a						) --> start_code;
		// search start code
		start_code          			( start_code.search					) --> start_code;
		start_code			            ( start_code.done					) --> read_Nal_unit_header;
		// read Nal Unit header
		read_Nal_unit_header			( read_nal_unit_header				) --> find_header;
		find_header	  					( look_for.VPS_header	  			) --> read_VPS_Header;
		find_header	  					( look_for.SEI_header	  			) --> read_SEI_Header;
		find_header	  					( look_for.SPS_header	  			) --> read_SPS_Header;
		find_header	  					( look_for.PPS_header	  			) --> read_PPS_Header;
		find_header	  					( look_for.Slice_header	  			) --> read_SliceHeader;
		// read VPS header
		read_VPS_Header	  				( read_VPS_Header	    			) --> read_VPS_Header;
		read_VPS_Header	  				( read_VPS_Header_done    			) --> byte_align;
		// read SEI header
		read_SEI_Header	  				( read_SEI_Header	    			) --> read_SEI_Header;
		read_SEI_Header	  				( read_SEI_Header_done    			) --> byte_align;
		// read SPS header
		read_SPS_Header	  				( read_SPS_Header	    			) --> read_SPS_Header;
		read_SPS_Header	  				( read_SPS_Header_done    			) --> byte_align;
		// read PPS header
		read_PPS_Header 				( read_PPS_Header   				) --> read_PPS_Header;
		read_PPS_Header	  				( read_PPS_Header_done    			) --> byte_align;
		// read_SliceHeader
		read_SliceHeader				( read_SliceHeader					) --> read_SliceHeader;
		read_SliceHeader				( read_SliceHeader_done				) --> read_SliceData;
		// read_SliceData
		read_SliceData				    ( read_SliceData	  				) --> read_SliceData;
		read_SliceData				    ( read_SliceData_gotoCodingTree		) --> read_CodingTree;
		read_SliceData				    ( read_SliceData_end	  			) --> byte_align;
		// read_CodingTree
		read_CodingTree				    ( read_CodingTree	  				) --> read_CodingTree;
		read_CodingTree				    ( read_CodingTree_gotoSaoParam		) --> read_SaoParam;
		read_CodingTree				    ( read_CodingTree_gotoCodingQuadTree) --> read_CodingQuadTree;
		read_CodingTree				    ( read_CodingTree_end	 			) --> read_SliceData;
		// read_SaoParam
		read_SaoParam					( read_SaoParam						) --> read_SaoParam;
		read_SaoParam					( read_SaoParam_endLoop				) --> read_CodingTree;
		// read_CodingQuadTree
		read_CodingQuadTree			    ( read_CodingQuadTree	  				) --> read_CodingQuadTree;
		read_CodingQuadTree			    ( read_CodingQuadTree_gotoCodingUnit	) --> read_CodingUnit;
		read_CodingQuadTree			    ( read_CodingQuadTree_gotoPCMSample		) --> read_PCMSample;
		read_CodingQuadTree				( read_CodingQuadTree_end	 			) --> read_CodingTree;
		// read_CodingUint
		read_CodingUnit				    ( read_CodingUnit                   ) --> read_CodingUnit;
		read_CodingUnit				    ( read_CodingUnit_noGoto1           ) --> send_IntraPredMode;
		read_CodingUnit				    ( read_CodingUnit_gotoPCMSample		) --> read_PCMSample2;
		read_CodingUnit				    ( read_CodingUnit_gotoPredictionUnit) --> read_PredictionUnit;
		read_CodingUnit				    ( read_CodingUnit_gotoTransformTree ) --> read_TransformTree;
		read_CodingUnit				    ( read_CodingUnit_end				) --> read_CodingQuadTree;

		send_IntraPredMode              (sendIntraPredMode                  )-->  send_CUInfo;
		send_CUInfo                     (sendCUInfo                         ) --> read_CodingUnit;
		// read_PredictionUnit
		read_PredictionUnit			    ( read_PredictionUnit	  			) --> read_PredictionUnit;
		read_PredictionUnit			    ( read_PredictionUnit_gotoMVDCoding ) --> read_MVDCoding;
		read_PredictionUnit			    ( read_PredictionUnit_end			) --> read_CodingUnit;
		// read_MVDCoding
		read_MVDCoding				    ( read_MVDCoding	  				) --> read_PredictionUnit;
		// read_PCMSample
		read_PCMSample				    ( read_PCMSample	  				) --> undefined;//read_CodingTree;
		read_PCMSample2				    ( read_PCMSample2	  				) --> undefined;//read_PredictionUnit;
		// read_TransformTree
		read_TransformTree			    ( read_TransformTree	  			) --> read_TransformTree;
		read_TransformTree              (read_TransformTree_start           ) --> send_Cbf;
		read_TransformTree			    ( read_TransformTree_gotoTransformUnit) --> read_TransformUnit;
		read_TransformTree			    ( read_TransformTree_end	  		) --> read_CodingUnit;

		send_Cbf                        (send_Cbf                           ) --> read_TransformTree;
		// read_TransformUnit
		read_TransformUnit			    ( read_TransformUnit	  			) --> read_TransformUnit;
		read_TransformUnit			    ( read_TransformUnit_gotoResidualCoding) --> read_ResidualCoding;
		read_TransformUnit			    ( read_TransformUnit_end			) --> read_TransformTree;
		// read_ResidualCoding
		read_ResidualCoding				( read_ResidualCoding				) --> read_ResidualCoding;
		read_ResidualCoding				( read_ResidualCoding_end			) --> read_TransformUnit;
		
		find_header                     ( look_for_other_header             ) --> byte_align;		
		
		// undefined
		undefined	  					( undefined		    				) --> undefined;
	end
	
	/**************************************************************************
	 * priority
	 *************************************************************************/
	priority
		look_for        > look_for_other_header;
	end
end