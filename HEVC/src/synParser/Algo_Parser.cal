package synParser;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  synParser.Algo_ParserUtils.*;

actor Algo_Parser () 
				uint(size= 8) byte
				==>
:
	bool DEBUG_BITSTREAM = false;
	uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL];
	uint(size= 2) zeroByte := 0;
	uint(size= 8) se_idx;
	uint(size=32) cnt_i;
	uint(size=10) sps_id;
	uint(size=10) pps_id;
	 int(size=32) slice[SLICE_STRUCT_SIZE];
	uint(size=32) wp[2][MAX_NUM_REF][3][WP_MAX_STRUCT];
	
	/**************************************************************************
	 * GLOBAL Sps_unit variables
 	 *************************************************************************/
	uint(size= 8) profile_idc;
	uint(size= 8) level_idc;
	uint(size= 1) pcm_enabled_flag;
	uint(size= 4) max_temporal_layers_minus1;
	uint(size= 8) log2_min_coding_block_size_minus3;
	uint(size= 8) num_short_term_ref_pic_sets;
	
	 
	/**************************************************************************
	 **************************************************************************
	 ********        Bitstream Reader                     *********************
	 **************************************************************************
	 *************************************************************************/
	
	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
 	action byte:[ b ] ==>
	guard 
		fifo[FIFO_CPT_BITS] <= (FIFO_SIZE-1)<<3
	var
		uint(size=4) fifo_idx  =  fifo[FIFO_IDX]
	do
		if b != EPR_VALUE or zeroByte != 3 then
			if b = START_CODE_VALUE and zeroByte = 3 then
				fifo[fifo_idx]      := b + START_CODE_FLAG;
			else
				fifo[fifo_idx]      := b;
			end
			fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] + 8;
			if DEBUG_BITSTREAM then
				println("fifo["+fifo_idx+"] := "+b+" \t "+fifo[FIFO_CPT_BITS]);
			end
			fifo[FIFO_IDX]      := (fifo_idx+1) & (FIFO_SIZE-1);
		end
		if b = 0 then
			zeroByte := ((zeroByte << 1) + 1) & 0x3;
		else
			zeroByte := 0;
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        NAL UNTI                             *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * byte_align_a
	 *************************************************************************/	
	byte_align_a : action ==>
	do
		byte_align(fifo);
	end 	
	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		not IsStartCode(fifo) and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
   	do
		flushBits( 8, fifo );
		if DEBUG_BITSTREAM then		
  			println("start_code.search");
   		end
	end
	start_code.done: action ==>
	guard
		IsStartCode(fifo) and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then
			println("start_code.done");
		end
	end
	/**************************************************************************
	 * read_nal_unit_header
	 *************************************************************************/	
	uint(size= 1) nal_ref_flag;
	uint(size= 6) nal_unit_type;
	uint(size= 3) temporal_id;
	uint(size= 2) tile_or_entropy_coding_sync_idc[NB_MAX_SPS];
	uint(size= 8) num_tile_columns_minus1;
	uint(size= 8) num_tile_rows_minus1;
	uint(size= 1) uniform_spacing_flag;
	uint(size= 8) maxCUWidth;
	uint(size= 8) addCUDepth;
	uint(size= 8) maxCUDepth;
	uint(size= 1) separate_colour_plane_flag[NB_MAX_SPS];
	uint(size= 8) log2_max_pic_order_cnt_lsb_minus4[NB_MAX_SPS];
	uint(size= 1) long_term_ref_pics_present_flag[NB_MAX_SPS];
	uint(size= 1) sample_adaptive_offset_enabled_flag[NB_MAX_SPS];
	uint(size= 1) scaling_list_enable_flag[NB_MAX_SPS];
	uint(size= 1) deblocking_filter_in_aps_enabled_flag[NB_MAX_SPS];
	uint(size= 1) adaptive_loop_filter_enabled_flag[NB_MAX_SPS];
	uint(size= 1) lists_modification_present_flag[NB_MAX_SPS];
	
	
	
	
	read_nal_unit_header : action ==>
	var
		uint(size=32) res[1]
	do
		if DEBUG_BITSTREAM then
			println("=========== NAL_UNIT ===========");
			flushBits_name( 1, fifo,   "reserved_zero_1bits                     ");
			vld_u_name(  1, fifo, res, "nal_ref_flag                            "); 
			nal_ref_flag  := res[0];
			vld_u_name(  6, fifo, res, "nal_unit_type                           "); 
			nal_unit_type := res[0];
		else
			flushBits( 1, fifo );
			vld_u(  1, fifo, res); nal_ref_flag  := res[0];
			vld_u(  6, fifo, res); nal_unit_type := res[0];
		end
		if DEBUG_BITSTREAM then
			vld_u_name(  3, fifo, res, "temporal_id                             "); 
			temporal_id		:= res[0];
			flushBits_name( 5, fifo,   "reserved_zero_5bits                     ");
		else
			vld_u(  3, fifo, res); 
			temporal_id := res[0];
			flushBits( 5, fifo  );
		end
		se_idx := 1;
	end
	/**************************************************************************
	 * look_for.SPS_header
	 *************************************************************************/
	look_for.SPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_SPS
	do
		if DEBUG_PARSER then
			println("=========== Sequence Parameter Set ID    ===========");
		end
	end
	/**************************************************************************
	 * look_for.PPS_header
	 *************************************************************************/
	look_for.PPS_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_PPS
	do
		if DEBUG_PARSER then
			println("=========== Picture Parameter Set ID    ===========");
		end
	end
	/**************************************************************************
	 * look_for.Slice_header
	 *************************************************************************/
	look_for.Slice_header: action ==>
	guard
		(nal_unit_type = NAL_UNIT_NON_IDR_AND_NON_CRA or
		 nal_unit_type = NAL_UNIT_CRA                 or
		 nal_unit_type = NAL_UNIT_IDR)
	var
		uint(size=32) res[1]
	do
		if DEBUG_PARSER then
			println("=========== Slice ===========");
		end
	end
	/**************************************************************************
	 * look_for.APS_header
	 *************************************************************************/
	look_for.APS_header: action ==>
	guard
		(nal_unit_type = NAL_UNIT_APS)
	do
		if DEBUG_PARSER then
			println("=========== APS ===========");
		end
	end
	/**************************************************************************
	 * look_for_other_header
	 *************************************************************************/
	look_for_other_header: action ==>
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Sequence Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * read_SPS_Header.se_idx_1
	 *************************************************************************/
	read_SPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size= 8) chroma_idc
	do
		vld_u_name(  8, fifo, res, "profile_idc                                "); 
		profile_idc := res[0];
		flushBits_name( 8, fifo,   "reserved_zero_8bits                        ");
		vld_u_name(  8, fifo, res, "level_idc                                  "); 
		level_idc := res[0];
		vld_ue_name(    fifo, res, "seq_parameter_set_id                       ");
		vld_ue_name(    fifo, res, "chroma_idc                                 ");
		chroma_idc := res[0];
		if (chroma_idc = 3) then
			vld_u_name(  1, fifo, res, "separate_colour_plane_flag                 ");
			separate_colour_plane_flag[sps_id]:=res[0];
		end
		vld_u_name(  3, fifo, res, "max_temporal_layers_minus1                 ");
		max_temporal_layers_minus1 := res[0];
		vld_ue_name(    fifo, res, "pic_width_in_luma_samples                  ");
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_2
	 *************************************************************************/
	read_SPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=1)  pic_cropping_flag
	do
		vld_ue_name(    fifo, res, "pic_height_in_luma_samples                 "); 
		vld_u_name(  1, fifo, res, "pic_cropping_flag                          "); pic_cropping_flag                               := res[0];
		if pic_cropping_flag=1 then
			vld_ue_name(    fifo, res, "pic_cropping_left_offset                   "); 
			vld_ue_name(    fifo, res, "pic_cropping_right_offset                  "); 
			vld_ue_name(    fifo, res, "pic_cropping_top_offset                    "); 
			vld_ue_name(    fifo, res, "pic_cropping_bottom_offset                 "); 
		end
		vld_ue_name(    fifo, res, "bit_depth_luma_minus8                      ");
		vld_ue_name(    fifo, res, "bit_depth_chroma_minus8                    ");
		vld_u_name(  1, fifo, res, "pcm_enabled_flag                           ");
		if pcm_enabled_flag = 1 then
			vld_u_name(  4, fifo, res, "pcm_bit_depth_luma_minus1                  ");
			vld_u_name(  4, fifo, res, "pcm_bit_depth_chroma_minus1                ");
		end
		vld_u_name(  1, fifo, res, "qpprime_y_zero_transquant_bypass_flag      ");
		vld_ue_name(    fifo, res, "log2_max_pic_order_cnt_lsb_minus4          ");
		log2_max_pic_order_cnt_lsb_minus4[sps_id]:=res[0];
		se_idx := se_idx + 1;
		cnt_i := 0;
	end

	/**************************************************************************
	 * read_SPS_Header.se_idx_3
	 *************************************************************************/
	read_SPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		cnt_i <= max_temporal_layers_minus1
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "max_dec_ref_buffering                      "); 
		vld_ue_name(    fifo, res, "num_reorder_pics                           "); 
		vld_ue_name(    fifo, res, "max_latency_increase                       "); 
		cnt_i := cnt_i + 1;
	end 

	read_SPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3 and cnt_i = max_temporal_layers_minus1 + 1
	do
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_4
	 *************************************************************************/
	read_SPS_Header.se_idx_4 : action ==>
	guard
		se_idx = 4 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size= 1) restricted_ref_pic_lists_flag,
		uint(size= 8) log2_diff_max_min_coding_block_size,
		uint(size= 8) log2_min_transform_block_size_minus2
	do
		vld_u_name(  1, fifo, res, "restricted_ref_pic_lists_flag              "); 
		restricted_ref_pic_lists_flag := res[0];
		if restricted_ref_pic_lists_flag = 1 then
			vld_u_name(  1, fifo, res, "lists_modification_present_flag            ");
			lists_modification_present_flag[sps_id] := res[0];
		else
			lists_modification_present_flag[sps_id] := 0;
		end
		vld_ue_name(    fifo, res, "log2_min_coding_block_size_minus3          ");
		log2_min_coding_block_size_minus3 := res[0];
		vld_ue_name(    fifo, res, "log2_diff_max_min_coding_block_size        ");
		log2_diff_max_min_coding_block_size := res[0];
		vld_ue_name(    fifo, res, "log2_min_transform_block_size_minus2       ");
		log2_min_transform_block_size_minus2 := res[0];
		vld_ue_name(    fifo, res, "log2_diff_max_min_transform_block_size     ");
		
		maxCUWidth := 1 << (log2_min_coding_block_size_minus3 + 3 + log2_diff_max_min_coding_block_size); 
    	addCUDepth := 0;
    	while ( ( maxCUWidth >> log2_diff_max_min_coding_block_size ) > 
    		( 1 << ( log2_min_transform_block_size_minus2 + 2 + log2_diff_max_min_coding_block_size )  )
    	)
    	do
        	addCUDepth := addCUDepth + 1;
    	end
    	maxCUDepth := log2_diff_max_min_coding_block_size + addCUDepth; 
		
		
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_5
	 *************************************************************************/	
	read_SPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		if log2_min_coding_block_size_minus3 = 0 then
			vld_u_name(  1, fifo, res, "inter_4x4_enabled_flag                     "); //TBC
		end
		if pcm_enabled_flag = 1 then
			vld_ue_name(    fifo, res, "log2_min_pcm_coding_block_size_minus3      ");
			vld_ue_name(    fifo, res, "log2_diff_max_min_pcm_coding_block_size    ");
		end
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_inter        ");
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_intra        ");
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_6
	 *************************************************************************/	
	read_SPS_Header.se_idx_6 : action ==>
	guard
		se_idx = 6 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do
		vld_u_name(  1, fifo, res, "scaling_list_enable_flag                   ");
		scaling_list_enable_flag[sps_id] := res[0];
		vld_u_name(  1, fifo, res, "chroma_pred_from_luma_enabled_flag         "); 
		vld_u_name(  1, fifo, res, "deblocking_filter_in_aps_enabled_flag      "); 
		deblocking_filter_in_aps_enabled_flag[sps_id] := res[0];
		vld_u_name(  1, fifo, res, "seq_loop_filter_across_slices_enabled_flag "); 
		vld_u_name(  1, fifo, res, "asymmetric_motion_partitions_enabled_flag  "); 
		vld_u_name(  1, fifo, res, "non_square_quadtree_enabled_flag           "); 
		vld_u_name(  1, fifo, res, "sample_adaptive_offset_enabled_flag        ");
		sample_adaptive_offset_enabled_flag[sps_id] := res[0];
		vld_u_name(  1, fifo, res, "adaptive_loop_filter_enabled_flag          ");
		adaptive_loop_filter_enabled_flag[sps_id] := res[0];
		if adaptive_loop_filter_enabled_flag[sps_id] = 1 then
			vld_u_name(  1, fifo, res, "alf_coef_in_slice_flag                     ");
		end
		if pcm_enabled_flag = 1 then
			vld_u_name(  1, fifo, res, "pcm_loop_filter_disable_flag               ");
		end
		vld_u_name(  1, fifo, res, "temporal_id_nesting_flag                   ");
		vld_ue_name(    fifo, res, "num_short_term_ref_pic_sets                "); 
		num_short_term_ref_pic_sets := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_7
	 *************************************************************************/
	uint(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE];	
	read_SPS_Header.se_idx_7.loop : action ==>
	guard
		se_idx = 7 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		cnt_i < num_short_term_ref_pic_sets
   	do
   		parseShortTermRefPicSet(cnt_i, fifo, pcRPS);
		cnt_i := cnt_i + 1;
 	end
 	read_SPS_Header.se_idx_7.loopEnd : action ==>
	guard
		se_idx = 7 and cnt_i = num_short_term_ref_pic_sets
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_8
	 *************************************************************************/	
	read_SPS_Header.se_idx_8 : action ==>
	guard
		se_idx = 8 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "long_term_ref_pics_present_flag            "); 
		long_term_ref_pics_present_flag[sps_id] := res[0];
		foreach int i in 0 .. maxCUDepth do
			vld_u_name(  1, fifo, res, "xxxx                                       "); 
		end
		vld_u_name(  2, fifo, res, "tile_or_entropy_coding_sync_idc             "); 
		if tile_or_entropy_coding_sync_idc[sps_id] = 1 then
			vld_ue_name(    fifo, res, "num_tile_columns_minus1                    "); 
			num_tile_columns_minus1 := res[0];
			vld_ue_name(    fifo, res, "num_tile_rows_minus1                       ");
			num_tile_rows_minus1 := res[0];
			vld_u_name ( 1, fifo, res, "uniform_spacing_flag                       ");
			uniform_spacing_flag:=res[0];
		else
			num_tile_columns_minus1 := 0;
			num_tile_rows_minus1 := 0;
			uniform_spacing_flag := 0;
		end
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_9
	 *************************************************************************/	
  	read_SPS_Header.se_idx_9.loop : action ==>
	guard
		se_idx = 9  and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		uniform_spacing_flag = 1 and cnt_i <= num_tile_columns_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "column_width[ ]                         "); 
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_9.loopEnd : action ==>
	guard
		se_idx = 9 and uniform_spacing_flag = 1 and cnt_i > num_tile_columns_minus1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_SPS_Header.se_idx_9.noLoop : action ==>
	guard
		se_idx = 9 and uniform_spacing_flag = 0
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx10
	 *************************************************************************/	
	read_SPS_Header.se_idx_10.loop : action ==>
	guard
		se_idx = 10 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		uniform_spacing_flag = 1 and cnt_i <= num_tile_rows_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "row_height[ ]                          ");
		cnt_i := cnt_i + 1;
	end 
	read_SPS_Header.se_idx_10.loopEnd : action ==>
	guard
		se_idx = 10 and uniform_spacing_flag = 1 and cnt_i > num_tile_rows_minus1
   	do
		se_idx := se_idx + 1;
	end 
	
	/**************************************************************************
	 * read_SPS_Header_done
	 *************************************************************************/	
	read_SPS_Header_done : action ==>
	guard
		se_idx = 11
	var
		uint(size=32) res[1],
		uint(size= 1) sps_extension_flag
	do
		vld_u_name(  1, fifo, res, "sps_extension_flag                      ");
		sps_extension_flag := res[0];
		if sps_extension_flag = 1 then
			println("moreRBSP data SPS");
		end
	end 
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER         *********************
	 **************************************************************************
	 *************************************************************************/
	 uint(size= 8) pps_sps_id[NB_MAX_PPS];
	 uint(size= 1) output_flag_present_flag[NB_MAX_PPS];
	 uint(size= 1) tile_control_present_flag;
	 uint(size= 1) cabac_init_present_flag[NB_MAX_PPS];
	 uint(size= 1) deblocking_filter_control_present_flag[NB_MAX_PPS];
	 uint(size=32) poc;
	 
	/**************************************************************************
	 * read_PPS_Header.se_idx_1
	 *************************************************************************/	
	read_PPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "pic_parameter_set_id                        "); 
		pps_id := res[0];
		vld_ue_name(    fifo, res, "seq_parameter_set_id                        "); 
		pps_sps_id[pps_id] := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end

	/**************************************************************************
	 * read_PPS_Header.se_idx_2
	 *************************************************************************/	
	read_PPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size= 1) sign_data_hiding_flag
   	do
		vld_u_name(  1, fifo, res, "sign_data_hiding_flag                       ");
		sign_data_hiding_flag := res[0];
		if sign_data_hiding_flag = 1 then
			vld_u_name(  4, fifo, res, "sign_hiding_threshold                       ");
		end
		vld_u_name(  1, fifo, res, "cabac_init_present_flag                     ");
		cabac_init_present_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "entropy_coding_mode_flag                    ");
		vld_se_name(    fifo, res, "pic_init_qp_minus26                         "); 
		vld_u_name(  1, fifo, res, "constrained_intra_pred_flag                 ");
		vld_u_name(  1, fifo, res, "enable_temporal_mvp_flag                    ");
		vld_u_name(  2, fifo, res, "slice_granularity                           ");
		vld_ue_name(    fifo, res, "max_cu_qp_delta_depth                       ");
		vld_se_name(    fifo, res, "cb_qp_offset                                ");
		vld_se_name(    fifo, res, "cr_qp_offset                                ");
		vld_u_name(  1, fifo, res, "weighted_pred_flag                          ");
		vld_u_name(  2, fifo, res, "weighted_bipred_idc                         ");
		vld_u_name(  1, fifo, res, "output_flag_present_flag                    ");
		output_flag_present_flag[pps_id]:=res[0];
		if tile_or_entropy_coding_sync_idc[sps_id] = 1 then
			vld_u_name(  1, fifo, res, "tile_info_present_flag                      ");
			vld_u_name(  1, fifo, res, "tile_control_present_flag                   ");
			tile_control_present_flag := res[0];
			if tile_or_entropy_coding_sync_idc[sps_id] = 1 then
				vld_ue_name(    fifo, res, "num_tile_columns_minus1                     "); 
				num_tile_columns_minus1 := res[0];
				vld_ue_name(    fifo, res, "num_tile_rows_minus1                        ");
				num_tile_rows_minus1 := res[0];
				vld_u_name ( 1, fifo, res, "uniform_spacing_flag                        ");
				uniform_spacing_flag:=res[0];
			else
				num_tile_columns_minus1 := 0;
				num_tile_rows_minus1 := 0;
				uniform_spacing_flag := 0;
			end
		end
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_3
	 *************************************************************************/	
  	read_PPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3  and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		uniform_spacing_flag = 1 and cnt_i <= num_tile_columns_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "column_width[ ]                        "); 
		cnt_i := cnt_i + 1;
	end 
	read_PPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3 and uniform_spacing_flag = 1 and cnt_i > num_tile_columns_minus1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_PPS_Header.se_idx_3.noLoop : action ==>
	guard
		se_idx = 3 and uniform_spacing_flag = 0
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_PPS_Header.se_idx4
	 *************************************************************************/	
	read_PPS_Header.se_idx_4.loop : action ==>
	guard
		se_idx = 4 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3 and
		uniform_spacing_flag = 1 and cnt_i <= num_tile_rows_minus1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "row_height[ ]                          ");
		cnt_i := cnt_i + 1;
	end 
	read_PPS_Header.se_idx_4.loopEnd : action ==>
	guard
		se_idx = 4 and uniform_spacing_flag = 1 and cnt_i > num_tile_rows_minus1
   	do
		se_idx := se_idx + 1;
	end 
	
	/**************************************************************************
	 * read_PPS_Header.se_idx5
	 *************************************************************************/	
	read_PPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5
	var
		uint(size=32) res[1],
		uint(size= 1) pps_extension_flag
   	do
		if (tile_or_entropy_coding_sync_idc[sps_id] = 1) then
			if tile_control_present_flag = 1 then
				vld_u_name(  1, fifo, res, "loop_filter_across_tiles_enabled_flag  ");
			end
			else if (tile_or_entropy_coding_sync_idc[sps_id] = 2) then
				vld_ue_name(    fifo, res, "num_substreams_minus1                  ");
			end
		end
		vld_u_name(  1, fifo, res, "deblocking_filter_control_present_flag ");
		deblocking_filter_control_present_flag[pps_id] := res[0];
		vld_ue_name(    fifo, res, "log2_parallel_merge_level_minus2       ");
		vld_u_name(  1, fifo, res, "pps_extension_flag                     ");
		pps_extension_flag := res[0];
		if pps_extension_flag = 1 then
			println("moreRBSP data PPS");
		end
		se_idx := se_idx + 1;
	end 

	/**************************************************************************
	 * read_PPS_Header_done
	 *************************************************************************/	
	read_PPS_Header_done : action ==>
	guard
		se_idx = 6
	end 	
	/**************************************************************************
	 **************************************************************************
	 ********        APS HEADER                           *********************
	 **************************************************************************
	 *************************************************************************/
	read_APS_Header.se_idx_1.read : action ==>
	guard
		se_idx = 1
	var 
		uint(size=32) res[1],
		uint(size= 1) aps_scaling_list_data_present_flag,
		uint(size= 1) aps_deblocking_filter_flag,
		uint(size= 1) disable_deblocking_filter_flag,
		uint(size= 1) aps_sao_interleaving_flag,
		uint(size= 1) aps_sample_adaptive_offset_flag,
		uint(size= 1) aps_adaptive_loop_filter_flag,
		uint(size= 1) aps_extension_flag
	do
		vld_ue_name(    fifo, res, "aps_id                                 ");
		vld_u_name(  1, fifo, res, "aps_scaling_list_data_present_flag     ");
		aps_scaling_list_data_present_flag := res[0];
		if aps_scaling_list_data_present_flag = 1 then
			println("TODO scaling_list_param( )");
		end
		vld_u_name(  1, fifo, res, "aps_deblocking_filter_flag             ");
		aps_deblocking_filter_flag:=res[0];
		if(aps_deblocking_filter_flag = 1) then	
			vld_u_name(  1, fifo, res, "disable_deblocking_filter_flag         ");
			disable_deblocking_filter_flag := res[0];
			if( disable_deblocking_filter_flag = 0) then	
				vld_se_name(    fifo, res, "beta_offset_div2                       ");
				vld_se_name(    fifo, res, "tc_offset_div2                         ");
			end
		end
		vld_u_name(  1, fifo, res, "aps_sao_interleaving_flag              ");
		aps_sao_interleaving_flag := res[0];
		if( aps_sao_interleaving_flag = 0) then	
			vld_u_name(  1, fifo, res, "aps_sample_adaptive_offset_flag        ");
			aps_sample_adaptive_offset_flag	:= res[0];
			if( aps_sample_adaptive_offset_flag = 1) then	
				println("TODO aps_sao_param( )");
			end	
		end
		vld_u_name(  1, fifo, res, "aps_adaptive_loop_filter_flag            ");
		aps_adaptive_loop_filter_flag	:= res[0];
		if( aps_adaptive_loop_filter_flag = 1) then	
			println("TODO alf_param( )");	
		end
		aps_sample_adaptive_offset_flag	:= res[0];
		vld_u_name(  1, fifo, res, "aps_extension_flag                       ");
		aps_extension_flag := res[0];
		if(aps_extension_flag = 1) then 
			println("APS moreDataflag");
		end
		se_idx := se_idx + 1;
	end
	read_APS_Header_done : action ==>
	guard
		se_idx = 2
	end 	

	/**************************************************************************
	 **************************************************************************
	 ********        Slice HEADER                         *********************
	 **************************************************************************
	 *************************************************************************/
		uint(size= 1) slice_type;
		uint(size= 1) entropy_slice_flag;

	/**************************************************************************
	 * read_SliceHeader.se_idx_1
	 *************************************************************************/
	 procedure compute_POC()
     var
	     int iPOClsb = slice[PIC_ORDER_CNT_LSB],
	     int iPrevPOC = poc,
	     int iMaxPOClsb := 1 << (log2_max_pic_order_cnt_lsb_minus4[pps_id] + 4),
	     int iPrevPOClsb,
	     int iPrevPOCmsb,
	     int iPOCmsb
	begin
		iPrevPOClsb := iPrevPOC mod iMaxPOClsb;
		iPrevPOCmsb := iPrevPOC-iPrevPOClsb;
	    if( (iPOClsb < iPrevPOClsb) and ( (iPrevPOClsb - iPOClsb) >= (iMaxPOClsb / 2) ) ) then
	    	iPOCmsb := iPrevPOCmsb + iMaxPOClsb;
	    else 
	    	if( (iPOClsb > iPrevPOClsb)  and ( (iPOClsb - iPrevPOClsb) > (iMaxPOClsb / 2) ) ) then
	 			iPOCmsb := iPrevPOCmsb - iMaxPOClsb;
	   		else
				iPOCmsb := iPrevPOCmsb;
			end
		end
	    poc:= iPOCmsb+iPOClsb;
	end
	
	read_SliceHeader.se_idx_1.read : action ==>
	guard
		se_idx = 1 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=32) prev := 0,
		uint(size=32) j,
		uint(size= 1) first_slice_in_pic_flag,
		uint(size= 1) slice_sao_interleaving_flag,
		uint(size= 1) slice_sample_adaptive_offset_flag
   	do	
		vld_u_name(  1, fifo, res, "first_slice_in_pic_flag                 ");
		first_slice_in_pic_flag := res[0];
		if first_slice_in_pic_flag = 0 then
			vld_ue_name(    fifo, res, "slice_address                           "); 
		end
		vld_ue_name(    fifo, res, "slice_type                              ");
		slice_type:=res[0];
		vld_u_name(  1, fifo, res, "entropy_slice_flag                      ");
		if entropy_slice_flag = 0 then
			vld_ue_name(    fifo, res, "pic_parameter_set_id                    "); 
			pps_id := res[0];
			sps_id := pps_sps_id[pps_id];
			if(output_flag_present_flag[pps_id] = 1) then	
				vld_u_name(  1, fifo, res, "pic_output_flag                         ");
			end
			if(separate_colour_plane_flag[sps_id] = 1) then
			vld_u_name(  2, fifo, res, "colour_plane_id                         ");
			end
			if nal_unit_type = NAL_UNIT_IDR then
			    vld_ue_name(    fifo, res, "idr_pic_id                              ");
	   			vld_u_name(  1, fifo, res, "no_output_of_prior_pics_flag            ");
	   			poc:=0;
			else
				vld_u_name( log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4, fifo, res, "pic_order_cnt_lsb                       "); slice[PIC_ORDER_CNT_LSB]	:= res[0];

				//compute the number of POC
				compute_POC();
				
				vld_u_name(  1, fifo, res, "short_term_ref_pic_set_pps_flag         ");
				if res[0] = 0 then
			   		parseShortTermRefPicSet(pps_id, fifo, pcRPS);
		   		else
				    vld_ue_name(    fifo, res, "short_term_ref_pic_set_idx              ");
				end
				if long_term_ref_pics_present_flag[sps_id] = 1 then
					vld_ue_name(    fifo, res, "num_long_term_pics                      "); pcRPS[pps_id][NUM_LONG_TERM_PICS]	:= res[0];
				   	j := res[0] + pcRPS[pps_id][NUM_PICS]-1;
			   		foreach uint(size=8) i in 0 .. res[0]-2 do
			    		vld_ue_name(    fifo, res, "delta_poc_lsb_lt                        "); prev := prev + res[0] + 1;
						pcRPS[j][POC] := pcRPS[pps_id][POC] - prev;
						vld_u_name(  1, fifo, res, "delta_poc_msb_present_flag              ");
						if res[0] = 1 then
			    			vld_ue_name(    fifo, res, "delta_poc_msb_cycle_lt_minus1                "); 
						end
						vld_u_name(  1, fifo, res, "used_by_curr_pic_lt_flag                "); pcRPS[pps_id][USED+i]		:= res[0];
					end
					pcRPS[pps_id][NUM_PICS] := pcRPS[pps_id][NUM_PICS] + pcRPS[pps_id][NUM_LONG_TERM_PICS];
				end
			end
			if( sample_adaptive_offset_enabled_flag[sps_id] = 1) then
				vld_u_name(  1, fifo, res, "slice_sao_interleaving_flag             ");
				slice_sao_interleaving_flag := res[0];
				vld_u_name(  1, fifo, res, "slice_sample_adaptive_offset_flag       "); 
				slice_sample_adaptive_offset_flag:=res[0];
				if( slice_sao_interleaving_flag = 1 &&
					slice_sample_adaptive_offset_flag = 1) then
					vld_u_name(  1, fifo, res, "sao_cb_enable_flag                     "); 
					vld_u_name(  1, fifo, res, "sao_cr_enable_flag                     "); 
				end
			end
			vld_ue_name(    fifo, res, "aps_id                                  "); 
		end
	    se_idx := se_idx + 1;
	end

	/**************************************************************************
	 * read_SliceHeader.se_idx_2
	 *************************************************************************/	
	read_SliceHeader.se_idx_2.read : action ==>
	guard
		se_idx = 2 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do
		if entropy_slice_flag = 0 then
			if slice_type = P_SLICE or slice_type = B_SLICE then
				vld_u_name(  1, fifo, res, "num_ref_idx_active_override_flag        ");		
	      		if res[0] = 1 then
					vld_ue_name(    fifo, res, "num_ref_idx_l0_active_minus1            ");
					if slice_type = B_SLICE then
						vld_ue_name(    fifo, res, "num_ref_idx_l1_active_minus1            ");
					end
	      		end
	        end
		    if (lists_modification_present_flag[sps_id] = 1) then
		    	println("TODO ref_pic_list_modification( )");
		    	println("TODO ref_pic_list_combination( )");
		    end
		    if slice_type = B_SLICE then
				vld_u_name(  1, fifo, res, "mvd_l1_zero_flag                        ");		
			end	    
	    end
		se_idx := se_idx + 1;
	end

	/**************************************************************************
	 * read_SliceHeader.se_idx_3
	 *************************************************************************/	
	read_SliceHeader.se_idx_3 : action ==>
	guard
		se_idx = 3 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size= 1) inherit_dbl_params_from_aps_flag := 0,
		uint(size= 1) disable_deblocking_filter_flag
   	do	
	if( cabac_init_present_flag[pps_id] = 1  and  slice_type  !=  I_SLICE )	then
		vld_u_name(  1, fifo, res, "cabac_init_flag                         ");		
	end
	if(entropy_slice_flag = 0) then
		vld_se_name(    fifo, res, "slice_qp_delta                          ");
		if(deblocking_filter_control_present_flag[pps_id] = 1) then	
 			if(deblocking_filter_in_aps_enabled_flag[sps_id] = 1) then
				vld_u_name(  1, fifo, res, "inherit_dbl_params_from_aps_flag        ");
				inherit_dbl_params_from_aps_flag := res[0];	
			end
			if(inherit_dbl_params_from_aps_flag = 0) then
				vld_u_name(  1, fifo, res, "disable_deblocking_filter_flag          ");
				if( disable_deblocking_filter_flag = 0) then
					vld_se_name(    fifo, res, "beta_offset_div2                        ");
					vld_se_name(    fifo, res, "tc_offset_div2                          ");
				end
			end
		end	
		if( slice_type = B_SLICE ) then	
			vld_u_name(  1, fifo, res, "collocated_from_l0_flag                 ");
		end
/* 		if( slice_type != I  &&  
			((collocated_from_l0_flag  &&	num_ref_idx_l0_active_minus1 > 0)  | |
			  (!collocated_from_l0_flag  &&  num_ref_idx_l1_active_minus1 > 0) )	
			collocated_ref_idx	ue(v)
		if( ( weighted_pred_flag  &&   slice_type = = P)  | |
			 ( weighted_bipred_idc  = =  1  &&  slice_type  = =  B ) )	
			pred_weight_table( )	
*/	
	end	
	vld_ue_name(    fifo, res, "five_minus_max_num_merge_cand           ");
/* 	if( adaptive_loop_filter_enabled_flag ) {	
		slice_adaptive_loop_filter_flag	u(1)
		if( slice_adaptive_loop_filter_flag  &&  alf_coef_in_slice_flag )	
			alf_param( )	
		if( slice_adaptive_loop_filter_flag  &&  !alf_coef_in_slice_flag )	
			alf_cu_control_param( )	
	}	
*/	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_4
	 *************************************************************************/	
	read_SliceHeader.se_idx_4 : action ==>
	guard
		se_idx = 4 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_5
	 *************************************************************************/	
	 procedure initWpScaling()
	 begin
		foreach uint(size=8) e in 0 .. 1 do
			foreach uint(size=8) i in 0 .. MAX_NUM_REF-1 do
				foreach uint(size=8) yuv in 0 .. 2 do
					if wp[e][i][yuv][WP_PRESENT_FLAG] = 1 then
						wp[e][i][yuv][WP_I_WEIGHT] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]);
						wp[e][i][yuv][WP_I_OFFSET] := 0;
					end
					wp[e][i][yuv][WP_W]     := wp[e][i][yuv][WP_I_WEIGHT];
					wp[e][i][yuv][WP_O]     := wp[e][i][yuv][WP_I_OFFSET] * (1);
					wp[e][i][yuv][WP_SHIFT] := wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM];
					if wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM] >= 1 then
						wp[e][i][yuv][WP_ROUND] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]) - 1;
					else
						wp[e][i][yuv][WP_ROUND] := 0;
					end
				end
			end
		end
	end
   	read_SliceHeader.se_idx_5 : action ==>
	guard
		se_idx = 5 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_6
	 *************************************************************************/	
	read_SliceHeader.se_idx_6 : action ==>
	guard
		se_idx = 6 and fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
   	do	
	    se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader_done
	 *************************************************************************/	
	read_SliceHeader_done : action ==>
	guard
		se_idx = 7
	do
		println("POC                                    "+poc);
		println("five_minus_max_num_merge_cand           ");
	end 	
	
	/**************************************************************************
	 **************************************************************************
	 ********        undefined                            *********************
	 **************************************************************************
	 *************************************************************************/
  	bool actorNotFinished := true;
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("Algo_Parser doesn't manage this case yet");
		actorNotFinished := false;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        schedule                             *********************
	 **************************************************************************
	 *************************************************************************/
  	schedule fsm start_code:
		// byte align
		byte_align          			( byte_align_a						) --> start_code;
		// search start code
		start_code          			( start_code.search					) --> start_code;
		start_code			            ( start_code.done					) --> read_Nal_unit_header;
		// read Nal Unit header
		read_Nal_unit_header			( read_nal_unit_header				) --> find_header;
		find_header	  					( look_for.SPS_header	  			) --> read_SPS_Header;
		find_header	  					( look_for.PPS_header	  			) --> read_PPS_Header;
		find_header	  					( look_for.Slice_header	  			) --> read_SliceHeader;
		find_header	  					( look_for.APS_header				) --> read_APS_Header;
		find_header	  					( look_for_other_header				) --> byte_align;
		// read SPS header
		read_SPS_Header	  				( read_SPS_Header	    			) --> read_SPS_Header;
		read_SPS_Header	  				( read_SPS_Header_done    			) --> byte_align;
		// read PPS header
		read_PPS_Header 				( read_PPS_Header   				) --> read_PPS_Header;
		read_PPS_Header	  				( read_PPS_Header_done    			) --> byte_align;
		// read_SliceHeader
		read_SliceHeader				( read_SliceHeader					) --> read_SliceHeader;
		read_SliceHeader				( read_SliceHeader_done				) --> byte_align;
		
		// read_APS_Header
		read_APS_Header				    ( read_APS_Header					) --> read_APS_Header;
		read_APS_Header				    ( read_APS_Header_done				) --> byte_align;
		
		
		
		// undefined
		undefined	  					( undefined		    				) --> undefined;
	end
	
	/**************************************************************************
	 * priority
	 *************************************************************************/
	priority
		look_for        > look_for_other_header;
	end
end