/******************************************************************************
 * Definition of CommonPackage
 *****************************************************************************/
package synParser;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  common.CommonConstantHEVC.*;
import  common.CabacDecodeBinFunction.*;
import  common.CabacContextConstantHEVC.*;
import  common.CabacContextFunctionHEVC.*;
import  common.CabacParserFunctionHEVC.*;


unit Algo_ParserUtils :
	/**************************************************************************
	 * GLOBAL CONSTANT
 	 *************************************************************************/
 	 uint(size= 8) EPR_VALUE                   = 0x03;
 	 uint(size= 8) START_CODE_VALUE            = 0x01;
 	 uint(size= 9) START_CODE_FLAG             = 0x100;
	/**************************************************************************
	 * GLOBAL NAL UNIT TYPE
 	 *************************************************************************/
 	 uint(size= 6) NAL_UNIT_NON_IDR_AND_NON_CRA =  1;
 	 uint(size= 6) NAL_UNIT_CRA                 =  4;
 	 uint(size= 6) NAL_UNIT_IDR                 =  8;
 	 uint(size= 6) NAL_UNIT_SEI                 = 31;
 	 uint(size= 6) NAL_UNIT_VPS                 = 25;
 	 uint(size= 6) NAL_UNIT_SPS                 = 26;
 	 uint(size= 6) NAL_UNIT_PPS                 = 27;
 	 uint(size= 6) NAL_UNIT_AUD                 =  9;
 	 uint(size= 6) NAL_UNIT_FIL                 = 12;
 	 uint(size= 6) NAL_UNIT_APS                 = 28;
	/**************************************************************************
	 * GLOBAL SPS PPS
 	 *************************************************************************/
 	 uint(size= 6) NB_MAX_SPS					 = 32;
 	 uint(size= 8) NB_MAX_PPS					 = 32;
	 uint(size= 8) NB_MAX_PICS					 = 32;
 	 uint(size= 6) MAX_TLAYER                   =  4; 
 	 uint(size= 6) MRG_MAX_NUM_CANDS            =  5;	 
	/**************************************************************************
	 * GLOBAL SLICE HEADER
 	 *************************************************************************/
  	 /// Weighted prediction struct
  	 uint(size= 1) WP_PRESENT_FLAG              =  0;
  	 uint(size=32) WP_LOG2_WEIGHT_DENOM         =  1;
  	 uint(size=32) WP_I_WEIGHT                  =  2;
  	 uint(size=32) WP_I_OFFSET                  =  3;
	 uint(size=32) WP_W                         =  4;
  	 uint(size=32) WP_O                         =  5;
  	 uint(size=32) WP_OFFSET                    =  6;
  	 uint(size=32) WP_SHIFT                     =  7;
  	 uint(size=32) WP_ROUND                     =  8;
  	 uint(size= 3) WP_MAX_STRUCT                =  9;

	/**************************************************************************
	 * GLOBAL pcRPS STRUCT
 	 *************************************************************************/
	uint(size= 8) INTER_RPS_FLAG						=  0;
	uint(size= 8) NUM_NEGATIVE_PICS						=  1;
	uint(size= 8) NUM_POSITIVE_PICS						=  2;
	uint(size= 8) NUM_PICS								=  3;
	uint(size= 8) DELTA_IDX								=  4;
	uint(size= 8) DELTA_RPS_SIGN						=  5;
	uint(size= 8) ABS_DELTA_RPS							=  6;
	uint(size= 8) NUM_REF_IDC							=  7;
	uint(size= 8) DELTAPOC								=  8;
	uint(size= 8) USED									= DELTAPOC + NB_MAX_PICS;
	uint(size= 8) REF_IDC								= USED + NB_MAX_PICS;
	uint(size= 8) NUM_LONG_TERM_PICS					= REF_IDC + 1;
	uint(size= 8) POC									= NUM_LONG_TERM_PICS + 1;
	uint(size= 8) PC_RPS_STRUCT_SIZE					= POC + 1;
	/**************************************************************************
	 * GLOBAL pcRPS STRUCT
 	 *************************************************************************/
	uint(size=16) COLUMN_WIDTH_MAX                     = 100;
	uint(size=16) CTB_ADDR_TS_MAX                      = 256;
	/**************************************************************************
	 * GLOABL Coding Tree
	 *************************************************************************/
	uint(size= 8) CT_idx								=  0;
	uint(size= 8) CT_x0									=  1;
	uint(size= 8) CT_y0									=  2;
	uint(size= 8) CT_x1									=  3;
	uint(size= 8) CT_y1									=  4;
	uint(size= 8) CT_log2CbSize							=  5;
	uint(size= 8) CT_ctDepth							=  6;
	uint(size= 8) CT_STRUCT_SIZE						=  7;
	/**************************************************************************
	 * GLOABL Transform Tree
	 *************************************************************************/
	uint(size= 8) TT_idx								=  0;
	uint(size= 8) TT_x0L								=  1;
	uint(size= 8) TT_y0L								=  2;
	uint(size= 8) TT_x1L								=  3;
	uint(size= 8) TT_y1L								=  4;
	uint(size= 8) TT_x2L								=  5;
	uint(size= 8) TT_y2L								=  6;
	uint(size= 8) TT_x3L								=  7;
	uint(size= 8) TT_y3L								=  8;
	uint(size= 8) TT_x0C								=  9;
	uint(size= 8) TT_y0C								= 10;
	uint(size= 8) TT_x1C								= 11;
	uint(size= 8) TT_y1C								= 12;
	uint(size= 8) TT_x2C								= 13;
	uint(size= 8) TT_y2C								= 14;
	uint(size= 8) TT_x3C								= 15;
	uint(size= 8) TT_y3C								= 16;
	uint(size= 8) TT_xBase								= 17;
	uint(size= 8) TT_yBase								= 18;
	uint(size= 8) TT_log2CbSize							= 19;
	uint(size= 8) TT_log2TrafoSize						= 20;
	uint(size= 8) TT_trafoDepth							= 21;
	uint(size= 8) TT_blkIdx								= 22;
	uint(size= 8) TT_STRUCT_SIZE						= 23;
	/**************************************************************************
	 *        Transform Unit
	 *************************************************************************/
	uint(size= 3) ScanType[4][36] = [
	   // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17
	   //18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35
		[ 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0,
		  0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
		[ 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0,
		  0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	];
	/**************************************************************************
	 * parseShortTermRefPicSet
 	 *************************************************************************/
	procedure parseShortTermRefPicSet(
		uint(size=32) pps_id,
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE]
	)
	var
		uint(size=32) res[1],
		uint(size= 8) rIdx,
		 int(size=32) deltaRPS,
		 int(size=32) deltaPOC,
		 int(size=32) k    := 0,
		 int(size=32) k0   := 0,
		 int(size=32) k1   := 0,
		uint(size=32) prev := 0
   	begin
 		vld_u_name(  1, fifo, res, "inter_ref_pic_set_prediction_flag       "); pcRPS[pps_id][INTER_RPS_FLAG]		:= res[0];
		if res[0] = 1 then 	
  			vld_ue_name(    fifo, res, "delta_idx_minus1                        "); pcRPS[pps_id][DELTA_IDX]		:= res[0] + 1;
    		rIdx := pps_id - 1 - res[0];
    		vld_u_name(  1, fifo, res, "delta_rps_sign                          "); pcRPS[pps_id][DELTA_RPS_SIGN]	:= res[0];
    		vld_ue_name(    fifo, res, "abs_delta_rps_minus1                    "); pcRPS[pps_id][ABS_DELTA_RPS]	:= res[0] + 1;
    		deltaRPS := (1 - (pcRPS[rIdx][DELTA_RPS_SIGN]<<1)) * (res[0] + 1);
    		foreach uint(size=8) i in 0 ..  pcRPS[rIdx][NUM_PICS]-1 do
    			vld_u_name(  1, fifo, res, "ref_idc0                                ");
    			if res[0] = 0 then
	    			vld_u_name(  1, fifo, res, "ref_idc1                                ");
	    			res[0] := res[0] << 1;
    			end
    			if res[0] = 1 or res[0] = 2 then
    				if i < pcRPS[rIdx][NUM_PICS] then
    					deltaPOC := deltaRPS + pcRPS[rIdx][DELTAPOC+i];
    				else
    					deltaPOC := deltaRPS;
					end
			        if deltaPOC < 0 then
          				k0 := k0 + 1;
        			else 
          				k1 := k1 + 1;
        			end
        			k := k + 1; 			
    			end
    			pcRPS[pps_id][REF_IDC+i] := res[0];
    		end
    		pcRPS[pps_id][NUM_REF_IDC]       := pcRPS[rIdx][NUM_REF_IDC]+1;  
    		pcRPS[pps_id][NUM_PICS]          := k;
    		pcRPS[pps_id][NUM_NEGATIVE_PICS] := k0;
			pcRPS[pps_id][NUM_POSITIVE_PICS] := k1;
			sortDeltaPOC(pps_id, pcRPS);
  		else
    		vld_ue_name(    fifo, res, "num_negative_pics                       "); pcRPS[pps_id][NUM_NEGATIVE_PICS] := res[0];
    		vld_ue_name(    fifo, res, "num_positive_pics                       "); pcRPS[pps_id][NUM_POSITIVE_PICS] := res[0];
    		pcRPS[pps_id][NUM_PICS] := pcRPS[pps_id][NUM_NEGATIVE_PICS] + res[0];
    		if pcRPS[pps_id][NUM_NEGATIVE_PICS] != 0 then
    			foreach uint(size=8) i in 0 ..  pcRPS[pps_id][NUM_NEGATIVE_PICS]-1 do
	    			vld_ue_name(    fifo, res, "delta_poc_s0_minus1                     ");
					prev := prev-res[0]-1;
					pcRPS[pps_id][DELTAPOC+i] := prev;
					vld_u_name(  1, fifo, res, "used_by_curr_pic_s0_flag                "); pcRPS[pps_id][USED+i]       := res[0];
				end
			end
			prev := 0;
			if pcRPS[pps_id][NUM_POSITIVE_PICS] != 0 then
    			foreach uint(size=8) i in pcRPS[pps_id][NUM_NEGATIVE_PICS] .. pcRPS[pps_id][NUM_PICS]-1 do
	    			vld_ue_name(    fifo, res, "delta_poc_s1_minus1                     ");
					prev := prev-res[0]-1;
					pcRPS[pps_id][DELTAPOC+i] := prev;
					vld_u_name(  1, fifo, res, "used_by_curr_pic_s1_flag                "); pcRPS[pps_id][USED+i]       := res[0];
				end
			end
		end
		printDeltaPOC(pps_id, pcRPS);
	end
	/**************************************************************************
	 * sortDeltaPOC
 	 *************************************************************************/
	procedure sortDeltaPOC(
		uint(size=32) pps_id,
		uint(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE]
	)
	var
		 int(size=32) deltaPOC_v,
		 int(size= 1) used_v,
		uint(size=32) k,
		 int(size=32) tmp
	begin
		// sort in increasing order (smallest first)
		if pcRPS[pps_id][NUM_PICS] != 0 then
    		foreach uint(size=8) i in 1 ..  pcRPS[pps_id][NUM_PICS]-1 do
	   			deltaPOC_v := pcRPS[pps_id][DELTAPOC+i];
   				used_v     := pcRPS[pps_id][USED+i];
   				foreach uint(size=8) j in 0 ..  i-1 do
	   				k := i-1-j;
   					tmp := pcRPS[pps_id][DELTAPOC+j];
   					if deltaPOC_v < tmp then
	   					pcRPS[pps_id][DELTAPOC+k+1] := tmp;
   						pcRPS[pps_id][USED+k+1]     := pcRPS[pps_id][USED+k]; 
   						pcRPS[pps_id][DELTAPOC+k]   := deltaPOC_v;
	   					pcRPS[pps_id][USED+k]       := used_v;
   					end
   				end
	   		end
	   	end
	   	if (pcRPS[pps_id][NUM_NEGATIVE_PICS]>>1) != 0 then
   			k := pcRPS[pps_id][NUM_NEGATIVE_PICS] - 1;
			// flip the negative values to largest first
    		foreach uint(size=8) i in 0 ..  (pcRPS[pps_id][NUM_NEGATIVE_PICS]>>1)-1 do
	    		deltaPOC_v       := pcRPS[pps_id][DELTAPOC+i];
   				used_v           := pcRPS[pps_id][USED+i];
   				pcRPS[pps_id][DELTAPOC+i] := pcRPS[pps_id][DELTAPOC+k];
   				pcRPS[pps_id][USED+i]     := pcRPS[pps_id][USED+k]; 
   				pcRPS[pps_id][DELTAPOC+k] := deltaPOC_v;
   				pcRPS[pps_id][USED+k]     := used_v;
   				k := k - 1;
   			end
   		end
	end
	/**************************************************************************
	 * printDeltaPOC
 	 *************************************************************************/
	procedure printDeltaPOC(
		uint(size=32) pps_id,
		uint(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE]
	)
	begin
		if pcRPS[pps_id][NUM_PICS] != 0 then
  			print("DeltaPOC = { ");
  			foreach uint(size=8) i in 0 ..  pcRPS[pps_id][NUM_PICS]-1 do
	    		print(pcRPS[pps_id][DELTAPOC+i]);
    			if pcRPS[pps_id][USED+i] = 1 then
	    			print("* ");
    			else
	    			print(" ");
    			end
 			end		
 		end
 		if pcRPS[pps_id][INTER_RPS_FLAG] = 1 then
 			print("}, RefIdc = { ");
			if pcRPS[pps_id][NUM_REF_IDC] != 0 then
  				foreach uint(size=8) i in 0 ..  pcRPS[pps_id][NUM_REF_IDC]-1 do
	  				print(pcRPS[pps_id][REF_IDC+i]+" ");
  				end
  			end
  		end
  		if pcRPS[pps_id][NUM_PICS] != 0 then
  			println("}");
  		end
	end
	/**************************************************************************
	 * sao_param
 	 *************************************************************************/
	procedure sao_param(
		uint(size= 8) rx,
		uint(size= 8) ry,
		uint(size= 8) cIdx,
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) CtbAddrInSlice,
		uint(size= 1) slice_loop_filter_across_slices_enabled_flag
	)
	var
		uint(size=32) res[1] := [0]
	begin
		if( rx > 0 and CtbAddrInSlice != 0 ) then
			get_SAO_MERGE_LEFT_FLAG(codIRange, codIOffset, ctxTable, fifo, res, cIdx);
		end
		if res[0] = 0 then
			if ry > 0 and slice_loop_filter_across_slices_enabled_flag = 1 then
				get_SAO_MERGE_UP_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			end
			if res[0] = 0 then
				get_SAO_OFFSET(codIRange, codIOffset, ctxTable, fifo);
			end
		end
	end
	/**************************************************************************
	 * InitScanningArray
 	 *************************************************************************/
	procedure InitScanningArray(
		uint(size= 8) log2TrafoWidth,
		uint(size= 8) log2TrafoHeight,
		uint(size= 8) ScanOrder[3][BLW_WIDTH_MAX*BLW_HEIGHT_MAX][2]
	)
	var
		uint(size= 8) blkWidth  := 1 << log2TrafoWidth,
		uint(size= 8) blkHeight := 1 << log2TrafoHeight,
		uint(size= 8) i		 	:= 0,
		uint(size= 8) x		 	:= 0,
		 int(size= 8) y			:= 0,
		bool		  stopLoop  := false,
		uint(size=16) i_off	 	:= 0,
		uint(size= 8) x_off	 	:= 0,
		 int(size= 8) y_off		:= 0,
		bool		   stopLoopSubblocks := false
	begin	
		/*********************** DiagScan ***********************/
		if blkWidth < 8 and blkHeight < 8 then
			while not stopLoop do
				while y >= 0 do
					if x < blkWidth and y < blkHeight then
						ScanOrder[ 0 ][ i ][ 0 ] := x;
						ScanOrder[ 0 ][ i ][ 1 ] := y;
						i := i + 1;
					end
					y := y - 1;
					x := x + 1;
				end
				y := x;
				x := 0;
				if i >= blkWidth * blkHeight then
					stopLoop := true;
				end
			end
		else
			while not stopLoopSubblocks do
				i := 0;
				x := 0;
				y := 0;
				stopLoop := false;
				while not stopLoop do
					while y >= 0 do
						if x < 4 and y < 4 then
							ScanOrder[ 0 ][ i + i_off ][ 0 ] := x + x_off;
							ScanOrder[ 0 ][ i + i_off ][ 1 ] := y + y_off;
							i := i + 1;
						end
						y := y - 1;
						x := x + 1;
					end
					y := x;
					x := 0;
					if i >= 16 then
						stopLoop := true;
					end
				end
				i_off := i_off + 16;
				if i_off >= blkWidth * blkHeight then
					stopLoopSubblocks := true;
				else
					y_off := y_off - 4;
					x_off := x_off + 4;
					if y_off < 0 then
						y_off := x_off;
						x_off := 0;
					end
					while not( x_off < blkWidth and y_off < blkHeight ) do
						y_off := y_off - 4;
						x_off := x_off + 4;
						if y_off < 0 then
							y_off := x_off;
							x_off := 0;
						end
					end
				end
			end	
		end
		/*********************** ScanOrder ***********************/
		i := 0;
		y := 0;
		while y < blkHeight do
			x := 0;
			while x < blkWidth do
				ScanOrder[ 1 ][ i ][ 0 ] := x;
				ScanOrder[ 1 ][ i ][ 1 ] := y;
				x := x + 1;
				i := i + 1;
			end
			y := y + 1;
		end
		i := 0;
		x := 0;
		while x < blkWidth do
			y := 0;
			while y < blkHeight do
				ScanOrder[ 2 ][ i ][ 0 ] := x;
				ScanOrder[ 2 ][ i ][ 1 ] := y;
				y := y + 1;
				i := i + 1;
			end
			x := x + 1;
		end	
	end
end