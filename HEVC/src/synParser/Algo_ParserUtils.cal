/******************************************************************************
 * Definition of CommonPackage
 *****************************************************************************/
package synParser;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  common.CommonConstantHEVC.*;
import  common.CabacDecodeBinFunction.*;
import  common.CabacContextConstantHEVC.*;
import  common.CabacContextFunctionHEVC.*;
import  common.CabacParserFunctionHEVC.*;


unit Algo_ParserUtils :
	/**************************************************************************
	 * GLOBAL CONSTANT
 	 *************************************************************************/
 	 uint(size= 8) EPR_VALUE                   = 0x03;
 	 uint(size= 8) START_CODE_VALUE            = 0x01;
 	 uint(size= 9) START_CODE_FLAG             = 0x100;
	/**************************************************************************
	 * GLOBAL NAL UNIT TYPE
 	 *************************************************************************/
 	 uint(size= 6) NAL_UNIT_TRAIL_R 			=  0;
 	 uint(size= 6) NAL_UNIT_TRAIL_N             =  1;
 	 uint(size= 6) NAL_IDR_W_DLP                = 19;
 	 uint(size= 6) NAL_UNIT_SEI                 = 39;
 	 uint(size= 6) NAL_UNIT_VPS                 = 32;
 	 uint(size= 6) NAL_UNIT_SPS                 = 33;
 	 uint(size= 6) NAL_UNIT_PPS                 = 34;
 	 uint(size= 6) NAL_UNIT_AUD                 = 35;
 	 uint(size= 6) NAL_UNIT_FIL                 = 38;
 	 
	/**************************************************************************
	 * GLOBAL SPS PPS
 	 *************************************************************************/
 	 uint(size= 6) NB_MAX_SPS					 = 32;
 	 uint(size= 8) NB_MAX_PPS					 = 32;
	 uint(size= 8) NB_MAX_PICS					 = 32;
 	 uint(size= 6) MAX_TLAYER                   =  4; 
 	 uint(size= 6) MRG_MAX_NUM_CANDS            =  5;	 
	/**************************************************************************
	 * GLOBAL SLICE HEADER
 	 *************************************************************************/
  	 /// Weighted prediction struct
  	 uint(size= 1) WP_PRESENT_FLAG              =  0;
  	 uint(size=32) WP_LOG2_WEIGHT_DENOM         =  1;
  	 uint(size=32) WP_I_WEIGHT                  =  2;
  	 uint(size=32) WP_I_OFFSET                  =  3;
	 uint(size=32) WP_W                         =  4;
  	 uint(size=32) WP_O                         =  5;
  	 uint(size=32) WP_OFFSET                    =  6;
  	 uint(size=32) WP_SHIFT                     =  7;
  	 uint(size=32) WP_ROUND                     =  8;
  	 uint(size= 3) WP_MAX_STRUCT                =  9;

	/**************************************************************************
	 * GLOBAL pcRPS STRUCT
 	 *************************************************************************/
	uint(size= 8) INTER_RPS_FLAG				=  0;
	uint(size= 8) NUM_NEGATIVE_PICS				=  1;
	uint(size= 8) NUM_POSITIVE_PICS				=  2;
	uint(size= 8) NUM_PICS						=  3;
	uint(size= 8) DELTA_IDX						=  4;
	uint(size= 8) DELTA_RPS_SIGN				=  5;
	uint(size= 8) ABS_DELTA_RPS					=  6;
	uint(size= 8) NUM_REF_IDC					=  7;
	uint(size= 8) DELTAPOC						=  8;
	uint(size= 8) USED							= DELTAPOC + NB_MAX_PICS;
	uint(size= 8) REF_IDC						= USED + NB_MAX_PICS;
	uint(size= 8) NUM_LONG_TERM_PICS			= REF_IDC + 1;
	uint(size= 8) POC							= NUM_LONG_TERM_PICS + 1;
	uint(size= 8) PC_RPS_STRUCT_SIZE			= POC + 1;
	/**************************************************************************
	 * GLOABL Coding Tree
	 *************************************************************************/
	uint(size= 8) CT_idx						=  0;
	uint(size=16) CT_x0							=  1;
	uint(size=16) CT_y0							=  2;
	uint(size=16) CT_x1							=  3;
	uint(size=16) CT_y1							=  4;
	uint(size= 8) CT_log2CbSize					=  5;
	uint(size= 8) CT_ctDepth					=  6;
	uint(size= 8) CT_STRUCT_SIZE				=  7;
	/**************************************************************************
	 * GLOABL Transform Tree
	 *************************************************************************/
	uint(size= 8) TT_idx						=  0;
	uint(size=16) TT_x0L 						=  1;
	uint(size=16) TT_y0L 						=  2;
	uint(size=16) TT_x1L 						=  3;
	uint(size=16) TT_y1L 						=  4;
	uint(size=16) TT_x0C						=  5;
	uint(size=16) TT_y0C						=  6;
	uint(size=16) TT_x1C						=  7;
	uint(size=16) TT_y1C						=  8;
	uint(size=16) TT_xBase						=  9;
	uint(size=16) TT_yBase						=  10;
	uint(size= 8) TT_log2TrafoSize				=  11;
	uint(size= 8) TT_trafoDepth					=  12;
	uint(size= 8) TT_blkIdx						=  13;
	uint(size= 8) TT_STRUCT_SIZE				=  14;
	/**************************************************************************
	 *        Transform Unit
	 *************************************************************************/
	uint(size= 3) ScanType[4][36] = [
	   // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17
	   //18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35
		[ 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0,
		  0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
		[ 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0,
		  0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	];
	/**************************************************************************
	 * parseShortTermRefPicSet
 	 *************************************************************************/
	procedure parseShortTermRefPicSet(
		uint(size=32) idx,
		uint(size= 8) num_short_term_ref_pic_sets,
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		 int(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE]
	)
	var
		uint(size=32) res[1],
		uint(size= 8) rIdx,
		 int(size=32) deltaRPS,
		 int(size=32) deltaPOC,
		 int(size=32) k    := 0,
		 int(size=32) k0   := 0,
		 int(size=32) k1   := 0,
		 int(size=32) prev := 0
   	begin
 		if (idx != 0) then
 			vld_u_name(  1, fifo, res, "inter_ref_pic_set_prediction_flag       "); pcRPS[idx][INTER_RPS_FLAG]		:= res[0];
 		else
 			pcRPS[idx][INTER_RPS_FLAG] := 0;
 		end
		if pcRPS[idx][INTER_RPS_FLAG] = 1 then
			if idx = num_short_term_ref_pic_sets then
  				vld_ue_name(    fifo, res, "delta_idx_minus1                        "); pcRPS[idx][DELTA_IDX]		:= res[0] + 1;
  			else
  				res[0] := 1;
  			end
    		rIdx := idx - res[0];
    		vld_u_name(  1, fifo, res, "delta_rps_sign                          "); pcRPS[idx][DELTA_RPS_SIGN]	:= res[0];
    		vld_ue_name(    fifo, res, "abs_delta_rps_minus1                    "); pcRPS[idx][ABS_DELTA_RPS]	:= res[0] + 1;
    		deltaRPS := (1 - (pcRPS[rIdx][DELTA_RPS_SIGN]<<1)) * (res[0] + 1);
    		foreach uint(size=8) i in 0 ..  pcRPS[rIdx][NUM_PICS] do
    			vld_u_name(  1, fifo, res, "used_by_curr_pic_flag                   ");
    			if res[0] = 0 then
	    			vld_u_name(  1, fifo, res, "use_delta_flag                          ");
	    			res[0] := res[0] << 1;
    			end
    			if res[0] = 1 or res[0] = 2 then
    				if i < pcRPS[rIdx][NUM_PICS] then
    					deltaPOC := deltaRPS + pcRPS[rIdx][DELTAPOC+i];
    				else
    					deltaPOC := deltaRPS;
					end
			        if deltaPOC < 0 then
          				k0 := k0 + 1;
        			else 
          				k1 := k1 + 1;
        			end
        			k := k + 1; 			
    			end
    			pcRPS[idx][REF_IDC+i] := res[0];
    		end
    		pcRPS[idx][NUM_REF_IDC]       := pcRPS[rIdx][NUM_REF_IDC]+1;  
    		pcRPS[idx][NUM_PICS]          := k;
    		pcRPS[idx][NUM_NEGATIVE_PICS] := k0;
			pcRPS[idx][NUM_POSITIVE_PICS] := k1;
			sortDeltaPOC(idx, pcRPS);
  		else
    		vld_ue_name(    fifo, res, "num_negative_pics                       "); pcRPS[idx][NUM_NEGATIVE_PICS] := res[0];
    		vld_ue_name(    fifo, res, "num_positive_pics                       "); pcRPS[idx][NUM_POSITIVE_PICS] := res[0];
    		pcRPS[idx][NUM_PICS] := pcRPS[idx][NUM_NEGATIVE_PICS] + res[0];
    		if pcRPS[idx][NUM_NEGATIVE_PICS] != 0 then
    			foreach uint(size=8) i in 0 ..  pcRPS[idx][NUM_NEGATIVE_PICS]-1 do
	    			vld_ue_name(    fifo, res, "delta_poc_s0_minus1                     ");
					prev := prev-res[0]-1;
					pcRPS[idx][DELTAPOC+i] := prev;
					vld_u_name(  1, fifo, res, "used_by_curr_pic_s0_flag                "); pcRPS[idx][USED+i]       := res[0];
				end
			end
			prev := 0;
			if pcRPS[idx][NUM_POSITIVE_PICS] != 0 then
    			foreach uint(size=8) i in pcRPS[idx][NUM_NEGATIVE_PICS] .. pcRPS[idx][NUM_PICS]-1 do
	    			vld_ue_name(    fifo, res, "delta_poc_s1_minus1                     ");
					prev := prev-res[0]-1;
					pcRPS[idx][DELTAPOC+i] := prev;
					vld_u_name(  1, fifo, res, "used_by_curr_pic_s1_flag                "); pcRPS[idx][USED+i]       := res[0];
				end
			end
		end
		printDeltaPOC(idx, pcRPS);
	end
	/**************************************************************************
	 * sortDeltaPOC
 	 *************************************************************************/
	procedure sortDeltaPOC(
		uint(size=32) pps_id,
		uint(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE]
	)
	var
		 int(size=32) deltaPOC_v,
		 int(size= 1) used_v,
		uint(size=32) k,
		 int(size=32) tmp
	begin
		// sort in increasing order (smallest first)
		if pcRPS[pps_id][NUM_PICS] != 0 then
    		foreach uint(size=8) i in 1 ..  pcRPS[pps_id][NUM_PICS]-1 do
	   			deltaPOC_v := pcRPS[pps_id][DELTAPOC+i];
   				used_v     := pcRPS[pps_id][USED+i];
   				foreach uint(size=8) j in 0 ..  i-1 do
	   				k := i-1-j;
   					tmp := pcRPS[pps_id][DELTAPOC+j];
   					if deltaPOC_v < tmp then
	   					pcRPS[pps_id][DELTAPOC+k+1] := tmp;
   						pcRPS[pps_id][USED+k+1]     := pcRPS[pps_id][USED+k]; 
   						pcRPS[pps_id][DELTAPOC+k]   := deltaPOC_v;
	   					pcRPS[pps_id][USED+k]       := used_v;
   					end
   				end
	   		end
	   	end
	   	if (pcRPS[pps_id][NUM_NEGATIVE_PICS]>>1) != 0 then
   			k := pcRPS[pps_id][NUM_NEGATIVE_PICS] - 1;
			// flip the negative values to largest first
    		foreach uint(size=8) i in 0 ..  (pcRPS[pps_id][NUM_NEGATIVE_PICS]>>1)-1 do
	    		deltaPOC_v       := pcRPS[pps_id][DELTAPOC+i];
   				used_v           := pcRPS[pps_id][USED+i];
   				pcRPS[pps_id][DELTAPOC+i] := pcRPS[pps_id][DELTAPOC+k];
   				pcRPS[pps_id][USED+i]     := pcRPS[pps_id][USED+k]; 
   				pcRPS[pps_id][DELTAPOC+k] := deltaPOC_v;
   				pcRPS[pps_id][USED+k]     := used_v;
   				k := k - 1;
   			end
   		end
	end
	/**************************************************************************
	 * printDeltaPOC
 	 *************************************************************************/
	procedure printDeltaPOC(
		uint(size=32) pps_id,
		 int(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE]
	)
	begin
		if pcRPS[pps_id][NUM_PICS] != 0 then
  			print("DeltaPOC = { ");
  			foreach uint(size=8) i in 0 ..  pcRPS[pps_id][NUM_PICS]-1 do
	    		print(pcRPS[pps_id][DELTAPOC+i]);
    			if pcRPS[pps_id][USED+i] = 1 then
	    			print("* ");
    			else
	    			print(" ");
    			end
 			end		
 		end
 		if pcRPS[pps_id][INTER_RPS_FLAG] = 1 then
 			print("}, RefIdc = { ");
			if pcRPS[pps_id][NUM_REF_IDC] != 0 then
  				foreach uint(size=8) i in 0 ..  pcRPS[pps_id][NUM_REF_IDC]-1 do
	  				print(pcRPS[pps_id][REF_IDC+i]+" ");
  				end
  			end
  		end
  		if pcRPS[pps_id][NUM_PICS] != 0 then
  			println("}");
  		end
	end
	/**************************************************************************
	 * InitScanningArray
 	 *************************************************************************/
	procedure InitScanningArray(
		uint(size= 8) log2TrafoSize,
		uint(size= 8) ScanOrder[3][BLW_WIDTH_MAX*BLW_HEIGHT_MAX][2]
	)
	var
		uint(size= 8) blkSize   := 1 << log2TrafoSize,
		uint(size= 8) i		 	:= 0,
		uint(size= 8) x		 	:= 0,
		 int(size= 8) y			:= 0,
		bool		  stopLoop  := false
	begin	
		/*********************** Init ***********************/
		foreach int n in 0 .. blkSize-1 do
			ScanOrder[ 0 ][ n ][ 0 ] := 0;
			ScanOrder[ 0 ][ n ][ 1 ] := 0;
			ScanOrder[ 1 ][ n ][ 0 ] := 0;
			ScanOrder[ 1 ][ n ][ 1 ] := 0;
			ScanOrder[ 2 ][ n ][ 0 ] := 0;
			ScanOrder[ 2 ][ n ][ 1 ] := 0;
		end
		/*********************** DiagScan ***********************/
		while not stopLoop do
			while y >= 0 do
				if x < blkSize and y < blkSize then
					ScanOrder[ 0 ][ i ][ 0 ] := x;
					ScanOrder[ 0 ][ i ][ 1 ] := y;
					i := i + 1;
				end
				y := y - 1;
				x := x + 1;
			end
			y := x;
			x := 0;
			if i >= blkSize * blkSize then
				stopLoop := true;
			end
		end
		/*********************** horScan ***********************/
		i := 0;
		y := 0;
		while y < blkSize do
			x := 0;
			while x < blkSize do
				ScanOrder[ 1 ][ i ][ 0 ] := x;
				ScanOrder[ 1 ][ i ][ 1 ] := y;
				x := x + 1;
				i := i + 1;
			end
			y := y + 1;
		end
		/*********************** verScan ***********************/
		i := 0;
		x := 0;
		while x < blkSize do
			y := 0;
			while y < blkSize do
				ScanOrder[ 2 ][ i ][ 0 ] := x;
				ScanOrder[ 2 ][ i ][ 1 ] := y;
				y := y + 1;
				i := i + 1;
			end
			x := x + 1;
		end
/*		
		println("==== ScabOrder "+blkSize);
		println("diag_scan"+blkSize+"x"+blkSize+"_x");
		foreach int j in 0 .. blkSize-1 do
			foreach int k in 0 .. blkSize-1 do
				print(ScanOrder[0][j*blkSize+k][0]+", ");
			end
			println();
		end
		println("diag_scan"+blkSize+"x"+blkSize+"_y");
		foreach int j in 0 .. blkSize-1 do
			foreach int k in 0 .. blkSize-1 do
				print(ScanOrder[0][j*blkSize+k][1]+", ");
			end
			println();
		end
		println("horiz_scan"+blkSize+"x"+blkSize+"_x");
		foreach int j in 0 .. blkSize-1 do
			foreach int k in 0 .. blkSize-1 do
				print(ScanOrder[1][j*blkSize+k][0]+", ");
			end
			println();
		end
		println("horiz_scan"+blkSize+"x"+blkSize+"_y");
		foreach int j in 0 .. blkSize-1 do
			foreach int k in 0 .. blkSize-1 do
				print(ScanOrder[1][j*blkSize+k][1]+", ");
			end
			println();
		end
		println("vert_scan"+blkSize+"x"+blkSize+"_x");
		foreach int j in 0 .. blkSize-1 do
			foreach int k in 0 .. blkSize-1 do
				print(ScanOrder[2][j*blkSize+k][0]+", ");
			end
			println();
		end
		println("vert_scan"+blkSize+"x"+blkSize+"_y");
		foreach int j in 0 .. blkSize-1 do
			foreach int k in 0 .. blkSize-1 do
				print(ScanOrder[2][j*blkSize+k][1]+", ");
			end
			println();
		end
*/
	end
	
	/**************************************************************************
	 * InitScanningArray
 	 *************************************************************************/
	procedure luma_intra_pred_mode(
		uint(size=16) x0,
		uint(size=16) y0,
		uint(size= 8) pu_size,
        uint(size= 8) prev_intra_luma_pred_flag,
        uint(size= 8) mpm_idx_or_rem_intra_luma_pred_mode,
        uint(size= 8) ret[1],
        
        uint(size= 8) log2_min_pu_size,
        uint(size= 8) log2_ctb_size,
        uint(size= 8) intraPredMode[CTB_ADDR_TS_MAX][CTB_ADDR_TS_MAX])
	var
    	uint(size= 8) candidate[4],
    	uint(size=16) x_pu = x0 >> log2_min_pu_size,
    	uint(size=16) y_pu = y0 >> log2_min_pu_size,
    	uint(size= 8) size_in_pus = pu_size >> log2_min_pu_size,
		uint(size= 8) cand_up  := if y_pu > 0 then intraPredMode[x_pu][y_pu-1] else INTRA_DC end,
    	uint(size= 8) cand_left = if x_pu > 0 then intraPredMode[x_pu-1][y_pu] else INTRA_DC end,
		uint(size=16) y_ctb = (y0 >> log2_ctb_size) << log2_ctb_size
	begin
//		println("luma_intra_pred_mode("+x0+", "+y0+", "+pu_size+", "+prev_intra_luma_pred_flag+", "+log2_min_pu_size+", "+log2_ctb_size+", "+cand_up+", "+cand_left+"");
	    // intra_pred_mode prediction does not cross vertical CTB boundaries
	    if (y0 - 1) < y_ctb then
        	cand_up := INTRA_DC;
        end
    	if cand_left = cand_up then
	        if cand_left < 2 then
            	candidate[0] := INTRA_PLANAR;
            	candidate[1] := INTRA_DC;
            	candidate[2] := INTRA_ANGULAR_26;
        	else
	            candidate[0] := cand_left;
            	candidate[1] := 2 + ((cand_left - 2 - 1 + 32) & 31);
            	candidate[2] := 2 + ((cand_left - 2 + 1) & 31);
        	end
    	else
        	candidate[0] := cand_left;
        	candidate[1] := cand_up;
        	if candidate[0] != INTRA_PLANAR and candidate[1] != INTRA_PLANAR then
	            candidate[2] := INTRA_PLANAR;
        	elsif candidate[0] != INTRA_DC and candidate[1] != INTRA_DC then
	            candidate[2] := INTRA_DC;
        	else 
	            candidate[2] := INTRA_ANGULAR_26;
        	end
    	end
		
    	if prev_intra_luma_pred_flag = 1 then
			ret[0] := candidate[mpm_idx_or_rem_intra_luma_pred_mode];
    	else
        	if candidate[0] > candidate[1] then
        		candidate[3] := candidate[0];
	            candidate[0] := candidate[1];
	            candidate[1] := candidate[3];
	        end
        	if candidate[0] > candidate[2] then
        		candidate[3] := candidate[0];
	            candidate[0] := candidate[2];
	            candidate[2] := candidate[3];
	        end
        	if candidate[1] > candidate[2] then
        		candidate[3] := candidate[1];
	            candidate[1] := candidate[2];
	            candidate[2] := candidate[3];
			end
	        ret[0] := mpm_idx_or_rem_intra_luma_pred_mode;
        	foreach int i in 0 .. 2 do
        	    if ret[0] >= candidate[i] then
            	    ret[0] := ret[0] + 1;
        		end
        	end
    	end
		foreach int i in 0 .. size_in_pus-1 do
			foreach int j in 0 .. size_in_pus-1 do
				intraPredMode[x_pu + i][y_pu + j] := ret[0];
			end
		end
	end
	/**************************************************************************
	 * getScanIdx
 	 *************************************************************************/
	function getScanIdx(
		uint(size= 8) predMode,
		uint(size= 8) log2TrafoSize,
		uint(size= 8) intraPredMode
	) --> uint(size=2) :
		if predMode = MODE_INTRA and log2TrafoSize < 4 then
			if intraPredMode >= 6 and intraPredMode <= 14 then
				SCAN_VER
			elsif intraPredMode >= 22 and intraPredMode <= 30 then
				SCAN_HOR
			else
				SCAN_ZIGZAG //SCAN_DIAG
			end
		else
			SCAN_ZIGZAG //SCAN_DIAG
		end
	end
end