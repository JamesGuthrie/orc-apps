/******************************************************************************
 * Definition of CommonPackage
 *****************************************************************************/
package synParser;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  common.CabacDecodeBinFunction.*;
import  common.CabacContextConstantHEVC.*;
import  common.CabacContextFunctionHEVC.*;
import  common.CabacParserFunctionHEVC.*;


unit Algo_ParserUtils :
	/**************************************************************************
	 * GLOBAL CONSTANT
 	 *************************************************************************/
 	 uint(size= 8) EPR_VALUE                   = 0x03;
 	 uint(size= 8) START_CODE_VALUE            = 0x01;
 	 uint(size= 9) START_CODE_FLAG             = 0x100;
	/**************************************************************************
	 * GLOBAL NAL UNIT TYPE
 	 *************************************************************************/
 	 uint(size= 6) NAL_UNIT_NON_IDR_AND_NON_CRA =  1;
 	 uint(size= 6) NAL_UNIT_CRA                 =  4;
 	 uint(size= 6) NAL_UNIT_IDR                 =  5;
 	 uint(size= 6) NAL_UNIT_SEI                 =  6;
 	 uint(size= 6) NAL_UNIT_SPS                 =  7;
 	 uint(size= 6) NAL_UNIT_PPS                 =  8;
 	 uint(size= 6) NAL_UNIT_AUD                 =  9;
 	 uint(size= 6) NAL_UNIT_FIL                 = 12;
 	 uint(size= 6) NAL_UNIT_APS                 = 14;
	/**************************************************************************
	 * GLOBAL SPS PPS
 	 *************************************************************************/
 	 uint(size= 6) NB_MAX_SPS					= 32;
 	 uint(size= 8) NB_MAX_PPS					= 32;
	 uint(size= 8) NB_MAX_PICS					= 32;
 	 uint(size= 6) MAX_TLAYER                   =  4; 
 	 uint(size= 6) MRG_MAX_NUM_CANDS            =  5;	 
	/**************************************************************************
	 * GLOBAL SLICE HEADER
 	 *************************************************************************/
	 uint(size= 3) I_SLICE                      =  0;
	 uint(size= 3) P_SLICE                      =  1;
	 uint(size= 3) B_SLICE                      =  2;
	 uint(size= 4) MAX_NUM_REF                  =  4;
	 uint(size= 4) MAX_NUM_REF_LC               =  8;
	 /// reference list index
	 uint(size= 3) REF_PIC_LIST_0               =  0;   ///< reference list 0
	 uint(size= 3) REF_PIC_LIST_1               =  1;   ///< reference list 1
  	 uint(size= 3) REF_PIC_LIST_C               =  2;   ///< combined reference list for uni-prediction in B-Slices
  	 /// Weighted prediction struct
  	 uint(size= 1) WP_PRESENT_FLAG              =  0;
  	 uint(size=32) WP_LOG2_WEIGHT_DENOM         =  1;
  	 uint(size=32) WP_I_WEIGHT                  =  2;
  	 uint(size=32) WP_I_OFFSET                  =  3;
	 uint(size=32) WP_W                         =  4;
  	 uint(size=32) WP_O                         =  5;
  	 uint(size=32) WP_OFFSET                    =  6;
  	 uint(size=32) WP_SHIFT                     =  7;
  	 uint(size=32) WP_ROUND                     =  8;
  	 uint(size= 3) WP_MAX_STRUCT                =  9;

	/**************************************************************************
	 * GLOBAL pcRPS STRUCT
 	 *************************************************************************/
	uint(size= 8) INTER_RPS_FLAG						=  0;
	uint(size= 8) NUM_NEGATIVE_PICS						=  1;
	uint(size= 8) NUM_POSITIVE_PICS						=  2;
	uint(size= 8) NUM_PICS								=  3;
	uint(size= 8) DELTA_IDX								=  4;
	uint(size= 8) DELTA_RPS_SIGN						=  5;
	uint(size= 8) ABS_DELTA_RPS							=  6;
	uint(size= 8) NUM_REF_IDC							=  7;
	uint(size= 8) DELTAPOC								=  8;
	uint(size= 8) USED									= DELTAPOC + NB_MAX_PICS;
	uint(size= 8) REF_IDC								= USED + NB_MAX_PICS;
	uint(size= 8) NUM_LONG_TERM_PICS					= REF_IDC + 1;
	uint(size= 8) POC									= NUM_LONG_TERM_PICS + 1;
	uint(size= 8) PC_RPS_STRUCT_SIZE					= POC + 1;
	/**************************************************************************
	 * parseShortTermRefPicSet
 	 *************************************************************************/
	procedure parseShortTermRefPicSet(
		uint(size=32) pps_id,
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE]
	)
	var
		uint(size=32) res[1],
		uint(size= 8) rIdx,
		 int(size=32) deltaRPS,
		 int(size=32) deltaPOC,
		 int(size=32) k    := 0,
		 int(size=32) k0   := 0,
		 int(size=32) k1   := 0,
		uint(size=32) prev := 0
   	begin
 		vld_u_name(  1, fifo, res, "inter_ref_pic_set_prediction_flag       "); pcRPS[pps_id][INTER_RPS_FLAG]		:= res[0];
		if res[0] = 1 then 	
  			vld_ue_name(    fifo, res, "delta_idx_minus1                        "); pcRPS[pps_id][DELTA_IDX]		:= res[0] + 1;
    		rIdx := pps_id - 1 - res[0];
    		vld_u_name(  1, fifo, res, "delta_rps_sign                          "); pcRPS[pps_id][DELTA_RPS_SIGN]	:= res[0];
    		vld_ue_name(    fifo, res, "abs_delta_rps_minus1                    "); pcRPS[pps_id][ABS_DELTA_RPS]	:= res[0] + 1;
    		deltaRPS := (1 - (pcRPS[rIdx][DELTA_RPS_SIGN]<<1)) * (res[0] + 1);
    		foreach uint(size=8) i in 0 ..  pcRPS[rIdx][NUM_PICS]-1 do
    			vld_u_name(  1, fifo, res, "ref_idc0                                ");
    			if res[0] = 0 then
	    			vld_u_name(  1, fifo, res, "ref_idc1                                ");
	    			res[0] := res[0] << 1;
    			end
    			if res[0] = 1 or res[0] = 2 then
    				if i < pcRPS[rIdx][NUM_PICS] then
    					deltaPOC := deltaRPS + pcRPS[rIdx][DELTAPOC+i];
    				else
    					deltaPOC := deltaRPS;
					end
			        if deltaPOC < 0 then
          				k0 := k0 + 1;
        			else 
          				k1 := k1 + 1;
        			end
        			k := k + 1; 			
    			end
    			pcRPS[pps_id][REF_IDC+i] := res[0];
    		end
    		pcRPS[pps_id][NUM_REF_IDC]       := pcRPS[rIdx][NUM_REF_IDC]+1;  
    		pcRPS[pps_id][NUM_PICS]          := k;
    		pcRPS[pps_id][NUM_NEGATIVE_PICS] := k0;
			pcRPS[pps_id][NUM_POSITIVE_PICS] := k1;
			sortDeltaPOC(pps_id, pcRPS);
  		else
    		vld_ue_name(    fifo, res, "num_negative_pics                       "); pcRPS[pps_id][NUM_NEGATIVE_PICS] := res[0];
    		vld_ue_name(    fifo, res, "num_positive_pics                       "); pcRPS[pps_id][NUM_POSITIVE_PICS] := res[0];
    		pcRPS[pps_id][NUM_PICS] := pcRPS[pps_id][NUM_NEGATIVE_PICS] + res[0];
    		if pcRPS[pps_id][NUM_NEGATIVE_PICS] != 0 then
    			foreach uint(size=8) i in 0 ..  pcRPS[pps_id][NUM_NEGATIVE_PICS]-1 do
	    			vld_ue_name(    fifo, res, "delta_poc_s0_minus1                     ");
					prev := prev-res[0]-1;
					pcRPS[pps_id][DELTAPOC+i] := prev;
					vld_u_name(  1, fifo, res, "used_by_curr_pic_s0_flag                "); pcRPS[pps_id][USED+i]       := res[0];
				end
			end
			prev := 0;
			if pcRPS[pps_id][NUM_POSITIVE_PICS] != 0 then
    			foreach uint(size=8) i in pcRPS[pps_id][NUM_NEGATIVE_PICS] .. pcRPS[pps_id][NUM_PICS]-1 do
	    			vld_ue_name(    fifo, res, "delta_poc_s1_minus1                     ");
					prev := prev-res[0]-1;
					pcRPS[pps_id][DELTAPOC+i] := prev;
					vld_u_name(  1, fifo, res, "used_by_curr_pic_s1_flag                "); pcRPS[pps_id][USED+i]       := res[0];
				end
			end
		end
		printDeltaPOC(pps_id, pcRPS);
	end
	/**************************************************************************
	 * sortDeltaPOC
 	 *************************************************************************/
	procedure sortDeltaPOC(
		uint(size=32) pps_id,
		uint(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE]
	)
	var
		 int(size=32) deltaPOC_v,
		 int(size= 1) used_v,
		uint(size=32) k,
		 int(size=32) tmp
	begin
		// sort in increasing order (smallest first)
		if pcRPS[pps_id][NUM_PICS] != 0 then
    		foreach uint(size=8) i in 1 ..  pcRPS[pps_id][NUM_PICS]-1 do
	   			deltaPOC_v := pcRPS[pps_id][DELTAPOC+i];
   				used_v     := pcRPS[pps_id][USED+i];
   				foreach uint(size=8) j in 0 ..  i-1 do
	   				k := i-1-j;
   					tmp := pcRPS[pps_id][DELTAPOC+j];
   					if deltaPOC_v < tmp then
	   					pcRPS[pps_id][DELTAPOC+k+1] := tmp;
   						pcRPS[pps_id][USED+k+1]     := pcRPS[pps_id][USED+k]; 
   						pcRPS[pps_id][DELTAPOC+k]   := deltaPOC_v;
	   					pcRPS[pps_id][USED+k]       := used_v;
   					end
   				end
	   		end
	   	end
	   	if (pcRPS[pps_id][NUM_NEGATIVE_PICS]>>1) != 0 then
   			k := pcRPS[pps_id][NUM_NEGATIVE_PICS] - 1;
			// flip the negative values to largest first
    		foreach uint(size=8) i in 0 ..  (pcRPS[pps_id][NUM_NEGATIVE_PICS]>>1)-1 do
	    		deltaPOC_v       := pcRPS[pps_id][DELTAPOC+i];
   				used_v           := pcRPS[pps_id][USED+i];
   				pcRPS[pps_id][DELTAPOC+i] := pcRPS[pps_id][DELTAPOC+k];
   				pcRPS[pps_id][USED+i]     := pcRPS[pps_id][USED+k]; 
   				pcRPS[pps_id][DELTAPOC+k] := deltaPOC_v;
   				pcRPS[pps_id][USED+k]     := used_v;
   				k := k - 1;
   			end
   		end
	end
	/**************************************************************************
	 * printDeltaPOC
 	 *************************************************************************/
	procedure printDeltaPOC(
		uint(size=32) pps_id,
		uint(size=32) pcRPS[NB_MAX_PPS][PC_RPS_STRUCT_SIZE]
	)
	begin
		if pcRPS[pps_id][NUM_PICS] != 0 then
  			print("DeltaPOC = { ");
  			foreach uint(size=8) i in 0 ..  pcRPS[pps_id][NUM_PICS]-1 do
	    		print(pcRPS[pps_id][DELTAPOC+i]);
    			if pcRPS[pps_id][USED+i] = 1 then
	    			print("* ");
    			else
	    			print(" ");
    			end
 			end		
 		end
 		if pcRPS[pps_id][INTER_RPS_FLAG] = 1 then
 			print("}, RefIdc = { ");
			if pcRPS[pps_id][NUM_REF_IDC] != 0 then
  				foreach uint(size=8) i in 0 ..  pcRPS[pps_id][NUM_REF_IDC]-1 do
	  				print(pcRPS[pps_id][REF_IDC+i]+" ");
  				end
  			end
  		end
  		if pcRPS[pps_id][NUM_PICS] != 0 then
  			println("}");
  		end
	end
	/**************************************************************************
	 * sao_unit_cabac
 	 *************************************************************************/
	procedure sao_unit_cabac(
		uint(size= 8) rx,
		uint(size= 8) ry,
		uint(size= 8) cIdx,
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) CtbAddrInSlice,
		uint(size=32) AddrUp,
		uint(size= 1) slice_loop_filter_across_slices_enabled_flag
	)
	var
		uint(size=32) res[1] := [0],
		uint(size= 8) sao_type_idx
	begin
		if( rx > 0 and CtbAddrInSlice != 0 ) then
			get_SAO_MERGE_LEFT_FLAG(codIRange, codIOffset, ctxTable, fifo, res, cIdx);
		end
		if res[0] = 0 then
			if ry > 0 and ( AddrUp > 0 or slice_loop_filter_across_slices_enabled_flag = 1 ) then
				get_SAO_MERGE_UP_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			end
			if res[0] = 0 then
				get_SAO_OFFSET(codIRange, codIOffset, ctxTable, fifo);
			end
		end
	end
end