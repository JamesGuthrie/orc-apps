package testBench.deblockingFilter;

import interPrediction.NaluType.*;
import std.util.Math.*;

actor GenerateBs()
	uint(size=16) CUInfo,
	uint(size=4)  PartMode,
	bool          SplitTransf
		==>
		:

	uint(size=7)  nS;
	uint(size=3)  log2NS;
	uint(size=16) cuAddr[2];
	uint(size=2)  cuMode;
	uint(size=3)  numPart;
	uint(size=3)  numPartDecoded;

	int (size=4) trafoTreeDepth;
	uint(size=3) trafoTreeIdx[6];


	int sliceNum := 0;
	/* Updating the picture size. */
	isNewSliceOrPict: action PartMode:[partMode] ==>
	guard
		partMode = NEW_SLICE || partMode = NEW_PICT
	do
		println("Slice Num : "+sliceNum);
		sliceNum := sliceNum + 1;
	end

	/* Check when there are two parts in the CU.  */
	getPartMode.isNonQuadTree: action PartMode:[partMode] ==>
	guard
		partMode != NEW_SLICE && partMode != NEW_PICT,
		partMode != PART_2Nx2N && partMode != PART_NxN
	end

	/* Check if all parts of the CU are a square. */
	getPartMode.isQuadTree: action PartMode:[partMode] ==>
	guard
		partMode != NEW_SLICE  && partMode != NEW_PICT,
		partMode = PART_2Nx2N || partMode = PART_NxN
	do
		numPart := partModeToNumPart[partMode];
		numPartDecoded := 0;
	end

	/* Get the information concerning the CU to be able to save the values in
	 * currPict.
	 */
	getCuInfo.launch: action CUInfo:[cuInfo] repeat 5 ==>
	guard
		numPartDecoded < numPart
	do
		cuMode := cuInfo[0];
		nS := cuInfo[3];
		cuAddr := [cuInfo[1], cuInfo[2]];
		numPartDecoded := numPartDecoded + 1;
	end

	/* When there are two parts, we get both part in once in order to perform a
	 * raster scan on the square (the SelectCU actor reorder the differents
	 * blocks)
	 */
	getCuInfo.nonQT.isInter: action CUInfo:[cuInfo] repeat 10 ==>
	do
		cuMode := cuInfo[0];
		nS := max(cuInfo[3], cuInfo[4]);
		numPart := 2;
		numPartDecoded := 2;
		trafoTreeDepth  := 0;
		trafoTreeIdx[0] := 3;
	end

	getCuInfo.done: action ==>
	guard
		numPartDecoded = numPart
	end

	getCuMode.isNotOther: action ==>
	guard
		cuMode = INTER || cuMode = SKIP || cuMode = INTRA
	do
		trafoTreeDepth  := 0;
		trafoTreeIdx[0] := 3;
	end

	/* When it's neither an intra nor inter prediction CU, do neither
	 * prediction nor saving pixels' value
	 */
	getCuMode.isOther: action ==>
	guard
		cuMode = OTHER
	end

	getSplitTrafo.launch: action SplitTransf:[splitTrafo] ==>
	guard
		trafoTreeDepth>-1
	do
		if(splitTrafo) then
			trafoTreeDepth := trafoTreeDepth + 1;
			trafoTreeIdx[trafoTreeDepth] := 0;
		else
			trafoTreeIdx[trafoTreeDepth] := trafoTreeIdx[trafoTreeDepth] + 1;
			while(trafoTreeDepth > -1 && trafoTreeIdx[trafoTreeDepth] = 4)
			do
				trafoTreeDepth := trafoTreeDepth - 1;
				if(trafoTreeDepth>-1) then
					trafoTreeIdx[trafoTreeDepth] :=
						trafoTreeIdx[trafoTreeDepth] + 1;
				end
			end
		end
	end

	getSplitTrafo.done: action ==>
	guard
		trafoTreeDepth = -1
	end

	schedule fsm GetPartMode:
		GetPartMode(isNewSliceOrPict          )--> GetPartMode;
		GetPartMode(getPartMode.isQuadTree    )--> GetCuInfo;
		GetPartMode(getPartMode.isNonQuadTree )--> GetCuInfoNonQT;

		GetCuInfoNonQT (getCuInfo.nonQT )--> GetSplitTrafo;

		GetCuInfo (getCuInfo.launch )--> GetCuMode;
		GetCuInfo (getCuInfo.done   )--> GetPartMode;

		GetCuMode (getCuMode.isNotOther )--> GetSplitTrafo;
		GetCuMode (getCuMode.isOther    )--> GetCuInfo;

		GetSplitTrafo (getSplitTrafo.launch )--> GetSplitTrafo;
		GetSplitTrafo (getSplitTrafo.done   )--> GetCuInfo;
	end
end