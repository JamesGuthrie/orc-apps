package testBench.deblockingFilter;

import interPrediction.NaluType.*;
import std.util.Math.*;

actor GenerateBs()
	uint(size=16) CUInfo,
	uint(size=4)  PartMode,
	bool          SplitTransf
		==>
		:

	uint(size=16) PIC_WIDTH_MAX = 2048;
	uint(size=1) HORIZ = 0;
	uint(size=1) VERT = 1;


	uint(size=7)  nS;
	uint(size=16) cuAddr[2] := [-1,-1];
	uint(size=2)  cuMode;
	uint(size=3)  numPart;
	uint(size=3)  numPartDecoded;

	int (size=4) trafoTreeDepth;
	uint(size=3) trafoTreeIdx[6];

	bool vertEdgeFlagVal[16] :=
		[true, true, true, true, true, true, true, true, true, true, true,
		 true, true, true, true, true];
	bool horEdgeFlagVal[16]  :=
		[true, true, true, true, true, true, true, true, true, true, true,
		 true, true, true, true, true];

	bool edgeFlag[2][16][16];
	bool isTUEdge[2][16][16];
	int chromaPartWidth[16][16];


	uint(size=2) predModeTab[PIC_WIDTH_MAX/4][2*64/4];//
	bool cbfTab[PIC_WIDTH_MAX/4][2*64/4];//
	bool isBiPredTab[PIC_WIDTH_MAX/4][2*64/4];//
	int(size=16) refPocTab[PIC_WIDTH_MAX/4][2*64/4][2];//
	int(size=16) mvTab[PIC_WIDTH_MAX/4][2*64/4][2][2];//

	procedure rstEdgeTables(uint(size=16) addr[2])
	begin
		foreach int i in 0 .. 15
		do
			foreach int j in 0 .. 15
			do
				edgeFlag[VERT][i][j] := false;
				edgeFlag[HORIZ][i][j] := false;
				isTUEdge[VERT][i][j] := false;
				isTUEdge[HORIZ][i][j] := false;
			end
		end
		vertEdgeFlagVal[0] := (addr[0] != 0);
		horEdgeFlagVal[0] := (addr[1] != 0);
	end

	procedure processTUBoundaries()
	var
		uint(size=16) treeAddr[2],
		uint(size=7)  treeNS,
		uint(size=16) xMin,
		uint(size=16) xMax,
		uint(size=16) yMin,
		uint(size=16) yMax
	begin
		treeAddr := [cuAddr[i]: for int i in 0 .. 1];
		treeNS := nS;
		foreach uint idx in 1 .. trafoTreeDepth
		do
			treeNS := treeNS >> 1;
			if((trafoTreeIdx[idx]&1) != 0) then
				treeAddr[0] := treeAddr[0] + treeNS;
			end
			if((trafoTreeIdx[idx]&2) != 0) then
				treeAddr[1] := treeAddr[1] + treeNS;
			end
		end
		treeAddr[0] := (treeAddr[0]&63) >> 2;
		treeAddr[1] := (treeAddr[1]&63) >> 2;
		treeNS      := treeNS >> 2;
		xMin := treeAddr[0];
		yMin := treeAddr[1];
		xMax := xMin + treeNS;
		yMax := yMin + treeNS;
		foreach int x in xMin .. xMax-1
		do
			edgeFlag[HORIZ][x][yMin]   := horEdgeFlagVal[yMin];
			isTUEdge[HORIZ][x][yMin] := horEdgeFlagVal[yMin];
		end
		foreach int y in yMin .. yMax-1
		do
			edgeFlag[VERT][xMin][yMin] := vertEdgeFlagVal[xMin];
			edgeFlag[VERT][xMin][yMin] := vertEdgeFlagVal[xMin];
		end
	end

	procedure processPUBoundary(uint(size=16) addr[2], uint(size=8) puSize[2])
	var
		int xMin = (addr[0]&63)>>2,
		int xMax = xMin + (puSize[0]>>2),
		int yMin = (addr[1]&63)>>2,
		int yMax = yMin + (puSize[1]>>2)
	begin
		foreach uint x in xMin .. xMax-1
		do
			edgeFlag[HORIZ][x][yMin] := horEdgeFlagVal[yMin];
		end
		foreach uint y in yMin .. yMax-1
		do
			edgeFlag[VERT][xMin][y] := vertEdgeFlagVal[xMin];
		end
	end

	procedure genBoundFilterStrength(uint(size=2) bS[1], uint(size=16) addr[2], bool isVerticalEdge, uint(size=2) cIdx, bool isTUEdge)
	var
		uint(size=16) q0[2] = [(addr[0]/4)&(PIC_WIDTH_MAX/4-1), (addr[1]/4)&31],
		uint(size=16) p0[2] = if(isVerticalEdge) then [q0[0]-1, q0[1]]
			else [q0[0], (q0[1]-1)&31] end,
		int(size=16) tmpRefPoc,
		int(size=16) tmpMv,
		int(size=16) absMv[2][2],
		int(size=16) absMvQP[2][2]
	begin
		if(isVerticalEdge && ((addr[0]>>2)&1)=1) then
			bS[0] := 0;
		else if(not isVerticalEdge && ((addr[1]>>2)&1)=1) then
			bS[0] := 0;
		else if(predModeTab[p0[0]][p0[1]] = INTRA || predModeTab[q0[0]][q0[1]] = INTRA) then
			bS[0] := 2;
		else if(cIdx=0 && isTUEdge && (cbfTab[p0[0]][p0[1]] || cbfTab[q0[0]][q0[1]])) then
			bS[0] := 1;
		else
			if(isBiPredTab[p0[0]][p0[1]] && isBiPredTab[q0[0]][q0[1]] && refPocTab[p0[0]][p0[1]][0] = refPocTab[q0[0]][q0[1]][1]) then
				tmpRefPoc := refPocTab[q0[0]][q0[1]][1];
				refPocTab[q0[0]][q0[1]][1] := refPocTab[q0[0]][q0[1]][0];
				refPocTab[q0[0]][q0[1]][0] := tmpRefPoc;
				tmpMv := mvTab[q0[0]][q0[1]][0][0];
				mvTab[q0[0]][q0[1]][0][0] := mvTab[q0[0]][q0[1]][1][0];
				mvTab[q0[0]][q0[1]][1][0] := tmpMv;
				tmpMv := mvTab[q0[0]][q0[1]][0][1];
				mvTab[q0[0]][q0[1]][0][1] := mvTab[q0[0]][q0[1]][1][1];
				mvTab[q0[0]][q0[1]][1][1] := tmpMv;
			end
			if(isBiPredTab[p0[0]][p0[1]] != isBiPredTab[q0[0]][q0[1]] ||
			   refPocTab[p0[0]][p0[1]][0] != refPocTab[q0[0]][q0[1]][0] ||
			   isBiPredTab[p0[0]][p0[1]] && //L1
			   (refPocTab[p0[0]][p0[1]][1] != refPocTab[q0[0]][q0[1]][1])) then
				bS[0] := 1;
			else
				absMv[0][0] := abs(mvTab[p0[0]][p0[1]][0][0]- mvTab[q0[0]][q0[1]][0][0]);
				absMv[0][1] := abs(mvTab[p0[0]][p0[1]][0][1]- mvTab[q0[0]][q0[1]][0][1]);
				if(not isBiPredTab[p0[0]][p0[1]] && (absMv[0][0]>=4 || absMv[0][0]>=4))then
					bS[0] := 1;
				else
					absMv[1][0] := abs(mvTab[p0[0]][p0[1]][1][0]- mvTab[q0[0]][q0[1]][1][0]);
					absMv[1][1] := abs(mvTab[p0[0]][p0[1]][1][1]- mvTab[q0[0]][q0[1]][1][1]);
					if(isBiPredTab[p0[0]][p0[1]] &&
					   refPocTab[p0[0]][p0[1]][0] != refPocTab[p0[0]][p0[1]][1] &&
					   (absMv[0][0]>=4 || absMv[0][1]>=4 || absMv[1][0]>=4 || absMv[1][1]>=4)) then
						bS[0] := 1;
					else
						if(isBiPredTab[p0[0]][p0[1]] &&
						   refPocTab[p0[0]][p0[1]][0] = refPocTab[p0[0]][p0[1]][1]) then
							absMvQP[0][0] := abs(mvTab[p0[0]][p0[1]][0][0]- mvTab[q0[0]][q0[1]][1][0]);
							absMvQP[0][1] := abs(mvTab[p0[0]][p0[1]][0][1]- mvTab[q0[0]][q0[1]][1][1]);
							absMvQP[1][0] := abs(mvTab[p0[0]][p0[1]][1][0]- mvTab[q0[0]][q0[1]][0][0]);
							absMvQP[1][1] := abs(mvTab[p0[0]][p0[1]][1][1]- mvTab[q0[0]][q0[1]][0][1]);
							if((absMv[0][0]>=4 || absMv[0][1]>=4 || absMv[1][0]>=4 || absMv[1][1]>=4) &&
							   (absMvQP[0][0]>=4 || absMvQP[0][1]>=4 || absMvQP[1][0]>=4
							   || absMvQP[1][1]>=4)) then
								bS[0] := 1;
							else
								bS[0] := 0;
							end
						else
							bS[0] := 0;
						end
					end
				end
			end
		end end end end
	end

	int sliceNum := 0;
	/* Updating the picture size. */
	isNewSliceOrPict: action PartMode:[partMode] ==>
	guard
		partMode = NEW_SLICE || partMode = NEW_PICT
	do
		println("Slice Num : "+sliceNum);
		sliceNum := sliceNum + 1;
	end

	/* Check when there are two parts in the CU.  */
	getPartMode.isNonQuadTree: action PartMode:[partMode] ==>
	guard
		partMode != NEW_SLICE && partMode != NEW_PICT,
		partMode != PART_2Nx2N && partMode != PART_NxN
	end

	/* Check if all parts of the CU are a square. */
	getPartMode.isQuadTree: action PartMode:[partMode] ==>
	guard
		partMode = PART_2Nx2N || partMode = PART_NxN
	do
		numPart := partModeToNumPart[partMode];
		numPartDecoded := 0;
	end

	/* Get the information concerning the CU to be able to save the values in
	 * currPict.
	 */
	getCuInfo.launch: action CUInfo:[cuInfo] repeat 5 ==>
	guard
		numPartDecoded < numPart
	do
		cuMode := cuInfo[0];
		nS := cuInfo[3];
		if((cuInfo[1]&~63) != (cuAddr[0]&~63) ||
		   (cuInfo[2]&~63) != (cuAddr[1]&~63)) then
			rstEdgeTables([cuInfo[1], cuInfo[2]]);
		end
		cuAddr := [cuInfo[1], cuInfo[2]];
		numPartDecoded := numPartDecoded + 1;
	end

	/* When there are two parts, we get both part in once in order to perform a
	 * raster scan on the square (the SelectCU actor reorder the differents
	 * blocks)
	 */
	getCuInfo.nonQT: action CUInfo:[cuInfo] repeat 10 ==>
	var
		uint(size=8) puSize[2]
	do
		cuMode := cuInfo[0];
		if((cuInfo[1]&~63) != (cuAddr[0]&~63) ||
		   (cuInfo[2]&~63) != (cuAddr[1]&~63)) then
			rstEdgeTables([cuInfo[1], cuInfo[2]]);
		end
		cuAddr := [cuInfo[1], cuInfo[2]];
		nS := max(cuInfo[3], cuInfo[4]);
		puSize := [cuInfo[3], cuInfo[4]];
		processPUBoundary(cuAddr, puSize);
		puSize := [cuInfo[8], cuInfo[9]];
		processPUBoundary([cuInfo[6], cuInfo[7]], puSize);
		numPart := 2;
		numPartDecoded := 2;
		trafoTreeDepth  := 0;
		trafoTreeIdx[0] := 3;
	end

	getCuInfo.done: action ==>
	guard
		numPartDecoded = numPart
	end

	getCuMode.isNotOther: action ==>
	guard
		cuMode = INTER || cuMode = SKIP || cuMode = INTRA
	do
		processPUBoundary(cuAddr, [nS, nS]);
		trafoTreeDepth  := 0;
		trafoTreeIdx[0] := 3;
	end

	/* When it's neither an intra nor inter prediction CU, do neither
	 * prediction nor saving pixels' value
	 */
	getCuMode.isOther: action ==>
	guard
		cuMode = OTHER
	end

	getSplitTrafo.launch: action SplitTransf:[splitTrafo] ==>
	guard
		trafoTreeDepth>-1
	do
		if(splitTrafo) then
			trafoTreeDepth := trafoTreeDepth + 1;
			trafoTreeIdx[trafoTreeDepth] := 0;
		else
			processTUBoundaries();

			trafoTreeIdx[trafoTreeDepth] := trafoTreeIdx[trafoTreeDepth] + 1;
			while(trafoTreeDepth > -1 && trafoTreeIdx[trafoTreeDepth] = 4)
			do
				trafoTreeDepth := trafoTreeDepth - 1;
				if(trafoTreeDepth>-1) then
					trafoTreeIdx[trafoTreeDepth] :=
						trafoTreeIdx[trafoTreeDepth] + 1;
				end
			end
		end
	end

	getSplitTrafo.done: action ==>
	guard
		trafoTreeDepth = -1
	end

	generateBS: action ==>
	var
		int(size=16) xMin = (cuAddr[0] & 63)>>2,
		int(size=16) xMax = xMin+(nS>>2),
		int(size=16) yMin = (cuAddr[0] & 63)>>2,
		int(size=16) yMax = yMin + (nS>>2),
		uint(size=2) bS[1],
		uint(size=16) addrBlk[2]
	do
		addrBlk := cuAddr;
		foreach int y in yMin .. yMax - 1
		do
			foreach int x in xMin .. xMax - 1
			do
				if(edgeFlag[VERT][x][y]) then
					genBoundFilterStrength(bS, addrBlk, true, 0, isTUEdge[VERT][x][y]);
				end
				if(edgeFlag[HORIZ][x][y]) then
					genBoundFilterStrength(bS, addrBlk, false, 0, isTUEdge[HORIZ][x][y]);
				end
				addrBlk[0] := addrBlk[0] + 4;
			end
			addrBlk[1] := addrBlk[1] + 4;
			addrBlk[0] := cuAddr[0];
		end
	end

	schedule fsm GetPartMode:
		GetPartMode(isNewSliceOrPict          )--> GetPartMode;
		GetPartMode(getPartMode.isQuadTree    )--> GetCuInfo;
		GetPartMode(getPartMode.isNonQuadTree )--> GetCuInfoNonQT;

		GetCuInfoNonQT (getCuInfo.nonQT )--> GetSplitTrafo;

		GetCuInfo (getCuInfo.launch )--> GetCuMode;
		GetCuInfo (getCuInfo.done   )--> GetPartMode;

		GetCuMode (getCuMode.isNotOther )--> GetSplitTrafo;
		GetCuMode (getCuMode.isOther    )--> GetCuInfo;

		GetSplitTrafo (getSplitTrafo.launch )--> GetSplitTrafo;
		GetSplitTrafo (getSplitTrafo.done   )--> GenerateBS;

		GenerateBS (generateBS )--> GetCuInfo;
	end
end