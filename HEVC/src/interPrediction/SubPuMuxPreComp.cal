/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
package interPrediction;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

actor SubPuMuxPreComp(uint(size=3) LOG2_NUM_SUB_BLK[2])
	uint(size=2)  IsBiPredOrLx,
	int (size=32) Mv,
	int (size=16) PocRef,
	uint(size=7)  PredCuSize,
	int (size=16) PredSampleIn1,
	int (size=16) PredSampleIn2
		==>
	int (size=16) PredSampleOut
		:

	uint(size=1)  numPocRef;
	bool          isBiPred;
	int (size=16) lastPocRef;
	int (size=32) lastMvRef[2];

	uint(size=7) puSize[2];
	uint(size=7) puSizeChr[2];

	uint(size=7) fullPuSize[2];
	uint(size=7) fullPuSizeChr[2];

	uint(size=7)  iLoop;
	uint(size=7)  jLoop;
	uint(size=2)  compIdx;

	uint(size=7) subPuIdxMin[16][16][2];
	uint(size=7) subPuIdxMax[16][16][2];

	getNewPred: action IsBiPredOrLx:[isBiPredOrLx] ==>
	do
		numPocRef :=
			if(isBiPredOrLx = BI_PRED) then
				2
			else
				1
			end;
		isBiPred := isBiPredOrLx = BI_PRED;
	end

	/* We get all the informations needed for sending the reference Cu. We save
	 * these samples in RefCu, it will be sent with the actions sendCu.isYxY
	 */
	getMvInfo.launch: action PocRef:[poc], PredCuSize:[predUnitSize] repeat 2,
		Mv:[mvX, mvY] ==>
	guard
		numPocRef != 0,
		not(isBiPred && numPocRef = 1 && lastPocRef = poc && lastMvRef[0] = mvX &&
			lastMvRef[1] = mvY)
	var
		uint(size=8) subPuIdx[2],
		uint(size=5) numPix,
		uint(size=5) blkRemain
	do
		fullPuSize    := [predUnitSize[i]   + 7: for int i in 0 .. 1];
		fullPuSizeChr := [predUnitSize[i]/2 + 3: for int i in 0 .. 1];
		puSize    := [predUnitSize[i]   : for int i in 0 .. 1];
		puSizeChr := [predUnitSize[i]/2 : for int i in 0 .. 1];
		iLoop   := 0;
		jLoop   := 0;
		lastPocRef := poc;
		lastMvRef  := [mvX, mvY];

		foreach uint yIdx in 0 .. (1<<LOG2_NUM_SUB_BLK[1])-1
		do
			foreach uint xIdx in 0 .. (1<<LOG2_NUM_SUB_BLK[0])-1
			do
				subPuIdx := [xIdx, yIdx];
				foreach uint i in 0 .. 1
				do
					numPix    := fullPuSize[i] >> LOG2_NUM_SUB_BLK[i];
					blkRemain := fullPuSize[i] - (numPix << LOG2_NUM_SUB_BLK[i]);
					subPuIdxMin[xIdx][yIdx][i] := subPuIdx[i] * numPix;
					if(subPuIdx[i] >= (1 << LOG2_NUM_SUB_BLK[i]) - blkRemain) then
						subPuIdxMin[xIdx][yIdx][i] := subPuIdxMin[xIdx][yIdx][i] + subPuIdx[i]
							- (1 << LOG2_NUM_SUB_BLK[i]) + blkRemain;
						numPix := numPix + 1;
					end
					subPuIdxMax[xIdx][yIdx][i] := subPuIdxMin[xIdx][yIdx][i] + numPix;
				end
			end
		end

		numPocRef := numPocRef - 1;
	end

	getMvInfo.skip: action PocRef:[poc], PredCuSize:[predUnitSize] repeat 2,
		Mv:[mvX, mvY] ==>
	guard
		isBiPred && numPocRef = 1 && lastPocRef = poc && lastMvRef[0] = mvX && lastMvRef[1] = mvY
	end

	getMvInfo.done: action ==>
	guard
		numPocRef = 0
	end

	getIntermPu.launch.lumaComp: action PredSampleIn1:[predSamp], PredSampleIn2:[predSamp2] ==> PredSampleOut:[predSamp]
	guard
		jLoop < fullPuSize[1]
	do
		iLoop := iLoop + 1;
		if(iLoop = puSize[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
		end
	end

	getIntermPu.launch.lumaDone: action ==>
	guard
		jLoop = fullPuSize[1]
	do
		iLoop   := 0;
		jLoop   := 0;
		compIdx := 1;
	end

	getIntermPu.launch.chromaComp: action PredSampleIn1:[predSamp], PredSampleIn2:[predSamp2] ==> PredSampleOut:[predSamp]
	guard
		compIdx < 3
	do
		iLoop := iLoop + 1;
		if(iLoop = puSizeChr[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
			if(jLoop = fullPuSizeChr[1]) then
				iLoop := 0;
				jLoop := 0;
				compIdx := compIdx + 1;
			end
		end
	end

	getIntermPu.done: action ==>
	guard
		compIdx = 3
	end

	schedule fsm GetNewPred:
		GetNewPred (getNewPred )--> GetMvInfo;

		GetMvInfo (getMvInfo.launch )--> GetIntermPuLuma;
		GetMvInfo (getMvInfo.skip   )--> GetNewPred;
		GetMvInfo (getMvInfo.done   )--> GetNewPred;

		GetIntermPuLuma (getIntermPu.launch.lumaComp )--> GetIntermPuLuma;
		GetIntermPuLuma (getIntermPu.launch.lumaDone )--> GetIntermPuChr;

		GetIntermPuChr (getIntermPu.launch.chromaComp )--> GetIntermPuChr;
		GetIntermPuChr (getIntermPu.done              )--> GetMvInfo;
	end
end