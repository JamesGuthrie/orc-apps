/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
package interPrediction;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

actor SubPuMuxPreComp(uint(size=3) LOG2_NUM_SUB_BLK[2])
	uint(size=2)  IsBiPredOrLx,
	int (size=32) Mv,
	int (size=16) PocRef,
	uint(size=7)  PredCuSize,
	int (size=16) PredSampleIn_0_0,
	int (size=16) PredSampleIn_1_0,
	int (size=16) PredSampleIn_0_1,
	int (size=16) PredSampleIn_1_1
		==>
	int (size=16) PredSampleOut
		:

	uint(size=1)  numPocRef;
	bool          isBiPred;
	int (size=16) lastPocRef;
	int (size=32) lastMvRef[2];

	uint(size=7) puSize[2];
	uint(size=7) puSizeChr[2];

	uint(size=7) fullPuSize[2];
	uint(size=7) fullPuSizeChr[2];

	uint(size=7)  iLoop;
	uint(size=7)  jLoop;
	uint(size=2)  compIdx;

	uint(size=13) tokenToSend;

	uint(size=7) subPuIdxMin[16][16][2][2];
	uint(size=7) subPuIdxMax[16][16][2][2];

	getNewPred: action IsBiPredOrLx:[isBiPredOrLx] ==>
	do
		numPocRef :=
			if(isBiPredOrLx = BI_PRED) then
				2
			else
				1
			end;
		isBiPred := isBiPredOrLx = BI_PRED;
	end
uint numMv;
	/* We get all the informations needed for sending the reference Cu. We save
	 * these samples in RefCu, it will be sent with the actions sendCu.isYxY
	 */
	getMvInfo.launch: action PocRef:[poc], PredCuSize:[predUnitSize] repeat 2,
		Mv:[mvX, mvY] ==>
	guard
		numPocRef != 0,
		not(isBiPred && numPocRef = 1 && lastPocRef = poc && lastMvRef[0] = mvX &&
			lastMvRef[1] = mvY)
	var
		uint(size=7) intermSize[2][2],
		uint(size=8) subPuIdx[2],
		uint(size=5) numPix,
		uint(size=5) blkRemain
	do
		numMv := numMv + 1;
		fullPuSize    := [predUnitSize[i]   + 7: for int i in 0 .. 1];
		fullPuSizeChr := [predUnitSize[i]/2 + 3: for int i in 0 .. 1];
		puSize    := [predUnitSize[i]   : for int i in 0 .. 1];
		puSizeChr := [predUnitSize[i]/2 : for int i in 0 .. 1];
		iLoop   := 0;
		jLoop   := 0;
		lastPocRef := poc;
		lastMvRef  := [mvX, mvY];

		intermSize[0][0] := puSize[0];
		intermSize[0][1] := fullPuSize[1];
		intermSize[1][0] := puSizeChr[0];
		intermSize[1][1] := fullPuSizeChr[1];
		foreach uint yIdx in 0 .. (1<<LOG2_NUM_SUB_BLK[1])-1
		do
			foreach uint xIdx in 0 .. (1<<LOG2_NUM_SUB_BLK[0])-1
			do
				subPuIdx := [xIdx, yIdx];
				foreach uint i in 0 .. 1
				do
					numPix    := intermSize[0][i] >> LOG2_NUM_SUB_BLK[i];
					blkRemain := intermSize[0][i] - (numPix << LOG2_NUM_SUB_BLK[i]);
					subPuIdxMin[xIdx][yIdx][0][i] := subPuIdx[i] * numPix;
					if(subPuIdx[i] >= (1 << LOG2_NUM_SUB_BLK[i]) - blkRemain) then
						subPuIdxMin[xIdx][yIdx][0][i] := subPuIdxMin[xIdx][yIdx][0][i] + subPuIdx[i]
							- (1 << LOG2_NUM_SUB_BLK[i]) + blkRemain;
						numPix := numPix + 1;
					end
					subPuIdxMax[xIdx][yIdx][0][i] := subPuIdxMin[xIdx][yIdx][0][i] + numPix;
				end
				foreach uint i in 0 .. 1
				do
					numPix    := intermSize[1][i] >> LOG2_NUM_SUB_BLK[i];
					blkRemain := intermSize[1][i] - (numPix << LOG2_NUM_SUB_BLK[i]);
					subPuIdxMin[xIdx][yIdx][1][i] := subPuIdx[i] * numPix;
					if(subPuIdx[i] >= (1 << LOG2_NUM_SUB_BLK[i]) - blkRemain) then
						subPuIdxMin[xIdx][yIdx][1][i] := subPuIdxMin[xIdx][yIdx][1][i] + subPuIdx[i]
							- (1 << LOG2_NUM_SUB_BLK[i]) + blkRemain;
						numPix := numPix + 1;
					end
					subPuIdxMax[xIdx][yIdx][1][i] := subPuIdxMin[xIdx][yIdx][1][i] + numPix;
				end
			end
		end
//		println("Sub 0 : subPuIdxMaxLuma " + subPuIdxMax[0][1][0][0] + " ; " + subPuIdxMax[0][1][0][1]);
//		println("Sub 0 : subPuIdxMinLuma " + subPuIdxMin[0][1][0][0] + " ; " + subPuIdxMin[0][1][0][1]);
//		println("Sub 0 : subPuIdxMaxChr "  + subPuIdxMax[0][1][1][0] + " ; " + subPuIdxMax[0][1][1][1]);
//		println("Sub 0 : subPuIdxMinChr "  + subPuIdxMin[0][1][1][0] + " ; " + subPuIdxMin[0][1][1][1]);
		numPocRef := numPocRef - 1;
	end

	getMvInfo.skip: action PocRef:[poc], PredCuSize:[predUnitSize] repeat 2,
		Mv:[mvX, mvY] ==>
	guard
		isBiPred && numPocRef = 1 && lastPocRef = poc && lastMvRef[0] = mvX && lastMvRef[1] = mvY
	end

	getMvInfo.done: action ==>
	guard
		numPocRef = 0
	end

	checkInputLuma.input_0_0: action ==>
	guard
		jLoop < fullPuSize[1],
		iLoop >= subPuIdxMin[0][0][0][0] && iLoop < subPuIdxMax[0][0][0][0] &&
		jLoop >= subPuIdxMin[0][0][0][1] && jLoop < subPuIdxMax[0][0][0][1]
	do
		tokenToSend := subPuIdxMax[0][0][0][0] - iLoop;
		iLoop := subPuIdxMax[0][0][0][0];
		if(iLoop = puSize[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
		end
	end

	checkInputLuma.input_1_0: action ==>
	guard
		jLoop < fullPuSize[1],
		LOG2_NUM_SUB_BLK[0] > 0,
		iLoop >= subPuIdxMin[1][0][0][0] && iLoop < subPuIdxMax[1][0][0][0] &&
		jLoop >= subPuIdxMin[1][0][0][1] && jLoop < subPuIdxMax[1][0][0][1]
	do
		tokenToSend := subPuIdxMax[1][0][0][0] - iLoop;
		iLoop := subPuIdxMax[1][0][0][0];
		if(iLoop = puSize[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
		end
	end

	checkInputLuma.input_0_1: action ==>
	guard
		jLoop < fullPuSize[1],
		LOG2_NUM_SUB_BLK[1] > 0,
		iLoop >= subPuIdxMin[0][1][0][0] && iLoop < subPuIdxMax[0][1][0][0] &&
		jLoop >= subPuIdxMin[0][1][0][1] && jLoop < subPuIdxMax[0][1][0][1]
	do
		tokenToSend := subPuIdxMax[0][1][0][0] - iLoop;
		iLoop := subPuIdxMax[0][1][0][0];
		if(iLoop = puSize[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
		end
	end

	checkInputLuma.input_1_1: action ==>
	guard
		jLoop < fullPuSize[1],
		LOG2_NUM_SUB_BLK[0] > 0 && LOG2_NUM_SUB_BLK[1] > 0,
		iLoop >= subPuIdxMin[1][1][0][0] && iLoop < subPuIdxMax[1][1][0][0] &&
		jLoop >= subPuIdxMin[1][1][0][1] && jLoop < subPuIdxMax[1][1][0][1]
	do
		tokenToSend := subPuIdxMax[1][1][0][0] - iLoop;
		iLoop := subPuIdxMax[1][1][0][0];
		if(iLoop = puSize[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
		end
	end

	checkInputLuma.done: action ==>
	guard
		jLoop = fullPuSize[1]
	do
//		println("lumaDone");
		iLoop   := 0;
		jLoop   := 0;
		compIdx := 1;
	end

	checkInputChroma.input_0_0: action ==>
	guard
		compIdx < 3,
		iLoop >= subPuIdxMin[0][0][1][0] && iLoop < subPuIdxMax[0][0][1][0] &&
		jLoop >= subPuIdxMin[0][0][1][1] && jLoop < subPuIdxMax[0][0][1][1]
	do
		tokenToSend := subPuIdxMax[0][0][1][0] - iLoop;
		iLoop := subPuIdxMax[0][0][1][0];
		if(iLoop = puSizeChr[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
			if(jLoop = fullPuSizeChr[1]) then
				iLoop := 0;
				jLoop := 0;
				compIdx := compIdx + 1;
			end
		end
	end

	checkInputChroma.input_1_0: action ==>
	guard
		compIdx < 3,
		iLoop >= subPuIdxMin[1][0][1][0] && iLoop < subPuIdxMax[1][0][1][0] &&
		jLoop >= subPuIdxMin[1][0][1][1] && jLoop < subPuIdxMax[1][0][1][1]
	do
		tokenToSend := subPuIdxMax[1][0][1][0] - iLoop;
		iLoop := subPuIdxMax[1][0][1][0];
		if(iLoop = puSizeChr[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
			if(jLoop = fullPuSizeChr[1]) then
				iLoop := 0;
				jLoop := 0;
				compIdx := compIdx + 1;
			end
		end
	end

	checkInputChroma.input_0_1: action ==>
	guard
		compIdx < 3,
		iLoop >= subPuIdxMin[0][1][1][0] && iLoop < subPuIdxMax[0][1][1][0] &&
		jLoop >= subPuIdxMin[0][1][1][1] && jLoop < subPuIdxMax[0][1][1][1]
	do
		tokenToSend := subPuIdxMax[0][1][1][0] - iLoop;
		iLoop := subPuIdxMax[0][1][1][0];
		if(iLoop = puSizeChr[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
			if(jLoop = fullPuSizeChr[1]) then
				iLoop := 0;
				jLoop := 0;
				compIdx := compIdx + 1;
			end
		end
	end

	checkInputChroma.input_1_1: action ==>
	guard
		compIdx < 3,
		iLoop >= subPuIdxMin[1][1][1][0] && iLoop < subPuIdxMax[1][1][1][0] &&
		jLoop >= subPuIdxMin[1][1][1][1] && jLoop < subPuIdxMax[1][1][1][1]
	do
		tokenToSend := subPuIdxMax[1][1][1][0] - iLoop;
		iLoop := subPuIdxMax[1][1][1][0];
		if(iLoop = puSizeChr[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
			if(jLoop = fullPuSizeChr[1]) then
				iLoop := 0;
				jLoop := 0;
				compIdx := compIdx + 1;
			end
		end
	end

	checkInputChroma.done: action ==>
	guard
		compIdx = 3
	end


	forward.input_0_0: action PredSampleIn_0_0:[in1] ==> PredSampleOut:[in1]
	guard
		tokenToSend > 0
	do
		tokenToSend := tokenToSend - 1;
	end

	forward.input_1_0: action PredSampleIn_1_0:[in2] ==> PredSampleOut:[in2]
	guard
		tokenToSend > 0
	do
		tokenToSend := tokenToSend - 1;
	end

	forward.input_0_1: action PredSampleIn_0_1:[in1] ==> PredSampleOut:[in1]
	guard
		tokenToSend > 0
	do
		tokenToSend := tokenToSend - 1;
	end

	forward.input_1_1: action PredSampleIn_1_1:[in2] ==> PredSampleOut:[in2]
	guard
		tokenToSend > 0
	do
		tokenToSend := tokenToSend - 1;
	end

	forward.done: action ==>
	guard
		tokenToSend = 0
	end



	schedule fsm GetNewPred:
		GetNewPred (getNewPred )--> GetMvInfo;

		GetMvInfo (getMvInfo.launch )--> CheckInLuma;
		GetMvInfo (getMvInfo.skip   )--> GetNewPred;
		GetMvInfo (getMvInfo.done   )--> GetNewPred;


		CheckInLuma (checkInputLuma.input_0_0 )--> ForwardIn_0_0_Luma;
		CheckInLuma (checkInputLuma.input_1_0 )--> ForwardIn_1_0_Luma;
		CheckInLuma (checkInputLuma.input_0_1 )--> ForwardIn_0_1_Luma;
		CheckInLuma (checkInputLuma.input_1_1 )--> ForwardIn_1_1_Luma;
		CheckInLuma (checkInputLuma.done      )--> CheckInChroma;

		ForwardIn_0_0_Luma (forward.input_0_0 )--> ForwardIn_0_0_Luma;
		ForwardIn_0_0_Luma (forward.done      )--> CheckInLuma;

		ForwardIn_1_0_Luma (forward.input_1_0 )--> ForwardIn_1_0_Luma;
		ForwardIn_1_0_Luma (forward.done      )--> CheckInLuma;

		ForwardIn_0_1_Luma (forward.input_0_1 )--> ForwardIn_0_1_Luma;
		ForwardIn_0_1_Luma (forward.done      )--> CheckInLuma;

		ForwardIn_1_1_Luma (forward.input_1_1 )--> ForwardIn_1_1_Luma;
		ForwardIn_1_1_Luma (forward.done      )--> CheckInLuma;


		CheckInChroma (checkInputChroma.input_0_0 )--> ForwardIn_0_0_Chroma;
		CheckInChroma (checkInputChroma.input_1_0 )--> ForwardIn_1_0_Chroma;
		CheckInChroma (checkInputChroma.input_0_1 )--> ForwardIn_0_1_Chroma;
		CheckInChroma (checkInputChroma.input_1_1 )--> ForwardIn_1_1_Chroma;
		CheckInChroma (checkInputChroma.done      )--> GetMvInfo;

		ForwardIn_0_0_Chroma (forward.input_0_0 )--> ForwardIn_0_0_Chroma;
		ForwardIn_0_0_Chroma (forward.done   )--> CheckInChroma;

		ForwardIn_1_0_Chroma (forward.input_1_0 )--> ForwardIn_1_0_Chroma;
		ForwardIn_1_0_Chroma (forward.done      )--> CheckInChroma;

		ForwardIn_0_1_Chroma (forward.input_0_1 )--> ForwardIn_0_1_Chroma;
		ForwardIn_0_1_Chroma (forward.done      )--> CheckInChroma;

		ForwardIn_1_1_Chroma (forward.input_1_1 )--> ForwardIn_1_1_Chroma;
		ForwardIn_1_1_Chroma (forward.done      )--> CheckInChroma;
	end
end