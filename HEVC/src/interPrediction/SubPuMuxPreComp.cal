/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
package interPrediction;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

actor SubPuMuxPreComp(uint(size=3) LOG2_NUM_SUB_BLK[2])
	uint(size=2)  IsBiPredOrLx,
	int (size=32) Mv,
	int (size=16) PocRef,
	uint(size=7)  PredCuSize
		==>
		:

	/* /!\ : Check the size of the border. */
	uint(size = 16) BORDER_SIZE = 128;

	uint(size=16) picSize[2];
	uint(size=1)  numPocRef;
	int (size=32) xMvOffset;
	int (size=32) yMvOffset;
	int (size=32) xMvOffChr;
	int (size=32) yMvOffChr;
	bool          isBiPred;
	int (size=16) lastPocRef;
	int (size=32) lastMvRef[2];

	getNewPred: action IsBiPredOrLx:[isBiPredOrLx] ==>
	do
		numPocRef :=
			if(isBiPredOrLx = BI_PRED) then
				2
			else
				1
			end;
		isBiPred := isBiPredOrLx = BI_PRED;
	end

	/* We get all the informations needed for sending the reference Cu. We save
	 * these samples in RefCu, it will be sent with the actions sendCu.isYxY
	 */
	getMvInfo.launch: action PocRef:[poc], PredCuSize:[predUnitSize] repeat 2,
		Mv:[mvX, mvY] ==>
	guard
		numPocRef != 0,
		not(isBiPred && numPocRef = 1 && lastPocRef = poc && lastMvRef[0] = mvX && lastMvRef[1] = mvY)
	var
		int(size=7)  sideMax,
		uint(size=7)  sideMaxChr
	do
		lastPocRef := poc;
		lastMvRef  := [mvX, mvY];
		sideMax := max(predUnitSize[0], predUnitSize[1]);
		sideMaxChr := sideMax >> 1;

		/* The mv components correspond to the absolute movement vector, that's
		 * why we don't need to add the address of the current Cu
		 */

		/* We remove 3 for each coordinate component, because for the luma
		 * prediction we need the 3 previous pixels
		 */
		xMvOffset := (mvX >> 2);
		xMvOffset := min(xMvOffset, picSize[0]+3);
		xMvOffset := max(xMvOffset, -(8 +3 -1) -(sideMax-1));
		xMvOffset := xMvOffset +BORDER_SIZE-3;
		yMvOffset := (mvY >> 2);
		yMvOffset := min(yMvOffset, picSize[1]+3);
		yMvOffset := max(yMvOffset, -(8 +3 -1) -(sideMax-1));
		yMvOffset := yMvOffset +BORDER_SIZE-3;

		/* We remove 1 for each coordinate component, because for the chroma
		 * prediction we need the previous pixel
		 */
		xMvOffChr := (mvX >> 3);
		xMvOffChr := min(xMvOffChr, picSize[0]/2+1);
		xMvOffChr := max(xMvOffChr, -(4 +1 -1) -(sideMaxChr-1));
		xMvOffChr := xMvOffChr +BORDER_SIZE/2-1;
		yMvOffChr := (mvY >> 3);
		yMvOffChr := min(yMvOffChr, picSize[1]/2+1);
		yMvOffChr := max(yMvOffChr, -(4 +1 -1) -(sideMaxChr-1));
		yMvOffChr := yMvOffChr +BORDER_SIZE/2-1;

		numPocRef := numPocRef - 1;
	end

	getMvInfo.skip: action PocRef:[poc], PredCuSize:[predUnitSize] repeat 2,
		Mv:[mvX, mvY] ==>
	guard
		isBiPred && numPocRef = 1 && lastPocRef = poc && lastMvRef[0] = mvX && lastMvRef[1] = mvY
	end

	getMvInfo.done: action ==>
	guard
		numPocRef = 0
	end

	schedule fsm GetNewPred:
		GetNewPred (getNewPred )--> GetMvInfo;

		GetMvInfo (getMvInfo.launch )--> GetMvInfo;
		GetMvInfo (getMvInfo.skip   )--> GetNewPred;
		GetMvInfo (getMvInfo.done   )--> GetNewPred;
	end
end