/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
package interPrediction;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

actor SubPuDemuxPreComp(uint(size=8) LOG2_NUM_SUB_BLK[2])
	uint(size=2)  IsBiPredOrLx,
	int (size=32) Mv,
	int (size=16) PocRef,
	uint(size=7)  PredCuSize,
	uint(size=8) PredSampleIn
		==>
	uint(size=8) Samp_0_0,
	uint(size=8) Samp_1_0
		:

	uint(size=1)  numPocRef;
	bool          isBiPred;
	int (size=16) lastPocRef;
	int (size=32) lastMvRef[2];

	uint(size=7) fullPuSize[2];
	uint(size=7) fullPuSizeChr[2];

	uint(size=7)  subPuIdxMin[8][8][2][2];
	uint(size=7)  subPuIdxMax[8][8][2][2];

	uint(size=13) tokenToSend[2];
	uint(size=13) tokenGot;
	uint(size=7)  iLoop;
	uint(size=7)  jLoop;

	getNewPred: action IsBiPredOrLx:[isBiPredOrLx] ==>
	do
		numPocRef :=
			if(isBiPredOrLx = BI_PRED) then
				2
			else
				1
			end;
		isBiPred := isBiPredOrLx = BI_PRED;
	end

	/* We get all the informations needed for sending the reference Cu. We save
	 * these samples in RefCu, it will be sent with the actions sendCu.isYxY
	 */
	getMvInfo.launch: action PocRef:[poc], PredCuSize:[predUnitSize] repeat 2,
		Mv:[mvX, mvY] ==>
	guard
		numPocRef != 0,
		not(isBiPred && numPocRef = 1 && lastPocRef = poc && lastMvRef[0] = mvX &&
			lastMvRef[1] = mvY)
	var
		uint(size=7) intermSize[2][2],
		uint(size=5) nbBlkInPu,
		uint(size=5) numBlk,
		uint(size=5) blkRemain,
		uint(size=6) idxSubBlk[2]
	do
		fullPuSize    := [predUnitSize[i]   + 7: for int i in 0 .. 1];
		fullPuSizeChr := [predUnitSize[i]/2 + 3: for int i in 0 .. 1];
		lastPocRef := poc;
		lastMvRef  := [mvX, mvY];
		tokenToSend[0] := fullPuSize[0] * fullPuSize[1];
		tokenToSend[1] := fullPuSizeChr[0] * fullPuSizeChr[1];
		numPocRef := numPocRef - 1;
		tokenGot := 0;

		intermSize := [[predUnitSize[0], fullPuSize[1]],
			[predUnitSize[0]/2, fullPuSizeChr[1]]];
		foreach uint xIdxSubBlk in 0 .. (1 << LOG2_NUM_SUB_BLK[0]) - 1
		do
			idxSubBlk[0] := xIdxSubBlk;
			foreach uint yIdxSubBlk in 0 .. (1 << LOG2_NUM_SUB_BLK[1]) - 1
			do
				idxSubBlk[1] := yIdxSubBlk;
				foreach uint i in 0 .. 1
				do
					nbBlkInPu := intermSize[0][i];
					numBlk    := nbBlkInPu>> LOG2_NUM_SUB_BLK[i];
					blkRemain := nbBlkInPu - (numBlk << LOG2_NUM_SUB_BLK[i]);
					subPuIdxMin[xIdxSubBlk][yIdxSubBlk][0][i] := idxSubBlk[i] * numBlk;
					if(idxSubBlk[i] >= (1 << LOG2_NUM_SUB_BLK[i]) - blkRemain) then
						subPuIdxMin[xIdxSubBlk][yIdxSubBlk][0][i] := subPuIdxMin[xIdxSubBlk][yIdxSubBlk][0][i] + idxSubBlk[i]
							- (1 << LOG2_NUM_SUB_BLK[i]) + blkRemain;
						numBlk := numBlk + 1;
					end
					subPuIdxMax[xIdxSubBlk][yIdxSubBlk][0][i] := subPuIdxMin[xIdxSubBlk][yIdxSubBlk][0][i] + numBlk;
		//			subPuSize[0][i]   := numBlk;
				end
				foreach uint i in 0 .. 1
				do
					nbBlkInPu := intermSize[1][i];
					numBlk    := nbBlkInPu>> LOG2_NUM_SUB_BLK[i];
					blkRemain := nbBlkInPu - (numBlk << LOG2_NUM_SUB_BLK[i]);
					subPuIdxMin[xIdxSubBlk][yIdxSubBlk][1][i] := idxSubBlk[i] * numBlk;
					if(idxSubBlk[i] >= (1 << LOG2_NUM_SUB_BLK[i]) - blkRemain) then
						subPuIdxMin[xIdxSubBlk][yIdxSubBlk][1][i] := subPuIdxMin[xIdxSubBlk][yIdxSubBlk][1][i] + idxSubBlk[i]
							- (1 << LOG2_NUM_SUB_BLK[i]) + blkRemain;
						numBlk := numBlk + 1;
					end
					subPuIdxMax[xIdxSubBlk][yIdxSubBlk][1][i] := subPuIdxMin[xIdxSubBlk][yIdxSubBlk][1][i] + numBlk;
		//			subPuSize[1][i]   := numBlk;
				end
			end
		end
	end

	getMvInfo.skip: action PocRef:[poc], PredCuSize:[predUnitSize] repeat 2,
		Mv:[mvX, mvY] ==>
	guard
		isBiPred && numPocRef = 1 && lastPocRef = poc && lastMvRef[0] = mvX && lastMvRef[1] = mvY
	end

	getMvInfo.done: action ==>
	guard
		numPocRef = 0
	end

	bool forwardToken[8][8];
	uint samp;

	getSample.luma.launch: action PredSampleIn:[sampIn] ==>
	guard
		tokenGot < tokenToSend[0]
	do
		samp := sampIn;
		forwardToken[0][0] :=
		   iLoop >= subPuIdxMin[0][0][0][0] && jLoop >= subPuIdxMin[0][0][0][1] &&
		   iLoop <  subPuIdxMax[0][0][0][0]+7 && jLoop <  subPuIdxMax[0][0][0][1];
		forwardToken[1][0] :=
		   iLoop >= subPuIdxMin[1][0][0][0] && jLoop >= subPuIdxMin[1][0][0][1] &&
		   iLoop <  subPuIdxMax[1][0][0][0]+7 && jLoop <  subPuIdxMax[1][0][0][1];
		iLoop := iLoop + 1;
		if(iLoop = fullPuSize[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
		end
		tokenGot := tokenGot + 1;
	end

	getSample.luma.done: action ==>
	guard
		tokenGot = tokenToSend[0]
	do
		tokenGot := 0;
		iLoop := 0;
		jLoop := 0;
	end

	getSample.chroma.launch: action PredSampleIn:[in1] ==>
	guard
		tokenGot < tokenToSend[1]
	do
		samp := in1;
		forwardToken[0][0] :=
			iLoop >= subPuIdxMin[0][0][1][0] && jLoop >= subPuIdxMin[0][0][1][1] &&
			iLoop < subPuIdxMax[0][0][1][0]+3 && jLoop <  subPuIdxMax[0][0][1][1];
		forwardToken[1][0] :=
			iLoop >= subPuIdxMin[1][0][1][0] && jLoop >= subPuIdxMin[1][0][1][1] &&
			iLoop < subPuIdxMax[1][0][1][0]+3 && jLoop <  subPuIdxMax[1][0][1][1];
		iLoop := iLoop + 1;
		if(iLoop = fullPuSizeChr[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
		end
		tokenGot := tokenGot + 1;
	end

	getSample.chroma.done: action ==>
	guard
		tokenGot = tokenToSend[1]
	do
		tokenGot := 0;
		iLoop := 0;
		jLoop := 0;
	end

	ForwardTo_0_0.launch: action ==> Samp_0_0:[samp]
	guard
		forwardToken[0][0]
	end

	ForwardTo_0_0.skip: action ==>
	guard
		not forwardToken[0][0]
	end

	ForwardTo_1_0.launch: action ==> Samp_1_0:[samp]
	guard
		forwardToken[1][0]
	end

	ForwardTo_1_0.skip: action ==>
	guard
		not forwardToken[1][0]
	end


	schedule fsm GetNewPred:
		GetNewPred (getNewPred )--> GetMvInfo;

		GetMvInfo (getMvInfo.launch )--> GetPixLuma;
		GetMvInfo (getMvInfo.skip   )--> GetNewPred;
		GetMvInfo (getMvInfo.done   )--> GetNewPred;

		GetPixLuma (getSample.luma.launch )--> ForwardLuma_0_0;
		GetPixLuma (getSample.luma.done   )--> GetPixChr1;

		ForwardLuma_0_0 (ForwardTo_0_0 )--> ForwardLuma_1_0;
		ForwardLuma_1_0 (ForwardTo_1_0 )--> GetPixLuma;

		GetPixChr1 (getSample.chroma.launch )--> ForwardChr1_0_0;
		GetPixChr1 (getSample.chroma.done   )--> GetPixChr2;

		ForwardChr1_0_0 (ForwardTo_0_0 )--> ForwardChr1_1_0;
		ForwardChr1_1_0 (ForwardTo_1_0 )--> GetPixChr1;

		GetPixChr2 (getSample.chroma.launch )--> ForwardChr2_0_0;
		GetPixChr2 (getSample.chroma.done   )--> GetMvInfo;

		ForwardChr2_0_0 (ForwardTo_0_0 )--> ForwardChr2_1_0;
		ForwardChr2_1_0 (ForwardTo_1_0 )--> GetPixChr2;
	end
end