/******************************************************************************
 * Definition of CabacContextFunction
 *****************************************************************************/
package common;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  org.sc29.wg11.common.CabacDecodeBinFunction.*;
import  org.sc29.wg11.common.CabacDebinarizationFunction.*;

import  common.CommonConstantHEVC.*;
import  common.CabacContextConstantHEVC.*;
import  common.CabacContextTableHEVC.*;
import  common.CabacContextFunctionHEVC.*;
//import  common.CabacDecodeBinFunction.*;

unit CabacParserFunctionHEVC :

	/*************************************************************************
	 * decodeBinTop
	 *************************************************************************/
	procedure decodeBinTop(
		uint(size= 9) ctxIdx,
		bool 		   bypassFlag,
		uint(size=32) binString[1],
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size= 8) se,
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size=7) state[1]	:= [0],
		uint(size=1) mps[1] 	:= [0],
		uint(size=1) binVal[1]	:= [0]
	begin
		if bypassFlag = true then
			decodeBypass(codIRange, codIOffset, binVal, fifo);			
			if DEBUG_CABAC then
				println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binVal[0]);
			end		
		else
			if se = SE_DUMMY and ctxIdx = 0 then
				decodeTerminate(codIRange, codIOffset, binVal, fifo);
				if DEBUG_CABAC then
					println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binVal[0]);
				end		
			else
				state[0]  := ctxTable[se][ctxIdx] >> 1;
				mps[0]    := ctxTable[se][ctxIdx]  & 1;
				if DEBUG_CABAC then
					println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]);
				end		
				decodeDecision(codIRange, codIOffset, state, mps, binVal, fifo);
				ctxTable[se][ctxIdx] := (state[0] << 1) + mps[0];
				if DEBUG_CABAC then
					println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]+" binVal := "+binVal[0]);
				end		
			end
		end
		binString[0] := (binString[0] << 1) + binVal[0];
	end
	/*************************************************************************
	 * decodeBinsEP
	 *************************************************************************/
	procedure decodeBinsEP(
		uint(size= 8) numBins,
		uint(size=32) binString[1],
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size=1) binVal[1]
	begin
		binString[0] := 0;
		if (numBins!=1) then
			foreach int i in 0 .. numBins-1 do
				binVal[0] := 0;
				decodeBypass(codIRange, codIOffset, binVal, fifo);			
				binString[0] := (binString[0] << 1) + binVal[0];
				if DEBUG_CABAC then
					println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binVal[0]);		
				end
			end
		else
			binVal[0] := 0;
			decodeBypass(codIRange, codIOffset, binVal, fifo);			
			binString[0] := (binString[0] << 1) + binVal[0];
			if DEBUG_CABAC then
				println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binVal[0]);
			end		
		end
	end
	/*************************************************************************
	 * get_SAO_Uflc
	 *************************************************************************/
	procedure get_SAO_Uflc(
		uint(size= 8) length,
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		decodeBinsEP(length, debinValue, codIRange, codIOffset, fifo);
	end
	/*************************************************************************
	 * get_SAO_MaxUvlc
	 *************************************************************************/
	procedure get_SAO_MaxUvlc(
		uint(size= 8) maxSymbol,
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=8) i := 1,
		uint(size=32) binString[1] := [0]
	begin
		debinValue[0] := 0;
		if maxSymbol != 0 then
			decodeBinsEP(1, binString, codIRange, codIOffset, fifo);
			if binString[0] != 0 then
				while i != maxSymbol do
					binString[0] := 0;
					decodeBinsEP(1, binString, codIRange, codIOffset, fifo);
					if binString[0] = 0 then
						debinValue[0] := i;
						i := maxSymbol-1;
					elsif i = maxSymbol-1 then
						debinValue[0] := maxSymbol;
					end
					i := i + 1;
				end
			end		
		end
	end
	/*************************************************************************
	 * get_SAO_MERGE_LEFT_FLAG
	 *************************************************************************/
	procedure get_SAO_MERGE_LEFT_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 9) ctxIdx
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" SAO_MERGE ==>");
		end
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_MERGE_LEFT_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SAO_MERGE = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_MERGE_UP_FLAG
	 *************************************************************************/
	procedure get_SAO_MERGE_UP_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" SAO_MERGE ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_MERGE_UP_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SAO_MERGE = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_TYPE_IDX
	 *************************************************************************/
	procedure get_SAO_TYPE_IDX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" SAO_TYPE_IDX ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_TYPE_IDX, fifo);
		if binString[0] = 0 then
			debinValue[0] := SAO_NOT_APPLIED;
		else
			binString[0] := 0;
			decodeBinsEP(1, binString, codIRange, codIOffset, fifo);
			if binString[0] = 0 then
				debinValue[0] := SAO_BAND;
			else
				debinValue[0] := SAO_EDGE;
			end
		end
		if DEBUG_CABAC then
			println(" SAO_TYPE_IDX = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_OFFSET_ABS
	 *************************************************************************/
	procedure get_SAO_OFFSET_ABS(
		uint(size= 8) offsetTh,
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" SAO_OFFSET_ABS ==> "+offsetTh);
		end
		get_SAO_MaxUvlc(offsetTh, codIRange, codIOffset, fifo, debinValue);
		if DEBUG_CABAC then
			println(" SAO_OFFSET_ABS = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_OFFSET_SIGN
	 *************************************************************************/
	procedure get_SAO_OFFSET_SIGN(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" SAO_OFFSET_SIGN ==>");
		end
		debinValue[0] := 0;
		decodeBinsEP(1, debinValue, codIRange, codIOffset, fifo);
		if DEBUG_CABAC then
			println(" SAO_OFFSET_SIGN = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_BAND_POSITION
	 *************************************************************************/
	procedure get_SAO_BAND_POSITION(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" SAO_BAND_POSITION ==>");
		end
		get_SAO_Uflc(5, codIRange, codIOffset, fifo, debinValue);
		if DEBUG_CABAC then
			println(" SAO_BAND_POSITION = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_EO
	 *************************************************************************/
	procedure get_SAO_EO(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" SAO_EO ==>");
		end
		decodeBinsEP(2, binString, codIRange, codIOffset, fifo);
		debinValue[0] := binString[0];
		if DEBUG_CABAC then
			println(" SAO_EO = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SPLIT_CODING_UNIT_FLAG
	 *************************************************************************/
	procedure get_SPLIT_CODING_UNIT_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		//
		uint(size= 8) depthSubPart,
		bool		  availableA,
		uint(size= 8) depthSubPartA,
		bool		  availableB,
		uint(size= 8) depthSubPartB
	)
	var
		uint(size= 9) ctxIdx,
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		ctxIdx	  := getCtx_SPLIT_CODING_UNIT_FLAG(depthSubPart, availableA, depthSubPartA, availableB, depthSubPartB);
		if DEBUG_CABAC then
			println(" SPLIT_CODING_UNIT_FLAG ==> ctxIdx := "+ctxIdx);
		end
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SPLIT_CODING_UNIT_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SPLIT_CODING_UNIT_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_PRED_MODE_FLAG
	 *************************************************************************/
	procedure get_PRED_MODE_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" PRED_MODE_FLAG ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_PRED_MODE_FLAG, fifo);
		debinValue[0] := MODE_INTER + binString[0];
		if DEBUG_CABAC then
			println(" PRED_MODE_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_PART_SIZE
	 *************************************************************************/
	procedure get_PART_SIZE(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" PART_SIZE ==>");
		end
		debinValue[0] := PART_2Nx2N;
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_PART_SIZE, fifo);
		if binString[0] = 0 then
			debinValue[0] := PART_NxN;
		end
		if DEBUG_CABAC then
			println(" PART_SIZE = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_PREV_INTRA_LUMA_PRED_FLAG
	 *************************************************************************/
	procedure get_PREV_INTRA_LUMA_PRED_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" PREV_INTRA_LUMA_PRED_FLAG ==>");
		end
		debinValue[0] := 0;
		decodeBinTop(0, false, debinValue, codIRange, codIOffset, ctxTable, SE_PREV_INTRA_LUMA_PRED_FLAG, fifo);
		if DEBUG_CABAC then
			println(" PREV_INTRA_LUMA_PRED_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_REM_INTRA_LUMA_PRED_MODE
	 *************************************************************************/
	procedure get_REM_INTRA_LUMA_PRED_MODE(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		 int(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" REM_INTRA_LUMA_PRED_MODE ==>");
		end
		decodeBinsEP(5, binString, codIRange, codIOffset, fifo);
		debinValue[0] := binString[0];
		if DEBUG_CABAC then
			println(" REM_INTRA_LUMA_PRED_MODE = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_MPM_IDX
	 *************************************************************************/
	procedure get_MPM_IDX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
 		uint(size=32) debinValue[1]
	)
	var
		uint(size= 8) binIdx := 0,
		uint(size= 1) debinCompleted[1] := [0],
		uint(size= 1) discard_suffix[1] := [0],		
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" MPM_IDX ==>");
		end
		debinValue[0] := 0;
		while debinCompleted[0] = 0 do
			decodeBinsEP(1, binString, codIRange, codIOffset, fifo);
			debinTU(binString[0], binIdx, DEBIN_TU2, debinCompleted, debinValue, discard_suffix);
			binIdx := binIdx + 1;
		end
		if DEBUG_CABAC then
			println(" MPM_IDX = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_INTRA_CHROMA_PRED_MODE
	 *************************************************************************/
	procedure get_INTRA_CHROMA_PRED_MODE(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" INTRA_CHROMA_PRED_MODE ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_INTRA_CHROMA_PRED_MODE, fifo);
		if binString[0] = 0 then
			debinValue[0] := 4;
		else
			binString[0] := 0;
			decodeBinsEP(2, binString, codIRange, codIOffset, fifo);
			debinValue[0] := binString[0];
		end
		if DEBUG_CABAC then
			println(" INTRA_CHROMA_PRED_MODE = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SPLIT_TRANSFORM_FLAG
	 *************************************************************************/
	procedure get_SPLIT_TRANSFORM_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 3) log2TransformBlockSize
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" SPLIT_TRANSFORM_FLAG ==> "+(5 - log2TransformBlockSize));
		end
		decodeBinTop(5 - log2TransformBlockSize, false, binString, codIRange, codIOffset, ctxTable, SE_SPLIT_TRANSFORM_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SPLIT_TRANSFORM_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_CBF_LUMA
	 *************************************************************************/
	procedure get_CBF_LUMA(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 3) trafoDepth
	)
	var
		uint(size= 9) ctxIdx = if (trafoDepth = 0) then 1 else 0 end,
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" CBF_LUMA ==> "+ctxIdx);
		end
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_CBF_LUMA, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" CBF_LUMA = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_CBF_CB_CR
	 *************************************************************************/
	procedure get_CBF_CB_CR(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 3) trafoDepth
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" CBF_CB_CR ==> "+trafoDepth);
		end
		decodeBinTop(trafoDepth, false, binString, codIRange, codIOffset, ctxTable, SE_CBF_CB_CR, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" CBF_CB_CR = "+debinValue[0]);
		end
	end

	/*************************************************************************
	 * get_TRANSFORM_SKIP_FLAG
	 *************************************************************************/
	procedure get_TRANSFORM_SKIP_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) rc_TType
		
	)
	var
		uint(size= 9) ctxIdx = if  rc_TType = TEXT_LUMA then 0 else 1 end,
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" TRANSFORM_SKIP_FLAG ==>");
		end
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_TRANSFORM_SKIP_FLAG, fifo);
		debinValue[0] := binString[0]; 
		if DEBUG_CABAC then
			println(" TRANSFORM_SKIP_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_LAST_SIGNIFICANT_COEFF_X_PREFIX
	 *************************************************************************/
	procedure get_LAST_SIGNIFICANT_COEFF_X_PREFIX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) log2TrafoWidth,
		uint(size= 8) cIdx
	)
	var
		uint(size= 9) ctxIdx,
		uint(size= 8) binIdx := 0,
		uint(size=32) binString[1] := [0],
		uint(size= 1) discard_suffix[1] := [0],
		uint(size= 1) debinCompleted[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_X_PREFIX ==> "+(1<<log2TrafoWidth));
		end
		while debinCompleted[0] = 0 do
			ctxIdx := context_92312(binIdx, log2TrafoWidth, cIdx);
			decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_LAST_SIGNIFICANT_COEFF_X_PREFIX, fifo);
			debinTU(binString[0], binIdx, (log2TrafoWidth << 1 ) - 2, debinCompleted, debinValue, discard_suffix);
			binIdx := binIdx + 1;
		end
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_X_PREFIX = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_LAST_SIGNIFICANT_COEFF_Y_PREFIX
	 *************************************************************************/
	procedure get_LAST_SIGNIFICANT_COEFF_Y_PREFIX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) log2TrafoHeight,
		uint(size= 8) cIdx
	)
	var
		uint(size= 9) ctxIdx,
		uint(size= 8) binIdx := 0,
		uint(size=32) binString[1] := [0],
		uint(size= 1) discard_suffix[1] := [0],
		uint(size= 1) debinCompleted[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_Y_PREFIX ==> "+(1<<log2TrafoHeight));
		end		
		while debinCompleted[0] = 0 do
			ctxIdx := context_92312(binIdx, log2TrafoHeight, cIdx);
			decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_LAST_SIGNIFICANT_COEFF_Y_PREFIX, fifo);
			debinTU(binString[0], binIdx, (log2TrafoHeight << 1 ) - 2, debinCompleted, debinValue, discard_suffix);
			binIdx := binIdx + 1;
		end
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_Y_PREFIX = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX
	 *************************************************************************/
	procedure get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) prefix
	)
	var
		uint(size= 8) binIdx := 0,
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_XY_SUFFIX ==>");
		end
		while debinCompleted[0] = 0 do
			decodeBinTop(0, true, binString, codIRange, codIOffset, ctxTable, SE_DUMMY, fifo);
			debinFL(binString[0], binIdx, (prefix>>1)-2, debinCompleted, debinValue);
			binIdx := binIdx + 1;
		end
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_XY_SUFFIX = "+debinValue[0]);
		end
	end	
	/*************************************************************************
	 * get_CODED_SUB_BLOCK_FLAG
	 *************************************************************************/
	procedure get_CODED_SUB_BLOCK_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],

		uint(size= 1) coded_sub_block_flag[8][8],
		uint(size=8) xC,
		uint(size=8) yC,
		uint(size=8) cIdx,	
		uint(size=8) log2TrafoSize
	)
	var
		uint(size= 9) ctxIdx[1],
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		context_93313(coded_sub_block_flag, xC, yC, cIdx, log2TrafoSize, ctxIdx);		
		if DEBUG_CABAC then
			println(" CODED_SUB_BLOCK_FLAG ==> "+ctxIdx[0]);
		end
		decodeBinTop(ctxIdx[0], false, binString, codIRange, codIOffset, ctxTable, SE_CODED_SUB_BLOCK_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" CODED_SUB_BLOCK_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SIGNIFICANT_COEFF_FLAG
	 *************************************************************************/
	procedure get_SIGNIFICANT_COEFF_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],

		uint(size= 1) coded_sub_block_flag[8][8],
		uint(size=8) xC,
		uint(size=8) yC,
		uint(size=8) cIdx,	
		uint(size=8) log2TrafoSize,
		uint(size=8) scanIdx
	)
	var
		uint(size= 9) ctxIdx[1],
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		context_93314(coded_sub_block_flag, xC, yC, cIdx, log2TrafoSize, scanIdx, ctxIdx);		
		if DEBUG_CABAC then
			println(" SIGNIFICANT_COEFF_FLAG ==> "+ctxIdx[0]);
		end
		decodeBinTop(ctxIdx[0], false, binString, codIRange, codIOffset, ctxTable, SE_SIGNIFICANT_COEFF_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SIGNIFICANT_COEFF_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_COEFF_ABS_LEVEL_GREATER1_FLAG
	 *************************************************************************/
	procedure get_COEFF_ABS_LEVEL_GREATER1_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		 int(size=32) debinValue[1],
		
		uint(size= 9) ctxIdx
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" COEFF_ABS_LEVEL_GREATER1_FLAG ==> "+ctxIdx);
		end
		debinValue[0] := 0;
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_COEFF_ABS_LEVEL_GREATER1_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);		
		if DEBUG_CABAC then
			println(" COEFF_ABS_LEVEL_GREATER1_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_COEFF_ABS_LEVEL_GREATER2_FLAG
	 *************************************************************************/
	procedure get_COEFF_ABS_LEVEL_GREATER2_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		
		uint(size= 8) cIdx,
		uint(size= 8) ctxSet
	)
	var
		uint(size= 9) ctxIdx = ctxSet + if cIdx != 0 then 4 else 0 end,
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" COEFF_ABS_LEVEL_GREATER2_FLAG ==> "+ctxIdx);
		end
		debinValue[0] := 0;
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_COEFF_ABS_LEVEL_GREATER2_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);		
		if DEBUG_CABAC then
			println(" COEFF_ABS_LEVEL_GREATER2_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_COEFF_SIGN_FLAG
	 *************************************************************************/
	procedure get_COEFF_SIGN_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" COEFF_SIGN_FLAG ==>");
		end
		debinValue[0] := 0;
		decodeBinsEP(1, debinValue, codIRange, codIOffset, fifo);		
		if DEBUG_CABAC then
			println(" COEFF_SIGN_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_COEFF_ABS_LEVEL
	 *************************************************************************/
	procedure get_COEFF_ABS_LEVEL(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		//
		uint(size= 8) rParam
	)
	var
		uint(size=16) prefix := 0,
		uint(size=32) codeWord[1] := [1]
	begin
		if DEBUG_CABAC then
			println(" COEFF_ABS_LEVEL ==> "+rParam);
		end
		while codeWord[0] = 1 do
			prefix      := prefix + 1;
			codeWord[0] := 0;
			decodeBinsEP(1, codeWord, codIRange, codIOffset, fifo);
		end
		codeWord[0] := 1 - codeWord[0];
		prefix		:= prefix - codeWord[0];
		if prefix < 3 then
			decodeBinsEP(rParam, codeWord, codIRange, codIOffset, fifo);
			debinValue[0] := (prefix<<rParam) + codeWord[0];
		else 
			decodeBinsEP(prefix-3+rParam, codeWord, codIRange, codIOffset, fifo);
			debinValue[0] := (((1<<(prefix-3))+3-1)<<rParam) + codeWord[0];
		end
		if DEBUG_CABAC then
			println(" COEFF_ABS_LEVEL = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_END_OF_SLICE_FLAG
	 *************************************************************************/
	procedure get_END_OF_SLICE_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" END_OF_SLICE_FLAG ==>");
		end
		decodeBinTop(0, false, debinValue, codIRange, codIOffset, ctxTable, SE_DUMMY, fifo);
		if DEBUG_CABAC then
			println(" END_OF_SLICE_FLAG = "+debinValue[0]);
		end
	end
	
end