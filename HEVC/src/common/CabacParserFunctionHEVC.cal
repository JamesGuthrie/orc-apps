/******************************************************************************
 * Definition of CabacContextFunction
 *****************************************************************************/
package common;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  org.sc29.wg11.common.CabacDecodeBinFunction.*;
import  org.sc29.wg11.common.CabacDebinarizationFunction.*;

import  common.CommonConstantHEVC.*;
import  common.CabacContextConstantHEVC.*;
import  common.CabacContextTableHEVC.*;
import  common.CabacContextFunctionHEVC.*;
//import  common.CabacDecodeBinFunction.*;

unit CabacParserFunctionHEVC :

	/*************************************************************************
	 * decodeBinTop
	 *************************************************************************/
	procedure decodeBinTop(
		uint(size= 9) ctxIdx,
		bool 		   bypassFlag,
		uint(size=32) binString[1],
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size= 8) se,
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size=7) state[1]	:= [0],
		uint(size=1) mps[1] 	:= [0],
		uint(size=1) binVal[1]	:= [0]
	begin
		if bypassFlag = true then
			decodeBypass(codIRange, codIOffset, binVal, fifo);			
			println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binVal[0]);		
		else
			if se = SE_DUMMY and ctxIdx = 0 then
				decodeTerminate(codIRange, codIOffset, binVal, fifo);
				println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]+" binVal := "+binVal[0]);		
			else
				state[0]  := ctxTable[se][ctxIdx] >> 1;
				mps[0]    := ctxTable[se][ctxIdx]  & 1;
				println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]);		
				decodeDecision(codIRange, codIOffset, state, mps, binVal, fifo);
				ctxTable[se][ctxIdx] := (state[0] << 1) + mps[0];
				println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]+" binVal := "+binVal[0]);		
			end
		end
		binString[0] := (binString[0] << 1) + binVal[0];
	end
	/*************************************************************************
	 * decodeBinsEP
	 *************************************************************************/
	procedure decodeBinsEP(
		uint(size= 8) numBins,
		uint(size=32) binString[1],
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size=1) binVal[1]
	begin
		binString[0] := 0;
		if (numBins!=1) then
			foreach int i in 0 .. numBins-1 do
				binVal[0] := 0;
				decodeBypass(codIRange, codIOffset, binVal, fifo);			
				binString[0] := (binString[0] << 1) + binVal[0];
				println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binString[0]);		
			end
		else
			binVal[0] := 0;
			decodeBypass(codIRange, codIOffset, binVal, fifo);			
			binString[0] := (binString[0] << 1) + binVal[0];
			println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binString[0]);		
		end
	end
	/*************************************************************************
	 * get_SAO_Uflc
	 *************************************************************************/
	procedure get_SAO_Uflc(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" SAO_Uflc ==>");
		end
		decodeBinsEP(5, debinValue, codIRange, codIOffset, fifo);
		if DEBUG_CABAC then
			println(" SAO_Uflc = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_MaxUvlc
	 *************************************************************************/
	procedure get_SAO_MaxUvlc(
		uint(size= 8) maxSymbol,
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=8) i := 1,
		uint(size=32) binString[1]
	begin
		if DEBUG_CABAC then
			println(" SAO_MaxUvlc ==> "+maxSymbol);
		end
		debinValue[0] := 0;
		if maxSymbol != 0 then
			decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_UVLC, fifo);
			if binString[0] != 0 then
				while i != maxSymbol do
					binString[0] := 0;
					decodeBinTop(1, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_UVLC, fifo);
					if binString[0] = 0 then
						debinValue[0] := i;
						i := maxSymbol-1;
					end
					i := i + 1;
				end
			end		
		end
		if DEBUG_CABAC then
			println(" SAO_MaxUvlc = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_MERGE_LEFT_FLAG
	 *************************************************************************/
	procedure get_SAO_MERGE_LEFT_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 9) ctxIdx
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_MERGE_LEFT_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SAO_MERGE_LEFT_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_MERGE_UP_FLAG
	 *************************************************************************/
	procedure get_SAO_MERGE_UP_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_MERGE_UP_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SAO_MERGE_UP_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_TYPE_IDX
	 *************************************************************************/
	procedure get_SAO_TYPE_IDX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size= 9) ctxIdx := 0,
		uint(size= 8) binIdx := 0, 
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1] := [0]		
	begin
		if DEBUG_CABAC then
			println(" SAO_TYPE_IDX ==>");
		end
		while debinCompleted[0] = 0 do
			decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_TYPE_IDX, fifo);
			debinU(binString[0], binIdx, debinCompleted, debinValue);
			ctxIdx := 1;
			binIdx := binIdx + 1;
		end
		if DEBUG_CABAC then
			println(" SAO_TYPE_IDX = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_BAND_POSITION
	 *************************************************************************/
	procedure get_SAO_BAND_POSITION(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		get_SAO_Uflc(codIRange, codIOffset, fifo, debinValue);
	end
	/*************************************************************************
	 * get_SAO_OFFSET_ABS
	 *************************************************************************/
	procedure get_SAO_OFFSET_ABS(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size= 8) offsetTh = (1<<3)-1,
		uint(size= 9) ctxIdx := 0,
		uint(size= 8) binIdx := 0,
		uint(size=32) binString[1] := [0],
		uint(size= 1) discard_suffix[1] := [0],
		uint(size= 1) debinCompleted[1] := [0]
	begin
		while debinCompleted[0] = 0 do
			decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_UVLC, fifo);
			debinTU(binString[0], binIdx, offsetTh, debinCompleted, debinValue, discard_suffix);
			ctxIdx := 1; 
			binIdx := binIdx + 1;
		end
	end
	/*************************************************************************
	 * get_SAO_OFFSET_SIGN
	 *************************************************************************/
	procedure get_SAO_OFFSET_SIGN(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1] := [0]
	begin
		decodeBinTop(0, true, binString, codIRange, codIOffset, ctxTable, SE_DUMMY, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
	end
	/*************************************************************************
	 * get_SAO_OFFSET
	 *************************************************************************/
	procedure get_SAO_OFFSET(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size= 8) typeIdx,
//		uint(size= 8) bandPosition,
		uint(size= 8) offsetTh = (1<<3)-1,
		 int(size=16) offset[4],
		uint(size= 8) length,
		 int(size=32) res[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" SAO_OFFSET ==>");
		end
		get_SAO_TYPE_IDX(codIRange, codIOffset, ctxTable, fifo, res);
		typeIdx := res[0] - 1;
		if res[0] != 0 then
			length := typeIdx; 
			if typeIdx = SAO_B0 then
				get_SAO_Uflc(codIRange, codIOffset, fifo, res);
				//bandPosition := res[0];
				foreach int i in 0 .. length do
					get_SAO_MaxUvlc(offsetTh, codIRange, codIOffset, ctxTable, fifo, res);
					offset[i] := res[0]; 
				end
				foreach int i in 0 .. length do
					if offset[i] != 0 then
						decodeBinTop(0, true, res, codIRange, codIOffset, ctxTable, SE_DUMMY, fifo);
						if res[0] != 0 then
							offset[i] := -offset[i];
						end 
					end
				end
			else
				get_SAO_MaxUvlc(offsetTh, codIRange, codIOffset, ctxTable, fifo, res);
				offset[0] := res[0]; 
				get_SAO_MaxUvlc(offsetTh, codIRange, codIOffset, ctxTable, fifo, res);
				offset[1] := res[0];
				get_SAO_MaxUvlc(offsetTh, codIRange, codIOffset, ctxTable, fifo, res);
				offset[2] := -res[0];
				get_SAO_MaxUvlc(offsetTh, codIRange, codIOffset, ctxTable, fifo, res);
				offset[3] := -res[0];
			end
		end
	end
	/*************************************************************************
	 * get_SPLIT_CODING_UNIT_FLAG
	 *************************************************************************/
	procedure get_SPLIT_CODING_UNIT_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		//
		uint(size= 8) depthSubPart,
		bool		   availableA,
		uint(size= 8) depthSubPartA,
		bool		   availableB,
		uint(size= 8) depthSubPartB
	)
	var
		uint(size= 9) ctxIdx,
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		ctxIdx	  := getCtx_SPLIT_CODING_UNIT_FLAG(depthSubPart, availableA, depthSubPartA, availableB, depthSubPartB);
		if DEBUG_CABAC then
			println(" SPLIT_CODING_UNIT_FLAG ==> ctxIdx := "+ctxIdx);
		end
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SPLIT_CODING_UNIT_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
//			println(" SPLIT_CODING_UNIT_FLAG = "+(depthSubPart+debinValue[0]));
		end
	end
	/*************************************************************************
	 * get_PRED_MODE_FLAG
	 *************************************************************************/
	procedure get_PRED_MODE_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" PRED_MODE_FLAG ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_PRED_MODE_FLAG, fifo);
		debinValue[0] := MODE_INTER + binString[0];
		if DEBUG_CABAC then
			println(" PRED_MODE_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_PART_SIZE
	 *************************************************************************/
	procedure get_PART_SIZE(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" PART_SIZE ==>");
		end
		debinValue[0] := PART_2Nx2N;
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_PART_SIZE, fifo);
		if binString[0] = 0 then
			debinValue[0] := PART_NxN;
		end
		if DEBUG_CABAC then
			println(" PART_SIZE = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_PREV_INTRA_LUMA_PRED
	 *************************************************************************/
	procedure get_PREV_INTRA_LUMA_PRED(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		 int(size=32) debinValue[1],
		uint(size= 8) mode
	)
	var
		uint(size= 8) partNum = if mode = PART_NxN then 4 else 1 end,
		uint(size= 1) mpmPred[4],
		 //int(size=32) preds[3] = [-1, -1, -1],
		 int(size=32) preds[3] = [0, 21, 24],
		uint(size= 8) predNum = 3,
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" PREV_INTRA_LUMA_PRED ==> "+mode);
		end
		foreach int j in 0 .. partNum-1 do
			binString[0] := 0;
			decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_PREV_INTRA_LUMA_PRED_FLAG, fifo);
			mpmPred[j] := binString[0];
		end
		foreach int j in 0 .. partNum-1 do
			if mpmPred[j] != 0 then
				binString[0] := 0;
				decodeBinTop(0, true, binString, codIRange, codIOffset, ctxTable, SE_DUMMY, fifo);
				if binString[0] != 0 then
					binString[0] := 0;
					decodeBinTop(0, true, binString, codIRange, codIOffset, ctxTable, SE_DUMMY, fifo);
					binString[0] := binString[0] + 1;			
				end
				debinValue[0] := preds[binString[0]];
			else
				decodeBinsEP(5, binString, codIRange, codIOffset, fifo);
				debinValue[0] := binString[0];
				foreach int i in 0 .. predNum-1 do
					debinValue[0] := debinValue[0] + if debinValue[0] >= preds[i] then 1 else 0 end;
				end
			end
			if DEBUG_CABAC then
				println(" PREV_INTRA_LUMA_PRED["+j+"] = "+debinValue[0]);
			end
		end
	end
	/*************************************************************************
	 * get_INTRA_CHROMA_PRED_MODE
	 *************************************************************************/
	procedure get_INTRA_CHROMA_PRED_MODE(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 1) useLMChroma
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" INTRA_CHROMA_PRED_MODE ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_INTRA_CHROMA_PRED_MODE, fifo);
		if binString[0] = 0 then
			debinValue[0] := DM_CHROMA_IDX;
		else
			binString[0] := 0;
			if useLMChroma = 1 then
				decodeBinTop(1, false, binString, codIRange, codIOffset, ctxTable, SE_INTRA_CHROMA_PRED_MODE, fifo);
			else
				binString[0] := 1;
			end
			if binString[0] = 0 then
				debinValue[0] := LM_CHROMA_IDX;
			else
				decodeBinsEP(2, binString, codIRange, codIOffset, fifo);
				debinValue[0] := binString[0];
			end
		end
	end
	/*************************************************************************
	 * get_SPLIT_TRANSFORM_FLAG
	 *************************************************************************/
	procedure get_SPLIT_TRANSFORM_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 3) log2TransformBlockSize
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" SPLIT_TRANSFORM_FLAG ==>");
		end
		decodeBinTop(log2TransformBlockSize, false, binString, codIRange, codIOffset, ctxTable, SE_SPLIT_TRANSFORM_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
	end
	/*************************************************************************
	 * get_CBF_LUMA
	 *************************************************************************/
	procedure get_CBF_LUMA(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 3) trafoDepth,
		uint(size= 8) log2TrafoSize,
		uint(size= 8) Log2MaxTrafoSize
	)
	var
		uint(size= 9) ctxIdx = if (trafoDepth = 0) or (log2TrafoSize = Log2MaxTrafoSize) then 1 else 0 end,
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" CBF_LUMA ==> "+ctxIdx);
		end
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_CBF_LUMA, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
	end
	/*************************************************************************
	 * get_CBF_CB_CR
	 *************************************************************************/
	procedure get_CBF_CB_CR(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 3) trafoDepth
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" CBF_CB_CR ==> "+trafoDepth);
		end
		decodeBinTop(trafoDepth, false, binString, codIRange, codIOffset, ctxTable, SE_CBF_CB_CR, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
	end
	/*************************************************************************
	 * get_LAST_SIGNIFICANT_COEFF_X_PREFIX
	 *************************************************************************/
	procedure get_LAST_SIGNIFICANT_COEFF_X_PREFIX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) log2TrafoWidth,
		uint(size= 8) cIdx
	)
	var
		uint(size= 9) ctxIdx,
		uint(size= 8) binIdx := 0,
		uint(size=32) binString[1] := [0],
		uint(size= 1) discard_suffix[1] := [0],
		uint(size= 1) debinCompleted[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_X_PREFIX ==> "+log2TrafoWidth);
		end
		while debinCompleted[0] = 0 do
			ctxIdx := context_92312(binIdx, log2TrafoWidth, cIdx);
			decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_LAST_SIGNIFICANT_COEFF_X_PREFIX, fifo);
			debinTU(binString[0], binIdx, log2TrafoWidth, debinCompleted, debinValue, discard_suffix);
			binIdx := binIdx + 1;
		end
	end
	/*************************************************************************
	 * get_LAST_SIGNIFICANT_COEFF_Y_PREFIX
	 *************************************************************************/
	procedure get_LAST_SIGNIFICANT_COEFF_Y_PREFIX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) log2TrafoHeight,
		uint(size= 8) cIdx
	)
	var
		uint(size= 9) ctxIdx,
		uint(size= 8) binIdx := 0,
		uint(size=32) binString[1] := [0],
		uint(size= 1) discard_suffix[1] := [0],
		uint(size= 1) debinCompleted[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_Y_PREFIX ==> "+log2TrafoHeight);
		end
		while debinCompleted[0] = 0 do
			ctxIdx := context_92312(binIdx, log2TrafoHeight, cIdx);
			decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_LAST_SIGNIFICANT_COEFF_Y_PREFIX, fifo);
			debinTU(binString[0], binIdx, log2TrafoHeight, debinCompleted, debinValue, discard_suffix);
			binIdx := binIdx + 1;
		end
	end
	/*************************************************************************
	 * get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX
	 *************************************************************************/
	procedure get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) prefix
	)
	var
		uint(size= 8) binIdx := 0,
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_XY_SUFFIX ==>");
		end
		while debinCompleted[0] = 0 do
			decodeBinTop(0, true, binString, codIRange, codIOffset, ctxTable, SE_DUMMY, fifo);
			debinFL(binString[0], binIdx, (prefix>>1)-2, debinCompleted, debinValue);
			binIdx := binIdx + 1;
		end
	end	
	/*************************************************************************
	 * get_SIGNIFICANT_COEFF_GROUP_FLAG
	 *************************************************************************/
	procedure get_SIGNIFICANT_COEFF_GROUP_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" SIGNIFICANT_COEFF_GROUP_FLAG ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_SIGNIFICANT_COEFF_GROUP_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
	end
	/*************************************************************************
	 * get_SIGNIFICANT_COEFF_FLAG
	 *************************************************************************/
	procedure get_SIGNIFICANT_COEFF_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],

		uint(size=8) patternSigCtx,
		uint(size=8) posX,
		uint(size=8) posY,		
		uint(size=8) blockType,
		uint(size=8) textureType
	)
	var
		uint(size= 9) ctxIdx[1],
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		context_92314(patternSigCtx, posX, posY, blockType, textureType, ctxIdx);		
		if DEBUG_CABAC then
			println(" SIGNIFICANT_COEFF_FLAG ==> "+ctxIdx[0]);
		end
		decodeBinTop(ctxIdx[0], false, binString, codIRange, codIOffset, ctxTable, SE_SIGNIFICANT_COEFF_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
	end
	procedure get_SIGNIFICANT_COEFF_FLAG_old(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],

		uint(size=8) log2TrafoWidth,
		uint(size=8) log2TrafoHeight,
		uint(size=8) xC,
		uint(size=8) yC,		
		uint(size=8) cIdx,
		uint(size=8) significant_coeff_flag[BLW_WIDTH_MAX][BLW_HEIGHT_MAX]
	)
	var
		uint(size= 9) ctxIdx[1],
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		context_92314_old(log2TrafoWidth, log2TrafoHeight, xC, yC, cIdx, significant_coeff_flag, ctxIdx);		
		if DEBUG_CABAC then
			println(" SIGNIFICANT_COEFF_FLAG ==> "+ctxIdx[0]);
		end
		decodeBinTop(ctxIdx[0], false, binString, codIRange, codIOffset, ctxTable, SE_SIGNIFICANT_COEFF_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
	end
	/*************************************************************************
	 * get_ONE_FLAG
	 *************************************************************************/
	procedure get_ONE_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		
		uint(size= 9) ctxIdx
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" ONE_FLAG ==> "+ctxIdx);
		end
		debinValue[0] := 0;
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_ONE_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);		
	end
	/*************************************************************************
	 * get_ABS_FLAG
	 *************************************************************************/
	procedure get_ABS_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" ABS_FLAG ==>");
		end
		debinValue[0] := 0;
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_ABS_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);		
	end
	/*************************************************************************
	 * get_Coef
	 *************************************************************************/
	procedure get_Coef(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		//
		uint(size= 8) rParam
	)
	var
		uint(size=16) prefix := 0,
		uint(size=32) codeWord[1] := [1]
	begin
		if DEBUG_CABAC then
			println(" xReadCoefRemainExGolomb ==> "+rParam);
		end
		while codeWord[0] = 1 do
			prefix      := prefix + 1;
			decodeBinsEP(1, codeWord, codIRange, codIOffset, fifo);
		end
		codeWord[0] := 1 - codeWord[0];
		prefix		:= prefix - codeWord[0];
		if prefix < 8 then
			decodeBinsEP(rParam, codeWord, codIRange, codIOffset, fifo);
			debinValue[0] := (prefix<<rParam) + codeWord[0];
		else 
			decodeBinsEP(prefix-8+rParam, codeWord, codIRange, codIOffset, fifo);
			debinValue[0] := (((1<<(prefix-8))+8-1)<<rParam) + codeWord[0];
		end
	end
end