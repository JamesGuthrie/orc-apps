/******************************************************************************
 * Definition of CabacContextFunction
 *****************************************************************************/
package common;

import  org.sc29.wg11.common.BitstreamReadUtils.*;

import  common.CabacContextConstantHEVC.*;
import  common.CabacContextTableHEVC.*;
import  common.CabacContextFunctionHEVC.*;
import  common.CabacDecodeBinFunction.*;
import  org.sc29.wg11.common.CabacDebinarizationFunction.*;

unit CabacParserFunctionHEVC :

	/*************************************************************************
	 * decodeBinTop
	 *************************************************************************/
	procedure decodeBinTop(
		uint(size= 9) ctxIdx,
		bool 		   bypassFlag,
		uint(size=32) binString[1],
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size= 8) se,
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size=7) state[1]	:= [0],
		uint(size=1) mps[1] 	:= [0],
		uint(size=1) binVal[1]	:= [0]
	begin
		if bypassFlag = true then
			decodeBypass(codIRange, codIOffset, binVal, fifo);			
			println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binVal[0]);		
		else
			if se = SE_DUMMY and ctxIdx = 0 then
				decodeTerminate(codIRange, codIOffset, binVal, fifo);
				println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]+" binVal := "+binVal[0]);		
			else
				state[0]  := ctxTable[se][ctxIdx] >> 1;
				mps[0]    := ctxTable[se][ctxIdx]  & 1;
				println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]);		
				decodeDecision(codIRange, codIOffset, state, mps, binVal, fifo);
				ctxTable[se][ctxIdx] := (state[0] << 1) + mps[0];
				println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]+" binVal := "+binVal[0]);		
			end
		end
		binString[0] := (binString[0] << 1) + binVal[0];
	end
	/*************************************************************************
	 * decodeBinsEP
	 *************************************************************************/
	procedure decodeBinsEP(
		uint(size= 8) numBins,
		uint(size=32) binString[1],
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size=1) binVal[1]
	begin
		foreach int i in 0 .. numBins-1 do
			binVal[0] := 0;
			decodeBypass(codIRange, codIOffset, binVal, fifo);			
			println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binVal[0]);		
			binString[0] := (binString[0] << 1) + binVal[0];
		end
	end
	/*************************************************************************
	 * get_SAO_Uflc
	 *************************************************************************/
	procedure get_SAO_Uflc(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1]
	begin
		if DEBUG_CABAC then
			println(" SAO_Uflc ==>");
		end
		debinValue[0] := 0;
		foreach int i in 0 .. 4 do
			binString[0] := 0;
			decodeBinTop(0, true, binString, codIRange, codIOffset, ctxTable, SE_SAO_UVLC, fifo);
			debinValue[0] := debinValue[0] | (binString[0] << i);
		end
		if DEBUG_CABAC then
			println(" SAO_Uflc = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_Sflc
	 *************************************************************************/
	procedure get_SAO_Sflc(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		 int(size=32) debinValue[1]
	)
	var
		uint(size= 8) binIdx := 0, 
		uint(size=32) binString[1] := [0],
		uint(size=32) iSign[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" SAO_Sflc ==>");
		end
		debinValue[0] := 0;
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_SVLC, fifo);
		if binString[0] != 0 then
			decodeBinTop(1, false, iSign, codIRange, codIOffset, ctxTable, SE_SAO_SVLC, fifo);
			binString[0] := 1;
			while binString[0] != 0  do
				decodeBinTop(2, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_SVLC, fifo);
				binString[0] := 0;
				binIdx := binIdx + 1;
			end
			if iSign[0] = 0 then
				debinValue[0] :=  binIdx;
			else
				debinValue[0] := -binIdx;
			end
		end
			
		if DEBUG_CABAC then
			println(" SAO_Sflc = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_MERGE_LEFT_FLAG
	 *************************************************************************/
	procedure get_SAO_MERGE_LEFT_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 9) ctxIdx
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_MERGE_LEFT_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SAO_MERGE_LEFT_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_MERGE_UP_FLAG
	 *************************************************************************/
	procedure get_SAO_MERGE_UP_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_MERGE_UP_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SAO_MERGE_UP_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_TYPE_IDX
	 *************************************************************************/
	procedure get_SAO_TYPE_IDX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size= 8) binIdx := 0, 
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" SAO_TYPE_IDX ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_TYPE_IDX, fifo);
		while binString[0] != 0  do
			binString[0] := 0;
			decodeBinTop(1, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_TYPE_IDX, fifo);
			binIdx := binIdx + 1;
		end
		debinValue[0] := binIdx;
		if DEBUG_CABAC then
			println(" SAO_TYPE_IDX = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_BAND_POSITION
	 *************************************************************************/
	procedure get_SAO_BAND_POSITION(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		get_SAO_Uflc(codIRange, codIOffset, ctxTable, fifo, debinValue);
	end
	/*************************************************************************
	 * get_SAO_OFFSET
	 *************************************************************************/
	procedure get_SAO_OFFSET(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size= 8) typeIdx[1] := [0],
		 int(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" SAO_OFFSET ==>");
		end
		get_SAO_TYPE_IDX(codIRange, codIOffset, ctxTable, fifo, binString);
		if binString[0] != 0 then
			typeIdx[0] := binString[0] - 1;
			if typeIdx[0] = SAO_B0 then
				get_SAO_BAND_POSITION(codIRange, codIOffset, ctxTable, fifo, binString);
				foreach int i in 0 .. 3 do
					binString[0] := 0;
					get_SAO_Sflc(codIRange, codIOffset, ctxTable, fifo, binString);
				end
			else
				binString[0] := 0;
				get_SAO_Uflc(codIRange, codIOffset, ctxTable, fifo, binString);
				binString[0] := 0;
				get_SAO_Uflc(codIRange, codIOffset, ctxTable, fifo, binString);
				binString[0] := 0;
				get_SAO_Uflc(codIRange, codIOffset, ctxTable, fifo, binString);
				binString[0] := 0;
				get_SAO_Uflc(codIRange, codIOffset, ctxTable, fifo, binString);
			end
		end
	end
	/*************************************************************************
	 * get_SPLIT_CODING_UNIT_FLAG
	 *************************************************************************/
	procedure get_SPLIT_CODING_UNIT_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		//
		uint(size= 8) depthSubPart,
		bool		   availableA,
		uint(size= 8) depthSubPartA,
		bool		   availableB,
		uint(size= 8) depthSubPartB
	)
	var
		uint(size= 9) ctxIdx,
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		ctxIdx	  := getCtx_SPLIT_CODING_UNIT_FLAG(depthSubPart, availableA, depthSubPartA, availableB, depthSubPartB);
		if DEBUG_CABAC then
			println(" SPLIT_CODING_UNIT_FLAG ==> ctxIdx := "+ctxIdx);
		end
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SPLIT_CODING_UNIT_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
//			println(" SPLIT_CODING_UNIT_FLAG = "+(depthSubPart+debinValue[0]));
		end
	end
	/*************************************************************************
	 * get_PRED_MODE_FLAG
	 *************************************************************************/
	procedure get_PRED_MODE_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		bool           isIntra
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" PRED_MODE_FLAG ==>");
		end
		if not isIntra then
			decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_PRED_MODE_FLAG, fifo);
			debinValue[0] := /*MODE_INTER + */binString[0];
			if DEBUG_CABAC then
				println(" PRED_MODE_FLAG = "+debinValue[0]);
			end
		end
	end
	/*************************************************************************
	 * get_PART_SIZE
	 *************************************************************************/
	procedure get_PART_SIZE(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" PART_SIZE ==>");
		end
	end
	/*************************************************************************
	 * get_PREV_INTRA_LUMA_PRED_FLAG
	 *************************************************************************/
	procedure get_PREV_INTRA_LUMA_PRED_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" PREV_INTRA_LUMA_PRED_FLAG ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_PREV_INTRA_LUMA_PRED_FLAG, fifo);
		debinValue[0] := binString[0];
	end
	/*************************************************************************
	 * get_MPM_IDX
	 *************************************************************************/
	procedure get_MPM_IDX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		 int(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" MPM_IDX ==>");
		end
		decodeBinTop(0, true, binString, codIRange, codIOffset, ctxTable, SE_DUMMY, fifo);
		if binString[0] = 1 then
			decodeBinTop(0, true, binString, codIRange, codIOffset, ctxTable, SE_DUMMY, fifo);
		end
		debinValue[0] := -1; 
	end
	/*************************************************************************
	 * get_PREV_INTRA_LUMA_PRED
	 *************************************************************************/
	procedure get_PREV_INTRA_LUMA_PRED(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		 int(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" PREV_INTRA_LUMA_PRED ==>");
		end
		decodeBinsEP(5, binString, codIRange, codIOffset, fifo);
	end
	/*************************************************************************
	 * get_INTRA_CHROMA_PRED_MODE
	 *************************************************************************/
	procedure get_INTRA_CHROMA_PRED_MODE(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 1) useLMChroma
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" INTRA_CHROMA_PRED_MODE ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_INTRA_CHROMA_PRED_MODE, fifo);
		if binString[0] = 0 then
			debinValue[0] := DM_CHROMA_IDX;
		else
			binString[0] := 0;
			if useLMChroma = 1 then
				decodeBinTop(1, false, binString, codIRange, codIOffset, ctxTable, SE_INTRA_CHROMA_PRED_MODE, fifo);
			else
				binString[0] := 1;
			end
			if binString[0] = 0 then
				debinValue[0] := LM_CHROMA_IDX;
			else
				decodeBinsEP(2, binString, codIRange, codIOffset, fifo);
			end
		end
	end
	/*************************************************************************
	 * get_SPLIT_TRANSFORM_FLAG
	 *************************************************************************/
	procedure get_SPLIT_TRANSFORM_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 3) log2TransformBlockSize
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" SPLIT_TRANSFORM_FLAG ==>");
		end
		decodeBinTop(log2TransformBlockSize, false, binString, codIRange, codIOffset, ctxTable, SE_SPLIT_TRANSFORM_FLAG, fifo);
		debinValue[0] := binString[0];
	end
	
end