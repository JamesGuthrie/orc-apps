/******************************************************************************
 * Definition of CabacContextFunction
 *****************************************************************************/
package common;

import  org.sc29.wg11.common.BitstreamReadUtils.*;

import  common.CabacContextConstantHEVC.*;
import  common.CabacContextTableHEVC.*;
import  common.CabacContextFunctionHEVC.*;
import  common.CabacDecodeBinFunction.*;
import  org.sc29.wg11.common.CabacDebinarizationFunction.*;

unit CabacParserFunctionHEVC :

	/*************************************************************************
	 * decodeBinTop
	 *************************************************************************/
	procedure decodeBinTop(
		uint(size= 9) ctxIdx,
		bool 		   bypassFlag,
		uint(size=32) binString[1],
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size= 8) se,
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size=7) state[1]	:= [0],
		uint(size=1) mps[1] 	:= [0],
		uint(size=1) binVal[1]	:= [0]
	begin
		if bypassFlag = true then
			decodeBypass(codIRange, codIOffset, binVal, fifo);			
		else
			if se = SE_DUMMY and ctxIdx = 0 then
				decodeTerminate(codIRange, codIOffset, binVal, fifo);
			else
				state[0]  := ctxTable[se][ctxIdx] >> 1;
				mps[0]    := ctxTable[se][ctxIdx]  & 1;
				println("ctxIdx := "+ctxIdx+" codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]);			
				decodeDecision(codIRange, codIOffset, state, mps, binVal, fifo);
				ctxTable[se][ctxIdx] := (state[0] << 1) + mps[0];
			end
		end
		binString[0] := (binString[0] << 1) + binVal[0];
		println("ctxIdx := "+ctxIdx+" codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]+" binVal := "+binVal[0]);		
	end

	/*************************************************************************
	 * get_SAO_MERGE_LEFT_FLAG
	 *************************************************************************/
	procedure get_SAO_MERGE_LEFT_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 9) ctxIdx
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_MERGE_LEFT_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SAO_MERGE_LEFT_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_MERGE_UP_FLAG
	 *************************************************************************/
	procedure get_SAO_MERGE_UP_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_MERGE_UP_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SAO_MERGE_UP_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_TYPE_IDX
	 *************************************************************************/
	procedure get_SAO_TYPE_IDX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size= 9) ctxIdx := 0,
		uint(size= 8) binIdx := 0, 
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" SAO_TYPE_IDX ==>");
		end
		while debinCompleted[0] = 0  do
			decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_TYPE_IDX, fifo);
			debinFL(binString[0], binIdx, DEBIN_FL3, debinCompleted, debinValue);
			ctxIdx := 1;
			binIdx := binIdx + 1;
		end
		if DEBUG_CABAC then
			println(" SAO_TYPE_IDX = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_BAND_POSITION
	 *************************************************************************/
	procedure get_SAO_BAND_POSITION(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size= 8) binIdx := 0, 
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		while debinCompleted[0] = 0  do
			decodeBinTop(0, true, binString, codIRange, codIOffset, ctxTable, SE_SAO_BAND_POSITION, fifo);
			debinFL(binString[0], binIdx, DEBIN_FL5, debinCompleted, debinValue);
			binIdx := binIdx + 1;
		end
		if DEBUG_CABAC then
			println(" SAO_BAND_POSITION = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_OFFSET
	 *************************************************************************/
	procedure get_SAO_OFFSET(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size= 9) ctxIdx := 0,
		uint(size= 8) binIdx := 0, 
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		while debinCompleted[0] = 0  do
			decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_OFFSET, fifo);
			debinEG0(binString[0], binIdx, 0, debinCompleted, debinValue);
			ctxIdx := if binIdx = 0 then 1 else 2 end;
			binIdx := binIdx + 1;
		end
		if DEBUG_CABAC then
			println(" SAO_OFFSET = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SPLIT_CODING_UNIT_FLAG
	 *************************************************************************/
	procedure get_SPLIT_CODING_UNIT_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		//
		uint(size= 8) depthSubPart,
		bool		   availableA,
		uint(size= 8) depthSubPartA,
		bool		   availableB,
		uint(size= 8) depthSubPartB
	)
	var
		uint(size= 9) ctxIdx,
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		ctxIdx	  := getCtx_SPLIT_CODING_UNIT_FLAG(depthSubPart, availableA, depthSubPartA, availableB, depthSubPartB);
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SPLIT_CODING_UNIT_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SPLIT_CODING_UNIT_FLAG = "+(depthSubPart+debinValue[0]));
		end
	end
end