/******************************************************************************
 * Definition of CabacContextFunction
 *****************************************************************************/
package common;

import  std.util.Math.*;
import  common.CommonConstantHEVC.*;
import  common.CabacContextConstantHEVC.*;
import  common.CabacContextTableHEVC.*;

unit CabacContextFunctionHEVC :

	/*************************************************************************
	 * ContextInit
	 *************************************************************************/
	procedure contextInit(uint(size=8) qp, uint(size=8) sliceType, uint(size=9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX])
	var
		uint(size= 8) qp_clip3 = clip_i32(qp, 0, 51),
		uint(size= 8) initValue,
		 int(size= 8) slope,
		 int(size= 8) offset,
		uint(size= 8) initState,
		uint(size= 8) mpState,
		uint(size= 8) pStateIdx
	begin
		foreach uint(size=8) i in 0 .. NB_MAX_SE-1 do
			foreach uint(size=8) j in 0 .. NUM_SE_CONTEXT_INDEX[i]-1 do
				initValue	:= InitContextIndex[i][sliceType][j];
				slope		:= (initValue>>4)*5 - 45;
				offset		:= ((initValue & 15) << 3) - 16;
				initState   := clip_i32( ((qp_clip3*slope)>>4)+offset, 1, 126);
				mpState		:= if initState >= 64 then 1 else 0 end;
				pStateIdx	:= if initState >= 64 then initState - 64 else 63 - initState end;
				ctxTable[i][j] := (pStateIdx<<1) + mpState;
//				if i = SE_LAST_SIGNIFICANT_COEFF_X_PREFIX then
//					println(" initValue = "+initValue+" slope = "+slope+" offset = "+offset+" state = "+initState+" mps = "+mpState+" ucState = "+ctxTable[i][j]);
//				end
			end	
		end
	end
	/*************************************************************************
	 * getCtx_SPLIT_CODING_UNIT_FLAG
	 *************************************************************************/
	function getCtx_SPLIT_CODING_UNIT_FLAG(
		uint(size= 8) depthSubPart,
		bool		  availableA,
		uint(size= 8) depthSubPartA,
		bool		   availableB,
		uint(size= 8) depthSubPartB
	) --> uint(size=2) :
		uint(size=1) condTermA = if depthSubPartA > depthSubPart and availableA = true then 1 else 0 end;
		uint(size=1) condTermB = if depthSubPartB > depthSubPart and availableB = true then 1 else 0 end;
		condTermA + condTermB
	end
	/*************************************************************************
	 * Context_92312
	 *************************************************************************/
	uint(size=8) LASTCTX[28] = [
	 	0,  1,  2,  2,  3,  4,  5,  5,  2,  2,  6,  7,  8,  8,
	 	9,  9,  2,  2, 10, 11, 12, 12, 13, 13, 14, 14,  2,  2
	 	];
	function context_92312(
		uint(size=8) binIdx,
		uint(size=8) log2TrafoSize,
		uint(size=8) cIdx
	) --> uint(size=8) :
		if cIdx > 0 then
			(binIdx >> (log2TrafoSize-2)) + 15
		else
			LASTCTX[( ( log2TrafoSize - 2 )*( log2TrafoSize + 1 ) ) + binIdx]
		end
	end
	/*************************************************************************
	 * Context_92314
	 *************************************************************************/
	procedure calcPatternSigCtx(
		uint(size= 1) sigCoeffGroupFlag[BLW_WIDTH_MAX][BLW_HEIGHT_MAX],
		uint(size= 8) posXCG,
		uint(size= 8) posYCG,		
		uint(size= 8) log2TrafoWidth,
		uint(size= 8) log2TrafoHeight,
		 int(size=32) ret[1]
	)
	var
		uint(size=1) sigRight := 0,
		uint(size=1) sigLower := 0, 
		uint(size=8) width    := 1 << log2TrafoWidth,
		uint(size=8) height   := 1 << log2TrafoHeight 
	begin
		println(" calcPatternSigCtx("+posXCG+", "+posYCG+", "+width+", "+height+") ==>");
	
		if width = height and width <= 8 then
			ret[0] := -1;
		else
  			width  := width  >> 2;
  			height := height >> 2;
			if  posXCG < width - 1 then
				sigRight := if sigCoeffGroupFlag[ posXCG+1 ][ posYCG ] != 0 then 1 else 0 end;
  			end
  			if posYCG < height - 1 then
				sigLower := if sigCoeffGroupFlag[ posXCG ][ posYCG+1 ] != 0 then 1 else 0 end;
			end
  			ret[0] := sigRight + (sigLower<<1);
  		end
  	end
	uint(size=8) ctxInMap[16] = [
		0, 1, 4, 5, 2, 3, 4, 5, 6, 6, 8, 8, 7, 7, 8, 8
		];
	procedure context_92314(
		 int(size=4) patternSigCtx,
		uint(size=8) posX,
		uint(size=8) posY,		
		uint(size=8) blockType,
		uint(size=8) textureType,
		uint(size=9) ctxIdx[1]
	)
	var
		uint(size=8) offset,
		uint(size=8) posXinSubset,
  		uint(size=8) posYinSubset,
  		uint(size=8) cnt 
	begin
		println(" getSigCtxInc("+patternSigCtx+", "+posX+", "+posY+", "+blockType+", "+textureType+") ==>");
		if posX + posY = 0 then
			ctxIdx[0]  := 0;
		elsif blockType = 2 then
			ctxIdx[0]   := ctxInMap[(posY<<2) + posX];
		elsif blockType = 3 then
			ctxIdx[0]   := 9 + ctxInMap[((posY>>1)<<2) + (posX>>1)];
		else
			offset       := 18;
			posXinSubset := posX-((posX>>2)<<2);
			posYinSubset := posY-((posY>>2)<<2);
			cnt          := 0;
			if patternSigCtx = 0 then
    			cnt := if posXinSubset+posYinSubset <= 2 then 1 else 0 end;
			elsif patternSigCtx = 1 then
				cnt := if posYinSubset <= 1 then 1 else 0 end;
			elsif patternSigCtx = 2 then
				cnt := if posXinSubset <= 1 then 1 else 0 end;
			else
				cnt := if posXinSubset+posYinSubset <= 4 then 2 else 1 end;
			end
			ctxIdx[0] := if textureType = TEXT_LUMA and ((posX>>2) + (posY>>2)) > 0  then 3 else 0 end + offset + cnt;
		end
	end
	uint(size=8) ctxIdxMap4x4[30] = [
		0, 1, 4, 5, 2, 3, 4, 5, 6, 6, 8, 8, 7, 7, 8,
		0, 1, 2, 4, 1, 1, 2, 4, 3, 3, 5, 5, 4, 4, 5
	 	];
	uint(size=8) ctxIdxMap8x8[16] = [
		0, 1, 2, 3, 4, 5, 6, 3, 8, 6, 6, 7, 9, 9, 7, 7
		];
	procedure context_92314_old(
		uint(size=8) log2TrafoWidth,
		uint(size=8) log2TrafoHeight,
		uint(size=8) xC,
		uint(size=8) yC,		
		uint(size=8) cIdx,
		uint(size=8) significant_coeff_flag[BLW_WIDTH_MAX][BLW_HEIGHT_MAX],
		uint(size=9) ctxIdx[1]
	)
	var
		uint(size=8) sigCtx := 0 
	begin
		if log2TrafoWidth = log2TrafoHeight and log2TrafoWidth = 2 then
			sigCtx := ctxIdxMap4x4[ if cIdx > 0 then 15 else 0 end + (yC << 2) + xC ];
		elsif log2TrafoWidth = log2TrafoHeight and log2TrafoWidth = 3 then
			sigCtx := if xC + yC = 0 then 10 else ctxIdxMap8x8[ ((yC >> 1 ) << 2) + (xC >> 1) ] end;
			sigCtx := sigCtx + if cIdx > 0 then 6 else 9 end;			 
		elsif xC + yC = 0 then
			sigCtx := if cIdx > 0 then 17 else 20 end;
		elsif (xC>>2) + (yC>>2) < (3 << (max(log2TrafoWidth, log2TrafoHeight) - 4)) then
			if xC < ( 1 << log2TrafoWidth ) - 1 then
				sigCtx := sigCtx + significant_coeff_flag[xC+1][yC];
				if yC < ( 1 << log2TrafoHeight ) - 1 then
					sigCtx := sigCtx + significant_coeff_flag[xC+1][yC+1];
				end
				if xC < ( 1 << log2TrafoWidth ) - 2 then
					sigCtx := sigCtx + significant_coeff_flag[xC+2][yC];
				end
			end
			if yC < ( 1 << log2TrafoHeight ) - 1 then
    			if ( (xC & 3) != 0 or (yC & 3) != 0) and ( (xC & 3) != 3 or (yC & 3) != 2 ) then
					sigCtx := sigCtx + significant_coeff_flag[xC][yC+1];
    			end
    			if yC < ( 1 << log2TrafoHeight ) - 2 and sigCtx < 4 then
					sigCtx := sigCtx + significant_coeff_flag[xC][yC+2];
    			end
    		end
    	else
    		sigCtx := if cIdx > 0 then 18 else 24 end;
  		end
   		if cIdx = 0 and (xC>>2) + (yC>>2) > 0 then
   			sigCtx := ( (sigCtx + 1) >> 1 ) + 24;
   		else
   			sigCtx := ( (sigCtx + 1) >> 1 ) + if cIdx > 0 then 18 else 21 end;
   		end
  		ctxIdx[0] := if cIdx = 0 then sigCtx else 27 + sigCtx end;
	end
end