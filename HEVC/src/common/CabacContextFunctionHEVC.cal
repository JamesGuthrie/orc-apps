/******************************************************************************
 * Definition of CabacContextFunction
 *****************************************************************************/
package common;

import  std.util.Math.*;
import  common.CabacContextConstantHEVC.*;
import  common.CabacContextTableHEVC.*;

unit CabacContextFunctionHEVC :

	/*************************************************************************
	 * ContextInit
	 *************************************************************************/
	procedure contextInit(uint(size=8) qp, uint(size=8) sliceType, uint(size=9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX])
	var
		uint(size= 8) initValue,
		 int(size=10) m,
		uint(size= 4) n,
		 int          val,
		uint(size= 8) valMps,
		uint(size= 8) pStateIdx
	begin
		foreach uint(size=8) i in 0 .. NB_MAX_SE-1 do
			foreach uint(size=8) j in 0 .. NUM_SE_CONTEXT_INDEX[i]-1 do
				initValue	:= InitContextIndex[i][sliceType][j];
				m 			:= M_SLOPES[initValue>>4];
				n 			:= initValue & 15;
				val 		:= max( 0, min( 3839, (n<<8) + m * (qp-26) + 128 ) );
				val 		:= val - 1920;
				valMps 		:= if val >= 0 then 1 else 0 end;
				val 		:= ( val ^ (val>>11) ) + 128;
				pStateIdx	:= M_ACCUMULATEDSEGOFFSET[val >> 8] + ( (val&255) * M_SEGOFFSET[val >> 8] >> 8);
				ctxTable[i][j] := (pStateIdx<<1) + valMps;
			end	
		end
	end
	/*************************************************************************
	 * getCtxSplitFlag
	 *************************************************************************/
	function getCtxSplitFlag(
		uint(size= 8) depthSubPart,
		bool		  availableA,
		uint(size= 8) depthSubPartA,
		bool		  availableB,
		uint(size= 8) depthSubPartB
	) --> uint(size=2) :
		uint(size=1) condTermA = if depthSubPartA > depthSubPart and availableA = true then 1 else 0 end;
		uint(size=1) condTermB = if depthSubPartB > depthSubPart and availableB = true then 1 else 0 end;
		condTermA + condTermB
	end
	/*************************************************************************
	 * Context_933112
	 *************************************************************************/
	procedure context_933112(
		uint(size= 8) binIdx,
		bool		  availableA,
		bool		  availableB,
		uint(size= 8) NumMergeCand,
		uint(size= 8) ctxIdxInc[1]
	)
	begin
		ctxIdxInc[0] := if binIdx = 0 then
							if availableB = true and availableA = true then
								0
							elsif availableB = true or availableA = true then
								2
							else
								3
							end
						elsif binIdx = 1 and NumMergeCand > 2 then
							if availableA = true then
								2
							else
								3
							end
						elsif binIdx = 2 and NumMergeCand > 3 then
							3
						else
							0
						end;
		//ctxIdxInc[0] := ctxIdxInc[0] âˆ’ availableCollocated;
	end
	/*************************************************************************
	 * Context_933113
	 *************************************************************************/
	uint(size=8) LASTCTX[31] = [
	 	0,  1,  2,  3,  3,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6, 7,
	 	7,  7,  7,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10
	 	];
	procedure context_933113(
		uint(size=8) binIdx,
		uint(size=8) cIdx,
		uint(size=8) log2TrafoSize,
		uint(size=8) ctxIdxInc[1]
	)
	begin
		ctxIdxInc[0] := if log2TrafoSize <= 2 then
							LASTCTX[binIdx]
						else
							LASTCTX[(1<<(log2TrafoSize-1)) + binIdx]
						end;
		if cIdx > 0 then
			ctxIdxInc[0] := ctxIdxInc[0] + 19;
		end
	end
	/*************************************************************************
	 * Context_933114
	 *************************************************************************/
	procedure context_933114(
		uint(size= 8) ctxIdxInc[1]
	)
	begin
	end
end