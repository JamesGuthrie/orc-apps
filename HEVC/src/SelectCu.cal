/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
import interPrediction.NaluType.*;
import std.util.Math.*;

actor SelectCu()
	uint(size=2) CuMode,
	uint(size=7) CuSize,
	uint(size=8) InterSample,
	uint(size=8) IntraSample,
	uint(size=4) PartMode,
	int (size=9) ResidualSample
		==>
	uint(size=8) Sample
		:

	uint(size=3)  numPart;
	uint(size=3)  numPartDecoded;
	uint(size=7)  cuSize[4][2];
	uint(size=5)  cuOff[4][2] := [[0,0],[0,0],[0,0],[0,0]];
	uint(size=7)  cuWidth;
	uint(size=9)  nbBlk;
	uint(size=9)  idxBlk;
	uint(size=8)  interSamp[16][16][16+2*4];
	uint(size=5)  xIdx;
	uint(size=5)  yIdx;

	isNewSlice: action PartMode:[partMode] ==>
	guard
		partMode = NEW_SLICE || partMode = NEW_PICT
	end

	getPartMode: action PartMode:[partMode] ==>
	guard
		partMode != NEW_SLICE && partMode != NEW_PICT
	do
		numPart := partModeToNumPart[partMode];
		numPartDecoded := 0;
	end

	getCuInfo.launch: action CuSize:[cuSizeVal] repeat 2 ==>
	guard
		numPartDecoded < numPart && numPart != 2
	do
		cuWidth := cuSizeVal[0];
		nbBlk   := cuWidth*cuWidth/16;
		idxBlk  := 0;
		cuSize := [[cuSizeVal[i]/4:for int i in 0 .. 1]:for int j in 0 .. 3];
		cuOff[1] := [0:for int i in 0 .. 1];
	end

	getCuInfo.launch.numPart2: action CuSize:[cuSizeVal] repeat 4, CuMode:[cuMode] ==>
	guard
		numPartDecoded < numPart && numPart = 2
	do
		cuSize  := [[cuSizeVal[i+2*j]/4:for uint i in 0 .. 1]: for uint j in 0 .. 1];
		cuWidth := max(cuSizeVal[0], cuSizeVal[1]);
		nbBlk   := cuWidth*cuWidth/16;
		idxBlk  := 0;
		if(cuMode=PART_2NxN || cuMode=PART_2NxnU || cuMode=PART_2NxnD) then
			cuOff[1][0] := 0;
			cuOff[1][1] := cuSizeVal[1]/4;
		else
			cuOff[1][0] := cuSizeVal[0]/4;
			cuOff[1][1] := 0;
		end
		numPartDecoded := 0;
	end

	getCuInfo.done: action ==>
	guard
		numPartDecoded = numPart
	end

	getCuMode.isIntra: action CuMode:[cuMode] ==>
	guard
		cuMode = INTRA
	do
		numPartDecoded := numPartDecoded + 1;
	end

	getCuMode.isInter: action CuMode:[cuMode] ==>
	guard
		cuMode = INTER || cuMode = SKIP
	do
		xIdx := 0;
		yIdx := 0;
	end

	getCuMode.isOther: action CuMode:[cuMode] ==>
	guard
		cuMode = OTHER
	do
		numPartDecoded := numPartDecoded + 1;
	end

	getCuSample.isIntra: action IntraSample:[intraSample] repeat 16 +2*4, ResidualSample:[resSample] repeat 16 +2*4 ==> Sample:[sample] repeat 16+2*4
	guard
		idxBlk < nbBlk
	var
		uint(size=8) sample[16+2*4]
	do
		idxBlk := idxBlk + 1;
		foreach int i in 0 .. 16+2*4-1
		do
			sample[i] := clip_i32(intraSample[i]+resSample[i], 0, 255);
		end
	end

	getCuSample.isInter: action InterSample:[interSample] repeat 16 +2*4 ==>
	guard
		idxBlk < nbBlk
	var
		uint xOff = cuOff[numPartDecoded][0],
		uint yOff = cuOff[numPartDecoded][1]
	do
		foreach uint i in 0 .. 16+2*4-1
		do
			interSamp[xIdx+xOff][yIdx+yOff][i] := interSample[i];
		end
		xIdx := xIdx + 1;
		if(xIdx = cuSize[numPartDecoded][0]) then
			xIdx := 0;
			yIdx := yIdx + 1;
			if(yIdx = cuSize[numPartDecoded][1]) then
				yIdx := 0;
				numPartDecoded := numPartDecoded + 1;
			end
		end
		idxBlk := idxBlk + 1;
	end

	getCuSample.isInterRes: action ResidualSample:[resSample] repeat 16 +2*4 ==> Sample:[sample] repeat 16+2*4
	guard
		idxBlk < nbBlk
	var
		uint(size=8)  sample[16+2*4],
		uint(size=16) interIdx[2]
	do
		rasterScanToAbsCoord(idxBlk, interIdx);
		interIdx[0] := interIdx[0]>>2;
		interIdx[1] := interIdx[1]>>2;
		idxBlk := idxBlk + 1;
		foreach int i in 0 .. 16+2*4-1
		do
			sample[i] := clip_i32(interSamp[interIdx[0]][interIdx[1]][i] + resSample[i], 0, 255);
		end
	end

	getCuSample.done: action ==>
	guard
		idxBlk = nbBlk
	do
		idxBlk := 0;
	end

	schedule fsm GetPartMode:
		GetPartMode (isNewSlice       )--> GetPartMode;
		GetPartMode (getPartMode      )--> GetCuInfo;

		GetCuInfo   (getCuInfo.launch )--> GetCuMode;
		GetCuInfo   (getCuInfo.done   )--> GetPartMode;

		GetCuMode (getCuMode.isIntra )--> GetCuSampleIntra;
		GetCuMode (getCuMode.isInter )--> GetCuSampleInter;
		GetCuMode (getCuMode.isOther )--> GetCuInfo;

		GetCuSampleIntra (getCuSample.isIntra )--> GetCuSampleIntra;
		GetCuSampleIntra (getCuSample.done    )--> GetCuInfo;

		GetCuSampleInter (getCuSample.isInter )--> GetCuSampleInter;
		GetCuSampleInter (getCuSample.done    )--> GetCuResInter;

		GetCuResInter (getCuSample.isInterRes )--> GetCuResInter;
		GetCuResInter (getCuSample.done       )--> GetCuInfo;
	end
end