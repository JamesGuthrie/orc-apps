/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
package inloopFilter;

import interPrediction.NaluType.*;
import std.util.Math.*;

actor GenerateBs()
	bool          Cbf,
	uint(size=16) CUInfo,
	uint(size=2)  IsBiPredOrLx,
	int (size=16) Mv,
	uint(size=4)  PartMode,
	int (size=16) RefPoc,
	bool          SplitTransf
		==>
	uint(size=2) BS
		:

	uint(size=16) PIC_WIDTH_MAX = 2048;
	uint(size=1) HORIZ = 0;
	uint(size=1) VERT = 1;


	uint(size=7)  nS;
	uint(size=16) cuAddr[2] := [-1,-1];
	uint(size=16) cuAddrNQT[2] := [-1,-1];
	uint(size=2)  cuMode;
	uint(size=3)  numPart;
	uint(size=3)  numPartDecoded;

	int (size=4) trafoTreeDepth;
	uint(size=3) trafoTreeIdx[6];

	bool vertEdgeFlagVal[16] :=
		[true, true, true, true, true, true, true, true, true, true, true,
		 true, true, true, true, true];
	bool horEdgeFlagVal[16]  :=
		[true, true, true, true, true, true, true, true, true, true, true,
		 true, true, true, true, true];

	bool edgeFlag[2][16][16];
	bool isTUEdge[2][16][16];


	uint(size=2) predModeTab[PIC_WIDTH_MAX/4][2*64/4];//
	bool cbfTab[PIC_WIDTH_MAX/4][2*64/4];//
	bool isBiPredTab[PIC_WIDTH_MAX/4][2*64/4];//
	int(size=16) refPocTab[PIC_WIDTH_MAX/4][2*64/4][2];//
	int(size=16) mvTab[PIC_WIDTH_MAX/4][2*64/4][2][2];//
	bool isBiPred[2];
	int(size=16) refPoc[2][2];
	int(size=16) mv[2][2][2];
	

	uint(size=9) currIdx;
	uint(size=9) maxRasterScanIdx;
	uint(size=2) numMvInfo;
	uint(size=2) bsTable[2][256];

	procedure savePredInfo(uint(size=16) addr[2], uint(size=8) puSize[2],
		uint(size=1) tabIdx)
	var
		uint(size=16) xMin = (addr[0]>>2)&(PIC_WIDTH_MAX/4-1),
		uint(size=16) xMax = ((addr[0]+puSize[0])/4)&(PIC_WIDTH_MAX/4-1),
		uint(size=16) yMin = (addr[1]/4)&31,
		uint(size=16) yMax = ((addr[1]+puSize[1])/4)&31,
		uint(size=16) y
	begin
		foreach uint x in xMin .. xMax-1
		do
			y := yMin;
			while(y!=yMax)
			do
				predModeTab[x][y] := cuMode;
				isBiPredTab[x][y] := isBiPred[tabIdx];
				foreach int i in 0 .. 1
				do
					refPocTab[x][y][i] := refPoc[tabIdx][i];
					mvTab[x][y][i][0] := mv[tabIdx][i][0]-(addr[0]<<2);
					mvTab[x][y][i][1] := mv[tabIdx][i][1]-(addr[1]<<2);
				end
				y := (y+1)&31;
			end
		end
	end

	procedure rstEdgeTables(uint(size=16) addr[2])
	begin
		foreach int i in 0 .. 15
		do
			foreach int j in 0 .. 15
			do
				edgeFlag[VERT][i][j] := false;
				edgeFlag[HORIZ][i][j] := false;
				isTUEdge[VERT][i][j] := false;
				isTUEdge[HORIZ][i][j] := false;
			end
		end
		vertEdgeFlagVal[0] := (addr[0] != 0);
		horEdgeFlagVal[0] := (addr[1] != 0);
	end

	procedure processTUBoundaries()
	var
		uint(size=16) treeAddr[2],
		uint(size=7)  treeNS,
		uint(size=16) xMin,
		uint(size=16) xMax,
		uint(size=16) yMin,
		uint(size=16) yMax
	begin
		treeAddr := [cuAddr[i]: for int i in 0 .. 1];
		treeNS := nS;
		foreach uint idx in 1 .. trafoTreeDepth
		do
			treeNS := treeNS >> 1;
			if((trafoTreeIdx[idx]&1) != 0) then
				treeAddr[0] := treeAddr[0] + treeNS;
			end
			if((trafoTreeIdx[idx]&2) != 0) then
				treeAddr[1] := treeAddr[1] + treeNS;
			end
		end
		treeAddr[0] := (treeAddr[0]&63) >> 2;
		treeAddr[1] := (treeAddr[1]&63) >> 2;
		treeNS      := treeNS >> 2;
		xMin := treeAddr[0];
		yMin := treeAddr[1];
		xMax := xMin + treeNS;
		yMax := yMin + treeNS;
		foreach int x in xMin .. xMax-1
		do
			edgeFlag[HORIZ][x][yMin] := horEdgeFlagVal[yMin];
			isTUEdge[HORIZ][x][yMin] := horEdgeFlagVal[yMin];
		end
		foreach int y in yMin .. yMax-1
		do
			edgeFlag[VERT][xMin][y] := vertEdgeFlagVal[xMin];
			isTUEdge[VERT][xMin][y] := vertEdgeFlagVal[xMin];
		end
	end

	procedure processPUBoundary(uint(size=16) addr[2], uint(size=8) puSize[2])
	var
		int xMin = (addr[0]&63)>>2,
		int xMax = xMin + (puSize[0]>>2),
		int yMin = (addr[1]&63)>>2,
		int yMax = yMin + (puSize[1]>>2)
	begin
		foreach uint x in xMin .. xMax-1
		do
			edgeFlag[HORIZ][x][yMin] := horEdgeFlagVal[yMin];
		end
		foreach uint y in yMin .. yMax-1
		do
			edgeFlag[VERT][xMin][y] := vertEdgeFlagVal[xMin];
		end
	end

	procedure genBoundFilterStrength(uint(size=2) bS[1], uint(size=16) addr[2], bool isVerticalEdge, uint(size=2) cIdx, bool isTUEdge)
	var
		uint(size=16) q0[2] = [(addr[0]/4)&(PIC_WIDTH_MAX/4-1), (addr[1]/4)&31],
		uint(size=16) p0[2] := if(isVerticalEdge) then [q0[0]-1, q0[1]]
			else [q0[0], (q0[1]-1)&31] end,
		int(size=16) tmpRefPoc,
		int(size=16) tmpMv,
		int(size=16) absMv[2][2],
		int(size=16) absMvQP[2][2]
	begin
		if(isVerticalEdge && ((addr[0]>>2)&1)=1) then
			bS[0] := 0;
		else if(not isVerticalEdge && ((addr[1]>>2)&1)=1) then
			bS[0] := 0;
		else if(predModeTab[p0[0]][p0[1]] = INTRA || predModeTab[q0[0]][q0[1]] = INTRA) then
			bS[0] := 2;
		else if(cIdx=0 && isTUEdge && (cbfTab[p0[0]][p0[1]] || cbfTab[q0[0]][q0[1]])) then
			bS[0] := 1;
		else
			if(not isVerticalEdge && ((p0[1] & ~15)!=(q0[1] & ~15))) then
				p0[0] := (p0[0]&~1) | ((p0[0]>>1)&1);
			end
			if(isBiPredTab[p0[0]][p0[1]] && isBiPredTab[q0[0]][q0[1]] && refPocTab[p0[0]][p0[1]][0] = refPocTab[q0[0]][q0[1]][1]) then
				tmpRefPoc := refPocTab[q0[0]][q0[1]][1];
				refPocTab[q0[0]][q0[1]][1] := refPocTab[q0[0]][q0[1]][0];
				refPocTab[q0[0]][q0[1]][0] := tmpRefPoc;
				tmpMv := mvTab[q0[0]][q0[1]][0][0];
				mvTab[q0[0]][q0[1]][0][0] := mvTab[q0[0]][q0[1]][1][0];
				mvTab[q0[0]][q0[1]][1][0] := tmpMv;
				tmpMv := mvTab[q0[0]][q0[1]][0][1];
				mvTab[q0[0]][q0[1]][0][1] := mvTab[q0[0]][q0[1]][1][1];
				mvTab[q0[0]][q0[1]][1][1] := tmpMv;
			end
			if(isBiPredTab[p0[0]][p0[1]] != isBiPredTab[q0[0]][q0[1]] ||
			   refPocTab[p0[0]][p0[1]][0] != refPocTab[q0[0]][q0[1]][0] ||
			   isBiPredTab[p0[0]][p0[1]] && //L1
			   (refPocTab[p0[0]][p0[1]][1] != refPocTab[q0[0]][q0[1]][1])) then
				bS[0] := 1;
			else
				absMv[0][0] := abs(mvTab[p0[0]][p0[1]][0][0]- mvTab[q0[0]][q0[1]][0][0]);
				absMv[0][1] := abs(mvTab[p0[0]][p0[1]][0][1]- mvTab[q0[0]][q0[1]][0][1]);
				if(not isBiPredTab[p0[0]][p0[1]] && (absMv[0][0]>=4 || absMv[0][1]>=4))then
					bS[0] := 1;
				else
					absMv[1][0] := abs(mvTab[p0[0]][p0[1]][1][0]- mvTab[q0[0]][q0[1]][1][0]);
					absMv[1][1] := abs(mvTab[p0[0]][p0[1]][1][1]- mvTab[q0[0]][q0[1]][1][1]);
					if(isBiPredTab[p0[0]][p0[1]] &&
					   refPocTab[p0[0]][p0[1]][0] != refPocTab[p0[0]][p0[1]][1] &&
					   (absMv[0][0]>=4 || absMv[0][1]>=4 || absMv[1][0]>=4 || absMv[1][1]>=4)) then
						bS[0] := 1;
					else
						if(isBiPredTab[p0[0]][p0[1]] &&
						   refPocTab[p0[0]][p0[1]][0] = refPocTab[p0[0]][p0[1]][1]) then
							absMvQP[0][0] := abs(mvTab[p0[0]][p0[1]][0][0]- mvTab[q0[0]][q0[1]][1][0]);
							absMvQP[0][1] := abs(mvTab[p0[0]][p0[1]][0][1]- mvTab[q0[0]][q0[1]][1][1]);
							absMvQP[1][0] := abs(mvTab[p0[0]][p0[1]][1][0]- mvTab[q0[0]][q0[1]][0][0]);
							absMvQP[1][1] := abs(mvTab[p0[0]][p0[1]][1][1]- mvTab[q0[0]][q0[1]][0][1]);
							if((absMv[0][0]>=4 || absMv[0][1]>=4 || absMv[1][0]>=4 || absMv[1][1]>=4) &&
							   (absMvQP[0][0]>=4 || absMvQP[0][1]>=4 || absMvQP[1][0]>=4
							   || absMvQP[1][1]>=4)) then
								bS[0] := 1;
							else
								bS[0] := 0;
							end
						else
							bS[0] := 0;
						end
					end
				end
			end
		end end end end
	end

	int sliceNum := 0;
	/* Updating the picture size. */
	isNewSliceOrPict: action PartMode:[partMode] ==>
	guard
		partMode = NEW_SLICE || partMode = NEW_PICT
	do
		println("Slice Num : "+sliceNum);
		sliceNum := sliceNum + 1;
	end

	/* Check when there are two parts in the CU.  */
	getPartMode.isNonQuadTree: action PartMode:[partMode] ==>
	guard
		partMode != NEW_SLICE && partMode != NEW_PICT,
		partMode != PART_2Nx2N && partMode != PART_NxN
	do
		currIdx := 0;
		numMvInfo := 2;
	end

	/* Check if all parts of the CU are a square. */
	getPartMode.isQuadTree: action PartMode:[partMode] ==>
	guard
		partMode = PART_2Nx2N || partMode = PART_NxN
	do
		numPart := partModeToNumPart[partMode];
		numPartDecoded := 0;
	end

	getRefPictInfo.launch.isNotBiPred: action IsBiPredOrLx:[isBiPredOrLx],
		RefPoc:[refPocVal], Mv:[mvVal] repeat 2 ==>
	guard
		isBiPredOrLx != BI_PRED and currIdx < numMvInfo
	do
		isBiPred[currIdx] := (isBiPredOrLx=BI_PRED);
		refPoc[currIdx][0] := refPocVal;
		if(currIdx=0) then
			mv[currIdx][0] := [mvVal[i]:for uint i in 0 .. 1];
		else
			mv[currIdx][0] := [mvVal[i]:for uint i in 0 .. 1];
		end
		currIdx := currIdx + 1;
	end

	getRefPictInfo.launch.isBiPred: action IsBiPredOrLx:[isBiPredOrLx],
		RefPoc:[refPocVal] repeat 2, Mv:[mvVal] repeat 4 ==>
	guard
		isBiPredOrLx = BI_PRED and currIdx < numMvInfo
	do
		isBiPred[currIdx] := (isBiPredOrLx=BI_PRED);
		refPoc[currIdx] := [refPocVal[i]:for uint i in 0 .. 1];
		if(currIdx=0) then
			mv[currIdx] := [[mvVal[i+2*j]:for uint i in 0 .. 1]: for uint j in 0 .. 1];
		else
			mv[currIdx] := [[mvVal[i+2*j]:for uint i in 0 .. 1]: for uint j in 0 .. 1];
		end
		currIdx := currIdx + 1;
	end

	getRefPictInfo.done: action ==>
	guard
		currIdx = numMvInfo
	do
		if(numMvInfo=1 or numMvInfo=0) then
			savePredInfo(cuAddr, [nS, nS], 0);
		end
	end

	/* Get the information concerning the CU to be able to save the values in
	 * currPict.
	 */
	getCuInfo.launch: action CUInfo:[cuInfo] repeat 5 ==>
	guard
		numPartDecoded < numPart
	do
		cuMode := cuInfo[0];
		nS := cuInfo[3];
		if((cuInfo[1]&~63) != (cuAddr[0]&~63) ||
		   (cuInfo[2]&~63) != (cuAddr[1]&~63)) then
			rstEdgeTables([cuInfo[1], cuInfo[2]]);
		end
		cuAddr := [cuInfo[1], cuInfo[2]];
		numPartDecoded := numPartDecoded + 1;
	end

	/* When there are two parts, we get both part in once in order to perform a
	 * raster scan on the square (the SelectCU actor reorder the differents
	 * blocks)
	 */
	getCuInfo.nonQT: action CUInfo:[cuInfo] repeat 10 ==>
	var
		uint(size=8) puSize[2]
	do
		cuMode := cuInfo[0];
		if((cuInfo[1]&~63) != (cuAddr[0]&~63) ||
		   (cuInfo[2]&~63) != (cuAddr[1]&~63)) then
			rstEdgeTables([cuInfo[1], cuInfo[2]]);
		end
		cuAddr := [cuInfo[1], cuInfo[2]];
		nS := max(cuInfo[3], cuInfo[4]);
		puSize := [cuInfo[3], cuInfo[4]];
		processPUBoundary(cuAddr, puSize);
		savePredInfo(cuAddr, puSize, 0);
		puSize := [cuInfo[8], cuInfo[9]];
		cuAddrNQT := [cuInfo[6], cuInfo[7]];
		processPUBoundary(cuAddrNQT, puSize);
		savePredInfo(cuAddrNQT, puSize, 1);
		numPart := 2;
		numPartDecoded := 2;
		trafoTreeDepth  := 0;
		trafoTreeIdx[0] := 3;
		
	end

	getCuInfo.done: action ==>
	guard
		numPartDecoded = numPart
	end

	getCuMode.isNotOther: action ==>
	guard
		cuMode = INTER || cuMode = SKIP || cuMode = INTRA
	do
		processPUBoundary(cuAddr, [nS, nS]);
		trafoTreeDepth  := 0;
		trafoTreeIdx[0] := 3;
		currIdx := 0;
		numMvInfo :=
			if(cuMode=INTRA) then
				0
			else
				1
			end;
	end

	/* When it's neither an intra nor inter prediction CU, do neither
	 * prediction nor saving pixels' value
	 */
	getCuMode.isOther: action ==>
	guard
		cuMode = OTHER
	end

	getSplitTrafo.launch.isTrue: action SplitTransf:[splitTrafo] ==>
	guard
		trafoTreeDepth>-1 && splitTrafo
	do
		trafoTreeDepth := trafoTreeDepth + 1;
		trafoTreeIdx[trafoTreeDepth] := 0;
	end

	getSplitTrafo.launch.isFalse: action SplitTransf:[splitTrafo], Cbf:[cbf] ==>
	guard
		trafoTreeDepth>-1 && not splitTrafo
	var
		uint(size=7)  treeNS,
		uint(size=16) treeAddr[2],
		uint(size=16) xMin,
		uint(size=16) xMax,
		uint(size=16) yMin,
		uint(size=16) yMax,
		uint(size=16) y
	do
		processTUBoundaries();

		/* Computing the size and the address of the current block. */
		treeNS := nS;
		treeAddr := [cuAddr[i]: for int i in 0 .. 1];
		foreach uint idx in 1 .. trafoTreeDepth
		do
			treeNS := treeNS >> 1;
			if((trafoTreeIdx[idx]&1) != 0) then
				treeAddr[0] := treeAddr[0] + treeNS;
			end
			if((trafoTreeIdx[idx]&2) != 0) then
				treeAddr[1] := treeAddr[1] + treeNS;
			end
		end

		xMin := (treeAddr[0] & PIC_WIDTH_MAX-1) >>2;
		xMax := (xMin+(treeNS>>2))&(PIC_WIDTH_MAX/4-1);
		yMin := (treeAddr[1]/4)&31;
		yMax := ((treeAddr[1]+treeNS)/4)&31;
		foreach int x in xMin .. xMax-1
		do
			y := yMin;
			while(y!=yMax)
			do
				cbfTab[x][y] := cbf;
				y:= (y+1)&31;
			end
		end

		trafoTreeIdx[trafoTreeDepth] := trafoTreeIdx[trafoTreeDepth] + 1;
		while(trafoTreeDepth > -1 && trafoTreeIdx[trafoTreeDepth] = 4)
		do
			trafoTreeDepth := trafoTreeDepth - 1;
			if(trafoTreeDepth>-1) then
				trafoTreeIdx[trafoTreeDepth] :=
					trafoTreeIdx[trafoTreeDepth] + 1;
			end
		end
	end

	getSplitTrafo.done: action ==>
	guard
		trafoTreeDepth = -1
	end

	generateBS: action ==>
	var
		int(size=16) xMin = (cuAddr[0] & 63)>>2,
		int(size=16) xMax = xMin+(nS>>2),
		int(size=16) yMin = (cuAddr[1] & 63)>>2,
		int(size=16) yMax = yMin + (nS>>2),
		uint(size=2) bS[1],
		uint(size=16) addrBlk[2],
		uint(size=8) rasterIdx
	do
		addrBlk := cuAddr;
		foreach int y in yMin .. yMax - 1
		do
			foreach int x in xMin .. xMax - 1
			do
				rasterIdx := absCoordToRasterScan(addrBlk);
				if(edgeFlag[VERT][x][y]) then
					genBoundFilterStrength(bS, addrBlk, true, 0, isTUEdge[VERT][x][y]);
					bsTable[0][rasterIdx] := bS[0];
				else				
					bsTable[0][rasterIdx] := 0;
				end
				if(edgeFlag[HORIZ][x][y]) then
					genBoundFilterStrength(bS, addrBlk, false, 0, isTUEdge[HORIZ][x][y]);
					bsTable[1][rasterIdx] := bS[0];
				else
					bsTable[1][rasterIdx] := 0;
				end
				addrBlk[0] := addrBlk[0] + 4;
			end
			addrBlk[1] := addrBlk[1] + 4;
			addrBlk[0] := cuAddr[0];
		end
		currIdx := absCoordToRasterScan(cuAddr);
		addrBlk := [cuAddr[0]+nS-1, cuAddr[1]+nS-1];
		maxRasterScanIdx := absCoordToRasterScan(addrBlk);
	end

	sendBS.launch: action ==> BS:[bs] repeat 2
	guard
		currIdx <= maxRasterScanIdx
	var
		uint(size=2)  bs[2]
	do
		bs := [bsTable[i][currIdx]: for uint i in 0 .. 1];
		currIdx := currIdx + 1;
	end

	sendBS.done: action ==>
	guard
		currIdx > maxRasterScanIdx
	end

	schedule fsm GetPartMode:
		GetPartMode(isNewSliceOrPict          )--> GetPartMode;
		GetPartMode(getPartMode.isQuadTree    )--> GetCuInfo;
		GetPartMode(getPartMode.isNonQuadTree )--> GetRefPictInfo1;

		GetRefPictInfo1 (getRefPictInfo.launch )--> GetRefPictInfo1;
		GetRefPictInfo1 (getRefPictInfo.done   )--> GetCuInfoNonQT;
		GetCuInfoNonQT  (getCuInfo.nonQT       )--> GetSplitTrafo;

		GetCuInfo (getCuInfo.launch )--> GetCuMode;
		GetCuInfo (getCuInfo.done   )--> GetPartMode;

		GetCuMode (getCuMode.isNotOther )--> GetRefPictInfo2;
		GetCuMode (getCuMode.isOther    )--> GetCuInfo;

		GetRefPictInfo2 (getRefPictInfo.launch )--> GetRefPictInfo2;
		GetRefPictInfo2 (getRefPictInfo.done   )--> GetSplitTrafo;

		GetSplitTrafo (getSplitTrafo.launch )--> GetSplitTrafo;
		GetSplitTrafo (getSplitTrafo.done   )--> GenerateBS;

		GenerateBS (generateBS )--> SendBS;

		SendBS (sendBS.launch )--> SendBS;
		SendBS (sendBS.done   )--> GetCuInfo;
	end
end