/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
package inLoopFilter;

import std.util.Math.*;
import interPrediction.NaluType.*;

actor SaoFilter(bool DEBUG)
	uint(size=16) PicSize,
	uint(size=8)  SampleIn,
	int (size=9)  SaoSe
		==>
	//uint(size=8)  FiltSample
		:

	uint(size=16) PIC_WIDTH_MAX=2048;
	uint(size=16) PIC_HEIGHT_MAX=2048;
	uint(size=4)  BIT_DEPTH = 8;


	int(size=3) constHPos0[4][2] = [[-1,1],  [ 0,0], [-1,1],  [ 1,-1]];
	int(size=3) constVPos0[4][2] = [[ 0,0],  [-1,1], [-1,1],  [-1, 1]];
	int(size=3) edgeIdxConv[5] = [1, 2, 0, 3, 4];

	uint(size=32) numSlice := 0;
	bool          slcSaoCompEn[3];

	uint(size=8) OrigPict[3][PIC_WIDTH_MAX][4*64];
	uint(size=8) FiltPict[3][PIC_WIDTH_MAX][PIC_HEIGHT_MAX];

	uint(size=2) cIdx;
	uint(size=2) saoTypeIdx[PIC_WIDTH_MAX/64][2][3];
	int (size=9) saoOffset[PIC_WIDTH_MAX/64][2][3][5];
	uint(size=2) saoEoClass[PIC_WIDTH_MAX/64][2][3];
	uint(size=5) saoLeftClass[PIC_WIDTH_MAX/64][2][3];

	uint(size=6)  picSizeInCu[2];
	uint(size=16) picSize[2];
	uint(size=6)  xIdx := 0;
	uint(size=6)  yIdx := 0;

	procedure nextLcuAddress()
	begin
		xIdx := xIdx + 1;
		if(xIdx = picSizeInCu[0]) then
			xIdx := 0;
			yIdx := yIdx + 1;
		end
	end

	procedure codingTreeBlockModif(uint(size=16) rx, uint(size=16) ry, uint(size=16) xCuIdx, uint(size=16) yCuIdx)
	var
		uint(size=3) xMax = if(cIdx=0) then 3 else 1 end,
		uint(size=3) yMax = if(cIdx=0) then 3 else 1 end,
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		uint(size=3) bandShift = 3,
		uint(size=3) bandTable[32],
		uint(size=3) bandIdx
	begin
		rx := if(cIdx=0) then rx<<2 else rx<<1 end;
		ry := if(cIdx=0) then ry<<2 else rx<<1 end;
		foreach uint(size=3) y in 0 .. yMax
		do
			yIdx := ry + y;
			foreach uint(size=3) x in 0 .. xMax
			do
				xIdx := rx + x;
				if(xIdx<picSize[0] && yIdx<picSize[1]) then
					if(saoTypeIdx[xCuIdx][yCuIdx][cIdx] = 2) then
						pixIsInPict := true;
						foreach uint k in 0 .. 1
						do
							pixIdx[k][0] := xIdx + constHPos0[saoEoClass[xCuIdx][yCuIdx][cIdx]][k];
							pixIdx[k][1] := xIdx + constVPos0[saoEoClass[xCuIdx][yCuIdx][cIdx]][k];
							if(pixIdx[k][0] > picSize[0] || pixIdx[k][1]>picSize[1]) then
								pixIsInPict := false;
							end
						end
						if(pixIsInPict) then
							edgeIdx := 2;
							foreach uint k in 0 .. 1
							do
								edgeIdx := edgeIdx + Sign3(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] -
									OrigPict[cIdx][pixIdx[k][0]][pixIdx[k][1] &(4*64-1)]);
							end
							edgeIdx := edgeIdxConv[edgeIdx];
						else
							edgeIdx := 0;
						end
						FiltPict[cIdx][xIdx][yIdx] := clip_i32(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] +
							saoOffset[xCuIdx][yCuIdx][cIdx][edgeIdx], 0, 255);
					else
						foreach uint i in 0 .. 31
						do
							bandTable[i] := 0;
						end
						foreach uint k in 0 .. 3
						do
							bandTable[(k+saoLeftClass[xCuIdx][yCuIdx][cIdx]) & 31] := k+1;
						end
						bandIdx := bandTable[OrigPict[cIdx][xIdx][yIdx &(4*64-1)]>>bandShift];
						FiltPict[cIdx][xIdx][yIdx] := clip_i32(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] +
							saoOffset[xCuIdx][yCuIdx][cIdx][bandIdx], 0, 255);
					end
				end		
			end
		end
	end

	isNewPict: action PicSize:[picWidthInPix, picHeightInPix], SaoSe:[saoSe] ==>
	do
		picSizeInCu := [picWidthInPix/64, picHeightInPix/64];
		picSize     := [picWidthInPix   , picHeightInPix];
		slcSaoCompEn[0] := (saoSe & 1) !=0;
		slcSaoCompEn[1] := (saoSe & 2) !=0;
		slcSaoCompEn[2] := slcSaoCompEn[1];
	end

	getCuPix.launch: action SampleIn:[samp] repeat 64*64 + 32*32*2 ==>
	guard
		yIdx < picSizeInCu[1] && xIdx < picSizeInCu[0]
	var
		uint(size=16) offset,
		uint(size=16) xPic,
		uint(size=16) yPic
	do
		xPic := xIdx<<6;
		yPic := (yIdx<<6)&(4*64-1);

		foreach uint y in 0 .. 63
		do
			foreach uint x in 0 .. 63
			do
				OrigPict[0][x+xPic][(y+yPic) &(4*64-1)] := samp[xPic + yPic*64]; 
			end
		end

		xPic := xPic>>1;
		yPic := yPic>>1;
		offset := 64*64;
		foreach uint cIdx in 1 .. 2
		do
			foreach uint y in 0 .. 31
			do
				foreach uint x in 0 .. 31
				do
					OrigPict[cIdx][x+xPic][(y+yPic) &(4*64-1)] := samp[x + y*32 +offset]; 
				end
			end
			offset := offset + 32*32;
		end
	end

	getSaoMerge.noMerge: action SaoSe:[mergeInfo] ==>
	guard
		(slcSaoCompEn[0] || slcSaoCompEn[1]) and mergeInfo = SAO_NO_MERGE
	do
	end

	getSaoMerge.merge: action SaoSe:[mergeInfo] ==>
	guard
		(slcSaoCompEn[0] || slcSaoCompEn[1]) and mergeInfo != SAO_NO_MERGE
	var
		uint(size=16) xMerge =
			if(mergeInfo = SAO_MERGE_LEFT) then xIdx-1 else xIdx end,
		uint(size=16) yMerge =
			if(mergeInfo = SAO_MERGE_UP)  then (yIdx-1)&1 else yIdx&1 end
	do
		foreach uint cIdx in 0 .. 2
		do
			saoTypeIdx[xMerge][yMerge][cIdx] := saoTypeIdx[xIdx][yIdx&1][cIdx];
			foreach uint i in 1 .. 4
			do
				saoOffset[xMerge][yMerge][cIdx][i] := saoOffset[xIdx][yIdx&1][cIdx][i];
			end
			saoEoClass[xMerge][yMerge][cIdx] := saoEoClass[xIdx][yIdx&1][cIdx];
			saoLeftClass[xMerge][yMerge][cIdx] := saoLeftClass[xIdx][yIdx&1][cIdx];
		end
		nextLcuAddress();
	end

	getSaoMerge.skip: action ==>
	guard
		not slcSaoCompEn[0] && not slcSaoCompEn[1]
	do
		nextLcuAddress();
	end

	getSaoTypeIdx.is0: action SaoSe:[typeIdx] ==>
	guard
		cIdx<3 && slcSaoCompEn[cIdx] && typeIdx = 0
	do
		saoTypeIdx[xIdx][yIdx&1][cIdx] := typeIdx;
		cIdx := cIdx + 1;
	end

	getSaoTypeIdx.isNot0: action SaoSe:[saoSe] repeat 6 ==>
	guard
		cIdx<3 && slcSaoCompEn[cIdx] && saoSe[0] != 0
	do
		saoTypeIdx[xIdx][yIdx&1][cIdx] := saoSe[0];
		foreach uint i in 1 .. 4
		do
			saoOffset[xIdx][yIdx&1][cIdx][i] := saoSe[i];
		end
		if(saoTypeIdx[xIdx][yIdx&1][cIdx]=2) then
			saoEoClass[xIdx][yIdx&1][cIdx] := saoSe[5];
		else
			saoLeftClass[xIdx][yIdx&1][cIdx] := saoSe[5];
		end
		cIdx := cIdx + 1;
	end

	getSaoTypeIdx.skip: action ==>
	guard
		cIdx<3 && not slcSaoCompEn[cIdx]
	do
		cIdx := cIdx + 1;
	end

	getSaoTypeIdxDone: action ==>
	guard
		cIdx = 3
	do
		cIdx := 0;
		nextLcuAddress();
	end

	getCuPix.done: action ==>
	guard
		yIdx = picSizeInCu[1]
	do
		xIdx := 0;
		yIdx := 0;
		if(DEBUG) then
			println("slice num "+numSlice);
			numSlice := numSlice + 1;
		end
	end

	schedule fsm IsNewPict:
		IsNewPict (isNewPict )--> GetCuPix;

		GetCuPix  (getCuPix.launch )--> GetSaoMerge;
		GetCuPix  (getCuPix.done   )--> IsNewPict;

		GetSaoMerge (getSaoMerge.skip    )--> GetCuPix;
		GetSaoMerge (getSaoMerge.merge   )--> GetCuPix;
		GetSaoMerge (getSaoMerge.noMerge )--> GetSaoTypeIdx;

		GetSaoTypeIdx(getSaoTypeIdx     )--> GetSaoTypeIdx;
		GetSaoTypeIdx(getSaoTypeIdxDone )--> GetCuPix;
	end
end