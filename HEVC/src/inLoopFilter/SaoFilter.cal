/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
package inLoopFilter;

import std.util.Math.*;
import common.CommonConstantHEVC.*;
import interPrediction.NaluType.*;

actor SaoFilter(bool DEBUG)
	uint(size=2)  IsPicSlcLcu,
	bool          LFAcrossSlc,
	uint(size=16) PicSize,
	uint(size=8)  SampleIn,
	int (size=9)  SaoSe
		==>
	uint(size=8)  FiltSample
		:
	uint(size=4)  BIT_DEPTH = 8;


	int(size=3) constHPos0[4][2] = [[-1,1],  [ 0,0], [-1,1],  [ 1,-1]];
	int(size=3) constVPos0[4][2] = [[ 0,0],  [-1,1], [-1,1],  [-1, 1]];
	int(size=3) edgeIdxConv[5] = [1, 2, 0, 3, 4];

	int(size=2) signResult[3][128][128];

	bool          slcSaoCompEn[3];

	uint(size=8) OrigPict[3][PICT_WIDTH][4*64];
	uint(size=8) FiltPict[3][PICT_WIDTH][PICT_HEIGHT];

	uint(size=2)  cIdx;
	uint(size=2)  saoTypeIdx[PICT_WIDTH/64][2][3];
	int (size=9)  saoOffset[PICT_WIDTH/64][2][3][5];
	uint(size=2)  saoEoClass[PICT_WIDTH/64][2][3];
	uint(size=5)  saoLeftClass[PICT_WIDTH/64][2][3];
	uint(size=3)  bandTable[32];
	uint(size=6)  picSizeInCu[2];
	uint(size=16) picSize[2];
	uint(size=6)  xCu := 0;
	uint(size=6)  yCu := 0;
	uint(size=6)  xCuFilt := 0;
	uint(size=6)  yCuFilt := 0;

	bool filterAcrossSlc;
	uint(size=16) begSlcAddr[3][2];
	uint(size=16) endSlcAddr[3][2];

	procedure nextLcuAddress()
	begin
		xCu := xCu + 1;
		if(xCu = picSizeInCu[0]) then
			xCu := 0;
			yCu := yCu + 1;
		end
	end

	procedure nextLcuAddressFilt()
	begin
		xCuFilt := xCuFilt + 1;
		if(xCuFilt = picSizeInCu[0]) then
			xCuFilt := 0;
			yCuFilt := yCuFilt + 1;
		end
	end

	procedure copyCu(uint(size=16) addrBeg[2], uint(size=16) addrEnd[2], uint(size=2) cIdx)
	begin
		foreach uint x in addrBeg[0] .. addrEnd[0]
		do
			foreach uint y in addrBeg[1] .. addrEnd[1]
			do
				FiltPict[cIdx][x][y] := OrigPict[cIdx][x][y &(4*64-1)];
			end
		end
	end

	procedure saoFilterEdgeLuma_Horiz(uint(size=16) rx, uint(size=16) ry,
		uint(size=16) picSize[2])
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		int(size=2) sign3Result
	begin
		foreach uint(size=3) y in 0 .. 63
		do
			yIdx := ry + y;
			foreach uint(size=3) x in 0 .. 63
			do
				xIdx := rx + x;
				if(xIdx<picSize[0] && yIdx<picSize[1]) then
						pixIdx[0][0] := xIdx - 1;
						pixIdx[0][1] := yIdx + 0;
						pixIdx[1][0] := xIdx + 1;
						pixIdx[1][1] := yIdx + 0;

						pixIsInPict := true;
						if(pixIdx[0][0] >= picSize[0] || pixIdx[0][1]>=picSize[1] ||
							pixIdx[1][0] >= picSize[0] || pixIdx[1][1]>=picSize[1]) then
							pixIsInPict := false;
						else if(not filterAcrossSlc) then
							if(pixIdx[0][1]<begSlcAddr[0][1] ||
								pixIdx[0][1]<begSlcAddr[0][1]+64
								&& pixIdx[0][0]<begSlcAddr[0][0]) then
								pixIsInPict := false;
							else if(pixIdx[1][1]>=endSlcAddr[0][1]+64
								|| pixIdx[1][1]>=endSlcAddr[0][1] &&
								pixIdx[1][0]>=endSlcAddr[0][0]) then
								pixIsInPict := false;
							end end
						end end

						if(pixIsInPict) then
							edgeIdx := 2;

							//Check if the value has already been computed.
							if(xIdx=0) then
								sign3Result := Sign3(OrigPict[0][xIdx][yIdx &(4*64-1)] -
									OrigPict[0][pixIdx[0][0]][pixIdx[0][1] &(4*64-1)]);
							end
							edgeIdx := edgeIdx + sign3Result;

							sign3Result := Sign3(OrigPict[0][xIdx][yIdx &(4*64-1)] -
								OrigPict[0][pixIdx[1][0]][pixIdx[1][1] &(4*64-1)]);
							edgeIdx := edgeIdx + sign3Result;

							edgeIdx := edgeIdxConv[edgeIdx];
							//Saving the value to avoid computing it again and Sign3(B-A) = -Sign3(A-B)
							sign3Result := -sign3Result;
						else
							edgeIdx := 0;
							sign3Result := Sign3(OrigPict[0][pixIdx[1][0]][pixIdx[1][1] &(4*64-1)] -
								OrigPict[0][xIdx][yIdx &(4*64-1)]);
						end
						FiltPict[0][xIdx][yIdx] := clip_i32(OrigPict[0][xIdx][yIdx &(4*64-1)] +
							saoOffset[xCuFilt][yCuFilt&1][0][edgeIdx], 0, 255);
				end		
			end
		end
	end

	procedure saoFilterEdgeLuma_Vert(uint(size=16) rx, uint(size=16) ry,
		uint(size=16) picSize[2])
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		int(size=2) sign3Result
	begin
		foreach uint(size=3) x in 0 .. 63
		do
			xIdx := rx + x;
			foreach uint(size=3) y in 0 .. 63
			do
				yIdx := ry + y;
				if(xIdx<picSize[0] && yIdx<picSize[1]) then
						pixIdx[0][0] := xIdx + 0;
						pixIdx[0][1] := yIdx - 1;
						pixIdx[1][0] := xIdx + 0;
						pixIdx[1][1] := yIdx + 1;

						pixIsInPict := true;
						if(pixIdx[0][0] >= picSize[0] || pixIdx[0][1]>=picSize[1] ||
							pixIdx[1][0] >= picSize[0] || pixIdx[1][1]>=picSize[1]) then
							pixIsInPict := false;
						else if(not filterAcrossSlc) then
							if(pixIdx[0][1]<begSlcAddr[0][1] ||
								pixIdx[0][1]<begSlcAddr[0][1]+64
								&& pixIdx[0][0]<begSlcAddr[0][0]) then
								pixIsInPict := false;
							else if(pixIdx[1][1]>=endSlcAddr[0][1]+64
								|| pixIdx[1][1]>=endSlcAddr[0][1] &&
								pixIdx[1][0]>=endSlcAddr[0][0]) then
								pixIsInPict := false;
							end end
						end end

						if(pixIsInPict) then
							edgeIdx := 2;

							//Check if the value has already been computed.
							if(yIdx=0) then
								sign3Result := Sign3(OrigPict[0][xIdx][yIdx &(4*64-1)] -
									OrigPict[0][pixIdx[0][0]][pixIdx[0][1] &(4*64-1)]);
							end
							edgeIdx := edgeIdx + sign3Result;

							sign3Result := Sign3(OrigPict[0][xIdx][yIdx &(4*64-1)] -
								OrigPict[0][pixIdx[1][0]][pixIdx[1][1] &(4*64-1)]);
							edgeIdx := edgeIdx + sign3Result;

							edgeIdx := edgeIdxConv[edgeIdx];
							//Saving the value to avoid computing it again and Sign3(B-A) = -Sign3(A-B)
							sign3Result := -sign3Result;
						else
							edgeIdx := 0;
							sign3Result := Sign3(OrigPict[0][pixIdx[1][0]][pixIdx[1][1] &(4*64-1)] -
								OrigPict[0][xIdx][yIdx &(4*64-1)]);
						end
						FiltPict[0][xIdx][yIdx] := clip_i32(OrigPict[0][xIdx][yIdx &(4*64-1)] +
							saoOffset[xCuFilt][yCuFilt&1][0][edgeIdx], 0, 255);
				end		
			end
		end
	end

	procedure codingTreeBlockModifLuma(uint(size=16) rx, uint(size=16) ry,
		uint(size=16) picSize[2])
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		uint(size=3) bandShift = BIT_DEPTH-5,
		uint(size=3) bandIdx,
		int(size=2) sign3Result
	begin
		if(saoTypeIdx[xCuFilt][yCuFilt&1][0] = 2 and saoEoClass[xCuFilt][yCuFilt&1][0] = 0) then
			saoFilterEdgeLuma_Horiz(rx,ry,picSize);
		else if(saoTypeIdx[xCuFilt][yCuFilt&1][0] = 2 and saoEoClass[xCuFilt][yCuFilt&1][1] = 0) then
			saoFilterEdgeLuma_Vert(rx,ry,picSize);
		else
			foreach uint(size=3) y in 0 .. 63
			do
				yIdx := ry + y;
				foreach uint(size=3) x in 0 .. 63
				do
					xIdx := rx + x;
					if(xIdx<picSize[0] && yIdx<picSize[1]) then
						if(saoTypeIdx[xCuFilt][yCuFilt&1][0] = 2) then
							pixIsInPict := true;
							foreach uint k in 0 .. 1
							do
								pixIdx[k][0] := xIdx + constHPos0[saoEoClass[xCuFilt][yCuFilt&1][0]][k];
								pixIdx[k][1] := yIdx + constVPos0[saoEoClass[xCuFilt][yCuFilt&1][0]][k];
								if(pixIdx[k][0] >= picSize[0] || pixIdx[k][1]>=picSize[1]) then
									pixIsInPict := false;
								else if(not filterAcrossSlc) then
									if(pixIdx[k][1]<begSlcAddr[0][1] ||
										pixIdx[k][1]<begSlcAddr[0][1]+64
										&& pixIdx[k][0]<begSlcAddr[0][0]) then
										pixIsInPict := false;
									else if(pixIdx[k][1]>=endSlcAddr[0][1]+64
										|| pixIdx[k][1]>=endSlcAddr[0][1] &&
										pixIdx[k][0]>=endSlcAddr[0][0]) then
										pixIsInPict := false;
									end end
								end end
							end
							edgeIdx := 0;
							if(pixIsInPict) then
								edgeIdx := 2;
	
								//Check if the value has already been computed.
								if(xIdx=0 || yIdx=0) then
									sign3Result := Sign3(OrigPict[0][xIdx][yIdx &(4*64-1)] -
										OrigPict[0][pixIdx[0][0]][pixIdx[0][1] &(4*64-1)]);
								else
									sign3Result := signResult[0][x][y];
								end
								edgeIdx := edgeIdx + sign3Result;
	
								sign3Result := Sign3(OrigPict[0][xIdx][yIdx &(4*64-1)] -
									OrigPict[0][pixIdx[1][0]][pixIdx[1][1] &(4*64-1)]);
								edgeIdx := edgeIdx + sign3Result;
	
								//Saving the value to avoid computing it again and Sign3(B-A) = -Sign3(A-B)
								signResult[0][pixIdx[1][0]&127][pixIdx[1][1]&127] := -sign3Result;
								edgeIdx := edgeIdxConv[edgeIdx];
							end
							FiltPict[0][xIdx][yIdx] := clip_i32(OrigPict[0][xIdx][yIdx &(4*64-1)] +
								saoOffset[xCuFilt][yCuFilt&1][0][edgeIdx], 0, 255);
						else
							bandIdx := bandTable[OrigPict[0][xIdx][yIdx &(4*64-1)]>>bandShift];
							FiltPict[0][xIdx][yIdx] := clip_i32(OrigPict[0][xIdx][yIdx &(4*64-1)] +
								saoOffset[xCuFilt][yCuFilt&1][0][bandIdx], 0, 255);
						end
					end		
				end
			end
		end end
	end

	procedure saoFilterEdgeChroma_Horiz(uint(size=16) rx, uint(size=16) ry,
		uint(size=2) cIdx, uint(size=16) picSize[2])
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		int(size=2) sign3Result
	begin
		foreach uint(size=3) y in 0 .. 31
		do
			yIdx := ry + y;
			foreach uint(size=3) x in 0 .. 31
			do
				xIdx := rx + x;
				if(xIdx<picSize[0] && yIdx<picSize[1]) then
					pixIdx[0][0] := xIdx - 1;
					pixIdx[0][1] := yIdx + 0;
					pixIdx[1][0] := xIdx + 1;
					pixIdx[1][1] := yIdx + 0;

					pixIsInPict := true;
					if(pixIdx[0][0] >= (picSize[0]>>1) || pixIdx[0][1]>=(picSize[1]>>1) ||
						pixIdx[1][0] >= (picSize[0]>>1) || pixIdx[1][1]>=(picSize[1]>>1)) then
						pixIsInPict := false;
					else if(not filterAcrossSlc) then
						if(pixIdx[0][1]<begSlcAddr[cIdx][1] ||
							pixIdx[0][1]<begSlcAddr[cIdx][1]+32
							&& pixIdx[0][0]<begSlcAddr[cIdx][0]) then
							pixIsInPict := false;
						else if(pixIdx[1][1]>=endSlcAddr[cIdx][1]+32
							|| pixIdx[1][1]>=endSlcAddr[cIdx][1] &&
							pixIdx[1][0]>=endSlcAddr[cIdx][0]) then
							pixIsInPict := false;
						end end
					end end

					if(pixIsInPict) then
						edgeIdx := 2;
						if(xIdx=0) then
							sign3Result := Sign3(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] -
								OrigPict[cIdx][pixIdx[0][0]][pixIdx[0][1] &(4*64-1)]);
						end
						edgeIdx := edgeIdx + sign3Result;

						sign3Result := Sign3(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] -
								OrigPict[cIdx][pixIdx[1][0]][pixIdx[1][1] &(4*64-1)]);
						edgeIdx := edgeIdx + sign3Result;

						edgeIdx := edgeIdxConv[edgeIdx];
						//Saving the value to avoid computing it again and Sign3(B-A) = -Sign3(A-B)
						sign3Result := -sign3Result;
					else
						edgeIdx := 0;
						sign3Result := Sign3(OrigPict[cIdx][pixIdx[1][0]][pixIdx[1][1] &(4*64-1)] -
							OrigPict[cIdx][xIdx][yIdx &(4*64-1)]);
					end
					FiltPict[cIdx][xIdx][yIdx] := clip_i32(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] +
						saoOffset[xCuFilt][yCuFilt&1][cIdx][edgeIdx], 0, 255);
				end		
			end
		end
	end

	procedure saoFilterEdgeChroma_Vert(uint(size=16) rx, uint(size=16) ry,
		uint(size=2) cIdx, uint(size=16) picSize[2])
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		int(size=2) sign3Result
	begin
		foreach uint(size=3) x in 0 .. 31
		do
			xIdx := rx + x;
			foreach uint(size=3) y in 0 .. 31
			do
				yIdx := ry + y;
				if(xIdx<picSize[0] && yIdx<picSize[1]) then
					pixIdx[0][0] := xIdx + 0;
					pixIdx[0][1] := yIdx - 1;
					pixIdx[1][0] := xIdx + 0;
					pixIdx[1][1] := yIdx + 1;

					pixIsInPict := true;
					if(pixIdx[0][0] >= (picSize[0]>>1) || pixIdx[0][1]>=(picSize[1]>>1) ||
						pixIdx[1][0] >= (picSize[0]>>1) || pixIdx[1][1]>=(picSize[1]>>1)) then
						pixIsInPict := false;
					else if(not filterAcrossSlc) then
						if(pixIdx[0][1]<begSlcAddr[cIdx][1] ||
							pixIdx[0][1]<begSlcAddr[cIdx][1]+32
							&& pixIdx[0][0]<begSlcAddr[cIdx][0]) then
							pixIsInPict := false;
						else if(pixIdx[1][1]>=endSlcAddr[cIdx][1]+32
							|| pixIdx[1][1]>=endSlcAddr[cIdx][1] &&
							pixIdx[1][0]>=endSlcAddr[cIdx][0]) then
							pixIsInPict := false;
						end end
					end end

					if(pixIsInPict) then
						edgeIdx := 2;
						if(yIdx=0) then
							sign3Result := Sign3(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] -
								OrigPict[cIdx][pixIdx[0][0]][pixIdx[0][1] &(4*64-1)]);
						end
						edgeIdx := edgeIdx + sign3Result;

						sign3Result := Sign3(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] -
								OrigPict[cIdx][pixIdx[1][0]][pixIdx[1][1] &(4*64-1)]);
						edgeIdx := edgeIdx + sign3Result;

						edgeIdx := edgeIdxConv[edgeIdx];
						//Saving the value to avoid computing it again and Sign3(B-A) = -Sign3(A-B)
						sign3Result := -sign3Result;
					else
						edgeIdx := 0;
						sign3Result := Sign3(OrigPict[cIdx][pixIdx[1][0]][pixIdx[1][1] &(4*64-1)] -
							OrigPict[cIdx][xIdx][yIdx &(4*64-1)]);
					end
					FiltPict[cIdx][xIdx][yIdx] := clip_i32(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] +
						saoOffset[xCuFilt][yCuFilt&1][cIdx][edgeIdx], 0, 255);
				end		
			end
		end
	end

	procedure codingTreeBlockModifChroma(uint(size=16) rx, uint(size=16) ry,
		uint(size=2) cIdx, uint(size=16) picSize[2])
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		uint(size=3) bandShift = BIT_DEPTH-5,
		uint(size=3) bandIdx,
		int(size=2) sign3Result
	begin
		if(saoTypeIdx[xCuFilt][yCuFilt&1][0] = 2 and saoEoClass[xCuFilt][yCuFilt&1][0] = 0) then
			saoFilterEdgeChroma_Horiz(rx, ry, cIdx, picSize);
		else if(saoTypeIdx[xCuFilt][yCuFilt&1][0] = 2 and saoEoClass[xCuFilt][yCuFilt&1][0] = 1) then
			saoFilterEdgeChroma_Vert(rx, ry, cIdx, picSize);
		else
			foreach uint(size=3) y in 0 .. 31
			do
				yIdx := ry + y;
				foreach uint(size=3) x in 0 .. 31
				do
					xIdx := rx + x;
					if(xIdx<picSize[0] && yIdx<picSize[1]) then
						if(saoTypeIdx[xCuFilt][yCuFilt&1][cIdx] = 2) then
							pixIsInPict := true;
							foreach uint k in 0 .. 1
							do
								pixIdx[k][0] := xIdx + constHPos0[saoEoClass[xCuFilt][yCuFilt&1][cIdx]][k];
								pixIdx[k][1] := yIdx + constVPos0[saoEoClass[xCuFilt][yCuFilt&1][cIdx]][k];
								if(pixIdx[k][0] >= picSize[0] || pixIdx[k][1]>=picSize[1]) then
									pixIsInPict := false;
								else if(not filterAcrossSlc) then
									if(pixIdx[k][1]<begSlcAddr[cIdx][1] ||
										pixIdx[k][1]<begSlcAddr[cIdx][1]+32
										&& pixIdx[k][0]<begSlcAddr[cIdx][0]) then
										pixIsInPict := false;
									else if(pixIdx[k][1]>=endSlcAddr[cIdx][1]+32
										|| pixIdx[k][1]>=endSlcAddr[cIdx][1] &&
										pixIdx[k][0]>=endSlcAddr[cIdx][0]) then
										pixIsInPict := false;
									end end
								end end
							end
							edgeIdx := 0;
							if(pixIsInPict) then
								edgeIdx := 2;
								//Check if the value has already been computed.
								if(xIdx=0 || yIdx=0) then
									sign3Result := Sign3(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] -
										OrigPict[cIdx][pixIdx[0][0]][pixIdx[0][1] &(4*64-1)]);
								else
									sign3Result := signResult[cIdx][x][y];
								end
								edgeIdx := edgeIdx + sign3Result;
	
								sign3Result := Sign3(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] -
										OrigPict[cIdx][pixIdx[1][0]][pixIdx[1][1] &(4*64-1)]);
								edgeIdx := edgeIdx + sign3Result;
	
								//Saving the value to avoid computing it again and Sign3(B-A) = -Sign3(A-B)
								signResult[cIdx][pixIdx[1][0]&127][pixIdx[1][1]&127] := -sign3Result;
								edgeIdx := edgeIdxConv[edgeIdx];
							end
							FiltPict[cIdx][xIdx][yIdx] := clip_i32(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] +
								saoOffset[xCuFilt][yCuFilt&1][cIdx][edgeIdx], 0, 255);
						else
							bandIdx := bandTable[OrigPict[cIdx][xIdx][yIdx &(4*64-1)]>>bandShift];
							FiltPict[cIdx][xIdx][yIdx] := clip_i32(OrigPict[cIdx][xIdx][yIdx &(4*64-1)] +
								saoOffset[xCuFilt][yCuFilt&1][cIdx][bandIdx], 0, 255);
						end
					end		
				end
			end
		end end
	end

	procedure sampAdapOffFilt(bool isNewSlice)
	var
		uint(size=16) picSizeLoc[2]
	begin
		picSizeLoc := [picSize[0]>>1, picSize[1]>>1];
		while( isNewSlice && (yCuFilt!=yCu || xCuFilt!=xCu)  ||
			(yCuFilt<yCu) && (xCuFilt<xCu || yCu=picSizeInCu[1]) ||
			(yCuFilt<yCu-1))
		do
			foreach uint cIdx in 0 .. 2
			do
				if(saoTypeIdx[xCuFilt][yCuFilt&1][cIdx] = 1) then
					foreach uint i in 0 .. 31
					do
						bandTable[i] := 0;
					end
					foreach uint k in 0 .. 3
					do
						bandTable[(k+saoLeftClass[xCuFilt][yCuFilt&1][cIdx]) & 31] := k+1;
					end
				end
				if(saoTypeIdx[xCuFilt][yCuFilt&1][cIdx]!=0) then
					if(cIdx=0) then
						codingTreeBlockModifLuma((xCuFilt<<6),
							(yCuFilt<<6), picSize);
					else
						codingTreeBlockModifChroma((xCuFilt<<5),
							(yCuFilt<<5), cIdx, picSizeLoc);
					end
				end
			end
			nextLcuAddressFilt();
		end
	end

	isNewPict: action IsPicSlcLcu:[isNewPicSlcLcu], LFAcrossSlc:[lfAcrossSlc],
		PicSize:[picWidthInPix, picHeightInPix], SaoSe:[saoSe] ==>
	guard
		isNewPicSlcLcu = NEW_PIC
	do
		picSizeInCu := [(picWidthInPix+63)/64, (picHeightInPix+63)/64];
		picSize     := [picWidthInPix   , picHeightInPix];
		slcSaoCompEn[0] := (saoSe & 1) !=0;
		slcSaoCompEn[1] := (saoSe & 2) !=0;
		slcSaoCompEn[2] := slcSaoCompEn[1];
		filterAcrossSlc := lfAcrossSlc;
		begSlcAddr[0] := [0, 0];
		begSlcAddr[1] := [0, 0];
		begSlcAddr[2] := [0, 0];
	end

	isNewSlice: action IsPicSlcLcu:[isNewPicSlcLcu], LFAcrossSlc:[lfAcrossSlc],
		PicSize:[picWidthInPix, picHeightInPix] ==>
	guard
		isNewPicSlcLcu = NEW_SLC
	do
		endSlcAddr[0] := [xCu<<6, yCu<<6];
		endSlcAddr[1] := [xCu<<5, yCu<<5];
		endSlcAddr[2] := [xCu<<5, yCu<<5];
		sampAdapOffFilt(true);
		filterAcrossSlc := lfAcrossSlc;
		begSlcAddr[0] := [xCu<<6, yCu<<6];
		begSlcAddr[1] := [xCu<<5, yCu<<5];
		begSlcAddr[2] := [xCu<<5, yCu<<5];
		endSlcAddr[0] := [0, picSize[1]];
		endSlcAddr[1] := [0, picSize[1]>>1];
		endSlcAddr[2] := [0, picSize[1]>>1];
	end

	getCuPix.launch: action IsPicSlcLcu:[isNewLcu], SampleIn:[samp] repeat 64*64 + 32*32*2 ==>
	guard
		yCu < picSizeInCu[1]
	var
		uint(size=16) offset,
		uint(size=16) xPic,
		uint(size=16) yPic
	do
		xPic := xCu<<6;
		yPic := (yCu<<6)&(4*64-1);

		foreach uint y in 0 .. 63
		do
			foreach uint x in 0 .. 63
			do
				OrigPict[0][x+xPic][(y+yPic) &(4*64-1)] := samp[x + y*64]; 
			end
		end

		xPic := xPic>>1;
		yPic := (yCu<<5)&(4*64-1);
		offset := 64*64;
		foreach uint cIdx in 1 .. 2
		do
			foreach uint y in 0 .. 31
			do
				foreach uint x in 0 .. 31
				do
					OrigPict[cIdx][x+xPic][(y+yPic) &(4*64-1)] := samp[x + y*32 +offset]; 
				end
			end
			offset := offset + 32*32;
		end
	end

	getCuPix.done: action ==>
	guard
		yCu = picSizeInCu[1]
	do
		sampAdapOffFilt(false);
		xCu := 0;
		yCu := 0;
	end

	getSaoMerge.noMerge: action SaoSe:[mergeInfo] ==>
	guard
		(slcSaoCompEn[0] || slcSaoCompEn[1]) and mergeInfo = SAO_NO_MERGE
	do
	end

	getSaoMerge.merge: action SaoSe:[mergeInfo] ==>
	guard
		(slcSaoCompEn[0] || slcSaoCompEn[1]) and mergeInfo != SAO_NO_MERGE
	var
		uint(size=16) addrBeg[2],
		uint(size=16) addrEnd[2],
		uint(size=16) xMerge =
			if(mergeInfo = SAO_MERGE_LEFT) then xCu-1 else xCu end,
		uint(size=16) yMerge =
			if(mergeInfo = SAO_MERGE_UP)  then (yCu-1)&1 else yCu&1 end
	do
		foreach uint cIdx in 0 .. 2
		do
			saoTypeIdx[xCu][yCu&1][cIdx] := saoTypeIdx[xMerge][yMerge&1][cIdx];
			if(saoTypeIdx[xCu][yCu&1][cIdx] = 0) then
				addrBeg :=
					if(cIdx=0) then
						[xCu<<6, yCu<<6]
					else
						[xCu<<5, yCu<<5]
					end;
				addrEnd :=
					if(cIdx=0) then
						[(xCu<<6)+63, (yCu<<6)+63]
					else
						[(xCu<<5)+31, (yCu<<5)+31]
					end;
		
				copyCu(addrBeg, addrEnd, cIdx);
			else
				foreach uint i in 1 .. 4
				do
					saoOffset[xCu][yCu&1][cIdx][i] := saoOffset[xMerge][yMerge&1][cIdx][i];
				end
				saoEoClass[xCu][yCu&1][cIdx] := saoEoClass[xMerge][yMerge&1][cIdx];
				saoLeftClass[xCu][yCu&1][cIdx] := saoLeftClass[xMerge][yMerge&1][cIdx];
			end
		end
		sampAdapOffFilt(false);
		nextLcuAddress();
	end

	getSaoMerge.skip: action ==>
	guard
		not slcSaoCompEn[0] && not slcSaoCompEn[1]
	do
		saoTypeIdx[xCu][yCu&1] := [0, 0, 0];
		copyCu([xCu<<6, yCu<<6], [(xCu<<6)+63, (yCu<<6)+63], 0);
		copyCu([xCu<<5, yCu<<5], [(xCu<<5)+31, (yCu<<5)+31], 1);
		copyCu([xCu<<5, yCu<<5], [(xCu<<5)+31, (yCu<<5)+31], 2);
		nextLcuAddress();
	end

	getSaoTypeIdx.is0: action SaoSe:[typeIdx] ==>
	guard
		cIdx<3 && slcSaoCompEn[cIdx] && typeIdx = 0
	var
		uint(size=16) addrBeg[2],
		uint(size=16) addrEnd[2]
	do
		addrBeg :=
			if(cIdx=0) then
				[xCu<<6, yCu<<6]
			else
				[xCu<<5, yCu<<5]
			end;
		addrEnd :=
			if(cIdx=0) then
				[(xCu<<6)+63, (yCu<<6)+63]
			else
				[(xCu<<5)+31, (yCu<<5)+31]
			end;

		copyCu(addrBeg, addrEnd, cIdx);
		saoTypeIdx[xCu][yCu&1][cIdx] := 0;
		cIdx := cIdx + 1;
	end

	getSaoTypeIdx.isNot0: action SaoSe:[saoSe] repeat 6 ==>
	guard
		cIdx<3 && slcSaoCompEn[cIdx] && saoSe[0] != 0
	do
		saoTypeIdx[xCu][yCu&1][cIdx] := saoSe[0];
		foreach uint i in 1 .. 4
		do
			saoOffset[xCu][yCu&1][cIdx][i] := saoSe[i];
		end
		if(saoTypeIdx[xCu][yCu&1][cIdx]=2) then
			saoEoClass[xCu][yCu&1][cIdx] := saoSe[5];
		else
			saoLeftClass[xCu][yCu&1][cIdx] := saoSe[5];
		end

		cIdx := cIdx + 1;
	end

	getSaoTypeIdx.skip: action ==>
	guard
		cIdx<3 && not slcSaoCompEn[cIdx]
	var
		uint(size=16) addrBeg[2],
		uint(size=16) addrEnd[2]
	do
		addrBeg :=
			if(cIdx=0) then
				[xCu<<6, yCu<<6]
			else
				[xCu<<5, yCu<<5]
			end;
		addrEnd :=
			if(cIdx=0) then
				[(xCu<<6)+63, (yCu<<6)+63]
			else
				[(xCu<<5)+31, (yCu<<5)+31]
			end;

		saoTypeIdx[xCu][yCu&1][cIdx] := 0;
		copyCu(addrBeg, addrEnd, cIdx);
		cIdx := cIdx + 1;
	end

	getSaoTypeIdxDone: action ==>
	guard
		cIdx = 3
	do
		cIdx := 0;
		sampAdapOffFilt(false);
		nextLcuAddress();
	end

	

	sendSamples.launch: action ==> FiltSample:[filtSamp] repeat 64*64 + 2* 32*32
	guard
		yCu < picSizeInCu[1]
	var
		uint tokenOffset,
		uint(size=8) filtSamp[64*64+2*32*32],
		uint(size=16) blkAddrX, uint(size=16) blkAddrY
	do
		blkAddrX := xCu*64;
		blkAddrY := yCu*64;
		foreach uint y in 0 .. 63
		do
			foreach uint x in 0 .. 63
			do
				if(not DEBUG) then
					filtSamp[x+y*64] := FiltPict[0][blkAddrX+x][blkAddrY+y];
				else
					if(blkAddrX+x<picSize[0] && blkAddrY+y<picSize[1]) then
						filtSamp[x+y*64] := FiltPict[0][blkAddrX+x][blkAddrY+y];
					else
						filtSamp[x+y*64] := 0;
					end
				end
			end
		end

		blkAddrX := blkAddrX>>1;
		blkAddrY := blkAddrY>>1;
		tokenOffset:= 64*64;
		foreach uint comp in 1 .. 2
		do
			foreach uint y in 0 .. 31
			do
				foreach uint x in 0 .. 31
				do
					if(not DEBUG) then
						filtSamp[x+y*32 + tokenOffset] := FiltPict[comp][blkAddrX+x][blkAddrY+y];
					else
						if(blkAddrX+x<picSize[0]/2 && blkAddrY+y<picSize[1]/2) then
							filtSamp[x+y*32 + tokenOffset] := FiltPict[comp][blkAddrX+x][blkAddrY+y];
						else
							filtSamp[x+y*32 + tokenOffset] := 0;
						end
					end
				end
			end
			tokenOffset:= tokenOffset + 32*32;
		end

		nextLcuAddress();
	end

	sendSamples.done: action ==>
	guard
		yCu = picSizeInCu[1]
	do
		xCuFilt := 0;
		yCuFilt := 0;
		xCu := 0;
		yCu := 0;
	end

	schedule fsm IsNewPict:
		IsNewPict (isNewPict )--> GetCuPix;

		GetCuPix (isNewSlice      )--> GetCuPix;
		GetCuPix (getCuPix.launch )--> GetSaoMerge;
		GetCuPix (getCuPix.done   )--> SendSamples;

		GetSaoMerge (getSaoMerge.skip    )--> GetCuPix;
		GetSaoMerge (getSaoMerge.merge   )--> GetCuPix;
		GetSaoMerge (getSaoMerge.noMerge )--> GetSaoTypeIdx;

		GetSaoTypeIdx(getSaoTypeIdx     )--> GetSaoTypeIdx;
		GetSaoTypeIdx(getSaoTypeIdxDone )--> GetCuPix;

		SendSamples (sendSamples.launch )--> SendSamples;
		SendSamples (sendSamples.done   )--> IsNewPict;
	end
end