/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * 
 * @author Damien de Saint Jorre (EPFL) <damien.desaintjorre@epfl.ch>
 */
 
 
package intraPrediction;

import interPrediction.NaluType.*;

actor intraPredMode()
	uint(size=16) CuAddr,
	uint(size=2)  CuMode,
	uint(size=7)  CuSize,
	uint(size=6)  SyntaxElem
		==>
	uint(size=6) IntraPredMode
		:

	uint(size=6) INTRA_PLANAR = 0;
	uint(size=6) INTRA_DC = 1;

	uint(size=6) intraPredModeC[5][5] =
		[[34,  0,  0,  0,  0],
		 [26, 34, 26, 26, 26],
		 [10, 10, 34, 10, 10],
		 [ 1,  1,  1, 34,  1],
		 [35, 35, 35, 35, 35]];
	
	/* Fix me : should be intraPredMode[2048/4][128/4], then using masks for yAddr. */
	uint(size=6) intraPredMode[2048/4][2048/4];
	uint(size=6) currIntraPredMod;

	procedure getCandModeList(uint(size=16) addr[2], uint(size=6) candModeList[3])
	var
		uint(size=6) intraPredModeA,
		uint(size=6) intraPredModeB
	begin
	
		intraPredModeA := getIntraPredModeN(addr[0]-1, addr[1], false);
		intraPredModeB := getIntraPredModeN(addr[0], addr[1]-1, true);
		if(intraPredModeA = intraPredModeB) then
			if(intraPredModeA<2) then
				candModeList[0] := INTRA_PLANAR;
				candModeList[1] := INTRA_DC;
				candModeList[2] := 26;
			else
				candModeList[0] := intraPredModeA;
				candModeList[1] := 2+((intraPredModeA+29) mod 32);
				candModeList[2] := 2+((intraPredModeA-1) mod 32);
			end
		else
			candModeList[0] := intraPredModeA;
			candModeList[1] := intraPredModeB;
			if(intraPredModeA != INTRA_PLANAR && intraPredModeB != INTRA_PLANAR) then
				candModeList[2] := INTRA_PLANAR;
			else if(intraPredModeA != INTRA_DC && intraPredModeB != INTRA_DC) then
				candModeList[2] := INTRA_DC;
			else
				candModeList[2] := 26;
			end end
		end
	end
	
	function getIntraPredModeN(int xBN, int yBN, bool isAbove) --> uint(size=6)
	:
		if(xBN<0 || yBN<0 || ((yBN&63) = 63 && isAbove)) then
			INTRA_DC
		else
			intraPredMode[xBN>>2][yBN>>2]
		end
	end

	procedure saveIntraPredMode(uint(size=16) addr[2], uint(size=7) sizeOfCu[2], uint(size=6) intraPred)
	var
		uint(size=14) xMin,
		uint(size=14) xMax,
		uint(size=14) yMin,
		uint(size=14) yMax
	begin
		xMin := addr[0]>>2;
		yMin := addr[1]>>2;
		xMax := xMin + (sizeOfCu[0]>>2);
		yMax := yMin + (sizeOfCu[1]>>2);
		foreach uint y in yMin .. yMax-1
		do
			foreach uint x in xMin .. xMax-1
			do
				intraPredMode[x][y] := intraPred;
			end
		end
	end

	getCu.isIntra: action CuAddr:[cuAddr] repeat 2, CuMode:[cuMode],
		CuSize:[cuSize] repeat 2, SyntaxElem:[se] repeat 2 ==>
		IntraPredMode:[currIntraPredMod]
	guard
		cuMode = INTRA
	var
		uint(size=6) candModeList[3],
		uint(size=6) candModeBuff,
		bool prevIntraPred = se[0] != 0,
		uint(size=2) mpmIdx = se[1],
		uint(size=6) remIntraLuma = se[1]
	do
		getCandModeList(cuAddr, candModeList);
		if(prevIntraPred) then
			currIntraPredMod := candModeList[mpmIdx];
		else
			foreach uint i in 0 .. 1
			do
				foreach uint j in i+1 .. 2
				do
					if(candModeList[i] > candModeList[j]) then
						candModeBuff := candModeList[i];
						candModeList[i] := candModeList[j];
						candModeList[j] := candModeBuff;
					end
				end
			end
			currIntraPredMod := remIntraLuma;
			foreach uint i in 0 .. 2
			do
				if(currIntraPredMod >= candModeList[i]) then
					currIntraPredMod := currIntraPredMod + 1;
				end
			end
		end
		saveIntraPredMode(cuAddr, cuSize, currIntraPredMod);
	end

	getCu.isNotIntra: action CuAddr:[cuAddr] repeat 2, CuMode:[cuMode], CuSize:[cuSize] repeat 2 ==>
	guard
		cuMode != INTRA
	do
		saveIntraPredMode(cuAddr, cuSize, INTRA_DC);
	end

	computeChromaPredMode: action SyntaxElem:[intraChrPredMode] ==> IntraPredMode:[predMode]
	var
		uint(size=6) predMode,
		uint(size=3) idx
	do
		if(intraChrPredMode=5) then
			predMode := currIntraPredMod;
		else
			idx :=
				if(currIntraPredMod = 0) then
					0
				else if(currIntraPredMod = 26) then
					1
				else if(currIntraPredMod = 10) then
					2
				else if(currIntraPredMod = 1) then
					3
				else
					4
				end end end end;
				predMode := intraPredModeC[intraChrPredMode][idx];
		end
		if(predMode = 35) then
			println("Warning : we don't manage Intra_FromLuma yet !!!");
		end
	end


	schedule fsm GetCu:
		GetCu (getCu.isIntra    )--> ComputeChrPredMode;
		GetCu (getCu.isNotIntra )--> GetCu;

		ComputeChrPredMode (computeChromaPredMode )--> GetCu;
	end
	priority
		getCu.isNotIntra > getCu.isIntra;
	end
	priority
		getCu.isNotIntra > getCu.isIntra;
	end
end