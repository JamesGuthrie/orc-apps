/********************************************************************************

This software module was originally developed by 
Damien de Saint Jorre (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
*****************************************************************************/
package MPEG.MPEG4.part10.CBP.deblockingFilter;

import MPEG.Common.Imp_PictureInfo.*;
import MPEG.MPEG4.part10.CBP.MacroBlockInfo.*;
import std.util.BitOps.*;
import std.util.Math.*;

/**
 * This actor give informations to the Deblocking Filter.
 * 
 * @input MbType
 * 		give the type of macroblock (Intra4x4, P_Skip, ...)
 * 
 * @input DisDbfIdc
 * 		Flag decoded in the parser which can disable the deblocking filter
 * 		process
 * 
 * @input NeighbourAvail
 * 		Show if the macroblock's neighbours exists
 * 		(see the SVC's documentation; chapter 6.4.8)
 * 
 * @author : Damien de Saint Jorre
 */
actor MgntDeblockFiltFlag()
	uint(size=16) CodedBlockPattern,
	uint(size=2)  DisDbfIdc,
	int (size=6)  FilterOffsetA,
	int (size=6)  FilterOffsetB,
	uint(size=7)  MbLocation,
	uint(size=6)  MbType,
	int (size=16) Mv,
	bool          NeighbourAvail,
	int(size=8)   QpIn,
	uint(size=4)  RefIdx
		==>
	bool         FilterEdges
		 :

	uint(size=8) ALPHA_PRIME_TAB[64] =
		[   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
		    0,   0,   0,   0,   0,   0,   4,   4,   5,   6,
		    7,   8,   9,  10,  12,  13,  15,  17,  20,  22,
		   25,  28,  32,  36,  40,  45,  50,  56,  63,  71,
		   80,  90, 101, 113, 127, 144, 162, 182, 203, 226,
		  255, 255,   0,   0,   0,   0,   0,   0,   0,   0,
		    0,   0,   0,   0];

	uint(size=8) BETA_PRIME_TAB[64] =
		[   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
			0,   0,   0,   0,   0,   0,   2,   2,   2,   3,
			3,   3,   3,   4,   4,   4,   6,   6,   7,   7,
			8,   8,   9,   9,  10,  10,  11,  11,  12,  12,
		   13,  13,  14,  14,  15,  15,  16,  16,  17,  17,
		   18,  18,   0,   0,   0,   0,   0,   0,   0,   0,
		    0,   0,   0,   0 ];


	int (size=6)  filterOffsetA;
	int (size=6)  filterOffsetB;
	uint(size=7)  mbLocX;
	uint(size=7)  mbLocY;
	bool filterLeft;
	bool filterInternal;
	bool filterTop;
	uint(size=6)  mbType[MAX_PICWIDTH_BLK][2];
	uint(size=16) codBlkPat[MAX_PICWIDTH_BLK][2];
	uint(size=4)  refIdx[MAX_PICWIDTH_BLK*4][2*4];
	int (size=16) mv[MAX_PICWIDTH_BLK*4][2*4][2];
	int (size=8)  qpTable[MAX_PICWIDTH_BLK][MAX_PICHEIGHT_BLK];

	function computeBoundaryFiltStrength (bool chromaEdgeFlag,
		bool verticalEdgeFlag, uint(size=16) idxP0X, uint(size=16) idxP0Y,
		uint(size=16) idxQ0X, uint(size=16) idxQ0Y, bool isMacroBlockEdge)
			-->
		uint(size=3)
	var
		bool mixedModeEdge = false
	:
		if(chromaEdgeFlag) then
			if(   Mb_IsIntra(mbType[idxP0X/4][(idxP0Y/4) & 1])
			   or Mb_IsIntra(mbType[idxQ0X/4][(idxQ0Y/4) & 1])) then
				if(isMacroBlockEdge)then
					4
				else
					3
				end
			else
				if(nonZeroCoeff(idxP0X,idxP0Y,true) or
				   nonZeroCoeff(idxQ0X,idxQ0Y,true)) then
					2
				else
					42
				end
			end
		else
			42 //not implemented yet!
		end
	end

	function nonZeroCoeff (uint(size=32) x, uint(size=32) y, bool isLuma)
			-->
		bool
	:
		if(isLuma)then
			getFlag(codBlkPat[x/4][(y/4) & 1],(y&3)*2 + x&3)
		else
			false
		end
	end

	/**
	 * Get informations needed about the current macroblock.
	 * 
	 */
	getMbType: action MbType:[mbTypeVal], DisDbfIdc :[disDbfIdc],
	                  NeighbourAvail :[isMbaAvail , isMbbAvail 
	                                 , isMbcAvail , isMbdAvail],
	                  MbLocation :[mbX, mbY],
	                  CodedBlockPattern :[codedBlkPattern],
	                  FilterOffsetA :[filtOffAVal],
	                  FilterOffsetB :[filtOffBVal]
	                  ==>
	                  FilterEdges :[filterLeft, filterInternal, filterTop]
	do
		filterInternal := (disDbfIdc != 1);
		filterLeft     :=
			if((mbX = 0) or (disDbfIdc = 1) or 
			  ((disDbfIdc = 2) and not isMbaAvail))then
				false
			else
				true
			end;
		filterTop :=
			if((mbY = 0) or (disDbfIdc = 1) or
			  ((disDbfIdc = 2) and not isMbbAvail))then
				false
			else
				true
			end;
		mbLocX := mbX;
		mbLocY := mbY;
		mbType[mbX][mbY&1]    := mbTypeVal;
		codBlkPat[mbX][mbY&1] := codedBlkPattern;
		filterOffsetA := filtOffAVal;
		filterOffsetB := filtOffBVal;
	end

	/**
	 * Store the current value of Qp
	 */
	getQp.launch: action QpIn :[qpIn] ==>
	guard
		mbType[mbLocX][mbLocY&1] != BLOCK_TYPE_I_PCM
	do
		qpTable[mbLocX][mbLocY] := qpIn;
	end

	getQp.skip: action ==>
	guard
		mbType[mbLocX][mbLocY&1] = BLOCK_TYPE_I_PCM
	do
		qpTable[mbLocX][mbLocY] := 0;
	end

	/**
	 * Get the prediction's values
	 */
	getRefIdx.launch: action RefIdx :[refIdxVal] repeat 16,
		Mv :[mvVal] repeat 32 ==>
	guard
		   mbIsPred(mbType[mbLocX][mbLocY&1])
		or mbIsBiPred(mbType[mbLocX][mbLocY&1])
	do
		foreach int y in 0 .. 3
		do
			foreach int x in 0 .. 3
			do
				refIdx[mbLocX*4+x][(mbLocY&1)*4+y] := refIdxVal[y*4+x];
				mv[mbLocX*4+x][(mbLocY&1)*4+y][0]  := refIdxVal[y*4+x];
				mv[mbLocX*4+x][(mbLocY&1)*4+y][1]  := refIdxVal[y*4+x + 16];
			end
		end
	end

	getRefIdx.skip: action ==>
	guard
		not mbIsPred(mbType[mbLocX][mbLocY&1]),
		not mbIsBiPred(mbType[mbLocX][mbLocY&1])
	do
		//refIdx[mbLocX][mbLocY&1] := 0;
	end

	sendDeblockFiltInfo: action ==>
	var
		uint(size=16) qpAv,
		int (size=7)  indexA,
		int (size=7)  indexB,
		uint(size=8)  alphaPrime,
		uint(size=8)  betaPrime,
		uint(size=16) alpha,
		uint(size=16) beta,
		uint(size=4)  BitDepth = 8
	do
		if(filterLeft)then
			qpAv := (qpTable[mbLocX-1][mbLocY&1] + qpTable[mbLocX][mbLocY&1]
			        + 1) >> 1;
			indexA     := clip_i32(qpAv+filterOffsetA,0,51);
			alphaPrime := ALPHA_PRIME_TAB[indexA];
			alpha      := alphaPrime *(1 <<(BitDepth - 8));

			indexB     := clip_i32(qpAv+filterOffsetB,0,51);
			betaPrime  := BETA_PRIME_TAB[indexB];
			beta       := betaPrime *(1<<(BitDepth - 8));
/*			foreach int i in 0 .. 15
			do

			end*/
		end
	end

	schedule fsm GetMbType:
		GetMbType           (getMbType           )--> GetQp;
		GetQp               (getQp               )--> GetRefIdx;
		GetRefIdx           (getRefIdx           )--> sendDeblockFiltInfo;
		sendDeblockFiltInfo (sendDeblockFiltInfo )--> GetMbType;
	end
	priority
		getQp.launch > getQp.skip;
	end
end