/********************************************************************************

This software module was originally developed by 
Florian Decologne (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
 
FU realizing Syntax Parsing for AVC
*****************************************************************************/

// This FU has been modified by Mickael Raulet (INSA of Rennes) Dec 2011

package org.mpeg4.part10.cbp.synParser.Monolithic;

import org.mpeg4.part10.Imp_PictureInfo.*;
import org.mpeg4.part10.cbp.MacroBlockInfo.*;
import std.util.BitOps.*;
import org.mpeg4.part10.cbp.synParser.Monolithic.ParserUtils.*;
import org.sc29.wg11.common.BitstreamReadUtils.*;

actor Algo_Synp_AVC_CBP()
		uint(size=8) BYTE 
		==> int(size=9) pix_I_PCM,
			uint(size=4) IntraPredMode,
			uint(size=4) IntraPredModeC, 
			uint(size=4) RUN, 
			int(size=12) VALUE, 
			bool LAST, 
			int(size=8) ScalingList, 
			int(size=8) QP, 
			int(size=8) QP_Cb, 
			int(size=8) QP_Cr, 
			uint(size=13) CurrMbAddr, 
			uint(size=7) PicWidthInMb, 
			uint(size=14) PicSize,
			int POC, 

			uint(size=4) MbPredRefIdxL0,
			int(size=16) MbPredResMvL0, 
			uint(size=4) SubMbPredRefIdxL0,
			int(size=16) SubMbPredResMvL0, 
			
			uint(size=31) RefReordering,
			uint(size=5)  Nb_RefFrame_l0,
			uint(size=31) MMCO,
			uint(size=5)  NumRefFrame,
			uint(size=31) FramNumCurrPic,
			uint(size=2)  RefList0Type,
			uint(size=31) MaxFrameNum,
			uint(size=16) cbp_blk,
			int(size=6) slice_alpha_c0_offset, 
			int(size=6) slice_beta_offset,
			uint(size=2) LFDisable,
			bool ConstrainedIFlag,
			int(size=16) WIDTH, 
			int(size=16) HEIGHT,

			uint(size=8) SizeDPBMax,
			uint(size=6) MbType,
			uint(size=4) SubMbType,
			uint(size=6) MbType4Pred,
			uint(size=7) MbLocation,
			bool NeighbourAvail,
			uint(size=2) IsMbSliceOrPic, 
			bool IsPicOrSlice
		:
  	uint(size=7) PICWIDTH =MAX_PICWIDTH_BLK;
	uint(size=7) PICHEIGHT=MAX_PICHEIGHT_BLK;

	uint(size=2) NEW_PIC   = 0;
	uint(size=2) NEW_SLICE = 1;
	uint(size=2) NEW_MB    = 2;

	bool DEBUG_BITSTREAM = false;
	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
	uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL];
	uint(size= 2) zeroByte := 0;
	/* */
  	action BYTE:[ b ] ==>
	guard 
		fifo[FIFO_CPT_BITS] <= (FIFO_SIZE-1)<<3
	var
		uint(size=4) fifo_idx  =  fifo[FIFO_IDX]
	do
		if zeroByte != 3 or b != EPR_VALUE then
			if b = START_CODE_VALUE and zeroByte = 3 then
				fifo[fifo_idx]      := b + START_CODE_FLAG;
			else
				fifo[fifo_idx]      := b;
			end
			fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] + 8;
			if DEBUG_BITSTREAM then
				println("fifo["+fifo_idx+"] := "+b+" \t "+fifo[FIFO_CPT_BITS]);
			end
			fifo[FIFO_IDX]      := (fifo_idx+1) & (FIFO_SIZE-1);
		end
		if b = 0 then
			zeroByte := ((zeroByte << 1) + 1) & 0x3;
		else
			zeroByte := 0;
		end
	end
	
	
	// ********** Read VLD ********** //
	int VLD_Counter;
	int Codeword;

	// ********** Read CAVLC ********** //
	bool NewCoeff := false;
	uint(size=2) CAVLC_type;// 0 coeff_token, 1 total_zeros, 2 run_before
	uint(size=7) coeff_token:=0;
	uint(size=4) total_zeros:=0;
	uint(size=4) run_before :=0;



	/*************************************************************
	*************************************************************
	********       		Slice DATA 	  	  		    *********
	*************************************************************
	*************************************************************/
	uint val_CurrMbAddr;
	uint(size=1) moreDataFlag;
	uint prevMbSkipped;
	uint mb_skip_run;
	uint(size=1) mb_field_decoding_flag := 0;

	uint Mb_x;
	uint Mb_y;
	uint PicWidthInMbs;
	//*************************************************************/


 	procedure more_rbsp_data()   
  	var 
  		uint(size=4) cptBits = (fifo[FIFO_CPT_BITS] - 1) & 7,
		uint(size=32) res[1],
 		uint(size=4) idx     = getFifoIdx(fifo[FIFO_CPT_BITS], fifo)
	begin
		if ((fifo[(idx + 3) & 7] & 0x100) = 0 and (fifo[(idx + 4) & 7] & 0x100) = 0 ) then 
				moreDataFlag:=1; 
			else 
				showBits ((cptBits + 1), fifo, res);
				moreDataFlag:=if(res[0] = 1<< cptBits) then 0 else 1 end;
			end
	end
	
  
	function mask_bits( int(size=41)v, int(size=41)n ) --> int :
		( v & (1 << n)-1 )
	end
  
	// ********** Read CAVLC ********** //

	function CAVLC_end() --> bool : not NewCoeff end

	procedure start_CAVLC(uint(size=2) x)
	begin
		NewCoeff := true;
		VLD_Counter := 0;
		Codeword := 0;
		CAVLC_type := x;
	end
      
	function TotalCoeff() --> uint(size=7) : (coeff_token >> 2) end
	function TrailingOnes() --> uint(size=2) : mask_bits(coeff_token,2) end
	function Abs(int x) --> uint : if x >= 0 then x else -x end end

	action /*bits:[ b ]*/ ==>
	guard
	NewCoeff,
	fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var int res[1]
	do
		vld_u(  1, fifo, res);
		VLD_Counter := VLD_Counter + 1;
		Codeword := ( (Codeword << 1) | if res[0] = 1 then 1 else 0 end);
		if CAVLC_type =0 then // coeff_token
			foreach int i in 0 .. 61 do
				if nc >=0 and nc < 2 then
					if VLD_Counter = VLC_nC_0to2[i][0] and Codeword = VLC_nC_0to2[i][1] then coeff_token := VLC_nC_0to2[i][2]; NewCoeff := false; end
				else
					if nc >=2 and nc < 4 then
						if VLD_Counter = VLC_nC_2to4[i][0] and Codeword = VLC_nC_2to4[i][1] then coeff_token := VLC_nC_2to4[i][2]; NewCoeff := false; end
					else
						if nc >=4 and nc < 8 then
							if VLD_Counter = VLC_nC_4to8[i][0] and Codeword = VLC_nC_4to8[i][1] then coeff_token := VLC_nC_4to8[i][2]; NewCoeff := false; end
						else
							if nc >=8 then
								if VLD_Counter = VLC_nC_8[i][0] and Codeword = VLC_nC_8[i][1] then coeff_token := VLC_nC_8[i][2]; NewCoeff := false; end 
							else
								if nc = -1 and i <14 then
									if VLD_Counter = VLC_nC_1[i][0] and Codeword = VLC_nC_1[i][1] then coeff_token := VLC_nC_1[i][2]; NewCoeff := false; end
								else
									if nc = -2 and i <30 then
										if VLD_Counter = VLC_nC_2[i][0] and Codeword = VLC_nC_2[i][1] then coeff_token := VLC_nC_2[i][2]; NewCoeff := false; end  
									end
								end
							end
						end
					end
				end
			end
		else
			if CAVLC_type = 1 then // total_zeros
				foreach int i in 0 .. (maxNumCoeff - TotalCoeff() ) do
					if maxNumCoeff != 4 and maxNumCoeff !=8 then 
						if VLD_Counter = VLC_total0[TotalCoeff()-1][i][0] and Codeword = VLC_total0[TotalCoeff()-1][i][1] then 
							total_zeros := VLC_total0[TotalCoeff()-1][i][2]; NewCoeff := false; 
						end
					else 
						if maxNumCoeff = 4 then
							if VLD_Counter = VLC_total0_Cr_DC2x2[TotalCoeff()-1][i][0] and Codeword = VLC_total0_Cr_DC2x2[TotalCoeff()-1][i][1] then 
								total_zeros := VLC_total0_Cr_DC2x2[TotalCoeff()-1][i][2]; NewCoeff := false; 
							end
						else //maxNumCoeff = 8
							println("Chroma DC 2x4 block not implemented");
						end
					end
				end
			else //run_before
				foreach int i in 0 .. zerosLeft do
					if zerosLeft > 6 then
						if VLD_Counter = VLC_run_before[6][i][0] and Codeword = VLC_run_before[6][i][1] then 
							run_before := VLC_run_before[6][i][2]; NewCoeff := false; 
						end
					else
						if VLD_Counter = VLC_run_before[zerosLeft-1][i][0] and Codeword = VLC_run_before[zerosLeft-1][i][1] then
							run_before := VLC_run_before[zerosLeft-1][i][2]; NewCoeff := false; 
						end         
					end
				end
			end
		end
	end
  

	/*************************************************************
	*************************************************************
	********              NAL Unit HEADER                ********
	*************************************************************
	*************************************************************/


	look_for_Sequence_Header: action ==>
	end

	uint(size=2) nal_ref_idc :=0;
	uint(size=5) nal_unit_type :=0;
	
	read_Nal_unit_header: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		//println("=========== NAL_UNIT ===========");
		flushBits_name( 1, fifo,   "reserved_zero_1bits                     ");
		vld_u_name(  2, fifo, res, "nal_ref_idc                             "); nal_ref_idc  := res[0];
		vld_u_name(  5, fifo, res, "nal_unit_type                           "); nal_unit_type := res[0];
	end 
 
	look_for_other_header: action ==>
	end

	uint(size=8) sps_profile_idc;
	uint(size=8) sps_level_idc;


	look_for.Sps_header: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		nal_unit_type = NAL_UNIT_SPS
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "profile_idc                             "); sps_profile_idc                := res[0];
		flushBits_name( 1, fifo,   "constraint_set0_flag                    ");
		flushBits_name( 1, fifo,   "constraint_set1_flag                    ");
		flushBits_name( 1, fifo,   "constraint_set2_flag                    ");
		flushBits_name( 1, fifo,   "constraint_set3_flag                    ");
		flushBits_name( 1, fifo,   "constraint_set4_flag                    ");
		flushBits_name( 3, fifo,   "reserved_zero_3bits                     ");
		vld_u_name(  8, fifo, res, "level_idc                               "); sps_level_idc                  := res[0];
	end

	look_for.Pps_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_PPS
	end
 
	look_for.Slice_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_IDR or nal_unit_type = NAL_UNIT_NON_IDR
	end

	/*************************************************************
	*************************************************************
	********        Sequence Parameter Set HEADER        ********
	*************************************************************
	*************************************************************/

	int sps_i;
	List (type: uint(size=8), size=32) level_idc := [ 0 : for int i in 0 .. 31 ];
	uint(size=5) sps_id;

	// High Profile
	List (type:uint(size=2), size=32 ) chroma_format_idc := [ 1 : for int i in 0 .. 31 ];
	List (type:uint(size=1), size=32 ) separate_colour_plane_flag := [ 0 : for int i in 0 .. 31 ];
	List (type:uint(size=3), size=32 ) bit_depth_luma_minus8 := [ 0 : for int i in 0 .. 31 ];
	List (type:uint(size=3), size=32 ) bit_depth_chroma_minus8 := [ 0 : for int i in 0 .. 31 ];

	List (type: uint(size=4), size=32) log2_max_frame_num_minus4 := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=2), size=32) pic_order_cnt_type := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=4), size=32) log2_max_pic_order_cnt_lsb_minus4 := [ 0 : for int i in 0 .. 31 ];
  
	List (type: uint(size=1), size=32) delta_pic_order_always_zero_flag := [ 0 : for int i in 0 .. 31 ];
	List (type: int, size=32) offset_for_non_ref_pic := [ 0 : for int i in 0 .. 31 ];
	List (type: int, size=32) offset_for_top_to_bottom_field := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=8), size=32) num_ref_frames_in_pic_order_cnt_cycle := [ 0 : for int i in 0 .. 31 ];
	List (type: List ( type: int, size=255), size=32 ) offset_for_ref_frame := [[ 0 : for int i in 0 .. 254 ]: for int j in 0 .. 31 ];

	List (type: uint, size=32) num_ref_frames := [ 0 : for int i in 0 .. 31 ];
	List (type: uint, size=32) pic_width_in_mbs_minus1 := [ 0 : for int i in 0 .. 31 ];
	List (type: uint, size=32) pic_height_in_map_units_minus1 := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=1), size=32) frame_mbs_only_flag := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=1), size=32) direct_8x8_interference_flag := [ 0 : for int i in 0 .. 31 ];

	List (type: uint(size=5), size=32) MaxDPBSz := [16 : for int i in 0 .. 31];
	uint(size=1) frame_cropping_flag;
	uint(size=1) vui_parameters_present_flag;

	read_Sps_id: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "seq_parameter_set_id                    "); sps_id                     := res[0]; // getBits(10) max
		level_idc[sps_id] := sps_level_idc;
	end
  
	read_Sps_chroma_format_idc: action ==>
	guard
		sps_profile_idc = 100 or sps_profile_idc = 110 or
		sps_profile_idc = 122 or sps_profile_idc = 244 or sps_profile_idc = 44 or
		sps_profile_idc = 83 or sps_profile_idc = 86 or sps_profile_idc = 118
	end
	
	read_Sps_log2_max_frame_num_minus4: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "log2_max_frame_num_minus4               ");
		log2_max_frame_num_minus4[sps_id] := res[0];
		vld_ue_name(    fifo, res, "pic_order_cnt_type                      ");
		pic_order_cnt_type[sps_id] := res[0];
	end

	// if pic_order_cnt_type == 0
	read_Sps_log2_max_pic_order_cnt_lsb_minus4: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		pic_order_cnt_type[sps_id] = 0
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "log2_max_pic_order_cnt_lsb_minus4       ");
		log2_max_pic_order_cnt_lsb_minus4[sps_id] := res[0];
	end
 
	// else if pic_order_cnt_type == 1
	read_Sps_delta_pic_order_always_zero_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		pic_order_cnt_type[sps_id] = 1
	var
		uint(size=32) res[1]
	do
		vld_u_name( 1, fifo, res,  "delta_pic_order_always_zero_flag        ");
		delta_pic_order_always_zero_flag[sps_id] := res[0];
		vld_se_name(    fifo, res, "offset_for_non_ref_pic                  ");
		offset_for_non_ref_pic[sps_id] := res[0];
	end

	read_Sps_offset_for_top_to_bottom_field: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "offset_for_top_to_bottom_field          ");
		offset_for_top_to_bottom_field[sps_id] := res[0];
		vld_ue_name(    fifo, res, "num_ref_frames_in_pic_order_cnt_cycle   ");
		num_ref_frames_in_pic_order_cnt_cycle[sps_id] := res[0];
		sps_i:=0;
	end

	// for (i=0 ; i<num_ref_frames_in_pic_order_cnt_cycle ; i++) 
	read_Sps_offset_for_ref_frame.loop: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		sps_i<num_ref_frames_in_pic_order_cnt_cycle[sps_id]
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "offset_for_ref_frame                    ");
		offset_for_ref_frame[sps_id][sps_i] := res[0];
		sps_i := sps_i + 1;
	end

	read_Sps_offset_for_ref_frame.done: action ==>
	guard
		sps_i=num_ref_frames_in_pic_order_cnt_cycle[sps_id]
	end
	// end for

	// else (pic_order_cnt_type != 0 and !=1)
	read_Sps_pic_order_cnt_type_skip01: action ==>
	guard
		pic_order_cnt_type[sps_id] !=0,
		pic_order_cnt_type[sps_id] !=1
	end
	// end if

	read_Sps_num_ref_frames: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res,   "num_ref_frames                          ");
		num_ref_frames[sps_id] := res[0];
		flushBits_name(1,  fifo,   "gaps_in_frame_num_value_allowed_flag    ");
		vld_ue_name(    fifo, res, "pic_width_in_mbs_minus1                 ");
		pic_width_in_mbs_minus1[sps_id] := res[0];
		vld_ue_name(    fifo, res, "pic_height_in_map_units_minus1          ");
		pic_height_in_map_units_minus1[sps_id] := res[0];
	end

	read_Sps_frame_mbs_only_flag: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(1, fifo, res,   "frame_mbs_only_flag                     ");
		frame_mbs_only_flag[sps_id] := res[0];
	end

	// if (!frame_mbs_only_flag)
	read_Sps_mb_adaptive_frame_field_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) PicWidthInMacroBs,
		uint(size=32) FrameHeightInMacroBs,
		uint(size=8)  Val_Level_IDC,
		int(size=32)  MaxDPB_x_2,
		uint(size=32) MaxFS,
		uint(size=32) Sqrt_8MaxFS,
		uint(size=32) FrameHeight_x_PicWidth,
		uint(size=32) MaxDPBSize,
		uint(size=32) res[1]
	do
		if (frame_mbs_only_flag[sps_id] = 0) then
			frame_mbs_only_flag[sps_id] := 0;
			Val_Level_IDC := level_idc[sps_id];
			if(Val_Level_IDC < 31) then                          // 1 <= Level Number <= 3
				if(Val_Level_IDC < 12) then                           // 1 <= Level Number <= 1.1
					if(   Val_Level_IDC = 10 
					   or ((level_idc[sps_id] & 0x10) = 0)) then            // Level Number = 1 or 1b
						MaxFS       := 99;
						Sqrt_8MaxFS := 28;
						MaxDPB_x_2  := 297;
					else                                                        // Level Number = 1.1
						MaxFS       := 396;
						Sqrt_8MaxFS := 56;
						MaxDPB_x_2  := 675;
					end
				else                                                  // 1.2 <= Level Number <= 3
					if(Val_Level_IDC < 21) then                                 // 1.2 <= Level Number <= 2
						MaxFS       := 396;
						Sqrt_8MaxFS := 56;
						MaxDPB_x_2  := 1782;
					else                                              // 2.1 <= Level Number <= 3
						if(Val_Level_IDC = 21) then                             // Level Number = 2.1
							MaxFS       := 792;
							Sqrt_8MaxFS := 80;//79.5989
							MaxDPB_x_2  := 3564;
						else                                                    // Level Number = 2.2 or 3
							MaxFS       := 1620;
							Sqrt_8MaxFS := 114;//113.8419
							MaxDPB_x_2  := 6075;
						end
					end
				end
			else                                                 // 3.1 <= Level Number <= 5.1
				if(Val_Level_IDC < 42) then                           // 3.1 <= Level Number <= 4.1
					if(Val_Level_IDC < 33) then                            // 3.1 <= Level Number <= 3.2
						if(Val_Level_IDC = 31) then                             // Level Number = 3.1
							MaxFS       := 3600;
							Sqrt_8MaxFS := 170;//169.7056
							MaxDPB_x_2  := 13500;
						else                                                    // Level Number = 3.2
							MaxFS       := 5120;
							Sqrt_8MaxFS := 202;//202.3858
							MaxDPB_x_2  := 15360;
						end
					else                                                        // Level Number = 4 or 4.1
						MaxFS       := 8192;
						Sqrt_8MaxFS := 256;//256
						MaxDPB_x_2  := 24576;
					end
				else                                                  // 4.2 <= Level Number <= 5.1
					if(Val_Level_IDC = 42) then                                 // Level Number = 4.2
						MaxFS       := 8704;
						Sqrt_8MaxFS := 264;//263.8788
						MaxDPB_x_2  := 26112;
					else
						if(Val_Level_IDC = 50) then                             // Level Number = 5
							MaxFS       := 22080;
							Sqrt_8MaxFS := 420;//420.2856
							MaxDPB_x_2  := 82800;
						else                                                    // Level Number = 5.1
							MaxFS       := 36864;
							Sqrt_8MaxFS := 543;//543.0580
							MaxDPB_x_2  := 138240;
						end
					end
				end
			end
			PicWidthInMacroBs    := pic_width_in_mbs_minus1[sps_id] + 1;
			FrameHeightInMacroBs := (2 - 0) * (pic_height_in_map_units_minus1[sps_id] + 1);
			if(PicWidthInMacroBs > Sqrt_8MaxFS) then
				PicWidthInMacroBs := Sqrt_8MaxFS;
			end
			if(FrameHeightInMacroBs > Sqrt_8MaxFS) then
				FrameHeightInMacroBs := Sqrt_8MaxFS;
			end
			FrameHeight_x_PicWidth := FrameHeightInMacroBs * PicWidthInMacroBs;
			if(FrameHeight_x_PicWidth > MaxFS) then
				FrameHeight_x_PicWidth := MaxFS;
			end
			MaxDPBSize := (512 * MaxDPB_x_2) / (FrameHeight_x_PicWidth * 384);
			if(MaxDPBSize >= 16) then
				MaxDPBSz[sps_id] := 16;
			else
				MaxDPBSz[sps_id] := MaxDPBSize;
			end
			vld_u_name(1, fifo, res,   "mb_adaptive_frame_field_flag                             ");
		else //frame_mbs_only_flag[sps_id] != 0
			Val_Level_IDC := level_idc[sps_id];
			if(Val_Level_IDC < 31) then                          // 1 <= Level Number <= 3
				if(Val_Level_IDC < 12) then                           // 1 <= Level Number <= 1.1
					if(   Val_Level_IDC = 10 
					   or ((level_idc[sps_id] & 0x10) = 0)) then            // Level Number = 1 or 1b
						MaxFS       := 99;
						Sqrt_8MaxFS := 28;
						MaxDPB_x_2  := 297;
					else                                                        // Level Number = 1.1
						MaxFS       := 396;
						Sqrt_8MaxFS := 56;
						MaxDPB_x_2  := 675;
					end
				else                                                  // 1.2 <= Level Number <= 3
					if(Val_Level_IDC < 21) then                                 // 1.2 <= Level Number <= 2
						MaxFS       := 396;
						Sqrt_8MaxFS := 56;
						MaxDPB_x_2  := 1782;
					else                                              // 2.1 <= Level Number <= 3
						if(Val_Level_IDC = 21) then                             // Level Number = 2.1
							MaxFS       := 792;
							Sqrt_8MaxFS := 80;//79.5989
							MaxDPB_x_2  := 3564;
						else                                                    // Level Number = 2.2 or 3
							MaxFS       := 1620;
							Sqrt_8MaxFS := 114;//113.8419
							MaxDPB_x_2  := 6075;
						end
					end
				end
			else                                                 // 3.1 <= Level Number <= 5.1
				if(Val_Level_IDC < 42) then                           // 3.1 <= Level Number <= 4.1
					if(Val_Level_IDC < 33) then                            // 3.1 <= Level Number <= 3.2
						if(Val_Level_IDC = 31) then                             // Level Number = 3.1
							MaxFS       := 3600;
							Sqrt_8MaxFS := 170;//169.7056
							MaxDPB_x_2  := 13500;
						else                                                    // Level Number = 3.2
							MaxFS       := 5120;
							Sqrt_8MaxFS := 202;//202.3858
							MaxDPB_x_2  := 15360;
						end
					else                                                        // Level Number = 4 or 4.1
						MaxFS       := 8192;
						Sqrt_8MaxFS := 256;//256
						MaxDPB_x_2  := 24576;
					end
				else                                                  // 4.2 <= Level Number <= 5.1
					if(Val_Level_IDC = 42) then                                 // Level Number = 4.2
						MaxFS       := 8704;
						Sqrt_8MaxFS := 264;//263.8788
						MaxDPB_x_2  := 26112;
					else
						if(Val_Level_IDC = 50) then                             // Level Number = 5
							MaxFS       := 22080;
							Sqrt_8MaxFS := 420;//420.2856
							MaxDPB_x_2  := 82800;
						else                                                    // Level Number = 5.1
							MaxFS       := 36864;
							Sqrt_8MaxFS := 543;//543.0580
							MaxDPB_x_2  := 138240;
						end
					end
				end
			end
			PicWidthInMacroBs    := pic_width_in_mbs_minus1[sps_id] + 1;
			FrameHeightInMacroBs := (2 - 0) * (pic_height_in_map_units_minus1[sps_id] + 1);
			if(PicWidthInMacroBs > Sqrt_8MaxFS) then
				PicWidthInMacroBs := Sqrt_8MaxFS;
			end
			if(FrameHeightInMacroBs > Sqrt_8MaxFS) then
				FrameHeightInMacroBs := Sqrt_8MaxFS;
			end
			FrameHeight_x_PicWidth := FrameHeightInMacroBs * PicWidthInMacroBs;
			if(FrameHeight_x_PicWidth > MaxFS) then
				FrameHeight_x_PicWidth := MaxFS;
			end
			MaxDPBSize := (512 * MaxDPB_x_2) / (FrameHeight_x_PicWidth * 384);
			if(MaxDPBSize >= 16) then
				MaxDPBSz[sps_id] := 16;
			else
				MaxDPBSz[sps_id] := MaxDPBSize;
			end
		end
	end

	read_Sps_direct_8x8_interference_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(1, fifo, res,   "direct_8x8_interference_flag                    ");
		direct_8x8_interference_flag[sps_id] := res[0];
		vld_u_name(1, fifo, res,   "frame_cropping_flag                             ");
		frame_cropping_flag := res[0];
	end

	// if (frame_cropping_flag)
	read_Sps_frame_crop_left_offset: action ==>
	guard
		frame_cropping_flag = 1
	end


	// else (!frame_cropping_flag)
	read_Sps_skip_frame_crop_left_offset: action ==>
	guard
		frame_cropping_flag = 0
	end
	//end if 

	read_Sps_vui_parameters_present_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(1, fifo, res,   "vui_parameters_present_flag                             ");
		vui_parameters_present_flag := res[0];
	end

	read_Sps_vui_parameters: action ==>
	guard
		vui_parameters_present_flag=1
	end
		
	read_Sps_done: action ==>
	guard
		vui_parameters_present_flag=0
	end
	/******* End of Sequence Parameter Set HEADER  ********/

	/*************************************************************
	*************************************************************
	********        Picture Parameter Set HEADER        *********
	*************************************************************
	*************************************************************/
	uint(size=8) pps_id;
	List (type:uint(size=5),size=255) sequence_parameter_set_id := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=1),size=255) entropy_coding_mode_flag := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=1),size=255) bottom_field_pic_order_in_frame_present_flag := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=3),size=255) num_slice_groups_minus1 := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=3),size=255) slice_group_map_type := [ 0 : for int i in 0 .. 254];

	List (type:uint,size=255) slice_group_change_rate_minus1 := [ 0 : for int i in 0 .. 254];

	List (type:uint(size=5),size=255) num_ref_idx_l0_active_minus1 := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=5),size=255) num_ref_idx_l1_active_minus1 := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=1),size=255) weighted_pred_flag := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=2),size=255) weighted_bipred_idc := [ 0 : for int i in 0 .. 254];
	List (type:int(size=6),size=255) pic_init_qp_minus26 := [ 0 : for int i in 0 .. 254];
	List (type:int(size=5),size=255) chroma_qp_index_offset := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=1),size=255) deblocking_filter_control_present_flag := [ 0 : for int i in 0 .. 254];
	List (type:bool,size=255) constrained_intra_pred_flag := [ false : for int i in 0 .. 254];
	List (type:uint(size=1),size=255) redundant_pic_cnt_present_flag := [ 0 : for int i in 0 .. 254];

	//High profile 
	List (type:uint(size=1),size=255) transform_8x8_mode_flag := [ 0 : for int i in 0 .. 254];
	List (type:int(size=5),size=255) second_chroma_qp_index_offset := [ 0 : for int i in 0 .. 254];


	//*************************************
	read_Pps_seq_parameter_set_id: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res,   "pps_id                             ");
		pps_id := res[0];
		vld_ue_name(  fifo, res,   "sequence_parameter_set_id                             ");
		sequence_parameter_set_id[pps_id] := res[0];
	end

	read_Pps_num_slice_groups_minus1: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(1,  fifo, res,  "entropy_coding_mode_flag                             ");
		entropy_coding_mode_flag[pps_id] := res[0];
		vld_u_name(1,  fifo, res,  "bottom_field_pic_order_in_frame_present_flag                             ");
		bottom_field_pic_order_in_frame_present_flag[pps_id] := res[0];
		vld_ue_name(  fifo, res,   "num_slice_groups_minus1                             ");
		num_slice_groups_minus1[pps_id] := res[0];
	end

	// if (num_slice_groups_minus1 <=0)
	read_Pps_slice_group_map_type_skip: action ==>
	guard
		num_slice_groups_minus1[pps_id] >= 0
	end

	// if (num_slice_groups_minus1 >0)
	read_Pps_slice_group_map_type: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		num_slice_groups_minus1[pps_id] > 0
	do
		println("num_slice_groups_minus1 > 0 not yet implemented");
	end
	// end if

	read_Pps_num_ref_idx_l0_active_minus1: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res,   "num_ref_idx_l0_active_minus1                    ");
		num_ref_idx_l0_active_minus1[pps_id] := res[0];
		vld_ue_name(  fifo, res,   "num_ref_idx_l1_active_minus1                    ");
		num_ref_idx_l1_active_minus1[pps_id] := res[0];
		vld_u_name(1,  fifo, res,  "weighted_pred_flag                              ");
		weighted_pred_flag[pps_id] := res[0];
		vld_u_name(2,  fifo, res,  "weighted_bipred_idc                             ");
		weighted_bipred_idc[pps_id] := res[0];
	end

	read_Pps_pic_init_qp_minus26: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_se_name(  fifo, res,   "pic_init_qp_minus26                             ");
		pic_init_qp_minus26[pps_id] := res[0];
		vld_se_name(  fifo, res,   "pic_init_qs_minus26                             ");
	end

	read_Pps_chroma_qp_index_offset: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_se_name(  fifo, res,   "chroma_qp_index_offset                          ");
		chroma_qp_index_offset[pps_id] := res[0];
		second_chroma_qp_index_offset[pps_id]:=res[0];
		vld_u_name(1,  fifo, res,  "deblocking_filter_control_present_flag          ");
		deblocking_filter_control_present_flag[pps_id] := res[0];
		vld_u_name(1,  fifo, res,  "constrained_intra_pred_flag                     ");
		constrained_intra_pred_flag[pps_id] := if (res[0] = 1) then true else false end ;
		vld_u_name(1,  fifo, res,  "redundant_pic_cnt_present_flag                  ");
		redundant_pic_cnt_present_flag[pps_id] := res[0];
	end

	read_Pps_more_rbsp_data: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
		more_rbsp_data();
	end 

	read_Pps_High_Profile: action ==>
	guard
		moreDataFlag = 1
	end

	read_Pps_not_High_Profile: action ==>
	guard
		moreDataFlag = 0
	end

	/******* End of Picture Parameter Set HEADER  ********/
  
	/*************************************************************
	*************************************************************
	********       Slice HEADER  	      *********
	*************************************************************
	*************************************************************/
	uint first_mb_in_slice ;
	uint(size=4) slice_type ;
	uint frame_num;
	uint(size=1) field_pic_flag := 0;
	int pic_order_cnt_lsb := 0;
	List (type:int,size=2)delta_pic_order_cnt  := [ 0 : for int i in 0 .. 1];
	uint(size=5) slice_num_ref_idx_l0_active_minus1 := 0;
	uint(size=5) slice_num_ref_idx_l1_active_minus1 := 0;
	uint(size=2) disable_deblocking_filter_idc := 0;
	int(size=5) slice_alpha_c0_offset_div2 := 0;
	int(size=5) slice_beta_offset_div2 := 0;
	int(size=6) val_slice_alpha_c0_offset := 0;
	int(size=6) val_slice_beta_offset := 0;

	uint(size=6) val_QP;
	uint(size=6) val_QP_Cb;
	uint(size=6) val_QP_Cr;

	uint(size=3) SLICE_TYPE_P = 0;
	uint(size=3) SLICE_TYPE_B = 1;
	uint(size=3) SLICE_TYPE_I = 2;
	uint(size=3) SLICE_TYPE_SP = 3;
	uint(size=3) SLICE_TYPE_SI = 4;


	read_SliceH_slice_type: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res,   "first_mb_in_slice                               ");
		first_mb_in_slice := res[0];
		vld_ue_name(  fifo, res,   "slice_type                                      ");
		slice_type := res[0];
		slice_type := slice_type mod 5;
		vld_ue_name(  fifo, res,   "pps_id                                          ");
		pps_id := res[0];
		sps_id := sequence_parameter_set_id[pps_id];
		if (separate_colour_plane_flag[sps_id] = 1) then
			vld_u_name(2,  fifo, res,  "colour_plane_id                                 ");
		end
	end

	read_SliceH_picSize: action ==> PicSize:[0, (pic_width_in_mbs_minus1[sps_id] + 1) * 16 - 1, 0, (pic_height_in_map_units_minus1[sps_id] + 1) * 16 - 1], WIDTH:[pic_width_in_mbs_minus1[sps_id] + 1], HEIGHT:[pic_height_in_map_units_minus1[sps_id] + 1]
	guard
		first_mb_in_slice = 0
	end

	read_SliceH_skip_picSize: action ==> 
	guard
		first_mb_in_slice != 0
	end

	read_SliceH_frame_num: action ==> NumRefFrame:[num_ref_frames[sps_id] ],FramNumCurrPic:[frame_num], MaxFrameNum:[ValMaxFrameNum]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		int(size=32) ValMaxFrameNum
	do
		vld_u_name(4+log2_max_frame_num_minus4[sps_id],  fifo, res, "frame_num                             ");
		frame_num := res[0];
		ValMaxFrameNum := 1 << (log2_max_frame_num_minus4[sps_id] + 4);
		if(frame_mbs_only_flag[sps_id] = 0) then
			vld_u_name(1,  fifo, res,   "field_pic_flag                             ");
			field_pic_flag := res[0];
			if (field_pic_flag=1) then
				vld_u_name(1,  fifo, res,  "bottom_field_flag                             ");
			end
		end
	end

	//if (nal_unit_type == 5)
	read_SliceH_idr_pic_id: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		if(nal_unit_type = 5) then
			vld_ue_name(  fifo, res, "idr_pic_id                             ");
		end
		if (pic_order_cnt_type[sps_id] = 0) then
			vld_u_name(log2_max_pic_order_cnt_lsb_minus4[sps_id] +4,  fifo, res, "pic_order_cnt_lsb                             ");
			pic_order_cnt_lsb := res[0];
			if (bottom_field_pic_order_in_frame_present_flag[pps_id] = 1 and field_pic_flag = 0) then
				vld_ue_name(  fifo, res, "delta_pic_order_cnt_bottom                             ");
			end
		end
	end

	read_SliceH_delta_pic_order_cnt0: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		if (pic_order_cnt_type[sps_id] = 1 and delta_pic_order_always_zero_flag[sps_id] = 0) then
			vld_se_name(  fifo, res, "idr_pic_id[0]                             ");
			delta_pic_order_cnt[0] := res[0];
			if( bottom_field_pic_order_in_frame_present_flag[sps_id] = 1 and field_pic_flag = 0 ) then
				vld_se_name(  fifo, res, "delta_pic_order_cnt[1]                             ");
				delta_pic_order_cnt[1] := res[0];
			end
		end
	end

	// MMO
	int prevPicOrderCntMsb := 0;
	int prevPicOrderCntLsb := 0;
	uint prev_frame_num := 0;
	uint prev_frame_num_offset := 0;

	CalcPOC: action ==> IsPicOrSlice:[first_mb_in_slice=0], 
		POC :[POC_val], 
		SizeDPBMax :[MaxDPBSz[sps_id]],IsMbSliceOrPic:[if first_mb_in_slice=0 then NEW_PIC else NEW_SLICE end]
	var 
		int PicOrderCntMsb,
		int TopFieldOrderCnt,
		int BottomFieldOrderCnt,
		int MaxPicOrderCntLsb = (1 << log2_max_pic_order_cnt_lsb_minus4[sps_id]+4)/2,
		int frame_num_offset, 
		int abs_frame_num, 
		int expected_delta_per_poc_cycle := 0, 
		int expectedpoc := 0,
		int POC_val:=0
	do
		if nal_unit_type = 5 then 
			frame_num_offset := 0;
		else 
			if frame_num < prev_frame_num then
				frame_num_offset := prev_frame_num_offset + (1 << 4+log2_max_frame_num_minus4[sps_id]);
			else
				frame_num_offset := prev_frame_num_offset;
			end
		end
		if pic_order_cnt_type[sps_id] = 0 then 
			if nal_unit_type = 5 then
				prevPicOrderCntMsb := 0;
				prevPicOrderCntLsb := 0;
			end
			if  (pic_order_cnt_lsb < prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) >= (MaxPicOrderCntLsb)) then
				PicOrderCntMsb :=  prevPicOrderCntMsb + MaxPicOrderCntLsb;
				prevPicOrderCntMsb := PicOrderCntMsb;
				prevPicOrderCntLsb := 0;
			else 
				if (pic_order_cnt_lsb > prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) > (MaxPicOrderCntLsb)) then 
					PicOrderCntMsb := prevPicOrderCntMsb - MaxPicOrderCntLsb;
					prevPicOrderCntMsb := PicOrderCntMsb;
				else
					PicOrderCntMsb :=  prevPicOrderCntMsb;
				end
			end
			BottomFieldOrderCnt := PicOrderCntMsb + pic_order_cnt_lsb;
			TopFieldOrderCnt := BottomFieldOrderCnt;
		else
			if pic_order_cnt_type[sps_id] = 1 then
				abs_frame_num := if num_ref_frames_in_pic_order_cnt_cycle[sps_id] != 0 then frame_num_offset + frame_num else 0 end ;
				if nal_ref_idc = 0 and abs_frame_num > 0 then abs_frame_num := abs_frame_num -1; end
				foreach int i in 0 .. num_ref_frames_in_pic_order_cnt_cycle[sps_id]-1 do
					expected_delta_per_poc_cycle := expected_delta_per_poc_cycle + offset_for_ref_frame[sps_id][ i ];
				end
				if abs_frame_num > 0 then
					expectedpoc := expected_delta_per_poc_cycle * ((abs_frame_num - 1) / num_ref_frames_in_pic_order_cnt_cycle[sps_id]);
					foreach int i in 0 .. ((abs_frame_num - 1) mod num_ref_frames_in_pic_order_cnt_cycle[sps_id]) do
						expectedpoc := expectedpoc + offset_for_ref_frame[sps_id][ i ];
					end
				else
					expectedpoc :=0;
				end
				if nal_ref_idc = 0 then expectedpoc := expectedpoc + offset_for_non_ref_pic[sps_id]; end
				TopFieldOrderCnt := expectedpoc + delta_pic_order_cnt[0];
				BottomFieldOrderCnt := TopFieldOrderCnt + offset_for_top_to_bottom_field[sps_id] + delta_pic_order_cnt[1];
				if field_pic_flag = 1 then BottomFieldOrderCnt := BottomFieldOrderCnt +delta_pic_order_cnt[1]; end
			else // pic_order_cnt_type[sps_id] = 2
				TopFieldOrderCnt := if nal_unit_type = 5 then 0 else if nal_ref_idc > 0 then ((frame_num_offset + frame_num) << 1) else ((frame_num_offset + frame_num) << 1) - 1 end end;
				BottomFieldOrderCnt := TopFieldOrderCnt; 
			end 
		end
		POC_val := if TopFieldOrderCnt < BottomFieldOrderCnt then TopFieldOrderCnt else BottomFieldOrderCnt end ;
		//println("Currentpoc "+POC);
		prev_frame_num_offset := frame_num_offset;
		prev_frame_num := frame_num;
		prevPicOrderCntLsb := pic_order_cnt_lsb;
	end

	//if (redundant_pic_cnt_present_flag)
	read_SliceH_redundant_pic_cnt: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=1) num_ref_idx_active_override_flag
	do
		if(redundant_pic_cnt_present_flag[pps_id] = 1) then
			vld_ue_name(  fifo, res, "redundant_pic_cnt                             ");
		end
		if( slice_type = SLICE_TYPE_B ) then
			vld_u_name(1,  fifo, res, "direct_spatial_mv_pred_flag                             ");
		end
		if( slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP or slice_type = SLICE_TYPE_B ) then
			vld_u_name(1,  fifo, res, "num_ref_idx_active_override_flag                             ");
			num_ref_idx_active_override_flag := res[0];
			if( num_ref_idx_active_override_flag=1) then
				vld_ue_name(  fifo, res, "num_ref_idx_l0_active_minus1                             ");
				slice_num_ref_idx_l0_active_minus1 := res[0];
				if( slice_type = SLICE_TYPE_B ) then
					vld_ue_name(  fifo, res, "num_ref_idx_l1_active_minus1                             ");
					slice_num_ref_idx_l1_active_minus1 := res[0];
				end
			else
				slice_num_ref_idx_l0_active_minus1 := num_ref_idx_l0_active_minus1[pps_id];
				slice_num_ref_idx_l1_active_minus1 := num_ref_idx_l1_active_minus1[pps_id];
			end
		end
	end

	//*******  ref_pic_list_reordering  ********/
	uint(size=1) ref_pic_list_reordering_flag_l0;
	uint(size=2) reordering_of_pic_nums_idc;

	//if (slice_type % 5 != 2 && slice_type % 5 != 4)
	read_SliceH_ref_pic_list_reordering_flag_l0: action ==> RefList0Type:[0], RefReordering:[ref_pic_list_reordering_flag_l0], Nb_RefFrame_l0:[slice_num_ref_idx_l0_active_minus1 + 1]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI
	var
		uint(size=32) res[1]
	do
		vld_u_name(1,  fifo, res, "ref_pic_list_reordering_flag_l0                             ");
		ref_pic_list_reordering_flag_l0 := res[0];
		reordering_of_pic_nums_idc :=0;
	end

	//if (ref_pic_list_reordering_flag_l0) || (ref_pic_list_reordering_flag_l1)
	//do
	read_SliceH_ref_pic_list_reordering_flag.isl0: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		ref_pic_list_reordering_flag_l0 = 1
	end

	read_SliceH_reordering_of_pic_nums_idc: action ==> RefReordering:[reordering_of_pic_nums_idc]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res, "reordering_of_pic_nums_idc                             ");
		reordering_of_pic_nums_idc := res[0];
	end

	//if (reordering_of_pic_nums_idc == 0 || reordering_of_pic_nums_idc == 1)
	read_SliceH_reordering_of_pic_nums_idc.idc1: action ==> RefReordering:[abs_diff_pic_num_minus1]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		reordering_of_pic_nums_idc =0 or reordering_of_pic_nums_idc =1
	var
		uint(size=32) res[1],
		uint(size=32) abs_diff_pic_num_minus1
	do
		vld_ue_name(  fifo, res, "abs_diff_pic_num_minus1                             ");
		abs_diff_pic_num_minus1 := res[0];
	end

	//******* dec_ref_pic_marking  ********/
	uint(size=1) adaptative_ref_pic_marking_mode_flag;
	uint(size=3) memory_management_control_operation;
	

	// else if (reordering_of_pic_nums_idc == 2)
	read_SliceH_reordering_of_pic_nums_idc.idc2: action ==> RefReordering:[long_term_pic_num]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		reordering_of_pic_nums_idc =2
	var
		uint(size=32) res[1],
		uint(size=5) long_term_pic_num
	do
		vld_ue_name(  fifo, res, "long_term_pic_num                             ");
		long_term_pic_num := res[0];
	end

	//else (reordering_of_pic_nums_idc == 3)
	read_SliceH_reordering_of_pic_nums_idc.idc3: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		reordering_of_pic_nums_idc = 3
	end
	//end if
	//while (reordering_of_pic_nums_idc != 3)

	//else ( !ref_pic_list_reordering_flag_l0 && !ref_pic_list_reordering_flag_l1 )
	read_SliceH_skip_reordering_of_pic_nums_idc: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		ref_pic_list_reordering_flag_l0 = 0
	end
	//end if

	//else (slice_type % 5 == 2 || slice_type % 5 == 4)
	read_SliceH_skip_ref_pic_list_reordering: action ==> RefReordering:[0], Nb_RefFrame_l0:[0], RefList0Type:[0]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI
	end

	//end if
	//******* End of ref_pic_list_reordering  ********/


	//******* pred_weight_table  ********/
	//if (weighted_pred_flag && (slice_type == P or slice_type == SP)) ||
	//   (weighted_bipred_idc == 1 && slice_type == B)
	read_SliceH_pred_weight_table: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		(weighted_pred_flag[sps_id] = 1 and (slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP))
		or (weighted_bipred_idc[sps_id] = 1 and slice_type = SLICE_TYPE_B)
	do
		println("SliceH : pred_weight_table not yet implemented"); 
	end
 
	//else
	read_SliceH_skip_pred_weight_table: action ==>
	end
	//end if
	//******* End of pred_weight_table  ********/

	//******* dec_ref_pic_marking  ********/

	// if (nal_ref_idc !=0)
	read_SliceH_dec_ref_pic_marking: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		nal_ref_idc !=0
	end

	// if (IdrPicFlag)
	read_SliceH_no_output_of_prior_pics_flag_done: action ==> MMCO:[0, long_term_reference_flag]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		nal_unit_type = 5
	var
		uint(size=32) res[1],
		uint(size=1) long_term_reference_flag		
	do
		vld_u_name(1,  fifo, res, "no_output_of_prior_pics_flag                         ");
		vld_u_name(1,  fifo, res, "long_term_reference_flag                             ");
		long_term_reference_flag := res[0];
	end


	// else (!IdrPicFlag)
	read_SliceH_adaptative_ref_pic_marking_mode_flag_done: action ==> MMCO:[1,adaptative_ref_pic_marking_mode_flag]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		nal_unit_type != 5
	var
		uint(size=32) res[1]
	do
		vld_u_name(1,  fifo, res, "adaptative_ref_pic_marking_mode_flag                 ");
		adaptative_ref_pic_marking_mode_flag := res[0];
	end
	
	//else (nal_ref_idc == 0)
	read_SliceH_skip_dec_ref_pic_marking: action ==> MMCO :[if (nal_unit_type = 5) then 0 else 1 end,0]
	guard
		nal_ref_idc = 0
	end

	// if (adaptative_ref_pic_marking_mode_flag)
	//do
	read_SliceH_memory_management_control_operation_done: action ==> MMCO:[memory_management_control_operation]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		adaptative_ref_pic_marking_mode_flag = 1
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res, "memory_management_control_operation                   ");
		memory_management_control_operation := res[0];
	end

	// if (mmco == 1 || mmco == 3)
	read_SliceH_difference_of_pic_nums_minus1_done: action ==> MMCO:[difference_of_pic_nums_minus1]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation = 1 or memory_management_control_operation = 3
	var
		uint(size=32) res[1],
		uint(size=5) difference_of_pic_nums_minus1
	do
		vld_ue_name(  fifo, res, "difference_of_pic_nums_minus1                         ");
		difference_of_pic_nums_minus1 := res[0];
	end

	// end if

	// if (mmco == 2)
	read_SliceH_long_term_pic_num_done: action ==> MMCO:[long_term_pic_num]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation = 2
	var
		uint(size=32) res[1],
		uint(size=5) long_term_pic_num
	do
		vld_ue_name(  fifo, res, "long_term_pic_num                                   ");
		long_term_pic_num := res[0];
	end
	// end if

	// if (mmco == 3 || mmco == 6)
	read_SliceH_long_term_frame_idx_done: action ==> MMCO:[long_term_frame_idx]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation = 3 or memory_management_control_operation = 6
	var
		uint(size=32) res[1],
		uint(size=5) long_term_frame_idx
	do
		vld_ue_name(  fifo, res, "long_term_frame_idx                                ");
		long_term_frame_idx := res[0];
	end

	// if (mmco == 3 || mmco == 6)
	read_SliceH_long_not_term_frame_idx_done: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation != 3 and memory_management_control_operation != 6
	end
	// end if

	// if (mmco == 4)
	read_SliceH_max_long_term_frame_idx_plus1_done: action ==> MMCO:[max_long_term_frame_idx_plus1]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation = 4
	var
		uint(size=32) res[1],
		uint(size=5) max_long_term_frame_idx_plus1		
	do
		vld_ue_name(  fifo, res, "max_long_term_frame_idx_plus1                      ");
		max_long_term_frame_idx_plus1 := res[0];
	end

	// if (mmco == 5)
	read_SliceH_mmco_5: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation = 5
	do
		prev_frame_num:=0;
	end
	// end if

	// if (mmco == 0)
	read_SliceH_mmco_0: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation = 0
	end
	// end if
	// while (mmco != 0)

	// else (!adaptative_ref_pic_marking_mode_flag)
	read_SliceH_skip_memory_management_control_operation_done: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		adaptative_ref_pic_marking_mode_flag = 0
	end

	//end if
	//******* End of dec_ref_pic_marking  ********/

	//if (entropy_coding_mode_flag && slice_type != I && slice_type != SI)
	read_SliceH_cabac_init_idc: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		int slice_qp_delta
	do
		if (entropy_coding_mode_flag[pps_id] = 1 and
			slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI) then
			vld_ue_name(  fifo, res, "cabac_init_idc                             ");
		end
		vld_se_name(  fifo, res, "slice_qp_delta                             ");
		slice_qp_delta := res[0];
		val_QP := 26 + pic_init_qp_minus26[pps_id] + slice_qp_delta;
		val_QP_Cb := qP_tab[val_QP + chroma_qp_index_offset[pps_id]];
		val_QP_Cr := qP_tab[val_QP + second_chroma_qp_index_offset[pps_id]];
		if (slice_type = SLICE_TYPE_SP or slice_type = SLICE_TYPE_SI) then
			if slice_type = SLICE_TYPE_SP then 
				vld_u_name(1,  fifo, res, "sp_for_switch_flag                             ");
			end
			vld_se_name(  fifo, res, "slice_qs_delta                             ");
		end
	end


	// if ( deblocking_filter_control_present_flag )
	read_SliceH_disable_deblocking_filter_idc: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		if (deblocking_filter_control_present_flag[pps_id] = 1) then
			vld_ue_name(  fifo, res, "disable_deblocking_filter_idc                             ");
			disable_deblocking_filter_idc := res[0];
			if (disable_deblocking_filter_idc!=1) then
				vld_se_name(  fifo, res, "slice_alpha_c0_offset_div2                             ");
				slice_alpha_c0_offset_div2 := res[0];
				val_slice_alpha_c0_offset:=(slice_alpha_c0_offset_div2 << 1);
				vld_se_name(  fifo, res, "slice_beta_offset_div2                             ");
				slice_beta_offset_div2 := res[0];
				val_slice_beta_offset:=(slice_beta_offset_div2 << 1);
			else
				val_slice_alpha_c0_offset:=0;
				val_slice_beta_offset:=0;
			end
		else //deblocking_filter_control_present_flag[pps_id] = 0
			val_slice_alpha_c0_offset:=0;
			val_slice_beta_offset:=0;
		end
	end


	//if ( num_slice_groups_minus1 > 0 && slice_group_map_type >= 3 && slice_group_map_type <= 5 )
	read_SliceH_slice_group_change_cycle: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var 
		int x, 
		int n,
		uint(size=32) res[1]
	do
		if ( num_slice_groups_minus1[pps_id] > 0 and slice_group_map_type[pps_id] >= 3 and slice_group_map_type[pps_id] <= 5 ) then
			x := (pic_width_in_mbs_minus1[sps_id] + 1) * (pic_height_in_map_units_minus1[sps_id] +1) / slice_group_change_rate_minus1[pps_id] +1;
			//n := log_base2( x )
			x := x -1;
			n:= 0;
			while x>0 do
				x := (x >> 1);
				n := n+1;
			end
			vld_u_name(n,  fifo, res, "slice_group_change_cycle                             ");
		end
	end

	//******* End of Slice HEADER  ********/

	/*************************************************************
	*************************************************************
	********       Slice DATA 	  	      *********
	*************************************************************
	*************************************************************/
 
	procedure NextMbAddress()
	begin
		val_CurrMbAddr := val_CurrMbAddr + 1;
		Mb_x := val_CurrMbAddr mod PicWidthInMbs;
		Mb_y := val_CurrMbAddr / PicWidthInMbs;
	end


	//if (entropy_coding_mode_flag) : CABAC
	//while( !byte_aligned())
	read_SliceD_CABAC_alignement: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		entropy_coding_mode_flag[pps_id] = 1
	do
		byte_align(fifo);
	end

	read_SliceD_skip_CABAC_alignement: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		entropy_coding_mode_flag[pps_id] = 0
	end

	SliceD_init: action ==>
	do
		val_CurrMbAddr := first_mb_in_slice;
		PicWidthInMbs := (pic_width_in_mbs_minus1[sps_id] +1);
		NonZeroCount := [[ 0 : for int j in 0 .. 16-1] : for int i in 0 .. PICHEIGHT*PICWIDTH-1]; //FIXME ! size is not right
		NonZeroCountCb := [[ 0 : for int j in 0 .. 4-1] : for int i in 0 .. PICHEIGHT*PICWIDTH-1]; //FIXME ! size is not right
		NonZeroCountCr := [[ 0 : for int j in 0 .. 4-1] : for int i in 0 .. PICHEIGHT*PICWIDTH-1]; //FIXME ! size is not right

		Mb_x := val_CurrMbAddr mod PicWidthInMbs;
		Mb_y := val_CurrMbAddr / PicWidthInMbs;

		moreDataFlag := 1;
		prevMbSkipped := 0;
	end

	//do
	sync_do_mb_layer: action
		==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	end


	//if (slice_type != I && slice_type != SI)
	//  if (!entropy_coding_mode_flag) : CAVLC
	read_SliceD_mb_skip_run: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI,
		entropy_coding_mode_flag[pps_id] = 0
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res, "mb_skip_run                             ");
		mb_skip_run := res[0];
	end

	read_SliceD_mb_skip_run_done0: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
		if mb_skip_run >0 then 
			prevMbSkipped := 1; 
		else 
			prevMbSkipped := 0; 
		end
	end

	read_SliceD_mb_skip_run_done1.I_BLOCK: action 
		==> 
			CurrMbAddr:[mb_addr],
			IsMbSliceOrPic:[NEW_MB],
			PicWidthInMb:[PicWidthInMbs],
			slice_alpha_c0_offset:[val_slice_alpha_c0_offset],
			slice_beta_offset:[val_slice_beta_offset],
			LFDisable:[disable_deblocking_filter_idc],
			ConstrainedIFlag:[constrained_intra_pred_flag[pps_id]],
			cbp_blk:[0],
			QP:[val_QP], 
			QP_Cb:[val_QP_Cb], 
			QP_Cr:[val_QP_Cr], 
			MbType:[BLOCK_TYPE_P_SKIP],
			MbType4Pred :[BLOCK_TYPE_P_SKIP],
			NeighbourAvail:[Is_MbA_Avail , Is_MbB_Avail , Is_MbC_Avail , Is_MbD_Avail],
			MbLocation:[mb_x, mb_y]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		prevMbSkipped = 1,
		slice_type != SLICE_TYPE_P
	var 
		int mb_addr, int mb_x, int mb_y,
		int MbLocxInSlc, int MbLocyInSlc, int MbLocxInPic,
		bool Is_MbA_Avail, bool Is_MbB_Avail, bool Is_MbC_Avail, bool Is_MbD_Avail
	do
		mb_addr:=val_CurrMbAddr;
		mb_x:=Mb_x;
		mb_y:=Mb_y;
		MbLocxInPic  := val_CurrMbAddr mod PicWidthInMbs;
		MbLocxInSlc    := (val_CurrMbAddr - first_mb_in_slice) mod PicWidthInMbs;
		MbLocyInSlc    := (val_CurrMbAddr - first_mb_in_slice)  /  PicWidthInMbs;
		Is_MbA_Avail := MbLocxInPic != 0 and (MbLocxInSlc != 0 or MbLocyInSlc != 0);
		Is_MbB_Avail := MbLocyInSlc != 0;
		Is_MbC_Avail := (MbLocyInSlc >= 1 or (MbLocxInSlc + 1) = PicWidthInMbs) and (MbLocxInPic + 1 <  PicWidthInMbs);
		Is_MbD_Avail := (MbLocyInSlc >= 1) and (MbLocxInPic > 0 and (MbLocyInSlc > 1 or MbLocyInSlc = 1 and MbLocxInSlc > 0));
		NextMbAddress();
		mb_skip_run := mb_skip_run -1;
		if mb_skip_run = 0 then 
			prevMbSkipped := 0; 
			more_rbsp_data();
		end
	end

	read_SliceD_mb_skip_run_done1.P_BLOCK: action 
		==> 
			CurrMbAddr:[mb_addr],
			IsMbSliceOrPic:[NEW_MB],
			PicWidthInMb:[PicWidthInMbs],
			slice_alpha_c0_offset:[val_slice_alpha_c0_offset],
			slice_beta_offset:[val_slice_beta_offset],
			LFDisable:[disable_deblocking_filter_idc],
			ConstrainedIFlag:[constrained_intra_pred_flag[pps_id]],
			cbp_blk:[0],
			QP:[val_QP], 
			QP_Cb:[val_QP_Cb], 
			QP_Cr:[val_QP_Cr], 
			NeighbourAvail:[Is_MbA_Avail , Is_MbB_Avail , Is_MbC_Avail , Is_MbD_Avail],
			MbType:[BLOCK_TYPE_P_SKIP],
			MbType4Pred :[BLOCK_TYPE_P_SKIP],
			MbLocation:[mb_x, mb_y]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		prevMbSkipped = 1,
		slice_type = SLICE_TYPE_P
	var 
		int mb_addr, int mb_x, int mb_y,
		int MbLocxInSlc, int MbLocyInSlc, int MbLocxInPic,
		bool Is_MbA_Avail, bool Is_MbB_Avail, bool Is_MbC_Avail, bool Is_MbD_Avail
	do
		mb_addr:=val_CurrMbAddr;
		mb_x:=Mb_x;
		mb_y:=Mb_y;
		MbLocxInPic  := val_CurrMbAddr mod PicWidthInMbs;
		MbLocxInSlc    := (val_CurrMbAddr - first_mb_in_slice) mod PicWidthInMbs;
		MbLocyInSlc    := (val_CurrMbAddr - first_mb_in_slice)  /  PicWidthInMbs;
		Is_MbA_Avail := MbLocxInPic != 0 and (MbLocxInSlc != 0 or MbLocyInSlc != 0);
		Is_MbB_Avail := MbLocyInSlc != 0;
		Is_MbC_Avail := (MbLocyInSlc >= 1 or (MbLocxInSlc + 1) = PicWidthInMbs) and (MbLocxInPic + 1 <  PicWidthInMbs);
		Is_MbD_Avail := (MbLocyInSlc >= 1) and (MbLocxInPic > 0 and (MbLocyInSlc > 1 or MbLocyInSlc = 1 and MbLocxInSlc > 0));
		NextMbAddress();
		mb_skip_run := mb_skip_run -1;
		if mb_skip_run = 0 then 
			prevMbSkipped := 0; 
			more_rbsp_data();
		end
	end

	read_SliceD_mb_skip_run_done2: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		prevMbSkipped = 0
	end

	read_SliceD_mb_skip_run_done2_moredata_1: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		moreDataFlag = 1
	end

	read_SliceD_mb_skip_run_done2_moredata_0: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		moreDataFlag = 0
	end

	//else (slice_type = I || slice_type = SI)
	read_SliceD_skip_mb_skip: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI
	end
	//end if


	// else
	read_SliceD_skip_mb_field_decoding_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		moreDataFlag = 1
	end
	//end if
	// --> macrobloc_layer()
	//end if
	//if( !entropy_coding_mode_flag ) : CAVLC
	SliceD_update_CAVLC: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		entropy_coding_mode_flag[pps_id] = 0
	do
		more_rbsp_data();
	end

	send_data_position_information_is_ipcm: action 
		==> 
			CurrMbAddr:[mb_addr],
			IsMbSliceOrPic:[NEW_MB],
			PicWidthInMb:[PicWidthInMbs],
			slice_alpha_c0_offset:[val_slice_alpha_c0_offset],
			slice_beta_offset:[val_slice_beta_offset],
			LFDisable:[disable_deblocking_filter_idc],
			ConstrainedIFlag:[constrained_intra_pred_flag[pps_id]],
			NeighbourAvail:[Is_MbA_Avail , Is_MbB_Avail , Is_MbC_Avail , Is_MbD_Avail],
			cbp_blk:[cbp_blk_tmp],
			MbType:[BLOCK_TYPE_I_PCM],
			MbLocation:[mb_x, mb_y]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mb_type = BLOCK_TYPE_I_PCM
	var 
		int mb_addr,
		int cbp_blk_tmp=val_cbp_blk, int mb_x, int mb_y,
		int MbLocxInSlc, int MbLocyInSlc, int MbLocxInPic,
		bool Is_MbA_Avail, bool Is_MbB_Avail, bool Is_MbC_Avail, bool Is_MbD_Avail
	do
		mb_addr:=val_CurrMbAddr;
		mb_x:=Mb_x;
		mb_y:=Mb_y;
		MbLocxInPic  := val_CurrMbAddr mod PicWidthInMbs;
		MbLocxInSlc    := (val_CurrMbAddr - first_mb_in_slice) mod PicWidthInMbs;
		MbLocyInSlc    := (val_CurrMbAddr - first_mb_in_slice)  /  PicWidthInMbs;
		Is_MbA_Avail := MbLocxInPic != 0 and (MbLocxInSlc != 0 or MbLocyInSlc != 0);
		Is_MbB_Avail := MbLocyInSlc != 0;
		Is_MbC_Avail := (MbLocyInSlc >= 1 or (MbLocxInSlc + 1) = PicWidthInMbs) and (MbLocxInPic + 1 <  PicWidthInMbs);
		Is_MbD_Avail := (MbLocyInSlc >= 1) and (MbLocxInPic > 0 and (MbLocyInSlc > 1 or MbLocyInSlc = 1 and MbLocxInSlc > 0));
		NextMbAddress();
		val_cbp_blk:=0;
	end

	send_data_position_information.intraPred: action 
		==> 
			CurrMbAddr:[mb_addr],
			IsMbSliceOrPic:[NEW_MB],
			PicWidthInMb:[PicWidthInMbs],
			slice_alpha_c0_offset:[val_slice_alpha_c0_offset],
			slice_beta_offset:[val_slice_beta_offset],
			LFDisable:[disable_deblocking_filter_idc],
			ConstrainedIFlag:[constrained_intra_pred_flag[pps_id]],
			NeighbourAvail:[Is_MbA_Avail , Is_MbB_Avail , Is_MbC_Avail , Is_MbD_Avail],
			cbp_blk:[cbp_blk_tmp],
			QP:[val_QP], 
			QP_Cb:[val_QP_Cb], 
			QP_Cr:[val_QP_Cr], 
			ScalingList:[[16: for int s in 0 .. 15 ]] repeat 16,
			MbType:[mb_type],
			MbLocation:[mb_x, mb_y]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		Mb_IsIntra(mb_type)
	var 
		int mb_addr,
		int cbp_blk_tmp=val_cbp_blk, int mb_x, int mb_y,
		int MbLocxInSlc, int MbLocyInSlc, int MbLocxInPic,
		bool Is_MbA_Avail, bool Is_MbB_Avail, bool Is_MbC_Avail, bool Is_MbD_Avail
	do
		mb_addr:=val_CurrMbAddr;
		mb_x:=Mb_x;
		mb_y:=Mb_y;
		MbLocxInPic  := val_CurrMbAddr mod PicWidthInMbs;
		MbLocxInSlc    := (val_CurrMbAddr - first_mb_in_slice) mod PicWidthInMbs;
		MbLocyInSlc    := (val_CurrMbAddr - first_mb_in_slice)  /  PicWidthInMbs;
		Is_MbA_Avail := MbLocxInPic != 0 and (MbLocxInSlc != 0 or MbLocyInSlc != 0);
		Is_MbB_Avail := MbLocyInSlc != 0;
		Is_MbC_Avail := (MbLocyInSlc >= 1 or (MbLocxInSlc + 1) = PicWidthInMbs) and (MbLocxInPic + 1 <  PicWidthInMbs);
		Is_MbD_Avail := (MbLocyInSlc >= 1) and (MbLocxInPic > 0 and (MbLocyInSlc > 1 or MbLocyInSlc = 1 and MbLocxInSlc > 0));
		NextMbAddress();
		val_cbp_blk:=0;
	end

	send_data_position_information.interPred: action 
		==> 
			CurrMbAddr:[mb_addr],
			IsMbSliceOrPic:[NEW_MB],
			PicWidthInMb:[PicWidthInMbs],
			slice_alpha_c0_offset:[val_slice_alpha_c0_offset],
			slice_beta_offset:[val_slice_beta_offset],
			LFDisable:[disable_deblocking_filter_idc],
			ConstrainedIFlag:[constrained_intra_pred_flag[pps_id]],
			NeighbourAvail:[Is_MbA_Avail , Is_MbB_Avail , Is_MbC_Avail , Is_MbD_Avail],
			cbp_blk:[cbp_blk_tmp],
			QP:[val_QP], 
			QP_Cb:[val_QP_Cb], 
			QP_Cr:[val_QP_Cr], 
			ScalingList:[[16: for int s in 0 .. 15 ]] repeat 16,
			MbType:[mb_type],
			MbType4Pred:[mb_type],
			MbLocation:[mb_x, mb_y]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		not Mb_IsIntra(mb_type)
	var 
		int mb_addr,
		int cbp_blk_tmp=val_cbp_blk, int mb_x, int mb_y,
		int MbLocxInSlc, int MbLocyInSlc, int MbLocxInPic,
		bool Is_MbA_Avail, bool Is_MbB_Avail, bool Is_MbC_Avail, bool Is_MbD_Avail
	do
		mb_addr:=val_CurrMbAddr;
		mb_x:=Mb_x;
		mb_y:=Mb_y;
		MbLocxInPic  := val_CurrMbAddr mod PicWidthInMbs;
		MbLocxInSlc    := (val_CurrMbAddr - first_mb_in_slice) mod PicWidthInMbs;
		MbLocyInSlc    := (val_CurrMbAddr - first_mb_in_slice)  /  PicWidthInMbs;
		Is_MbA_Avail := MbLocxInPic != 0 and (MbLocxInSlc != 0 or MbLocyInSlc != 0);
		Is_MbB_Avail := MbLocyInSlc != 0;
		Is_MbC_Avail := (MbLocyInSlc >= 1 or (MbLocxInSlc + 1) = PicWidthInMbs) and (MbLocxInPic + 1 <  PicWidthInMbs);
		Is_MbD_Avail := (MbLocyInSlc >= 1) and (MbLocxInPic > 0 and (MbLocyInSlc > 1 or MbLocyInSlc = 1 and MbLocxInSlc > 0));
		NextMbAddress();
		val_cbp_blk:=0;
	end
	
	syncSliceD_endwhile: action ==>
	end

	SliceD_moredata_1: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		moreDataFlag = 1
	end

	SliceD_moredata_0: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		moreDataFlag = 0
	end

	//else (CABAC)
	SliceD_update_CABAC: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		entropy_coding_mode_flag[pps_id] = 1
	do
		println("SliceD_update_CABAC : CABAC not yet implemented");
	end

	//while( moreDataFlag )
	SliceD_while_moreDataFlag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		moreDataFlag = 1
	end

	SliceD_end: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		moreDataFlag = 0
	end
	//******* End of Slice DATA  ********/
 
	/*************************************************************
	*************************************************************
	********       Macroblock layer    	    *********
	*************************************************************
	*************************************************************/
	uint(size=6) mb_type;
	uint MB_inc;
	uint(size=1) noSubMbPartSizeLessThan8x8Flag;
	uint(size=1) transform_size_8x8_flag := 0;
	uint(size=6) val_CodedBlockPatternLuma := 0;
	uint(size=6) CodedBlockPatternChroma := 0;

	read_MB_layer_mb_type: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res, "mb_type                             ");
		mb_type := res[0];
		
		mb_type :=
			if((slice_type = SLICE_TYPE_SI) or (slice_type = SLICE_TYPE_I))then
				mb_type
			else
				if((slice_type = SLICE_TYPE_SP) or (slice_type = SLICE_TYPE_P))then
					if(mb_type >= 5) then
						if(mb_type < 32)then
							mb_type - 5
						else
							0
						end
					else
						mb_type + BLOCK_TYPE_P_MIN - BLOCK_TYPE_I_8x8
					end
				else
					if(mb_type < 23) then
						mb_type + BLOCK_TYPE_B_MIN - BLOCK_TYPE_I_8x8
					else
						if(mb_type < 49) then
							mb_type - 23
						else
							0
						end
					end
				end
			end;
		if mb_type != BLOCK_TYPE_I_4x4 then
			mb_type := mb_type + BLOCK_TYPE_I_8x8;
		end
		
	end

	//if( mb_type = = I_PCM )
	// while( !byte_aligned( ) )
	read_MB_layer_I_PCM_alignement: action  ==>  IntraPredMode : [ 4 ]
	guard
		mb_type = BLOCK_TYPE_I_PCM
	do
		byte_align(fifo);
		MB_inc := 0;
		foreach int i in 0 .. 15 do
			NonZeroCount[val_CurrMbAddr][i] := 16;
		end
		foreach  int i in 0 .. 3 do
			NonZeroCountCb[val_CurrMbAddr][i] := 16;
			NonZeroCountCr[val_CurrMbAddr][i] := 16;
		end
	end

	//for( i = 0; i < 256; i++ )
	read_MB_layer_pcm_sample_luma.loop: action ==>  pix_I_PCM:[ pcm_sample_luma ]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		MB_inc < 256
	var
		uint(size=32) res[1],
		uint(size=32) pcm_sample_luma
	do
		vld_u_name(bit_depth_luma_minus8[sps_id]+8,  fifo, res, "pcm_sample_luma                             ");
		pcm_sample_luma := res[0];
		MB_inc := MB_inc + 1;
	end

	read_MB_layer_pcm_sample_luma.done: action  ==> 
	guard
		MB_inc = 256
	do
		MB_inc := 0;
	end
	
	// for( i = 0; i < 2 * MbWidthC * MbHeightC; i++ )
	read_MB_layer_pcm_sample_chroma.loop: action   ==> pix_I_PCM:[ pcm_sample_chroma ]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		MB_inc < 2*64
	var
		uint(size=32) res[1],
		uint(size=32) pcm_sample_chroma
	do
		vld_u_name(bit_depth_chroma_minus8[sps_id]+8,  fifo, res, "pcm_sample_chroma                             ");
		pcm_sample_chroma := res[0];
		MB_inc := MB_inc + 1;
	end

	read_MB_layer_pcm_sample_chroma.done: action  ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		MB_inc = 2*64
	end

	//} else {
	read_MB_layer_not_I_PCM: action ==>
	guard
		not (mb_type = BLOCK_TYPE_I_PCM)
	do
		noSubMbPartSizeLessThan8x8Flag := 1;
	end

	//if( mb_type != I_NxN && MbPartPredMode( mb_type, 0 ) != Intra_16x16 && NumMbPart( mb_type ) = = 4 )
	read_MB_layer_sub_mb_pred: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		not Is_Intra_NxN(mb_type),
		not Is_Intra_16x16(mb_type),
		(numMbPart(mb_type) = 4) // numMbPart(mb_type) tests the slice_type and return 0 if slice_type is I or SI
	do
		mbPartIdx := 0;
	end
	// --> sub_mb_pred( mb_type )

	read_MB_layer_sub_mb_pred_done: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
		foreach int i in 0 .. 3 do
			mbPartIdx := i;
			//  if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 )
			if not IS_B_Direct_8x8() then
				//    if( NumSubMbPart( sub_mb_type[ mbPartIdx ] ) > 1 )
				if numSubMbPart(mb_type, sub_mb_type[mbPartIdx]) >1 then noSubMbPartSizeLessThan8x8Flag := 0; end
			else 
				if direct_8x8_interference_flag[sps_id] = 0 then noSubMbPartSizeLessThan8x8Flag := 0; end
			end
		end
	end

	// else (! ( mb_type != I_NxN && MbPartPredMode( mb_type, 0 ) != Intra_16x16 && NumMbPart( mb_type ) = = 4 ) )
	// if( transform_8x8_mode_flag && mb_type = = I_NxN )
	read_MB_layer_transform_size_8x8_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		numMbPart(mb_type) != 4, // numMbPart(mb_type) tests the slice_type and return 0 if slice_type is I or SI
		transform_8x8_mode_flag[pps_id] = 1 and Is_Intra_NxN(mb_type)
	var
		uint(size=32) res[1]
	do
		vld_u_name(1,  fifo, res, "transform_size_8x8_flag                             ");
		transform_size_8x8_flag := res[0];
	end

	// else
	read_MB_layer_skip_transform_size_8x8_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		numMbPart(mb_type) != 4
	end
	// end if 
	// --> mb_pred( mb_type )
	// end if

	// if( MbPartPredMode( mb_type, 0 ) != Intra_16x16 )
	read_MB_layer_coded_block_pattern: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=6) coded_block_pattern
	do
		if (not Is_Intra_16x16(mb_type)) then
			vld_me_name(  fifo, res, chroma_format_idc[sps_id], Is_Intra_NxN(mb_type), "coded_block_pattern                             ");
			coded_block_pattern := res[0];
			val_CodedBlockPatternLuma := coded_block_pattern mod 16;
			CodedBlockPatternChroma := coded_block_pattern / 16;
			if( val_CodedBlockPatternLuma > 0 and 
				transform_8x8_mode_flag[pps_id] = 1 and 
				Is_Intra_NxN(mb_type) and
				noSubMbPartSizeLessThan8x8Flag = 1 and
				(mb_type != BLOCK_TYPE_B_DIRECT_16x16 or direct_8x8_interference_flag[sps_id] = 1 ) )then 
					vld_u_name(1,  fifo, res, "transform_size_8x8_flag                             ");
					transform_size_8x8_flag := res[0];
			end
		else
			val_CodedBlockPatternLuma := Intra_16x16_tab[mb_type - BLOCK_TYPE_I_8x8][2];
			CodedBlockPatternChroma := Intra_16x16_tab[mb_type - BLOCK_TYPE_I_8x8][1];
		end
	end

	//if( val_CodedBlockPatternLuma > 0 || CodedBlockPatternChroma > 0 | | MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
	read_MB_layer_mb_qp_delta: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		val_CodedBlockPatternLuma > 0 or CodedBlockPatternChroma > 0 or Is_Intra_16x16(mb_type)
	var
		uint(size=32) res[1],
		int mb_qp_delta		
	do
		vld_se_name(  fifo, res, "mb_qp_delta                             ");
		mb_qp_delta := res[0];
		val_QP := (val_QP + mb_qp_delta + 52) mod 52;
		val_QP_Cb := qP_tab[val_QP + chroma_qp_index_offset[pps_id]];
		val_QP_Cr := qP_tab[val_QP + second_chroma_qp_index_offset[pps_id]];
	end
	// --> residual( )

	//else	
	read_MB_layer_skip_mb_qp_delta: action ==>  LAST:[[true: for int t in 0 .. 25 ]] repeat 26
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		( val_CodedBlockPatternLuma = 0 and CodedBlockPatternChroma = 0 and not Is_Intra_16x16(mb_type) )
	end
	//end if

	//end if
	//******* End of Macroblock layer  ********/

	/*************************************************************
	*************************************************************
	********       	Sub Mb Pred    	    *********
	*************************************************************
	*************************************************************/
	uint(size=3) mbPartIdx;
	uint(size=3) subMbPartIdx;
	List (type:uint,size=5) sub_mb_type := [ 0 : for int i in 0 .. 4];
	List (type:int,size=4) ref_idx_l0 := [ 0 : for int i in 0 .. 3];
 	function IS_B_Direct_8x8() --> bool : (mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX) and (sub_mb_type[mbPartIdx] = B_DIRECT_8x8) end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	read_sub_MB_pred_sub_mb_type.loop: action ==> SubMbType :[subMbType]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < 4
	var
		uint(size=4) subMbType,
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res, "sub_mb_type[mbPartIdx]                             ");
		sub_mb_type[mbPartIdx] := res[0];
		subMbType := sub_mb_type[mbPartIdx];
		mbPartIdx := mbPartIdx +1;
	end
	//end for

	read_sub_MB_pred_sub_mb_type.done: action ==>
	guard
		mbPartIdx = 4
	do
		mbPartIdx := 0;
	end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	//if( ( num_ref_idx_l0_active_minus1 > 0 | | mb_field_decoding_flag ) && mb_type != P_8x8ref0 && sub_mb_type[ mbPartIdx ] != B_Direct_8x8 && SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L1 )
	read_sub_MB_pred_ref_idx_l0.loop: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < 4
	var
		uint(size=32) res[1]
	do
		if ((slice_num_ref_idx_l0_active_minus1 > 0 or mb_field_decoding_flag = 1) and
			not IS_B_Direct_8x8() and 
			not (mb_type = BLOCK_TYPE_P_8x8ref0) and 
			(subMbPredMode(mb_type, sub_mb_type[ mbPartIdx ] ) != PRED_L1)) then
			if slice_num_ref_idx_l0_active_minus1 = 1 then 
				vld_u_name(1,  fifo, res, "ref_idx_l0[mbPartIdx]                             ");
				ref_idx_l0[mbPartIdx] := 1 - res[0];
			else
				vld_ue_name(  fifo, res, "ref_idx_l0[mbPartIdx]                             ");
				ref_idx_l0[mbPartIdx] := res[0];
			end
		else
			ref_idx_l0[mbPartIdx] := 0;
		end
		mbPartIdx := mbPartIdx +1;
	end
	//end for

	read_sub_MB_pred_ref_idx_l0.done: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx = 4
	do
		mbPartIdx := 0;
	end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	//if( ( num_ref_idx_l0_active_minus1 > 0 | | mb_field_decoding_flag ) && mb_type != P_8x8ref0 && sub_mb_type[ mbPartIdx ] != B_Direct_8x8 && SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L0 )
	read_sub_MB_pred_ref_idx_l1.loop: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < 4
	var
		uint(size=32) res[1]
	do
		if ((slice_num_ref_idx_l1_active_minus1 > 0 or mb_field_decoding_flag = 1) 
			and not IS_B_Direct_8x8() 
			and not (mb_type = BLOCK_TYPE_P_8x8ref0)
			and (subMbPredMode(mb_type, sub_mb_type[ mbPartIdx ] ) != PRED_L0)) then
			if slice_num_ref_idx_l1_active_minus1 = 1 then 
				vld_u_name(1,  fifo, res, "ref_idx_l1[mbPartIdx]                             ");
			else
				vld_ue_name(  fifo, res, "ref_idx_l1[mbPartIdx]                             ");
			end
		end
		mbPartIdx := mbPartIdx +1;
	end

	//end for
	read_sub_MB_pred_ref_idx_l1.done: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx = 4
	do
		mbPartIdx := 0;
	end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	// if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 && SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L1 )
	read_sub_MB_pred_mvd_l0.loop: action ==> 
	guard
		mbPartIdx < 4,
		not IS_B_Direct_8x8(), (subMbPredMode(mb_type, sub_mb_type[ mbPartIdx ] ) != PRED_L1)
	do
		subMbPartIdx := 0;
	end
	//   for( subMbPartIdx = 0; subMbPartIdx < NumSubMbPart( sub_mb_type[ mbPartIdx ] ); subMbPartIdx++)
	//     for( compIdx = 0; compIdx < 2; compIdx++ )
	read_sub_MB_pred_mvd_l0.inner.loop: action ==> 
		SubMbPredRefIdxL0:[ref_idx_l0[mbPartIdx]],
		SubMbPredResMvL0:[mvd_l0[0], mvd_l0[1]]		
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		subMbPartIdx < numSubMbPart(mb_type, sub_mb_type[mbPartIdx])
	var
		uint(size=32) res[1],
		int mvd_l0[2]
	do
		vld_se_name(  fifo, res, "mvd_l0[0]                             ");
		mvd_l0[0] := res[0];
		vld_se_name(  fifo, res, "mvd_l0[1]                             ");
		mvd_l0[1] := res[0];
		subMbPartIdx := subMbPartIdx +1;
	end
	//end for

	read_sub_MB_pred_mvd_l0.inner.done: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		subMbPartIdx = numSubMbPart(mb_type, sub_mb_type[mbPartIdx])
	do
		mbPartIdx := mbPartIdx+1;
	end

	//else
	read_sub_MB_pred_mvd_l0.skip: action ==> 
	guard
		mbPartIdx < 4,
		IS_B_Direct_8x8() or (subMbPredMode(mb_type, sub_mb_type[ mbPartIdx ] ) = PRED_L1)
	do
		mbPartIdx := mbPartIdx+1;
	end
	//end if
	//end for

	read_sub_MB_pred_mvd_l0.done: action ==>
	guard
		mbPartIdx = 4
	do
		mbPartIdx := 0;
	end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	// if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 && SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L0 )
	read_sub_MB_pred_mvd_l1.loop: action ==> 
	guard
		mbPartIdx < 4,
		not IS_B_Direct_8x8(), (subMbPredMode(mb_type, sub_mb_type[ mbPartIdx ] ) != PRED_L0)
	do
		subMbPartIdx := 0;
	end
	//   for( subMbPartIdx = 0; subMbPartIdx < NumSubMbPart( sub_mb_type[ mbPartIdx ] ); subMbPartIdx++)
	//     for( compIdx = 0; compIdx < 2; compIdx++ )
	read_sub_MB_pred_mvd_l1.inner.loop: action ==> 
	guard
		subMbPartIdx < numSubMbPart(mb_type, sub_mb_type[mbPartIdx]),
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_se_name(  fifo, res, "mvd_l1[0]                             ");
		vld_se_name(  fifo, res, "mvd_l1[1]                             ");
		subMbPartIdx := subMbPartIdx +1;
	end
	//end for

	read_sub_MB_pred_mvd_l1.inner.done: action ==> 
	guard
		subMbPartIdx = numSubMbPart(mb_type, sub_mb_type[mbPartIdx])
	do
		mbPartIdx := mbPartIdx+1;
	end

	//else
	read_sub_MB_pred_mvd_l1.skip: action ==> 
	guard
		mbPartIdx < 4,
		IS_B_Direct_8x8() or (subMbPredMode(mb_type, sub_mb_type[ mbPartIdx ] ) = PRED_L0)
	do
		mbPartIdx := mbPartIdx+1;
	end
	//end if
	//end for

	sub_MB_pred_done: action ==>
	guard
		mbPartIdx = 4
	end
	//******* End of Sub Mb pred  ********/
 
	/*************************************************************
	*************************************************************
	********       	Mb Pred    	    *********
	*************************************************************
	*************************************************************/

	uint(size=5) luma4x4BlkIdx;
	uint(size=1) prev_intra4x4_pred_mode_flag := 0;
	List (type:uint(size=4),size=16) rem_intra4x4_pred_mode := [ 0 : for int i in 1 .. 16];
	uint(size=2) intra_chroma_pred_mode;

	//if( MbPartPredMode( mb_type, 0 ) = = Intra_4x4 )
	MB_pred_init_Intra_4x4: action ==> IntraPredMode: [ 1 ]
	guard
		mb_type = BLOCK_TYPE_I_4x4
	do
		luma4x4BlkIdx := 0;
	end

	//for( luma4x4BlkIdx=0; luma4x4BlkIdx<16; luma4x4BlkIdx++ )
	read_MB_pred_rem_intra4x4_pred_mode.loop: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		luma4x4BlkIdx < 16
	var
		uint(size=32) res[1]
	do
		vld_u_name(1,  fifo, res, "prev_intra4x4_pred_mode_flag                             ");
		prev_intra4x4_pred_mode_flag := res[0];
		if prev_intra4x4_pred_mode_flag = 0 then 
			vld_u_name(3,  fifo, res, "prev_intra4x4_pred_mode_flag                             ");
			rem_intra4x4_pred_mode[ luma4x4BlkIdx ] := res[0];
		else
			rem_intra4x4_pred_mode[ luma4x4BlkIdx ] := 15; // indicates that the mode is predicted using the neighbourhood 
		end
		luma4x4BlkIdx := luma4x4BlkIdx +1;
	end

	read_MB_pred_rem_intra4x4_pred_mode.done: action ==> IntraPredMode: [ [ rem_intra4x4_pred_mode[ s ] :for int s in 0 .. 15] ] repeat 16
	guard
		luma4x4BlkIdx = 16
	end
	//end for

	//else if( MbPartPredMode( mb_type, 0 ) = = Intra_8x8 )
	MB_pred_init_Intra_8x8: action ==> IntraPredMode :[ 2 ]
	guard
		mb_type = BLOCK_TYPE_I_8x8
	do
		luma4x4BlkIdx := 0;
	end

	//for( luma8x8BlkIdx=0; luma8x8BlkIdx<4; luma8x8BlkIdx++ )
	read_MB_pred_rem_intra8x8_pred_mode.loop: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		luma4x4BlkIdx < 4
	var
		uint(size=32) res[1]
	do
		vld_u_name(1,  fifo, res, "prev_intra4x4_pred_mode_flag                             ");
		prev_intra4x4_pred_mode_flag := res[0];
		if prev_intra4x4_pred_mode_flag = 0 then 
			vld_u_name(3,  fifo, res, "prev_intra4x4_pred_mode_flag                             ");
			rem_intra4x4_pred_mode[ luma4x4BlkIdx ] := res[0];
		else
			rem_intra4x4_pred_mode[ luma4x4BlkIdx ] := 15; // indicates that the mode is predicted using the neighbourhood 
		end
		luma4x4BlkIdx := luma4x4BlkIdx +1;
	end


	read_MB_pred_rem_intra8x8_pred_mode.done: action ==> IntraPredMode: [ [ rem_intra4x4_pred_mode[ s ] :for int s in 0 .. 3] ] repeat 4
	guard
		luma4x4BlkIdx = 4
	end
	//end for

	//else
	MB_pred_init_Intra_16x16: action ==> IntraPredMode: [ 3, Intra_16x16_tab[mb_type - BLOCK_TYPE_I_8x8][0] ]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		Is_Intra_16x16(mb_type)
	end
	//end if

	//if( ChromaArrayType = = 1 | | ChromaArrayType = = 2 )
	read_MB_pred_intra_chroma_pred_mode.launch: action ==> IntraPredModeC: [intra_chroma_pred_mode]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		chroma_format_idc[sps_id] = 1 or chroma_format_idc[sps_id] = 2
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res, "intra_chroma_pred_mode                             ");
		intra_chroma_pred_mode := res[0];
	end

	//else
	read_MB_pred_intra_chroma_pred_mode.skip: action ==>
	guard
		chroma_format_idc[sps_id] = 0
	end
	// end if

	// else (INTER pred)
	// if( MbPartPredMode( mb_type, 0 ) != Direct ) {
	MB_pred_Inter_not_direct: action ==>
	guard
		mbIsPred(mb_type)
		or mbIsBiPred(mb_type) and mb_type != BLOCK_TYPE_B_DIRECT_16x16
	do
		mbPartIdx := 0;
	end
	
	//  for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
	//    if( ( num_ref_idx_l0_active_minus1 > 0 || mb_field_decoding_flag ) && MbPartPredMode( mb_type, mbPartIdx ) != Pred_L1 )
	read_MB_pred_ref_idx_l0.loop: action ==> MbPredRefIdxL0:[ref_idx_l0[mbPartIdx-1]]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < numMbPart(mb_type)
	var
		uint(size=32) res[1]
	do
		if ( (slice_num_ref_idx_l0_active_minus1 > 0 or mb_field_decoding_flag = 1)
			and not Mb_Is_PredL1(mb_type, mbPartIdx)) then
			if slice_num_ref_idx_l0_active_minus1 = 1 then 
				vld_u_name(1,  fifo, res, "ref_idx_l0[mbPartIdx]                            ");
				ref_idx_l0[mbPartIdx] := 1 - res[0];
			else 
				vld_ue_name(  fifo, res, "ref_idx_l0[mbPartIdx]                             ");
				ref_idx_l0[mbPartIdx] := res[0];
			end
		else
			ref_idx_l0[mbPartIdx] := 0;
		end		
		mbPartIdx := mbPartIdx +1;
	end
	//end for

	read_MB_pred_ref_idx_l0.done: action ==> 
	guard
		mbPartIdx = numMbPart(mb_type)
	do
		mbPartIdx := 0;
	end

	//  for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
	//    if( ( num_ref_idx_l1_active_minus1 > 0 || mb_field_decoding_flag ) && MbPartPredMode( mb_type, mbPartIdx ) != Pred_L0 )
	read_MB_pred_ref_idx_l1.loop: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < numMbPart(mb_type)
	var
		uint(size=32) res[1]
	do
		if ((slice_num_ref_idx_l1_active_minus1 > 0 or mb_field_decoding_flag = 1)
			and not Mb_Is_PredL0(mb_type, mbPartIdx)) then
			if slice_num_ref_idx_l1_active_minus1 = 1 then 
				vld_u_name(1,  fifo, res, "ref_idx_l1[mbPartIdx]                             ");
			else 
				vld_ue_name(  fifo, res, "ref_idx_l1[mbPartIdx]                              ");
			end
		end
		mbPartIdx := mbPartIdx +1;
	end
	//end for

	read_MB_pred_ref_idx_l1.done: action ==> 
	guard
		mbPartIdx = numMbPart(mb_type)
	do
		mbPartIdx := 0;
	end

	//  for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
	//    if( MbPartPredMode ( mb_type, mbPartIdx ) != Pred_L1 )
	read_MB_pred_mvd_l0.loop: action ==> MbPredResMvL0:[mvd_l0[0], mvd_l0[1]]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < numMbPart(mb_type),
		not Mb_Is_PredL1(mb_type, mbPartIdx)
	var
		uint(size=32) res[1],
		int mvd_l0[2]
	do
		vld_se_name(  fifo, res, "mvd_l0                             ");
		mvd_l0[0] := res[0];
		vld_se_name(  fifo, res, "mvd_l0                             ");
		mvd_l0[1] := res[0];
		mbPartIdx := mbPartIdx +1;
	end

	//else
	read_MB_pred_mvd_l0.skip: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < numMbPart(mb_type)
	do
		mbPartIdx := mbPartIdx+1;
	end
	//end if
	//end for

	read_MB_pred_mvd_l0.done: action ==> 
	guard
		mbPartIdx = numMbPart(mb_type)
	do
		mbPartIdx := 0;
	end

	// for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
	//   if( MbPartPredMode( mb_type, mbPartIdx ) != Pred_L0 )
	read_MB_pred_mvd_l1.loop: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < numMbPart(mb_type),
		not Mb_Is_PredL0(mb_type, mbPartIdx)
	var
		uint(size=32) res[1]
	do
		vld_se_name(  fifo, res, "mvd_l1                            ");
		vld_se_name(  fifo, res, "mvd_l1                             ");
		mbPartIdx := mbPartIdx +1;
	end

	//else
	read_MB_pred_mvd_l1.skip: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < numMbPart(mb_type)
	do
		mbPartIdx := mbPartIdx+1;
	end
	//end if
	//end for

	MB_pred_done: action ==> 
	guard
		mbPartIdx = numMbPart(mb_type)
	end

	//else (INTER pred, MbPartPredMode( mb_type, 0 ) == Direct ) )
	MB_pred_Inter_direct: action ==>
	guard
		(mb_type = BLOCK_TYPE_B_DIRECT_16x16)
	end 
	//******* End of Mb pred  ********/

	/*************************************************************
	*************************************************************
	********       Residual    	    *********
	*************************************************************
	*************************************************************/

	uint(size=1) bmFlag;
	uint(size=4) startIdx;
	uint(size=4) endIdx;
	uint(size=4) block_startIdx;
	uint(size=6) block_endIdx;
	uint(size=7) maxNumCoeff;

	uint(size=3) i8x8;
	uint(size=3) i4x4;
	uint(size=3) NumC8x8;
	uint(size=2) iCbCr;
	uint(size=2) leveltype := 0; // Intra16x16DCLevel 0, Intra16x16ACLevel / LumaLevel 1, ChromaDCLevel 2, ChromaACLevel 3

	//*************************************************************/
	// Only CAVLC decoding process is implemented
	Residual_init: action ==>
	do
		bmFlag := 0;
		startIdx := 0;
		endIdx := 15;
	end

	//if( !bmFlag && startIdx = = 0 && MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
	Residual_luma_DC_init: action ==>
	guard
		bmFlag = 0,
		startIdx = 0,
		Is_Intra_16x16(mb_type)
	do
		block_startIdx := 0;
		block_endIdx := 15;
		maxNumCoeff := 16;
		leveltype := 0; 
	end
	// --> residual_block( i16x16DClevel, 0, 15, 16 )

	Residual_return_luma_DC: action ==> LAST:[true]
	guard
		leveltype=0
	end

	//else
	Residual_luma_skip_DC_init.Block_4x4: action ==> //LAST:[true]
	guard
		( bmFlag != 0 or startIdx != 0 or not Is_Intra_16x16(mb_type) )
	end
	//end if

	Residual_luma_AC_init: action ==>
	do
		leveltype := 1;
		i8x8 := 0;
		i4x4 := 0; 
	end

	// for( i8x8 = 0; i8x8 < 4; i8x8++ )
	// if( !transform_size_8x8_flag || !entropy_coding_mode_flag )
	Residual_luma_AC_CAVLC: action ==>
	guard
		i8x8 < 4,
		transform_size_8x8_flag = 0 or entropy_coding_mode_flag[pps_id] = 0 // bloc4x4 or CAVLC
	end

	// for( i4x4 = 0; i4x4 < 4; i4x4++ ) {
	// if( val_CodedBlockPatternLuma & ( 1 << i8x8 ) )
	Residual_luma_AC_CodedBlock8x8: action ==>
	guard
		i4x4 < 4,
		((val_CodedBlockPatternLuma & (1 << i8x8) ) >> i8x8) = 1 // MB sub part 8x8 != 0
	do
		luma4x4BlkIdx := i4x4 + (i8x8 << 2);
		//if( !bmFlag && endIdx > 0 &&  MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
		if bmFlag = 0 and endIdx > 0 and  Is_Intra_16x16(mb_type) then 
			block_startIdx := if startIdx - 1 > 0 then startIdx - 1 else 0 end ;
			block_endIdx := endIdx -1;
			maxNumCoeff := 15;
			// --> residual_block( i16x16AClevel[i8x8*4+ i4x4],max( 0, startIdx1 ), endIdx1, 15)
		else
			block_startIdx := startIdx;
			block_endIdx := endIdx;
			maxNumCoeff := 16;
			// --> residual_block( level[ i8x8 * 4 + i4x4 ], startIdx, endIdx, 16)
		end
		//end if
	end

	Residual_return_luma_AC: action ==> LAST: [true]
	guard
		leveltype = 1
	end

	// else 
	Residual_luma_skip_AC_CodedBlock8x8: action ==>  LAST: [true]
	guard
		i4x4 < 4,
		((val_CodedBlockPatternLuma & (1 << i8x8) ) >> i8x8) = 0 // MB sub part 8x8 == 0
	do
		luma4x4BlkIdx := i4x4 + (i8x8 << 2);
		/*
		// if( !bmFlag && MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
		for( i = 0; i < 15; i++ )
		i16x16AClevel[ i8x8 * 4 + i4x4 ][ i ] = 0
		// else
		for( i = 0; i < 16; i++ )
		level[ i8x8 * 4 + i4x4 ][ i ] = 0
		// end if
		*/
	end
	// end if

	/*
	if( !entropy_coding_mode_flag && transform_size_8x8_flag )
	for( i = 0; i < 16; i++ )
	level8x8[ i8x8 ][ 4 * i + i4x4 ] = level[ i8x8 * 4 + i4x4 ][ i ]
	*/
	Residual_luma_inc_AC_4x4: action ==>
	do
		i4x4 := i4x4 +1;
		if i4x4 = 4 then i4x4 := 0; i8x8 := i8x8+1; end
	end
	//end for

	// else ( transform_size_8x8_flag = 1 && entropy_coding_mode_flag = 1 ) <==> CABAC && 8x8
	/* if( val_CodedBlockPatternLuma & ( 1 << i8x8 ) )
	residual_block( level8x8[ i8x8 ], 4 * startIdx, 4 * endIdx + 3, 64 ) 3 | 4
	else
	for( i = 0; i < 64; i++ )
	level8x8[ i8x8 ][ i ] = 0
	//end if
	*/

	Residual_luma_skip_AC_CAVLC: action ==>
	guard
		i8x8 = 4
	end
	//end for

	//if( ChromaArrayType = = 1 | | ChromaArrayType = = 2 )
	Residual_ChromaArrayType_1_2_init: action ==>
	guard
		(chroma_format_idc[sps_id] = 1 or chroma_format_idc[sps_id] = 2) and separate_colour_plane_flag[sps_id] = 0 
	do
		if chroma_format_idc[sps_id] = 1 then 
			NumC8x8 := 1;
		else 
			NumC8x8 := 2;
		end
		iCbCr := 0;
		leveltype := 2;
		luma4x4BlkIdx := 0;
	end

	// for( iCbCr = 0; iCbCr < 2; iCbCr++ )
	//if( ( CodedBlockPatternChroma & 3 ) && startIdx = = 0 ) // chroma DC residual present
	Residual_chroma_DC_init: action ==>
	guard
		iCbCr < 2,
		(CodedBlockPatternChroma & 3) != 0 and startIdx = 0
	do
		block_startIdx := 0;
		block_endIdx := 4 * NumC8x8 - 1;
		maxNumCoeff := 4 * NumC8x8;
	end 
	//--> residual_block( ChromaDCLevel[ iCbCr ], 0, 4 * NumC8x8 - 1, 4 * NumC8x8 )

	Residual_return_chroma_DC: action ==> LAST: [true]
	guard
		leveltype = 2
	do
		iCbCr := iCbCr +1; 
	end

	// else
	Residual_skip_chroma_DC_init: action ==> LAST: [true]
	guard
		iCbCr < 2,
		(CodedBlockPatternChroma & 3) =0 or startIdx != 0
	do
		//for( i = 0; i < 4 * NumC8x8; i++ )
		//ChromaDCLevel[ iCbCr ][ i ] = 0
		iCbCr := iCbCr +1; 
	end   
	//end if

	Residual_skip_chroma_DC: action ==>
	guard
		iCbCr = 2
	end
	//end for  

	Residual_chroma_AC_init: action ==>
	do
		leveltype := 3;
		iCbCr := 0;
		i8x8 := 0;
		i4x4 := 0;
		luma4x4BlkIdx := 0;
	end

	//for( iCbCr = 0; iCbCr < 2; iCbCr++ )
	//  for( i8x8 = 0; i8x8 < NumC8x8; i8x8++ )
	//    for( i4x4 = 0; i4x4 < 4; i4x4++ )
	//      if( ( CodedBlockPatternChroma & 2 ) && endIdx > 0 ) // chroma AC residual present
	Residual_chroma_AC_CodedBlock4x4: action ==>
	guard
		iCbCr < 2,
		(CodedBlockPatternChroma & 2) = 2 and endIdx > 0
	do
		luma4x4BlkIdx := i4x4 + (i8x8 << 2);
		block_startIdx := if startIdx - 1 > 0 then startIdx - 1 else 0 end ;
		block_endIdx := endIdx - 1;
		maxNumCoeff := 15;
	end
	// --> residual_block( ChromaACLevel[ iCbCr ][ i8x8*4+i4x4 ], max( 0, startIdx1 ), endIdx1, 15)

	Residual_return_chroma_AC: action ==> LAST:[true]
	guard
		leveltype = 3
	do
		i4x4 := i4x4 +1;
		if i4x4 = 4 then i4x4 := 0; i8x8 := i8x8 +1; end
		if i8x8 = NumC8x8 then i8x8 := 0; iCbCr := iCbCr +1; end
	end

	// else
	Residual_chroma_AC_skip_CodedBlock4x4: action ==> LAST: [true]
	guard
		iCbCr < 2,
		(CodedBlockPatternChroma & 2) != 2 or endIdx <= 0
	do
		/* for( i = 0; i < 15; i++ )
		ChromaACLevel[ iCbCr ][ i8x8*4+i4x4 ][ i ] = 0
		*/
		i4x4 := i4x4 +1;
		if i4x4 = 4 then i4x4 := 0; i8x8 := i8x8 +1; end
		if i8x8 = NumC8x8 then i8x8:=0; iCbCr := iCbCr +1; end
		luma4x4BlkIdx := i4x4 + (i8x8 << 2);
	end
	//end if

	Residual_skip_chroma_AC: action ==> 
	guard
		iCbCr = 2
	end
	//end for
	//end for
	//end for

	// else if( ChromaArrayType = = 3 ) ==> Profile HP not yet implemented
	// else ( ChromaArrayType = = 0 ) ==> Profile HP not yet implemented

	//******* End of Residual  ********/

	/*************************************************************
	*************************************************************
	********       		Residual Block CAVLC   	    *********
	*************************************************************
	*************************************************************/
	int(size=6) nc;
	List ( type: List(type: uint(size=4), size=16), size = PICHEIGHT*PICWIDTH) NonZeroCount; // FIXME those numbers should be independent of the size
	List ( type: List(type: uint(size=4), size=4), size=PICHEIGHT*PICWIDTH) NonZeroCountCb; // FIXME those numbers should be independent of the size
	List ( type: List(type: uint(size=4), size=4), size=PICHEIGHT*PICWIDTH) NonZeroCountCr; // FIXME those numbers should be independent of the size
	uint(size=3) suffixLength;
	uint(size=5) inc_nb_coeff;
	uint level_prefix;
	uint(size=16) val_cbp_blk:=0;
	uint levelCode;
	uint(size=4) zerosLeft;
	int(size=16) coeff_sent := 0;

	List (type:int(size=16),size=16) level := [ 0 : for int i in 1 .. 16];
	List (type:uint(size=4),size=16) run := [ 0 : for int i in 1 .. 16];
	List ( type: uint(size=4), size=16) InverseScan4x4Tab = [ 0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15 ];

	Residual_block_init_coeff_token: action ==>
	var 
		uint(size=1) top, uint(size=1) left,//= 1 if MB not available
		uint(size=5) nA, 
		uint(size=5) nB
	do
		if leveltype = 2 then //chromaDC
			nc := -1;
		else
			top :=1; left :=1;
			if leveltype = 0 then luma4x4BlkIdx := 0; end
			if leveltype < 2 then //luma
				if (val_CurrMbAddr<first_mb_in_slice + PicWidthInMbs and InverseScan4x4Tab[luma4x4BlkIdx]<4) then // MB 4x4 current situated on the first line of MBs 4x4, so there is no MB 4x4 above  
					nB :=0; top:=0;
				else
					if(InverseScan4x4Tab[luma4x4BlkIdx]<4) then
						nB := NonZeroCount[val_CurrMbAddr-PicWidthInMbs][12+InverseScan4x4Tab[luma4x4BlkIdx]]; 
					else
						nB := NonZeroCount[val_CurrMbAddr][InverseScan4x4Tab[luma4x4BlkIdx]-4];
					end					
				end
				if ((val_CurrMbAddr = first_mb_in_slice and InverseScan4x4Tab[luma4x4BlkIdx] mod 4 = 0) or (Mb_x = 0 and InverseScan4x4Tab[luma4x4BlkIdx] mod 4 = 0))  then // MB 4x4 current situated on the first column of MBs 4x4, so there is no MB 4x4 at left  
					nA :=0; left:=0;
				else
					if(InverseScan4x4Tab[luma4x4BlkIdx] mod 4 = 0) then
						nA := NonZeroCount[val_CurrMbAddr-1][3+InverseScan4x4Tab[luma4x4BlkIdx]]; 
					else
						nA := NonZeroCount[val_CurrMbAddr][InverseScan4x4Tab[luma4x4BlkIdx]-1];
					end
				end
			else //chroma
				if (val_CurrMbAddr<first_mb_in_slice + PicWidthInMbs and luma4x4BlkIdx<2) then // MB 4x4 current situated on the first line of MBs 4x4, so there is no MB 4x4 above  
					nB :=0; top:=0;
				else
					nB := if iCbCr = 0 then 
						if(luma4x4BlkIdx<2) then
							NonZeroCountCb[val_CurrMbAddr - PicWidthInMbs][2 + luma4x4BlkIdx]
						else
							NonZeroCountCb[val_CurrMbAddr][luma4x4BlkIdx- 2]
						end					
					else 
						if(InverseScan4x4Tab[luma4x4BlkIdx]<2) then
							NonZeroCountCr[val_CurrMbAddr - PicWidthInMbs][2 + luma4x4BlkIdx]
						else
							NonZeroCountCr[val_CurrMbAddr][luma4x4BlkIdx - 2]
						end			
					end;
						end					
				if ((val_CurrMbAddr = first_mb_in_slice and luma4x4BlkIdx mod 2 = 0) or (Mb_x = 0 and luma4x4BlkIdx mod 2 = 0)) then // MB 4x4 current situated on the first column of MBs 4x4, so there is no MB 4x4 at left  
					nA :=0; left:=0;
				else
					nA := if iCbCr = 0 then 
						if(luma4x4BlkIdx mod 2 = 0) then
							NonZeroCountCb[val_CurrMbAddr-1][1 + luma4x4BlkIdx]
						else
							NonZeroCountCb[val_CurrMbAddr][luma4x4BlkIdx - 1]
						end
					else 
						if(InverseScan4x4Tab[luma4x4BlkIdx] mod 2 = 0) then
							NonZeroCountCr[val_CurrMbAddr-1][1 + luma4x4BlkIdx]
						else
							NonZeroCountCr[val_CurrMbAddr][luma4x4BlkIdx - 1]
						end
					end;
				end
			end
			if top = 1 and left = 1 then nc := ((nA + nB +1) >> 1); else nc := nA + nB ; end
		end
		start_CAVLC(0);
		level := [0 : for int i in 0 .. 15];
	end

	//if( TotalCoeff( coeff_token ) > 0 ) 
	Residual_block_read_suffixLength: action ==>
	guard
		CAVLC_end(),
		TotalCoeff() >0
	do
		if leveltype = 1 then //luma
    		val_cbp_blk:=(1<<InverseScan4x4Tab[luma4x4BlkIdx])+val_cbp_blk;
			NonZeroCount[val_CurrMbAddr][InverseScan4x4Tab[luma4x4BlkIdx]] := TotalCoeff();
		else //chroma
			if iCbCr = 0 then
				NonZeroCountCb[val_CurrMbAddr][luma4x4BlkIdx] := TotalCoeff();
			else
				NonZeroCountCr[val_CurrMbAddr][luma4x4BlkIdx] := TotalCoeff();
			end
		end
		if TotalCoeff() > 10 and TrailingOnes() < 3 then suffixLength := 1; else suffixLength := 0; end
		inc_nb_coeff := 0;
	end

	// for( i = 0; i < TotalCoeff( coeff_token ); i++ )
	//if( i < TrailingOnes( coeff_token ) )
	Residual_block_read_trailing_ones_sign_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		inc_nb_coeff < TotalCoeff()
	var
		uint levelSuffixSize,
		uint(size=32) res[1],
		uint level_suffix,
		uint level_prefix_temp		
	do
		if (inc_nb_coeff < TrailingOnes()) then
			vld_u_name(1,  fifo, res, "level[ inc_nb_coeff ]                             ");
			level[ inc_nb_coeff ] := 1 - 2 * res[0];
			inc_nb_coeff := inc_nb_coeff +1 ;
		else
			level_prefix := 0;
			level_prefix_temp:=0;
			while(level_prefix_temp = 0) do
				vld_u_name(1,  fifo, res, "level_prefix_temp                             ");
				level_prefix_temp := res[0];
				level_prefix := level_prefix +1;
			end
			level_prefix := level_prefix - 1;
	
			levelCode := ( if level_prefix < 15 then level_prefix else 15 end << suffixLength );
			if level_prefix = 14 and suffixLength = 0 then levelSuffixSize := 4;
			else if level_prefix >=15 then levelSuffixSize := level_prefix - 3;
			else levelSuffixSize := suffixLength; end end
			if levelSuffixSize > 0 then 
				vld_u_name(levelSuffixSize,  fifo, res, "level_suffix                             ");
				level_suffix := res[0];
			else
				level_suffix:=0;
			end
			//if( suffixLength > 0 | | level_prefix >= 14 )
			if suffixLength > 0 or level_prefix >= 14 then levelCode := levelCode + level_suffix; end
	
			// if( level_prefix > = 15 && suffixLength = = 0 )
			if level_prefix >= 15 and  suffixLength = 0 then levelCode := levelCode +15; end
	
			// if( level_prefix > = 16 )
			if level_prefix >= 16 then levelCode := levelCode + ( 1 << (level_prefix - 3) ) - 4096; end
	
			// if( i = = TrailingOnes( coeff_token ) &&	TrailingOnes( coeff_token ) < 3 )
			if inc_nb_coeff = TrailingOnes() and	TrailingOnes() < 3 then levelCode := levelCode + 2; end
	
			// if( levelCode % 2 = = 0 )
			if (levelCode mod 2) = 0 then level[ inc_nb_coeff ] := ( (levelCode + 2) >> 1);
			else	level[ inc_nb_coeff ] := ( (-levelCode - 1) >> 1); end
	
			// if( suffixLength = = 0 )
			if suffixLength = 0 then suffixLength := 1; end
	
			//if( Abs( level[ i ] ) > ( 3 << ( suffixLength 1 ) ) &&	suffixLength < 6 )
			if  Abs(level[ inc_nb_coeff ]) > (3 << suffixLength - 1) and suffixLength < 6 then suffixLength := suffixLength +1; end
			inc_nb_coeff := inc_nb_coeff +1 ;
		end
	end

	// end if
	//end for 
	Residual_block_read_TotalCoeff_done: action ==>
	guard
		inc_nb_coeff = TotalCoeff()
	do
		//if( TotalCoeff( coeff_token ) < endIdx startIdx + 1 )
		if TotalCoeff() < block_endIdx - block_startIdx +1 then start_CAVLC(1); end
		run := [0 : for int i in 0 .. 15];
	end

	Residual_block_read_total_zeros_done: action ==>
	guard
		CAVLC_end()
	do
		//if( TotalCoeff( coeff_token ) < endIdx startIdx + 1 )
		zerosLeft := if TotalCoeff() < block_endIdx - block_startIdx +1 then total_zeros else 0 end;
		inc_nb_coeff := 0;
	end

	//for( i = 0; i < TotalCoeff( coeff_token ) 1; i++ )
	Residual_block_read_run_before: action ==>
	guard
		inc_nb_coeff < TotalCoeff()-1,
		zerosLeft > 0
	do
		start_CAVLC(2);
	end

	Residual_block_read_run_before_done: action ==>
	guard
		CAVLC_end()
	do
		run[inc_nb_coeff] := run_before;
		zerosLeft := zerosLeft - run_before;
		inc_nb_coeff := inc_nb_coeff+1;
	end

	Residual_block_skip_read_run_before: action ==>
	guard
		inc_nb_coeff < TotalCoeff()-1,
		zerosLeft = 0
	do
		run[inc_nb_coeff] := 0;
		inc_nb_coeff := inc_nb_coeff+1;
	end

	//end for
	Residual_block_read_run_done: action ==> 
	guard
		inc_nb_coeff = TotalCoeff()-1
	do
		run[TotalCoeff()-1] := zerosLeft;
		if (Is_Intra_16x16(mb_type) and leveltype = 1) or leveltype = 3 then run[TotalCoeff()-1] := run[TotalCoeff()-1] +1; end//the first coeffAC will be replaced by coeffDC
		coeff_sent := -1;
	end
	// --> residual_return

	//end for
	Residual_block_send_run: action ==> LAST:[false], RUN:[run[coeff_sent]], VALUE:[level[coeff_sent]]
	guard
		coeff_sent < TotalCoeff()-1
	do
		coeff_sent := coeff_sent+1;
	end

	//end for
	Residual_block_send_done: action ==> 
	guard
		coeff_sent = TotalCoeff()-1
	end



	//else ( TotalCoeff( coeff_token ) = 0 )
	Residual_block_skip_read_suffixLength: action ==>
	guard
		CAVLC_end(),
		TotalCoeff() = 0
	do
		if leveltype < 2 then //luma
			NonZeroCount[val_CurrMbAddr][InverseScan4x4Tab[luma4x4BlkIdx]] := 0;
		else //chroma
			if iCbCr = 0 then
				NonZeroCountCb[val_CurrMbAddr][luma4x4BlkIdx] := 0;
			else
				NonZeroCountCr[val_CurrMbAddr][luma4x4BlkIdx] := 0;
			end
		end
	end 
	// --> residual return

	//******* End of Residual Block CAVLC ********  

	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		not IsStartCode(fifo)
   	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then		
  			println("start_code.search");
   		end
	end
	start_code.done: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		IsStartCode(fifo)
	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then
			println("start_code.done");
		end
	end

	byte_align_a: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
		byte_align(fifo);
	end
	
	/**************************************************************************
	 **************************************************************************
	 ********        undefined                            *********************
	 **************************************************************************
	 *************************************************************************/
  	bool actorNotFinished := true;
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("Algo_Parser doesn't manage this case yet");
		actorNotFinished := false;
	end
	
	
//********************************************************************************************************************************** 
	schedule fsm look_for_Sequence_Header :
		look_for_Sequence_Header						( look_for_Sequence_Header							) --> byte_align_a;

	    // FIXME: add minimal error resilience.
	    // byte align, then look for a starting on any byte boundary.
	    // is hex 00000100.
	    byte_align_a    ( byte_align_a    ) --> search_start_code;
	
		// search start code
		search_start_code          			( start_code.search					    ) --> search_start_code;
		search_start_code			            ( start_code.done					) --> read_Nal_unit_header;
	    

		// read Nal Unit header
		read_Nal_unit_header							( read_Nal_unit_header								) --> find_header;

		//
		find_header	  									( look_for_other_header								) --> look_for_Sequence_Header;
		find_header	  									( look_for.Sps_header	  							) --> read_Sps_id;
		find_header	  									( look_for.Pps_header	  							) --> read_Pps_seq_parameter_set_id;
		find_header	  									( look_for.Slice_header	  							) --> read_SliceH_slice_type;

		// read Sps header
		read_Sps_id	  										( read_Sps_id	    								) --> read_Sps_check_profile_idc;
		read_Sps_check_profile_idc	 						( read_Sps_chroma_format_idc	  					) --> undefined; //not yet realized
		read_Sps_check_profile_idc	 						( read_Sps_log2_max_frame_num_minus4				) --> read_Sps_check_pic_order_cnt_type;
		read_Sps_check_pic_order_cnt_type	 				( read_Sps_pic_order_cnt_type_skip01				) --> read_Sps_num_ref_frames; 
		read_Sps_check_pic_order_cnt_type	 				( read_Sps_log2_max_pic_order_cnt_lsb_minus4		) --> read_Sps_num_ref_frames;
		read_Sps_check_pic_order_cnt_type	 				( read_Sps_delta_pic_order_always_zero_flag			) --> read_Sps_offset_for_top_to_bottom_field;   
		read_Sps_offset_for_top_to_bottom_field				( read_Sps_offset_for_top_to_bottom_field	        ) --> read_Sps_offset_for_ref_frame;
		read_Sps_offset_for_ref_frame						( read_Sps_offset_for_ref_frame.loop	            ) --> read_Sps_offset_for_ref_frame;
		read_Sps_offset_for_ref_frame						( read_Sps_offset_for_ref_frame.done 	                ) --> read_Sps_num_ref_frames;
		read_Sps_num_ref_frames 							( read_Sps_num_ref_frames  	                        ) --> read_Sps_frame_mbs_only_flag;
		read_Sps_frame_mbs_only_flag 						( read_Sps_frame_mbs_only_flag	  	                ) --> read_Sps_mb_adaptive_frame_field_flag;
		read_Sps_mb_adaptive_frame_field_flag				( read_Sps_mb_adaptive_frame_field_flag  	        ) --> read_Sps_direct_8x8_interference_flag;
		read_Sps_direct_8x8_interference_flag 				( read_Sps_direct_8x8_interference_flag             ) --> read_Sps_frame_crop_left_offset;    

		read_Sps_frame_crop_left_offset						( read_Sps_frame_crop_left_offset  	                ) --> undefined;
		read_Sps_frame_crop_left_offset						( read_Sps_skip_frame_crop_left_offset	  	        ) --> read_Sps_vui_parameters_present_flag; 
		read_Sps_vui_parameters_present_flag				( read_Sps_vui_parameters_present_flag	  	        ) --> read_Sps_vui_parameters_present_flag_done;
		read_Sps_vui_parameters_present_flag_done			( read_Sps_done	                            		) --> look_for_Sequence_Header; //end of Sps
		read_Sps_vui_parameters_present_flag_done			( read_Sps_vui_parameters                    		) --> undefined; //end of Sps

		// read Pps header
		read_Pps_seq_parameter_set_id 						( read_Pps_seq_parameter_set_id                     ) --> read_Pps_num_slice_groups_minus1;
		read_Pps_num_slice_groups_minus1					( read_Pps_num_slice_groups_minus1				  	) --> look_Pps_slice_group_map_type; 			  
		look_Pps_slice_group_map_type						( read_Pps_slice_group_map_type                     ) --> undefined;
		look_Pps_slice_group_map_type					    ( read_Pps_slice_group_map_type_skip 	  	        ) --> read_Pps_num_ref_idx_l0_active_minus1;
		read_Pps_num_ref_idx_l0_active_minus1				( read_Pps_num_ref_idx_l0_active_minus1	 	        ) --> read_Pps_pic_init_qp_minus26;
		read_Pps_pic_init_qp_minus26						( read_Pps_pic_init_qp_minus26	  	                ) --> read_Pps_chroma_qp_index_offset;
		read_Pps_chroma_qp_index_offset						( read_Pps_chroma_qp_index_offset 	                ) --> read_Pps_more_rbsp_data;
		read_Pps_more_rbsp_data 							( read_Pps_more_rbsp_data							) --> read_Pps_more_rbsp_data_done;
		read_Pps_more_rbsp_data_done						( read_Pps_High_Profile					  			) --> undefined;
		read_Pps_more_rbsp_data_done						( read_Pps_not_High_Profile						  	) --> look_for_Sequence_Header;

		// read Slice header
		read_SliceH_slice_type								( read_SliceH_slice_type  	                        ) --> read_SliceH_picSize;
		read_SliceH_picSize									( read_SliceH_picSize						  		) --> read_SliceH_frame_num;
		read_SliceH_picSize									( read_SliceH_skip_picSize						  	) --> read_SliceH_frame_num;
		read_SliceH_frame_num								( read_SliceH_frame_num	  	                        ) --> read_SliceH_idr_pic_id;

		read_SliceH_idr_pic_id								( read_SliceH_idr_pic_id  	                        ) --> read_SliceH_delta_pic_order_cnt0;
		
		read_SliceH_delta_pic_order_cnt0					( read_SliceH_delta_pic_order_cnt0					) --> CalcPOC;

		CalcPOC												( CalcPOC	                                        ) --> read_SliceH_redundant_pic_cnt;
		read_SliceH_redundant_pic_cnt						( read_SliceH_redundant_pic_cnt                     ) --> read_SliceH_ref_pic_list_reordering;

		//ref_pic_list_reordering
		read_SliceH_ref_pic_list_reordering					( read_SliceH_ref_pic_list_reordering_flag_l0		) --> read_SliceH_reordering_of_pic_nums_idc;
		read_SliceH_ref_pic_list_reordering					( read_SliceH_skip_ref_pic_list_reordering			) --> read_SliceH_pred_weight_table;
		
		read_SliceH_reordering_of_pic_nums_idc 				( read_SliceH_ref_pic_list_reordering_flag.isl0	    ) --> read_SliceH_reordering_of_pic_nums_idc_done;
		read_SliceH_reordering_of_pic_nums_idc				( read_SliceH_skip_reordering_of_pic_nums_idc		) --> read_SliceH_pred_weight_table;	
		read_SliceH_reordering_of_pic_nums_idc_done			( read_SliceH_reordering_of_pic_nums_idc     		) --> look_SliceH_reordering_of_pic_nums_idc_done;	
		look_SliceH_reordering_of_pic_nums_idc_done			( read_SliceH_reordering_of_pic_nums_idc.idc1       ) --> read_SliceH_reordering_of_pic_nums_idc_done;	
		look_SliceH_reordering_of_pic_nums_idc_done			( read_SliceH_reordering_of_pic_nums_idc.idc2		) --> read_SliceH_reordering_of_pic_nums_idc_done;
		look_SliceH_reordering_of_pic_nums_idc_done			( read_SliceH_reordering_of_pic_nums_idc.idc3   	) --> read_SliceH_pred_weight_table;

		//pred_weight_table
		read_SliceH_pred_weight_table						( read_SliceH_pred_weight_table						) --> read_SliceH_dec_ref_pic_marking; //not yet realised
		read_SliceH_pred_weight_table						( read_SliceH_skip_pred_weight_table				) --> read_SliceH_dec_ref_pic_marking;

		//dec_ref_pic_marking
		read_SliceH_dec_ref_pic_marking						( read_SliceH_dec_ref_pic_marking	                ) --> read_SliceH_check_IdrPicFlag;
		read_SliceH_check_IdrPicFlag						( read_SliceH_no_output_of_prior_pics_flag_done		) --> read_SliceH_cabac_init_idc;
		read_SliceH_check_IdrPicFlag						( read_SliceH_adaptative_ref_pic_marking_mode_flag_done) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco								( read_SliceH_skip_memory_management_control_operation_done ) --> read_SliceH_cabac_init_idc;
		read_SliceH_check_mmco								( read_SliceH_memory_management_control_operation_done) --> read_SliceH_check_mmco_done;
		read_SliceH_check_mmco_done							( read_SliceH_mmco_0								) --> read_SliceH_cabac_init_idc;
		read_SliceH_check_mmco_done							( read_SliceH_difference_of_pic_nums_minus1_done	) --> read_SliceH_check_mmco_36;
		read_SliceH_check_mmco_done							( read_SliceH_long_term_pic_num_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_done							( read_SliceH_long_term_frame_idx_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_36							( read_SliceH_long_term_frame_idx_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_36							( read_SliceH_long_not_term_frame_idx_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_done							( read_SliceH_max_long_term_frame_idx_plus1_done	) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_done							( read_SliceH_mmco_5								) --> read_SliceH_check_mmco;
		read_SliceH_dec_ref_pic_marking						( read_SliceH_skip_dec_ref_pic_marking				) --> read_SliceH_cabac_init_idc;

		read_SliceH_cabac_init_idc							( read_SliceH_cabac_init_idc						) --> read_SliceH_disable_deblocking_filter_idc;
		read_SliceH_disable_deblocking_filter_idc			( read_SliceH_disable_deblocking_filter_idc 		) --> read_SliceH_slice_group_change_cycle;		
		read_SliceH_slice_group_change_cycle				( read_SliceH_slice_group_change_cycle				) --> read_SliceD_CABAC_alignement;

		// read Slice Data     only decoding CAVLC process is implemented
		read_SliceD_CABAC_alignement						( read_SliceD_CABAC_alignement						) --> read_SliceD_init;
		read_SliceD_CABAC_alignement						( read_SliceD_skip_CABAC_alignement	                ) --> read_SliceD_init;
		read_SliceD_init									( SliceD_init										) --> sync_do_mb_layer;
		sync_do_mb_layer 									( sync_do_mb_layer									) --> read_SliceD_mb_skip;
		read_SliceD_mb_skip									( read_SliceD_mb_skip_run							) --> read_SliceD_mb_skip_run_done0;
		read_SliceD_mb_skip_run_done0						( read_SliceD_mb_skip_run_done0						) --> read_SliceD_mb_skip_run_done1;
		read_SliceD_mb_skip_run_done1						( read_SliceD_mb_skip_run_done1						) --> read_SliceD_mb_skip_run_done1;
		read_SliceD_mb_skip_run_done1						( read_SliceD_mb_skip_run_done2						) --> read_SliceD_mb_skip_run_done2_moredata;
		read_SliceD_mb_skip_run_done2_moredata              ( read_SliceD_mb_skip_run_done2_moredata_1          ) --> read_SliceD_mb_field_decoding_flag;
		read_SliceD_mb_skip_run_done2_moredata 				( read_SliceD_mb_skip_run_done2_moredata_0			) --> syncSliceD_endwhile;
		read_SliceD_mb_skip									( read_SliceD_skip_mb_skip 							) --> read_SliceD_mb_field_decoding_flag;
		read_SliceD_mb_field_decoding_flag					( read_SliceD_skip_mb_field_decoding_flag			) --> read_MB_layer_mb_type;

		// --> macrobloc_layer()
		SliceD_update										( SliceD_update_CAVLC								) --> SliceD_moredata;
		SliceD_moredata                                     ( SliceD_moredata_1                                 ) --> SliceD_moredata_1_done;
		SliceD_moredata_1_done								( send_data_position_information_is_ipcm            ) --> syncSliceD_endwhile;
		SliceD_moredata_1_done								( send_data_position_information	                ) --> syncSliceD_endwhile;
		SliceD_moredata 									( SliceD_moredata_0									) --> SliceD_stop_byte_align__done;
		SliceD_stop_byte_align__done							( send_data_position_information_is_ipcm            ) --> syncSliceD_endwhile;
		SliceD_stop_byte_align__done							( send_data_position_information	                ) --> syncSliceD_endwhile;
		syncSliceD_endwhile									( syncSliceD_endwhile								) --> SliceD_while_moreDataFlag;
		
		SliceD_update										( SliceD_update_CABAC								) --> undefined;
		SliceD_while_moreDataFlag							( SliceD_while_moreDataFlag							) --> sync_do_mb_layer;
		SliceD_while_moreDataFlag							( SliceD_end										) --> look_for_Sequence_Header;
		read_SliceD_mb_field_decoding_flag					( SliceD_end										) --> look_for_Sequence_Header;
		
		// macrobloc_layer
		read_MB_layer_mb_type								( read_MB_layer_mb_type								) --> read_MB_layer_check_I_PCM;
		read_MB_layer_check_I_PCM							( read_MB_layer_I_PCM_alignement					) --> read_MB_layer_pcm_sample_luma;
		read_MB_layer_pcm_sample_luma					    ( read_MB_layer_pcm_sample_luma.loop	            ) --> read_MB_layer_pcm_sample_luma;
		read_MB_layer_pcm_sample_luma						( read_MB_layer_pcm_sample_luma.done	            ) --> read_MB_layer_pcm_sample_chroma;
		read_MB_layer_pcm_sample_chroma						( read_MB_layer_pcm_sample_chroma.loop				) --> read_MB_layer_pcm_sample_chroma;	
		read_MB_layer_pcm_sample_chroma						( read_MB_layer_pcm_sample_chroma.done				) --> SliceD_update;
		read_MB_layer_check_I_PCM							( read_MB_layer_not_I_PCM							) --> read_MB_layer_check_pred;
		read_MB_layer_check_pred							( read_MB_layer_sub_mb_pred							) --> Sub_mb_pred; //--> sub_mb_pred
		read_MB_layer_sub_mb_pred_done				        ( read_MB_layer_sub_mb_pred_done	                ) --> read_MB_layer_coded_block_pattern;
		read_MB_layer_check_pred							( read_MB_layer_transform_size_8x8_flag				) --> MB_pred;
		read_MB_layer_check_pred							( read_MB_layer_skip_transform_size_8x8_flag		) --> MB_pred; 
		// --> mb_pred()	

		read_MB_layer_coded_block_pattern					( read_MB_layer_coded_block_pattern					) --> read_MB_layer_mb_qp_delta;
		read_MB_layer_mb_qp_delta							( read_MB_layer_mb_qp_delta							) --> Residual_init;
		// --> residual ()
		read_MB_layer_mb_qp_delta							( read_MB_layer_skip_mb_qp_delta					) --> SliceD_update;

		// sub_mb_pred
		Sub_mb_pred											( read_sub_MB_pred_sub_mb_type.loop					) --> Sub_mb_pred;
		Sub_mb_pred											( read_sub_MB_pred_sub_mb_type.done					) --> read_sub_MB_pred_ref_idx_l0;
		read_sub_MB_pred_ref_idx_l0							( read_sub_MB_pred_ref_idx_l0.loop					) --> read_sub_MB_pred_ref_idx_l0;
		read_sub_MB_pred_ref_idx_l0							( read_sub_MB_pred_ref_idx_l0.done					) --> read_sub_MB_pred_ref_idx_l1;
		read_sub_MB_pred_ref_idx_l1							( read_sub_MB_pred_ref_idx_l1.loop					) --> read_sub_MB_pred_ref_idx_l1;
		read_sub_MB_pred_ref_idx_l1							( read_sub_MB_pred_ref_idx_l1.done					) --> read_sub_MB_pred_mvd_l0;
		read_sub_MB_pred_mvd_l0								( read_sub_MB_pred_mvd_l0.loop	                    ) --> read_sub_MB_pred_mvd_l0_inner;
		read_sub_MB_pred_mvd_l0								( read_sub_MB_pred_mvd_l0.skip						) --> read_sub_MB_pred_mvd_l0;
		read_sub_MB_pred_mvd_l0								( read_sub_MB_pred_mvd_l0.done						) --> read_sub_MB_pred_mvd_l1;
		read_sub_MB_pred_mvd_l0_inner						( read_sub_MB_pred_mvd_l0.inner.loop				) --> read_sub_MB_pred_mvd_l0_inner;
		read_sub_MB_pred_mvd_l0_inner						( read_sub_MB_pred_mvd_l0.inner.done				) --> read_sub_MB_pred_mvd_l0;
		read_sub_MB_pred_mvd_l1								( read_sub_MB_pred_mvd_l1.loop						) --> read_sub_MB_pred_mvd_l1_inner;
		read_sub_MB_pred_mvd_l1								( read_sub_MB_pred_mvd_l1.skip						) --> read_sub_MB_pred_mvd_l1;
		read_sub_MB_pred_mvd_l1_inner						( read_sub_MB_pred_mvd_l1.inner.loop				) --> read_sub_MB_pred_mvd_l1_inner;
		read_sub_MB_pred_mvd_l1_inner						( read_sub_MB_pred_mvd_l1.inner.done				) --> read_sub_MB_pred_mvd_l1;
		read_sub_MB_pred_mvd_l1								( sub_MB_pred_done									) --> read_MB_layer_sub_mb_pred_done; // --> macrobloc_layer()	

		// mb_pred
		MB_pred												( MB_pred_init_Intra_4x4							) --> read_MB_pred_rem_intra4x4_pred_mode;
		read_MB_pred_rem_intra4x4_pred_mode					( read_MB_pred_rem_intra4x4_pred_mode.loop			) --> read_MB_pred_rem_intra4x4_pred_mode;
		read_MB_pred_rem_intra4x4_pred_mode					( read_MB_pred_rem_intra4x4_pred_mode.done			) --> read_MB_pred_intra_chroma_pred_mode;
		MB_pred												( MB_pred_init_Intra_8x8							) --> read_MB_pred_rem_intra8x8_pred_mode;
		read_MB_pred_rem_intra8x8_pred_mode					( read_MB_pred_rem_intra8x8_pred_mode.loop			) --> read_MB_pred_rem_intra8x8_pred_mode;
		read_MB_pred_rem_intra8x8_pred_mode					( read_MB_pred_rem_intra8x8_pred_mode.done			) --> read_MB_pred_intra_chroma_pred_mode;
		MB_pred												( MB_pred_init_Intra_16x16							) --> read_MB_pred_intra_chroma_pred_mode;
		read_MB_pred_intra_chroma_pred_mode					( read_MB_pred_intra_chroma_pred_mode.launch		) --> read_MB_layer_coded_block_pattern;
		read_MB_pred_intra_chroma_pred_mode					( read_MB_pred_intra_chroma_pred_mode.skip			) --> read_MB_layer_coded_block_pattern; // --> macrobloc_layer()
		MB_pred												( MB_pred_Inter_not_direct							) --> read_MB_pred_ref_idx_l0;
		read_MB_pred_ref_idx_l0								( read_MB_pred_ref_idx_l0.loop						) --> read_MB_pred_ref_idx_l0;
		read_MB_pred_ref_idx_l0								( read_MB_pred_ref_idx_l0.done						) --> read_MB_pred_ref_idx_l1;
		read_MB_pred_ref_idx_l1								( read_MB_pred_ref_idx_l1.loop						) --> read_MB_pred_ref_idx_l1;
		read_MB_pred_ref_idx_l1								( read_MB_pred_ref_idx_l1.done						) --> read_MB_pred_mvd_l0;
		read_MB_pred_mvd_l0									( read_MB_pred_mvd_l0.loop							) --> read_MB_pred_mvd_l0;
		read_MB_pred_mvd_l0									( read_MB_pred_mvd_l0.skip							) --> read_MB_pred_mvd_l0;
		read_MB_pred_mvd_l0									( read_MB_pred_mvd_l0.done							) --> read_MB_pred_mvd_l1;
		read_MB_pred_mvd_l1									( read_MB_pred_mvd_l1.loop							) --> read_MB_pred_mvd_l1;
		read_MB_pred_mvd_l1									( read_MB_pred_mvd_l1.skip							) --> read_MB_pred_mvd_l1;
		read_MB_pred_mvd_l1									( MB_pred_done										) --> read_MB_layer_coded_block_pattern; // --> macrobloc_layer()	
		MB_pred												( MB_pred_Inter_direct								) --> read_MB_layer_coded_block_pattern; // --> macrobloc_layer()

		// residual
		Residual_init										( Residual_init										) --> Residual_luma_DC_init;
		Residual_luma_DC_init								( Residual_luma_DC_init								) --> Residual_block; // --> residual_block()
		Residual_return										( Residual_return_luma_DC							) --> Residual_luma_AC_init;
		Residual_luma_DC_init								( Residual_luma_skip_DC_init						) --> Residual_luma_AC_init;
		Residual_luma_AC_init								( Residual_luma_AC_init								) --> Residual_luma_AC_CAVLC;
		Residual_luma_AC_CAVLC								( Residual_luma_AC_CAVLC							) --> Residual_luma_AC_CodedBlock8x8;
		Residual_luma_AC_CodedBlock8x8						( Residual_luma_AC_CodedBlock8x8					) --> Residual_block; // --> residual_block()
		Residual_return										( Residual_return_luma_AC							) --> Residual_luma_inc_AC_4x4;
		Residual_luma_AC_CodedBlock8x8						( Residual_luma_skip_AC_CodedBlock8x8				) --> Residual_luma_inc_AC_4x4;
		Residual_luma_inc_AC_4x4							( Residual_luma_inc_AC_4x4							) --> Residual_luma_AC_CAVLC; 
		Residual_luma_AC_CAVLC								( Residual_luma_skip_AC_CAVLC						) --> Residual_chroma; 
		Residual_chroma										( Residual_ChromaArrayType_1_2_init					) --> Residual_chroma_DC_init;
		Residual_chroma_DC_init								( Residual_chroma_DC_init							) --> Residual_block; // --> residual_block()
		Residual_return										( Residual_return_chroma_DC							) --> Residual_chroma_DC_init;
		Residual_chroma_DC_init								( Residual_skip_chroma_DC_init						) --> Residual_chroma_DC_init;
		Residual_chroma_DC_init								( Residual_skip_chroma_DC							) --> Residual_chroma_AC_init;
		Residual_chroma_AC_init								( Residual_chroma_AC_init							) --> Residual_chroma_AC_CodedBlock4x4;
		Residual_chroma_AC_CodedBlock4x4					( Residual_chroma_AC_CodedBlock4x4 					) --> Residual_block; // --> residual_block()
		Residual_return										( Residual_return_chroma_AC							) --> Residual_chroma_AC_CodedBlock4x4;
		Residual_chroma_AC_CodedBlock4x4					( Residual_chroma_AC_skip_CodedBlock4x4 			) --> Residual_chroma_AC_CodedBlock4x4;
		Residual_chroma_AC_CodedBlock4x4					( Residual_skip_chroma_AC							) --> SliceD_update; 
		// --> macrobloc_layer / --> Slice_data

		// residual_block
		Residual_block										( Residual_block_init_coeff_token					) --> Residual_block_read_suffixLength;
		Residual_block_read_suffixLength					( Residual_block_read_suffixLength					) --> Residual_block_read_non_zero_coeff;
		Residual_block_read_non_zero_coeff					( Residual_block_read_trailing_ones_sign_flag		) --> Residual_block_read_non_zero_coeff;
		
		Residual_block_read_non_zero_coeff					( Residual_block_read_TotalCoeff_done				) --> Residual_block_read_total_zeros_done;
		Residual_block_read_total_zeros_done				( Residual_block_read_total_zeros_done				) --> Residual_block_read_run_before;
		Residual_block_read_run_before						( Residual_block_read_run_before					) --> Residual_block_read_run_before_done;
		Residual_block_read_run_before_done					( Residual_block_read_run_before_done				) --> Residual_block_read_run_before;
		Residual_block_read_run_before						( Residual_block_skip_read_run_before				) --> Residual_block_read_run_before;
		Residual_block_read_run_before						( Residual_block_read_run_done						) --> Residual_block_send_run;
		Residual_block_send_run								( Residual_block_send_run							) --> Residual_block_send_run;
		Residual_block_send_run								( Residual_block_send_done							) --> Residual_return;
		Residual_block_read_suffixLength					( Residual_block_skip_read_suffixLength				) --> Residual_return;

		// undefined
		undefined	  					( undefined		    				) --> undefined;

	end

	priority
		look_for > look_for_other_header;
		read_SliceH_pred_weight_table > read_SliceH_skip_pred_weight_table;
		read_SliceH_difference_of_pic_nums_minus1_done > read_SliceH_long_term_frame_idx_done > read_SliceH_memory_management_control_operation_done;
		read_MB_layer_transform_size_8x8_flag > read_MB_layer_skip_transform_size_8x8_flag;
		read_MB_pred_mvd_l0.loop >  read_MB_pred_mvd_l0.skip > read_MB_pred_mvd_l0.done;
		read_MB_pred_mvd_l1.loop >  read_MB_pred_mvd_l1.skip > MB_pred_done;
		send_data_position_information_is_ipcm>send_data_position_information;
	end

end
