/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package org.mpeg4.part10.cbp.synParser.modular.decodePicture;

import org.mpeg4.part10.Imp_PictureInfo.*;
import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import org.mpeg4.part10.cbp.MacroBlockInfo.*;
import std.util.BitOps.*;

actor Algo_DecodeMacroblockLayer(bool isAvc, bool DEBUG)
	int (size=32) ValVLD,
	int (size=16) Parameters,

	uint(size=4)  SubMbType,

	int(size=32)  ResFeedback
		==>
	int (size=6)  TypeOfVLD,
	int (size=32) VLDParam,

	//MbPred parameters
	uint(size=6)  MbPredParameters,

	//SubMbPred parameters
	uint(size=6)  SubMbPredParameters,

	//Residual Parameters
	uint(size=16) ResParameters,

	uint(size=6)  MbType,
	uint(size=8)   pix_I_PCM_Y,
	uint(size=8)   pix_I_PCM_U,
	uint(size=8)   pix_I_PCM_V,

	uint(size=5)  NbCoeffInMB,
	bool          SkipMacroBlk,
	bool          IsIPCM,
	uint(size=16) cbp_blk,
	int (size=32) Feedback
		:


/*
*
* Constants
*
*/

	uint(size=4) SLICE_TYPE_P  = 0;
	uint(size=4) SLICE_TYPE_B  = 1;
	uint(size=4) SLICE_TYPE_I  = 2;
//	uint(size=4) SLICE_TYPE_EI = 2;
	uint(size=4) SLICE_TYPE_SP = 3;
	uint(size=4) SLICE_TYPE_SI = 4;

	uint(size=6) TabCodedBlockPattern[8]       = [0x00, 0x10, 0x20, 0x0F, 0x1F, 0x2F, 0x00, 0x00];
	uint(size=4) TabCodedBlockPatternChroma[8] = [0x00, 0x01, 0x02, 0x00, 0x01, 0x02, 0x00, 0x00];
	uint(size=4) TabCodedBlockPatternLuma[8]   = [0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00];
	uint(size=4) InverseScan4x4Tab[16]         = [0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15 ];

	//Should be in VariableLengthDecoding actor
	List ( type: List ( type: List ( type: uint(size=6), size=2), size=48 ), size=4) VLD_ME_TABLE =
		[
			[[15, 0], [ 0, 1], [ 7, 2], [11, 4], [13, 8], [14, 3], [ 3, 5], [ 5,10], [10,12], [12,15],
			 [ 1, 7], [ 2,11], [ 4,13], [ 8,14], [ 6, 6], [ 9, 9], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0],
			 [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0],
			 [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0],
			 [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]
			],
			[[47, 0], [31,16], [15, 1], [ 0, 2], [23, 4], [27, 8], [29,32], [30, 3], [ 7, 5], [11, 10],
			 [13,12], [14,15], [39,47], [43, 7], [45,11], [46,13], [16,14], [ 3, 6], [ 5, 9], [10,31],
			 [12,35], [19,37], [21,42], [26,44], [28,33], [35,34], [37,36], [42,40], [44,39], [ 1,43],
			 [ 2,45], [ 4,46], [ 8,17], [17,18], [18,20], [20,24], [24,19], [ 6,21], [ 9,26], [22,28],
			 [25,23], [32,27], [33,29], [34,30], [36,22], [40,25], [38,38], [41,41]
			],
			[[47, 0], [31,16], [15, 1], [ 0, 2], [23, 4], [27, 8], [29,32], [30, 3], [ 7, 5], [11, 10],
			 [13,12], [14,15], [39,47], [43, 7], [45,11], [46,13], [16,14], [ 3, 6], [ 5, 9], [10,31],
			 [12,35], [19,37], [21,42], [26,44], [28,33], [35,34], [37,36], [42,40], [44,39], [ 1,43],
			 [ 2,45], [ 4,46], [ 8,17], [17,18], [18,20], [20,24], [24,19], [ 6,21], [ 9,26], [22,28],
			 [25,23], [32,27], [33,29], [34,30], [36,22], [40,25], [38,38], [41,41]
			],
			[[15, 0], [ 0, 1], [ 7, 2], [11, 4], [13, 8], [14, 3], [ 3, 5], [ 5,10], [10,12], [12,15],
			 [ 1, 7], [ 2,11], [ 4,13], [ 8,14], [ 6, 6], [ 9, 9], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0],
			 [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0],
			 [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0],
			 [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]
			]
		];

	List (type:uint(size=6),size=64) QP_TAB = 
		[
			 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
			10,11,12,13,14,15,16,17,18,19,
			20,21,22,23,24,25,26,27,28,29,
			29,30,31,32,32,33,34,34,35,35,
			36,36,37,37,37,38,38,38,39,39,
			39,39,39,39,39,39,39,39,42,42,
			42,42,42,42
		];

	uint(size=32) picWidthInMbs;
	uint(size=32) currMbAddr;
	uint(size=6)  mb_type                        := 0;
	bool          noSubMbPartSizeLessThan8x8Flag := true;
	bool          transform_size_8x8_flag        := true;
	uint(size=4)  codedBlkPattTab[POW2_PICWIDTH_BLK_PLUS1];
	uint(size=6)  CodedBlockPatternLuma          := 0;
	uint(size=6)  CodedBlockPatternChroma        := 0;
	//int (size=32) mb_qp_delta                    := 0;
	bool          entropyCodingMode;
	//SliceData Parameters
	uint(size=4)  slice_type;
	uint(size=4)  bit_depth_luma;
	uint(size=4)  bit_depth_chroma;
	uint(size=16) cbfChrNeighbA;
	uint(size=16) cbfChrNeighbB;
	bool          direct_8x8_inference_flag;
	bool          transform_8x8_mode_flag;
	uint(size=2)  Chroma_Array_Type;
	uint(size=5)  num_ref_idx_l0_active;
	uint(size=5)  num_ref_idx_l1_active;
	bool          mb_field_decoding;
	List(type: uint(size=5), size=12) nATab;
	List(type: uint(size=5), size=12) nBTab;
	bool          LeftMb_Exists;
	bool          AboveMb_Exists;
	uint(size=2)  NumC8x8;
	int (size=8)  QpValue;
	int (size=8)  Qp_CbValue;
	int (size=8)  Qp_CrValue;
	int (size=5)  chroma_qp_index_offset;
	int (size=5)  second_chroma_qp_index_offset;
	int (size=8)  prevMbQpDelta;
	int (size=8)  currMbQpDelta;
	bool          baseMode = false;
/*	Svc parameters 
	bool          adaptBaseMode = false; /// !!!!!!!!!!!!!!!!!
	bool          residualPred = false; //!!!!!!!!!!!!!
	uint(size=4)  scanIdxStart = 0;//!!!!!!!!!!!!!
	uint(size=4)  scanIdxEnd = 0;//!!!!!!!!!!!!
*/

	uint(size=9)  NbCoeffChroma;
	uint(size=9)  ChromaReadIdx  := 0;
	uint(size=9)  ChromaWriteIdx := 0;

		//not implemented yet ! (Svc function)
/*	function inCropWindow(uint(size=32) currMbAddr) --> bool :
		currMbAddr = 42
	end*/

	ReadParameters: action Parameters:[param] repeat 41 ==>
	do
		direct_8x8_inference_flag     := getFlag(param[0], 0);
		transform_8x8_mode_flag       := getFlag(param[0], 1);
		mb_field_decoding             := getFlag(param[0], 2);
		entropyCodingMode             := getFlag(param[0], 3);
		LeftMb_Exists                 := getFlag(param[0], 4);
		AboveMb_Exists                := getFlag(param[0], 5);

		slice_type                    := param[1];
		bit_depth_luma                := param[2];
		bit_depth_chroma              := param[3];
		Chroma_Array_Type             := param[4];
		num_ref_idx_l0_active         := param[5];
		num_ref_idx_l1_active         := param[6];
		NumC8x8                       := param[7];
		QpValue                       := param[8];
		chroma_qp_index_offset        := param[9];
		second_chroma_qp_index_offset := param[10];
		Qp_CbValue                    := QP_TAB[(QpValue + chroma_qp_index_offset) & 0x3F];
		Qp_CrValue                    := QP_TAB[(QpValue + second_chroma_qp_index_offset) & 0x3F];
		foreach int i in 0 .. 11
		do
			nATab[i] := param[11 + i];
			nBTab[i] := param[23 + i];
		end
		NbCoeffChroma := param[35] * param[36];
		picWidthInMbs := param[37];
		currMbAddr    := param[38];
		cbfChrNeighbA := param[39];
		cbfChrNeighbB := param[40];

		prevMbQpDelta := currMbQpDelta;
		currMbQpDelta  := 0;
	end

/* Svc actions
	askBaseModeFlag: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not isAvc and inCropWindow(42) and adaptBaseMode
	end

	getBaseModeFlag: action ValVLD:[baseModeFlag] ==>
	do
		baseMode := (baseModeFlag != 0);
	end
*/
	ReadMbType.Asked.cavlc: action ==> TypeOfVLD:[VLD_UE]
	guard
		(not baseMode || isAvc) && not entropyCodingMode
	end

	ReadMbType.Asked.cabac: action ==> TypeOfVLD:[CABAC_MB_TYPE],
		VLDParam:[slice_type]
	guard
		(not baseMode || isAvc) && entropyCodingMode
	end

	readMbType.done: action ValVLD:[ValueOfVLD] ==>
	do
		uint Idx;

		mb_type :=
			if((slice_type = SLICE_TYPE_SI) or (slice_type = SLICE_TYPE_I))then
				ValueOfVLD
			else
				if((slice_type = SLICE_TYPE_SP) or (slice_type = SLICE_TYPE_P))then
					if(ValueOfVLD >= 5) then
						if(ValueOfVLD < 32)then
							ValueOfVLD - 5
						else
							0
						end
					else
						ValueOfVLD + BLOCK_TYPE_P_MIN - BLOCK_TYPE_I_8x8
					end
				else
					if(ValueOfVLD < 23) then
						ValueOfVLD + BLOCK_TYPE_B_MIN - BLOCK_TYPE_I_8x8
					else
						if(ValueOfVLD < 49) then
							ValueOfVLD - 23
						else
							0
						end
					end
				end
			end;
		if mb_type != BLOCK_TYPE_I_4x4 then
			mb_type := mb_type + BLOCK_TYPE_I_8x8;
		end
		transform_size_8x8_flag        := false;
		noSubMbPartSizeLessThan8x8Flag := true;
		if(DEBUG)then
			println("mb_type : "+mb_type);
		end
		Idx := (mb_type - BLOCK_TYPE_INTRA_16x16_MIN)/4;
		CodedBlockPatternLuma   := TabCodedBlockPatternLuma[Idx & 7];
		CodedBlockPatternChroma := TabCodedBlockPatternChroma[Idx & 7];
		codedBlkPattTab[currMbAddr &
		MASK_POW2_PICWIDTH_BLK_PLUS1] := TabCodedBlockPattern[Idx & 7];
	end
	
	CheckMbType.IsIPCM: action
				==>
			//    pcm_alignment_zero_bit , pcm_sample_luma[ i ]
			TypeOfVLD :[   ValTypeOfVLD    ] repeat 257,
			//Orcc doesn't support it yet :
			//TypeOfVLD    :[ [BYTE_ALIGNED_REQUIRED] +  [ValTypeOfVLDecod]repeat 256 ],
			VLDParam  :[ BitDepthChromaTab ] repeat 256,

			Feedback:[feedbackValues] repeat 54,

			IsIPCM :[true],
			MbType:[mb_type]
		guard
			mb_type = BLOCK_TYPE_I_PCM and (not baseMode or isAvc)
		do
			uint(size=3) ValTypeOfVLD[257] := [READ_BITS : for int s in 0 .. 256];
			//List(type: uint(size=3), size=256) ValTypeOfVLDecod   = [READ_BITS        : for int s in 0 .. 255],
			uint(size=5) BitDepthChromaTab[256]  = [bit_depth_luma : for int s in 0 .. 255];

			int(size=32) feedbackValues[54] := [16: for int s in 0 .. 53];

			if(DEBUG)then
				println("IsIPCM");
			end
			feedbackValues[0]  := QpValue;
			feedbackValues[1]  := Qp_CbValue;
			feedbackValues[2]  := Qp_CrValue;
			ValTypeOfVLD[0] := BYTE_ALIGNED_REQUIRED;
		end

	ReadPcmSampleLuma.Done: action
			ValVLD       :[ValueOfVLD] repeat 256
				==>
			pix_I_PCM_Y  :[ValueOfVLD] repeat 256
		do
			if(DEBUG)then
				println("");
				/* Forward to the output for the pcm decoding */
				foreach int a in 0 .. 255
				do
					println("\t\tpcm_sample_luma[" + a + "] : " + ValueOfVLD[a]);
				end
				println("");
			end
		end

	ReadPcmSampleChroma.Asked: action
				==>
			//            pcm_sample_chroma[ i ]
			TypeOfVLD :[     READ_BITS    ],
			VLDParam  :[ bit_depth_chroma ]
		guard
			ChromaWriteIdx < NbCoeffChroma
		do
			ChromaWriteIdx  := ChromaWriteIdx + 1;
		end

	ReadPcmSampleChroma.UComponent: action
			ValVLD      :[ValueOfVLD]
				==>
			pix_I_PCM_U :[ValueOfVLD]
		guard
			ChromaReadIdx < ChromaWriteIdx
		do
			if(DEBUG)then
				println("\t\tpcm_sample_chroma1[" + ChromaReadIdx + "] : " + ValueOfVLD);
			end
			ChromaReadIdx := ChromaReadIdx + 1;
		end

	ReadPcmSampleChroma.VComponent: action
			ValVLD      :[ValueOfVLD]
				==>
			pix_I_PCM_V :[ValueOfVLD]
		guard
			ChromaReadIdx < ChromaWriteIdx
		do
			if(DEBUG)then
				println("\t\tpcm_sample_chroma2[" + ChromaReadIdx + "] : " + ValueOfVLD);
			end
			ChromaReadIdx := ChromaReadIdx + 1;
		end

	ReadPcmSampleChroma.Done: action ==>
		guard
			ChromaReadIdx = NbCoeffChroma
		do
			ChromaReadIdx  := 0;
			ChromaWriteIdx := 0;
			if(DEBUG)then
				println("");
			end
		end

	cabacInitArithm.launch: action ==> TypeOfVLD:[CABAC_INIT_ARITHM]
	guard
		entropyCodingMode
	end

	cabacInitArithm.skip: action ==>
	guard
		not entropyCodingMode
	end

	CheckMbType.IsNotIPCM: action ==> NbCoeffInMB:[NbCoeff], IsIPCM:[false]
	guard
		not baseMode or isAvc
	var
		uint(size=5) NbCoeff
	do
		NbCoeff := 16 + 1 + 1 + 4 + 4; // 16 Luma AC + 1 * 2 Chroma DC + 4 * 2 Chroma AC
		if(Is_Intra_16x16(mb_type))then
			NbCoeff := NbCoeff + 1;// 1 Luma DC
		end
	end

	LaunchSubMbPred.cavlc: action ==> TypeOfVLD:[LAUNCH_ACTOR],
		VLDParam:[SUB_MB_PRED], SubMbPredParameters:[mb_type,
		num_ref_idx_l0_active, num_ref_idx_l1_active,
		setFlag(mb_field_decoding,0,setFlag (entropyCodingMode,1,0))],
		MbType:[mb_type]
	guard
		numMbPart(mb_type) = 4 && not entropyCodingMode
	end

	LaunchSubMbPred.cabac: action ==> TypeOfVLD:[CABAC_SEND_MB_TYPE,
		LAUNCH_ACTOR], VLDParam:[mb_type, SUB_MB_PRED],
		SubMbPredParameters:[mb_type, num_ref_idx_l0_active,
		num_ref_idx_l1_active, setFlag(mb_field_decoding,0,
		setFlag (entropyCodingMode,1,0))], MbType:[mb_type]
	guard
		numMbPart(mb_type) = 4 && entropyCodingMode 
	end

	CheckSubMbType: action
			SubMbType :[sub_mb_type] repeat 4
				==>
		do
			if(slice_type = SLICE_TYPE_B) then
				foreach int mbPartIdx in 0 .. 3
				do	//if(sub_mb_type != B_DIRECT_8x8
				   // && NumSubMbPart(sub_mb_type) > 1)
					if(sub_mb_type[mbPartIdx] > 3)then
						noSubMbPartSizeLessThan8x8Flag := false;
					else//if(sub_mb_type = B_DIRECT_8x8
				        // && !direct_8x8_inference_flag)
						if((sub_mb_type[mbPartIdx] = 0) and (not direct_8x8_inference_flag))then
							noSubMbPartSizeLessThan8x8Flag := false;
						end
					end
				end
			else
				//if(sub_mb_type != B_DIRECT_8x8)
				if((slice_type = SLICE_TYPE_P) or (slice_type = SLICE_TYPE_SP))then
					foreach int mbPartIdx in 0 .. 3
					do  //if(NumSubMbPart(sub_mb_type) > 1)
						if(sub_mb_type[mbPartIdx] != 0)then
							noSubMbPartSizeLessThan8x8Flag := false;
						end
					end
				end
			end
		end

	ReadTransformSize.Asked: action
			==>
			//        transform_size_8x8_flag
			TypeOfVLD :[ READ_BITS ],
			VLDParam  :[     1     ]
		guard
			transform_8x8_mode_flag = true and mb_type = BLOCK_TYPE_I_4x4
		end
	ReadTransformSize.NoAsked: action
			==>
		guard
			transform_8x8_mode_flag = false or mb_type != BLOCK_TYPE_I_4x4
		end

	ReadTransformSize.Puts.cavlc: action ==> MbType:[mb_type]
	guard
		not entropyCodingMode
	do
		if transform_size_8x8_flag = true then
			mb_type := BLOCK_TYPE_I_8x8;
			if(DEBUG)then			
				println("mb_type is I8x8");
			end
		end
	end

	ReadTransformSize.Puts.cabac: action ==> MbType:[mb_type],
		TypeOfVLD:[CABAC_SEND_MB_TYPE], VLDParam:[mb_type]
	guard
		entropyCodingMode
	do
		if transform_size_8x8_flag = true then
			mb_type := BLOCK_TYPE_I_8x8;
			if(DEBUG)then			
				println("mb_type is I8x8");
			end
		end
	end
	
	LaunchMbPred: action
				==>
			TypeOfVLD               :[LAUNCH_ACTOR],
			VLDParam                :[MB_PRED],

			MbPredParameters :[mb_type               , Chroma_Array_Type , 
			                   num_ref_idx_l0_active , num_ref_idx_l1_active ,
			                   setFlag(transform_size_8x8_flag,1,setFlag(
			                   	mb_field_decoding,0, setFlag(entropyCodingMode,
			                   	2,0))), picWidthInMbs, currMbAddr]
		end
/* Svc actions
	askResidualPredFlag: action ==>
	guard
		not isAvc,
		residualPred and slice_type != SLICE_TYPE_EI and
		(baseMode or (not Mb_IsIntra(mb_type) and inCropWindow(42)))
	end

	checkForResidualFlag.launch: action ==>
	guard
		isAvc or (scanIdxEnd >= scanIdxStart)
	end

	checkForResidualFlag.skip: action ==>
	end
*/
	ReadCodedBlockPattern.Asked.cavlc: action ==> TypeOfVLD:[VLD_UE]
	guard
		not(Is_Intra_16x16(mb_type)) or (baseMode and not isAvc),
		not entropyCodingMode
	end

	ReadCodedBlockPattern.Asked.cabac: action ==>
		TypeOfVLD:[CABAC_CODED_BLOCK_PATERN], VLDParam:[codedBlkPatt] repeat 2
	guard
		not(Is_Intra_16x16(mb_type)) or (baseMode and not isAvc),
		entropyCodingMode
	do
		uint(size=6) codedBlkPatt[2];
		codedBlkPatt[0] := codedBlkPattTab[(currMbAddr - 1) &
			MASK_POW2_PICWIDTH_BLK_PLUS1];
		codedBlkPatt[1] := codedBlkPattTab[(currMbAddr - picWidthInMbs) &
			MASK_POW2_PICWIDTH_BLK_PLUS1];
	end

	ReadCodedBlockPattern.Done: action ValVLD:[CodeNum] ==>
	do
		uint(size=6) coded_block_pattern;

		coded_block_pattern :=
			if(not entropyCodingMode) then
				if( Is_Intra_NxN(mb_type) )then
					VLD_ME_TABLE[Chroma_Array_Type][CodeNum][0]
				else
					VLD_ME_TABLE[Chroma_Array_Type][CodeNum][1]
				end
			else
				CodeNum
			end;
		codedBlkPattTab[currMbAddr &
			MASK_POW2_PICWIDTH_BLK_PLUS1] := coded_block_pattern;
		CodedBlockPatternLuma   := coded_block_pattern mod 16;
		CodedBlockPatternChroma := coded_block_pattern  /  16;
		if(DEBUG)then
			println("coded_block_pattern : "+coded_block_pattern);
		end
	end

	ReadTransformSize8x8.Asked: action
				==>
			//        transform_size_8x8_flag
			TypeOfVLD :[ READ_BITS ],
			VLDParam  :[     1     ]
		guard
			CodedBlockPatternLuma  > 0,
			transform_8x8_mode_flag,
			(baseMode and not isAvc) or 
			((not Is_Intra_NxN(mb_type)) and
			noSubMbPartSizeLessThan8x8Flag and
			(mb_type != BLOCK_TYPE_B_DIRECT_16x16 or direct_8x8_inference_flag))
		end

	ReadTransformSize8x8.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			transform_size_8x8_flag :=
				if(ValueOfVLD = 0) then
					false
				else
					true
				end;
			if(DEBUG)then
				println("transform_size_8x8_flag : "+ValueOfVLD);
			end
		end
		
			//            mb_qp_delta
	ReadMbQpDelta.Asked.cavlc: action ==> TypeOfVLD:[VLD_SE]
	guard
		(CodedBlockPatternLuma   > 0) or (CodedBlockPatternChroma > 0)
		or (not baseMode or isAvc) and Is_Intra_16x16(mb_type),
		not entropyCodingMode
	end

	ReadMbQpDelta.Asked.cabac: action ==> TypeOfVLD:[CABAC_MB_QP_DELTA],
		VLDParam:[param] repeat 2
	guard
		(CodedBlockPatternLuma   > 0) or (CodedBlockPatternChroma > 0)
		or (not baseMode or isAvc) and Is_Intra_16x16(mb_type),
		entropyCodingMode
	do
		int(size=32) param[2];

		param[0] := codedBlkPattTab[(currMbAddr - 1) &
			MASK_POW2_PICWIDTH_BLK_PLUS1];
		param[1] := prevMbQpDelta;
	end

	ReadMbQpDelta.Done: action ValVLD:[ValueOfVLD] ==>
		Feedback:[QpValue, Qp_CbValue, Qp_CrValue]
	do
		currMbQpDelta := ValueOfVLD;
		if(DEBUG)then
			println("mb_qp_delta : "+ValueOfVLD);
		end
		//mb_qp_delta := ValueOfVLD;
		QpValue      := (QpValue + ValueOfVLD + 52) mod 52;
		Qp_CbValue := QP_TAB[(QpValue + chroma_qp_index_offset) & 0x3F];
		Qp_CrValue := QP_TAB[(QpValue + second_chroma_qp_index_offset) & 0x3F];
	end

	LaunchResidual: action
				==>
			TypeOfVLD            :[LAUNCH_ACTOR],
			VLDParam             :[RESIDUAL],

			ResParameters        :[parameters] repeat 34,

			SkipMacroBlk         :[false]
		do
			uint(size=16) parameters[34];
			uint(size=6) flag;

			flag := setFlag(entropyCodingMode , 0 , setFlag( transform_size_8x8_flag, 1 , 0    ) );
			flag := setFlag( false /*BmFlag*/ , 2 , setFlag( LeftMb_Exists          , 3 , flag ) );
			flag := setFlag( AboveMb_Exists   , 4 ,  flag );
			parameters[0] := flag;
			parameters[1] := mb_type;
			parameters[2] := 0;//StartIdx
			parameters[3] := 15;//EndIdx
			parameters[4] := CodedBlockPatternLuma;
			parameters[5] := CodedBlockPatternChroma;
			parameters[6] := Chroma_Array_Type;
			parameters[7] := NumC8x8;
			foreach int i in 0 .. 11
			do
				parameters[8  + i] := nATab[i];
				parameters[20 + i] := nBTab[i];
			end
			parameters[32] := cbfChrNeighbA;
			parameters[33] := cbfChrNeighbB;
		end

	GetResidualCoeffToken: action ResFeedback:[CoLu] repeat 51 ==>
		Feedback:[CoLu] repeat 51, cbp_blk:[CbpBlk]
	do
		uint(size=16) CbpBlk := 0;
		//We check all TotalCoeffLuma
		foreach int i in 0 .. 15
		do
			CbpBlk := CbpBlk << 1;
			if(CoLu[InverseScan4x4Tab[15 - i]] > 0)then
				CbpBlk := CbpBlk + 1;
			end
		end
	end

	noResidual: action ==> Feedback:[feedbackValues] repeat 54,
		SkipMacroBlk:[true]
	do
		int(size=16) feedbackValues[54] := [0: for int s in 0 .. 53];

		feedbackValues[0]  := QpValue;
		feedbackValues[1]  := Qp_CbValue;
		feedbackValues[2]  := Qp_CrValue;
	end

	sendEndMbLayer: action ==> TypeOfVLD:[SKIP_NAL]
	end

	schedule fsm ReadParameters:
		ReadParameters   (ReadParameters        )--> ReadMbType_Asked;
		ReadMbType_Asked (ReadMbType.Asked      )--> ReadMbType;
		ReadMbType       (readMbType.done       )--> CheckMbType;
		CheckMbType      (CheckMbType.IsIPCM    )--> ReadPcmSampleLuma;
		CheckMbType      (CheckMbType.IsNotIPCM )--> CheckMbPred;

		CheckMbPred (LaunchSubMbPred            )--> CheckSubMbType;
		CheckMbPred (ReadTransformSize.Asked    )--> ReadTransformSize8x8_1;
		CheckMbPred (ReadTransformSize.NoAsked  )--> ReadTransformSize8x8_1_Puts;

		/* PCM Macroblock */
		ReadPcmSampleLuma    (ReadPcmSampleLuma.Done         )--> ReadPcmSampleChroma1;
		ReadPcmSampleChroma1 (ReadPcmSampleChroma.Asked      )--> ReadPcmSampleChroma1;
		ReadPcmSampleChroma1 (ReadPcmSampleChroma.UComponent )--> ReadPcmSampleChroma1;
		ReadPcmSampleChroma1 (ReadPcmSampleChroma.Done       )--> ReadPcmSampleChroma2;

		ReadPcmSampleChroma2 (ReadPcmSampleChroma.Asked      )--> ReadPcmSampleChroma2;
		ReadPcmSampleChroma2 (ReadPcmSampleChroma.VComponent )--> ReadPcmSampleChroma2;
		ReadPcmSampleChroma2 (ReadPcmSampleChroma.Done       )--> CabacInitArithm;
		CabacInitArithm      (cabacInitArithm                )--> SendEndMbLayer;

		/* Other Macroblock */
		CheckSubMbType          (CheckSubMbType              )--> Check4CodedBlockPattern;
		Check4CodedBlockPattern (ReadCodedBlockPattern.Asked )--> ReadCodedBlockPattern;
		Check4CodedBlockPattern (ReadMbQpDelta.Asked         )--> ReadMbQpDelta;
		Check4CodedBlockPattern (noResidual                  )--> SendEndMbLayer;

		ReadTransformSize8x8_1      (ReadTransformSize8x8.Done )--> ReadTransformSize8x8_1_Puts;
		ReadTransformSize8x8_1_Puts (ReadTransformSize.Puts    )--> LaunchMbPred;
		LaunchMbPred                (LaunchMbPred              )--> Check4CodedBlockPattern;
	
		ReadCodedBlockPattern  (ReadCodedBlockPattern.Done )--> Check4TransformSize8x8;
		Check4TransformSize8x8 (ReadTransformSize8x8.Asked )--> ReadTransformSize8x8_2;
		Check4TransformSize8x8 (ReadMbQpDelta.Asked        )--> ReadMbQpDelta;
		Check4TransformSize8x8 (noResidual                 )--> SendEndMbLayer;

		ReadTransformSize8x8_2 (ReadTransformSize8x8.Done )--> Check4MbQpDelta;

		Check4MbQpDelta (ReadMbQpDelta.Asked )--> ReadMbQpDelta;
		Check4MbQpDelta (noResidual          )--> SendEndMbLayer;

		ReadMbQpDelta         (ReadMbQpDelta.Done    )--> LaunchResidual;
		LaunchResidual        (LaunchResidual        )--> GetResidualCoeffToken;
		GetResidualCoeffToken (GetResidualCoeffToken )--> SendEndMbLayer;
		SendEndMbLayer        (sendEndMbLayer        )--> ReadParameters;
	end

	priority
		CheckMbType.IsIPCM             > CheckMbType.IsNotIPCM;
		LaunchSubMbPred                > ReadTransformSize.Asked;// > LaunchMbPred; //ReadTransformSize.Puts;
		ReadCodedBlockPattern.Asked    > ReadMbQpDelta.Asked;
		ReadTransformSize8x8.Asked     > ReadMbQpDelta.Asked;
		ReadMbQpDelta.Asked            > noResidual;
		ReadPcmSampleChroma.Asked      > ReadPcmSampleChroma.Done;
		ReadPcmSampleChroma.Done       > ReadPcmSampleChroma.VComponent;
		ReadPcmSampleChroma.Done       > ReadPcmSampleChroma.UComponent;
//		checkForResidualFlag.launch    > checkForResidualFlag.skip;
	end
end