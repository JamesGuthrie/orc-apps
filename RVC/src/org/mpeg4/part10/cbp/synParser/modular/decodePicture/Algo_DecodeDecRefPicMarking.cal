/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package org.mpeg4.part10.cbp.synParser.modular.decodePicture;

import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;

actor Algo_DecodeDecRefPicMarking(bool DEBUG)
	int (size=32) ValVLD,

	uint(size=2) PicNalRefIdc,
	bool         IdrPic,

	bool          IsNewPic
		==>
	uint(size=5)  TypeOfVLD,
	int (size=32) NbBitsToRead,

	uint(size=31) Mmco,
	bool          EmptyDpb
		:

	bool emptyDpb;
	bool is_new_pic;

	bool adaptive_ref_pic_marking_mode_flag;
	//CheckNaluType Parameters
	uint(size=2) nal_ref_idc;
	bool         IdrPicFlag;

	ReadNalRefIdc.IsNewPic: action
			PicNalRefIdc :[ValNalRefIdc],
			IdrPic       :[IsAnIdr],
			IsNewPic     :[ValIsNewPic]
				==>
			Mmco         :[ValIdr]
		guard
			ValIsNewPic
		var
			uint(size=31) ValIdr
		do
			is_new_pic  := ValIsNewPic;
			nal_ref_idc := ValNalRefIdc;
			IdrPicFlag  := IsAnIdr;
			ValIdr :=
				if(not IsAnIdr )then
					1
				else
					0
				end;
			emptyDpb := false;
		end

	ReadNalRefIdc.IsNewSlice: action
			PicNalRefIdc :[ValNalRefIdc],
			IdrPic       :[IsAnIdr],
			IsNewPic     :[ValIsNewPic]
				==>
		guard
			not ValIsNewPic
		var
			uint(size=31) ValIdr
		do
			is_new_pic  := ValIsNewPic;
			nal_ref_idc := ValNalRefIdc;
			IdrPicFlag  := IsAnIdr;
			ValIdr :=
				if(not IsAnIdr )then
					1
				else
					0
				end;
		end

	NalRefIdc.IsEqualTo0.IsNewPic: action
				==>
			Mmco :[adaptive_ref_pic_marking_mode_flag]
		guard
			nal_ref_idc = 0,
			is_new_pic
		var
			uint(size=31) adaptive_ref_pic_marking_mode_flag = 0
		end

	NalRefIdc.IsEqualTo0.IsNewSlice: action ==>
		guard
			nal_ref_idc = 0,
			not is_new_pic
		end

	IsAnIdrPic.IsEqualToFalse: action
				==>
			//     adaptive_ref_pic_marking_mode_flag
			TypeOfVLD    :[ READ_BITS ],
			NbBitsToRead :[     1     ]
		guard
			IdrPicFlag = false
		end

	IsAnIdrPic.IsEqualToTrue: action
				==>
			//              no_output , long_term
			TypeOfVLD    :[ READ_BITS , READ_BITS ],
			NbBitsToRead :[     1     ,     1     ]
		guard
			IdrPicFlag = true
		end

	ReadIdrParam.Done.IsNewPic: action
			ValVLD     :[no_output_of_prior_pics_flag, long_term_reference_flag]
				==>
			Mmco         :[long_term_reference_flag]
		guard
			is_new_pic
		do
			if(DEBUG)then
				println("\t\tno_output_of_prior_pics_flag: "+no_output_of_prior_pics_flag);
				println("\t\tlong_term_reference_flag: "+long_term_reference_flag);
			end
		end

	ReadIdrParam.Done.IsNewSlice: action
			ValVLD     :[no_output_of_prior_pics_flag, long_term_reference_flag]
				==>
		guard
			not is_new_pic
		do
			if(DEBUG)then
				println("\t\tno_output_of_prior_pics_flag: "+no_output_of_prior_pics_flag);
				println("\t\tlong_term_reference_flag: "+long_term_reference_flag);
			end
		end

	ReadAdaptRefPicMarkMode.Done.IsNewPic: action
			ValVLD     :[ValueOfVLD]
				==>
			Mmco       :[ValueOfVLD]
		guard
			is_new_pic
		do
			adaptive_ref_pic_marking_mode_flag :=
				if(ValueOfVLD = 0)then
					false
				else
					true
				end;
			if(DEBUG)then
				println("\t\tadaptive_ref_pic_marking_mode_flag: "+adaptive_ref_pic_marking_mode_flag);
			end
		end

	ReadAdaptRefPicMarkMode.Done.IsNewSlice: action
			ValVLD     :[ValueOfVLD]
				==>
		guard
			not is_new_pic
		do
			adaptive_ref_pic_marking_mode_flag :=
				if(ValueOfVLD = 0)then
					false
				else
					true
				end;
			if(DEBUG)then
				println("\t\tadaptive_ref_pic_marking_mode_flag: "+adaptive_ref_pic_marking_mode_flag);
			end
		end

	AdaptRefPicMarkMode.IsEqualToTrue: action
				==>
			//  memory_management_control_operation
			TypeOfVLD    :[ VLD_UE ]
		guard
			adaptive_ref_pic_marking_mode_flag = true
		end

	MMCO.IsEqualTo1_2_4_6.IsNewPic: action
			ValVLD :[ValueOfVLD]
				==>
			TypeOfVLD    :[ VLD_UE ],

			Mmco         :[ValueOfVLD]
		guard
			   ValueOfVLD = 1
			or ValueOfVLD = 2
			or ValueOfVLD = 4
			or ValueOfVLD = 6,
			is_new_pic
		do
			if(DEBUG)then
				println("\t\tmemory_management_control_operation: "+ValueOfVLD);
			end
		end

	MMCO.IsEqualTo1_2_4_6.IsNewSlice: action
			ValVLD :[ValueOfVLD]
				==>
			TypeOfVLD    :[ VLD_UE ]
		guard
			   ValueOfVLD = 1
			or ValueOfVLD = 2
			or ValueOfVLD = 4
			or ValueOfVLD = 6,
			not is_new_pic
		do
			if(DEBUG)then
				println("\t\tmemory_management_control_operation: "+ValueOfVLD);
			end
		end

	MMCO.IsEqualTo3.IsNewPic: action
			ValVLD :[ValueOfVLD]
				==>
			//              differ , long_te
			TypeOfVLD    :[ VLD_UE , VLD_UE ],

			Mmco         :[ValueOfVLD]
		guard
			ValueOfVLD = 3,
			is_new_pic
		do
			if(DEBUG)then
				println("\t\tmemory_management_control_operation: "+ValueOfVLD);
			end
		end

	MMCO.IsEqualTo3.IsNewSlice: action
			ValVLD :[ValueOfVLD]
				==>
			//              differ , long_te
			TypeOfVLD    :[ VLD_UE , VLD_UE ]
		guard
			ValueOfVLD = 3,
			not is_new_pic
		do
			if(DEBUG)then
				println("\t\tmemory_management_control_operation: "+ValueOfVLD);
			end
		end

	MMCO.IsEqualTo5.IsNewPic: action
			ValVLD :[ValueOfVLD]
				==>
			//   memory_management_control_operation
			TypeOfVLD    :[ VLD_UE ],

			Mmco         :[ValueOfVLD]
		guard
			ValueOfVLD = 5,
			is_new_pic
		do
			emptyDpb := true;
			if(DEBUG)then
				println("\t\tmemory_management_control_operation: "+ValueOfVLD);
			end
		end

	MMCO.IsEqualTo5.IsNewSlice: action
			ValVLD :[ValueOfVLD]
				==>
			//   memory_management_control_operation
			TypeOfVLD    :[ VLD_UE ]
		guard
			ValueOfVLD = 5,
			not is_new_pic
		do
			if(DEBUG)then
				println("\t\tmemory_management_control_operation: "+ValueOfVLD);
			end
		end

	MMCO.IsEqualTo0.IsNewPic: action
			ValVLD :[ValueOfVLD]
				==>
			Mmco         :[ValueOfVLD]
		guard
			ValueOfVLD = 0,
			is_new_pic
		do
			if(DEBUG)then
				println("\t\tmemory_management_control_operation: "+ValueOfVLD);
			end
		end

	MMCO.IsEqualTo0.IsNewSlice: action
			ValVLD :[ValueOfVLD]
				==>
		guard
			ValueOfVLD = 0,
			not is_new_pic
		do
			if(DEBUG)then
				println("\t\tmemory_management_control_operation: "+ValueOfVLD);
			end
		end

	ReadMMCOParam.Byte1.IsNewPic: action
			ValVLD :[ValueOfVLD]
				==>
			//      reordering_of_pic_nums_idc
			TypeOfVLD    :[ VLD_UE ],

			Mmco         :[ValueOfVLD]
		guard
			is_new_pic
		do
			if(DEBUG)then
				println("\t\tmemory_management_control_operation Param: "+ValueOfVLD);
			end
		end

	ReadMMCOParam.Byte1.IsNewSlice: action
			ValVLD :[ValueOfVLD]
				==>
			//      reordering_of_pic_nums_idc
			TypeOfVLD    :[ VLD_UE ]
		guard
			not is_new_pic
		do
			if(DEBUG)then
				println("\t\tmemory_management_control_operation Param: "+ValueOfVLD);
			end
		end

	ReadMMCOParam.Byte2.IsNewPic: action
			ValVLD :[ValueOfVLD] repeat 2
				==>
			//      reordering_of_pic_nums_idc
			TypeOfVLD    :[ VLD_UE ],

			Mmco         :[ValueOfVLD] repeat 2
		guard
			is_new_pic
		do
			if(DEBUG)then
				println("\t\tmemory_management_control_operation Param: "+ValueOfVLD[0]);
				println("\t\tmemory_management_control_operation Param: "+ValueOfVLD[1]);
			end
		end

	ReadMMCOParam.Byte2.IsNewSlice: action
			ValVLD :[ValueOfVLD] repeat 2
				==>
			//      reordering_of_pic_nums_idc
			TypeOfVLD    :[ VLD_UE ]
		guard
			not is_new_pic
		do
			if(DEBUG)then
				println("\t\tmemory_management_control_operation Param: "+ValueOfVLD[0]);
				println("\t\tmemory_management_control_operation Param: "+ValueOfVLD[1]);
			end
		end

	SendEndSliceHeader.isNewPic: action ==> TypeOfVLD :[SKIP_NAL], EmptyDpb:[emptyDpb]
	guard
		is_new_pic
	end

	SendEndSliceHeader.isNewSlice: action ==> TypeOfVLD :[SKIP_NAL]
	guard
		not is_new_pic
	end

	schedule fsm ReadNalRefIdc:
		ReadNalRefIdc            (ReadNalRefIdc                     )--> CheckNalRefIdcAndIdr;

		CheckNalRefIdcAndIdr     (NalRefIdc.IsEqualTo0              )--> EndSliceHeader;
		CheckNalRefIdcAndIdr     (IsAnIdrPic.IsEqualToFalse         )--> ReadAdaptRefPicMarkMode;
		CheckNalRefIdcAndIdr     (IsAnIdrPic.IsEqualToTrue          )--> ReadIdrParamDone;

		ReadIdrParamDone         (ReadIdrParam.Done                 )--> EndSliceHeader;

		ReadAdaptRefPicMarkMode  (ReadAdaptRefPicMarkMode.Done      )--> CheckAdaptRefPicMarkMode;

		CheckAdaptRefPicMarkMode (AdaptRefPicMarkMode.IsEqualToTrue )--> CheckMMCO;
		CheckAdaptRefPicMarkMode (SendEndSliceHeader                )--> ReadNalRefIdc;

		CheckMMCO                (MMCO.IsEqualTo1_2_4_6             )--> MMCORead1Byte;
		CheckMMCO                (MMCO.IsEqualTo3                   )--> MMCORead2Bytes;
		CheckMMCO                (MMCO.IsEqualTo5                   )--> CheckMMCO;
		CheckMMCO                (MMCO.IsEqualTo0                   )--> EndSliceHeader;

		MMCORead1Byte            (ReadMMCOParam.Byte1               )--> CheckMMCO;
		MMCORead2Bytes           (ReadMMCOParam.Byte2               )--> CheckMMCO;

		EndSliceHeader           (SendEndSliceHeader                )--> ReadNalRefIdc;
	end
	priority
		NalRefIdc.IsEqualTo0              > IsAnIdrPic.IsEqualToFalse > IsAnIdrPic.IsEqualToTrue;
		AdaptRefPicMarkMode.IsEqualToTrue > SendEndSliceHeader;
		MMCO.IsEqualTo1_2_4_6             > MMCO.IsEqualTo3           > MMCO.IsEqualTo0            > MMCO.IsEqualTo5;
	end
end
