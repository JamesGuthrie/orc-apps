/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
package org.mpeg4.part10.cbp.synParser.modular.decodePicture;

import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import std.util.BitOps.*;

actor Algo_DecodeSliceHeaderPart2(bool IsAvcCbp)
	uint(size=32) Header1Param,
	int (size=32) PpsParameters,
	int (size=32) ValVLD
		==>
	int (size=6)  TypeOfVLD,
	int (size=32) VLDParam,
	int (size=14) SliceDataParam
		:

	uint(size=4) SLICE_TYPE_I  = 2;
	uint(size=4) SLICE_TYPE_SP = 3;
	uint(size=4) SLICE_TYPE_SI = 4;
	bool DEBUG = false;


	//Parameters read
	uint(size=4)  slice_type;
	int (size=3)  cabacInitIdc;
	//int (size=32) slice_qp_delta;
	bool          sp_for_switch_flag;
	uint(size=6)  slice_qs_delta;
	uint(size=2)  disable_deblocking_filter_idc := 0;
	int(size=6)   slice_alpha_c0_offset         := 0;
	int(size=6)   slice_beta_offset             := 0;
	uint(size=32) slice_group_change_cycle      := 0;
	//PpsParameters
	bool          entropy_coding_mode_flag;
	bool          deblocking_filter_control_present_flag;
	uint(size=4)  num_slice_groups;
	uint(size=3)  slice_group_map_type;
	int (size=32) SzSliceGroupChgCycle;
	int (size=8)  ValPicInitQp;
	//Slice Data Parameters
	bool          MbaffFrameFlag := false;

	readPpsAndHeader1Info: action  PpsParameters:[PpsParam] repeat 6,
		Header1Param :[header1Param] repeat 3 ==>
		SliceDataParam :[dataParam] repeat 3
	do
		int (size=14) dataParam[3];
		uint(size=32) firstMbInSlice;

		disable_deblocking_filter_idc := 0;
		slice_alpha_c0_offset := 0;
		slice_beta_offset     := 0;
		num_slice_groups     := PpsParam[0];
		ValPicInitQp         := PpsParam[1];
		SzSliceGroupChgCycle := PpsParam[2];
		slice_group_map_type := PpsParam[3];
		deblocking_filter_control_present_flag := getFlag(PpsParam[4],0);
		entropy_coding_mode_flag               := getFlag(PpsParam[4],3);
		slice_type := header1Param[0];
		firstMbInSlice := header1Param[1];
		MbaffFrameFlag := getFlag(header1Param[2], 0);
		dataParam[0] := slice_type;
		dataParam[1] := firstMbInSlice;
		dataParam[2] := if MbaffFrameFlag then 1 else 0 end;
		cabacInitIdc := -1;
	end

	RefPicList.Launch: action
			==>
		TypeOfVLD :[LAUNCH_ACTOR],
		VLDParam  :[REF_PIC_LIST]
	end

	PredWeightTable.launch: action ==> TypeOfVLD:[LAUNCH_ACTOR],
		VLDParam:[PRED_WEIGHT_TABLE]
	guard
		not IsAvcCbp
	end

	PredWeightTable.skip: action ==>
	guard
		IsAvcCbp
	end

	DecRefPicMarking.Launch: action ==> TypeOfVLD:[LAUNCH_ACTOR],
		VLDParam:[REF_PIC_MARKING]
	end

	//                                  cabac_init_idc
	ReadCabacInitDc.Asked: action ==> TypeOfVLD:[VLD_UE]
	guard
		entropy_coding_mode_flag  = true,
		slice_type               != SLICE_TYPE_I,
		slice_type               != SLICE_TYPE_SI
	end

	ReadCabacInitDc.Done: action ValVLD :[VLDecoding] ==>
	do
		cabacInitIdc := VLDecoding;
		if(DEBUG)then
			println("\t\tcabac_init_idc: "+cabacInitIdc);
		end
	end

	//                                         slice_qp_delta
	ReadSliceQpDelta.Asked: action ==> TypeOfVLD :[ VLD_SE ]
	end

	ReadSliceQpDelta.Done: action ValVLD :[VLDec] ==> SliceDataParam:[ValOfQp]
	var
		int(size=8) ValOfQp
	do
		//slice_qp_delta := VLDecoding;
		ValOfQp      := VLDec + ValPicInitQp;
		if(DEBUG)then
			println("\t\tslice_qp_delta: "+VLDec);
		end
	end

	Slice_Type.IsEqualToSP: action
			==>
		//              sp_for_sw , slice_q
		TypeOfVLD :[ READ_BITS , VLD_SE ],
		VLDParam  :[     1              ]
	guard
		slice_type = SLICE_TYPE_SP
	end

	ReadSliceSpParameters.Done: action ValVLD :[VLDecoding] repeat 2 ==>
	do
		sp_for_switch_flag :=
			if(VLDecoding[0] = 0)then
				false
			else
				true
			end;
		slice_qs_delta := VLDecoding[1];
		if(DEBUG)then
			println("\t\tsp_for_switch_flag: "+sp_for_switch_flag);
			println("\t\tslice_qs_delta: "+slice_qs_delta);
		end
	end

	//                                          slice_qs_delta
	Slice_Type.IsEqualToSI: action ==> TypeOfVLD :[ VLD_SE ]
	guard
		slice_type = SLICE_TYPE_SP
	end

	ReadSliceSiParameters.Done: action ValVLD :[VLDecoding] ==>
	do
		slice_qs_delta := VLDecoding;
		if(DEBUG)then
			println("\t\tslice_qs_delta: "+slice_qs_delta);
		end
	end

	//                                       slice_qs_delta
	DeblocFilterPresent: action ==> TypeOfVLD :[ VLD_UE ]
	guard
		deblocking_filter_control_present_flag = true
	end

	ReadDisDeblocFilterIdc.Done: action ValVLD :[VLDecoding] ==>
	do
		disable_deblocking_filter_idc := VLDecoding;
		if(DEBUG)then
			println("\t\tdisable_deblocking_filter_idc: "+disable_deblocking_filter_idc);
		end
	end

	//                                                       slice_ , slice_
	DisDeblocFilterIdc.IsNotEqualTo1: action ==> TypeOfVLD :[VLD_SE , VLD_SE]
	guard
		disable_deblocking_filter_idc != 1
	end

	ReadSliceAlphaAndBeta: action ValVLD :[VLDecoding] repeat 2 ==>
	do
		slice_alpha_c0_offset := VLDecoding[0] * 2;
		slice_beta_offset     := VLDecoding[1] * 2;
		if(DEBUG)then
			println("\t\tslice_alpha_c0_offset_div2: "+VLDecoding[0]);
			println("\t\tslice_beta_offset_div2: "+VLDecoding[1]);
		end
	end

	ReadSlcGrpChgCycl.Asked: action
			==>
		//            slice_group_change_cycle
		TypeOfVLD :[       READ_BITS      ],
		VLDParam  :[ SzSliceGroupChgCycle ]
	guard
		num_slice_groups     >  1,
		slice_group_map_type >= 3,
		slice_group_map_type <= 5
	end

	ReadSlcGrpChgCycl.Done: action ValVLD :[VLDecoding] ==>
	do
		slice_group_change_cycle := VLDecoding;
		if(DEBUG)then
			println("\t\tslice_group_change_cycle: "+slice_group_change_cycle);
		end
	end

	SendEndSliceHeader: action ==>
		SliceDataParam :[disable_deblocking_filter_idc , slice_beta_offset,
		                 slice_alpha_c0_offset, cabacInitIdc],
		TypeOfVLD:[LAUNCH_ACTOR, SKIP_NAL], VLDParam:[SLICE_DATA]
	end

	schedule fsm ReadPpsAndHeader1Info:
		ReadPpsAndHeader1Info          (readPpsAndHeader1Info             )--> DecodeRefPicList;
		DecodeRefPicList               (RefPicList.Launch                 )--> DecodeWeightedPred;
		DecodeWeightedPred             (PredWeightTable                   )--> DecodeDecRefPicMarking;
		DecodeDecRefPicMarking         (DecRefPicMarking.Launch           )--> CheckEntropyCodingMode;

		CheckEntropyCodingMode         (ReadCabacInitDc.Asked             )--> ReadCabacInitIdc;
		CheckEntropyCodingMode         (ReadSliceQpDelta.Asked            )--> ReadSliceQpDeltaDone;

		ReadCabacInitIdc               (ReadCabacInitDc.Done              )--> ReadSliceQpDeltaAsked;
		ReadSliceQpDeltaAsked          (ReadSliceQpDelta.Asked            )--> ReadSliceQpDeltaDone;
		ReadSliceQpDeltaDone           (ReadSliceQpDelta.Done             )--> CheckSliceType;

		CheckSliceType                 (Slice_Type.IsEqualToSP            )--> ReadSliceSpParameters;
		CheckSliceType                 (Slice_Type.IsEqualToSI            )--> ReadSliceSiParameters;
		CheckSliceType                 (DeblocFilterPresent               )--> ReadDisDeblocFilterIdc;
		CheckSliceType                 (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckSliceType                 (SendEndSliceHeader                )--> ReadPpsAndHeader1Info;

		ReadSliceSpParameters          (ReadSliceSpParameters.Done        )--> CheckDeblocFilterControl;

		ReadSliceSiParameters          (ReadSliceSiParameters.Done        )--> CheckDeblocFilterControl;

		CheckDeblocFilterControl       (DeblocFilterPresent               )--> ReadDisDeblocFilterIdc;
		CheckDeblocFilterControl       (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckDeblocFilterControl       (SendEndSliceHeader                )--> ReadPpsAndHeader1Info;

		ReadDisDeblocFilterIdc         (ReadDisDeblocFilterIdc.Done       )--> CheckDisDeblocFilterIdc;

		CheckDisDeblocFilterIdc        (DisDeblocFilterIdc.IsNotEqualTo1  )--> ReadSliceAlphaAndBeta;
		CheckDisDeblocFilterIdc        (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckDisDeblocFilterIdc        (SendEndSliceHeader                )--> ReadPpsAndHeader1Info;

		ReadSliceAlphaAndBeta          (ReadSliceAlphaAndBeta             )--> CheckNumSliceGroups;

		CheckNumSliceGroups            (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckNumSliceGroups            (SendEndSliceHeader                )--> ReadPpsAndHeader1Info;

		ReadSlcGrpChgCycl              (ReadSlcGrpChgCycl.Done            )--> EndSliceHeader;

		EndSliceHeader                 (SendEndSliceHeader                )--> ReadPpsAndHeader1Info;
	end
	priority
		ReadCabacInitDc.Asked            > ReadSliceQpDelta.Asked;
		Slice_Type.IsEqualToSP           > Slice_Type.IsEqualToSI         > DeblocFilterPresent;
		DeblocFilterPresent              > ReadSlcGrpChgCycl.Asked;
		DisDeblocFilterIdc.IsNotEqualTo1 > ReadSlcGrpChgCycl.Asked;
		ReadSlcGrpChgCycl.Asked          > SendEndSliceHeader;
	end
end