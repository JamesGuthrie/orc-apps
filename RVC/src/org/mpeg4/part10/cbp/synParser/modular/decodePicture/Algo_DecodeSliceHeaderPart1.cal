/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
package org.mpeg4.part10.cbp.synParser.modular.decodePicture;

import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import std.util.BitOps.*;

actor Algo_DecodeSliceHeaderPart1()
	int (size=32) ValVLD,
	bool          IsAnIdrPic,
	uint(size=2)  NalRefIdc,
	bool          RstPrevFrameNum,
	int (size=32) PpsParameters,
	int (size=32) SpsParameters
		==>
	uint(size=31) FramNumCurrPic,
	int (size=6)  TypeOfVLD,
	int (size=32) VLDParam,
	uint(size=8)  GetPps,
	uint(size=4)  SliceType,
	bool          IsNewPic,
	uint(size=32) Poc,
	uint(size=32) Header2Param,
    int (size=16) Width,
    int (size=16) Height
		:
	bool DEBUG_FLAG_DECODED = true;

	//Parameters read
	List( type:int(size=32), size=2)   delta_pic_order_cnt          := [ 0 : for int i in 0 .. 1];
	//Sps Parameters
	List( type: int(size=32), size=32) offset_for_ref_frame_accumul := [ 0 : for int j in 0 .. 31 ];

	//Parameters read
	int (size=32) frame_num;
	bool          Idr_flag;
	uint(size=32) first_mb_in_slice;
	uint(size=4)  slice_type;
	bool          separate_colour_plane_flag    := false;
	bool          field_pic_flag;
	bool          bottom_field_flag;
	uint(size=16) idr_pic_id                    := 0;
	int (size=32) pic_order_cnt_lsb             := 0;
	int (size=32) delta_pic_order_cnt_bottom    := 0;
	uint(size=7)  redundant_pic_cnt             := 0;
	//Sps Parameters
	uint(size=6)  log2_max_frame_num;
	bool          frame_mbs_only_flag;
	uint(size=2)  pic_order_cnt_type;
	uint(size=6)  SzMaxPocLsb;
	bool          delta_pic_order_always_zero_flag;
	uint(size=8)  num_ref_frames_in_pic_order_cnt_cycle := 0;
	int (size=32) expected_delta_per_poc_cycle          := 0;
	int (size=32) offset_for_non_ref_pic                := 0;
	int (size=32) offset_for_top_to_bottom_field        := 0;
	bool          mb_adaptive_frame_field_flag          := false;
	//PpsParameters
	bool          pic_order_present_flag;
	bool          redundant_pic_cnt_present_flag;
	//Poc parameters
	int (size=32) prev_frame_num         := 0;
	int (size=32) frame_num_offset       := 0;
	int (size=32) PicOrderCntMsb         := 0;
	int (size=32) prevPicOrderCntLsb     := 0;
	uint(size=2)  nal_ref_idc            := 0;
	int (size=32) expectedpoc            := 0;
	//Slice Data Parameters
	bool          MbaffFrameFlag := false;
	int (size=32) LoopVal;
	bool IsNewPic;

	ResetPrevFrameNum.Launch: action RstPrevFrameNum :[ResetAsked] ==>
	guard
		IsNewPic
	do
		if(ResetAsked) then
			frame_num := 0;
		end
	end

	ResetPrevFrameNum.Skip: action ==>
	guard
		not IsNewPic
	end

	//                                          first_ , slice_ , pic_par
	ReadSliceType.Asked: action ==> TypeOfVLD :[VLD_UE , VLD_UE , VLD_UE]
	end

	ReadSliceType.Done: action ValVLD:[ValueOfVLD] repeat 3 ==>
		Header2Param    :[slice_type, first_mb_in_slice],
		GetPps          :[ValueOfVLD[2]],
		SliceType       :[slice_type],
		IsNewPic   :[IsNewPic]
	do
		first_mb_in_slice := ValueOfVLD[0];
		IsNewPic          := (first_mb_in_slice = 0);
		slice_type        :=
			if( ValueOfVLD[1] < 5) then
				ValueOfVLD[1]
			else
				ValueOfVLD[1] - 5
			end;
		if(DEBUG_FLAG_DECODED)then
			println("\n\t**************New Slice**************");
			println("\t\tfirst_mb_in_slice:"+first_mb_in_slice);
			println("\t\tslice_type:       "+ValueOfVLD[1]);
			println("\t\tpps_id:           "+ValueOfVLD[2]);
		end
		//pps_id            := ValueOfVLD[2]; ==> don't need
		//Ask sps_id
		//Ask and get separate_colour_plane_flag ==> not implemented in decodeSpsHeader yet !!
	end

	SeparateColourPlane.IsEqualToTrue: action
			==>
		//           colour_plane_id
		TypeOfVLD :[ READ_BITS ],
		VLDParam  :[     2     ]
	guard
		separate_colour_plane_flag = true
	end

	ReadFrameNum.Asked: action
		SpsParameters :[SpsParam] repeat 10
			==>
		//                frame_num
		TypeOfVLD :[   READ_BITS   ],
		VLDParam  :[ log2_max_frame_num ],
		Width          :[SpsParam[8]],
		Height         :[SpsParam[9]]
	do
		expected_delta_per_poc_cycle           := SpsParam[0];
		log2_max_frame_num                     := SpsParam[1];
		num_ref_frames_in_pic_order_cnt_cycle  := SpsParam[2];
		offset_for_top_to_bottom_field         := SpsParam[3];
		offset_for_non_ref_pic                 := SpsParam[4];
		SzMaxPocLsb                            := SpsParam[5];
		pic_order_cnt_type                     := SpsParam[6];
		mb_adaptive_frame_field_flag           := getFlag(SpsParam[7],0);
		delta_pic_order_always_zero_flag       := getFlag(SpsParam[7],1);
		frame_mbs_only_flag                    := getFlag(SpsParam[7],2);
	end

	ReadFrameNum.Done.IsNewPic: action
		ValVLD        :[ValueOfVLD],
		PpsParameters :[PpsParam] repeat 5,
		IsAnIdrPic    :[IdrPic],
		NalRefIdc     :[ValNalRefIdc]
			==>
		FramNumCurrPic                    :[ValueOfVLD]
	guard
		IsNewPic
	do
		pic_order_present_flag                 := getFlag(PpsParam[4],1);
		redundant_pic_cnt_present_flag         := getFlag(PpsParam[4],2);
		prev_frame_num                         := frame_num;
		Idr_flag                               := IdrPic;
		nal_ref_idc                            := ValNalRefIdc;
		frame_num                              := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tframe_num:        "+ValueOfVLD);
		end
		LoopVal := 0;
	end

	ReadFrameNum.Done.IsNewSlice: action
		ValVLD        :[ValueOfVLD],
		PpsParameters :[PpsParam] repeat 5,
		IsAnIdrPic    :[IdrPic],
		NalRefIdc     :[ValNalRefIdc]
			==>
	guard
		not IsNewPic
	do
		pic_order_present_flag                 := getFlag(PpsParam[4],1);
		redundant_pic_cnt_present_flag         := getFlag(PpsParam[4],2);
		Idr_flag                               := IdrPic;
		nal_ref_idc                            := ValNalRefIdc;
		prev_frame_num                         := frame_num;
		frame_num                              := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tframe_num:        "+ValueOfVLD);
		end
		LoopVal := 0;
	end

	GetOff4RefFrameAcc.Launch: action SpsParameters:[ValOffAccumul] ==>
	guard
		LoopVal <= num_ref_frames_in_pic_order_cnt_cycle
	do
		offset_for_ref_frame_accumul[LoopVal] := ValOffAccumul;
		LoopVal := LoopVal + 1;
	end

	GetOff4RefFrameAcc.Done: action ==>
	guard
		LoopVal > num_ref_frames_in_pic_order_cnt_cycle
	end

	//                                             field_pic_flag
	FrameMbsOnly.IsEqToFalse: action ==> TypeOfVLD :[ READ_BITS ], VLDParam :[1]
	guard
		frame_mbs_only_flag = false
	end

	ReadFieldPicFlag.Done: action ValVLD :[ValueOfVLD] ==>
	do
		field_pic_flag := 
			if(ValueOfVLD = 0) then
				false
			else
				true
			end;
		MbaffFrameFlag := (field_pic_flag and mb_adaptive_frame_field_flag);
		if(DEBUG_FLAG_DECODED)then
			println("\t\tfield_pic_flag:   "+field_pic_flag);
		end
	end

	FieldPicFlag.IsEqualToTrue: action
				==>
			//           bottom_field_flag
			TypeOfVLD :[ READ_BITS ],
			VLDParam  :[     1     ]
		guard
			field_pic_flag = true
		end

	ReadBottomField.Done: action ValVLD :[ValueOfVLD] ==>
	do
		bottom_field_flag :=
			if(ValueOfVLD = 0)then
				false
			else
				true
			end;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tbottom_field_flag: "+bottom_field_flag);
		end
	end


	IdrFlag.IsEqualToFalse: action ==> Header2Param :[header2Param]
	guard
		Idr_flag = false
	do
		uint(size=4) header2Param;

		if(frame_num < prev_frame_num) then
			frame_num_offset := frame_num_offset + (1 << log2_max_frame_num);
		end
		header2Param := setFlag(MbaffFrameFlag, 0, 0);
	end

	IdrFlag.IsEqualToTrue: action ==> Header2Param :[header2Param],
		TypeOfVLD :[VLD_UE] // idr_pic_id
	guard
		Idr_flag = true
	do
		uint(size=4) header2Param;

		frame_num_offset := 0;
		frame_num        := 0;
		prev_frame_num   := 0;
		PicOrderCntMsb     := 0;
		prevPicOrderCntLsb := 0;
		expectedpoc        := 0;
		header2Param := setFlag(MbaffFrameFlag, 0, 0);
	end

	ReadIdrPicId.Done: action ValVLD :[ValueOfVLD] ==>
	do
		idr_pic_id := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tidr_pic_id:       "+idr_pic_id);
		end
	end

	PocType.IsEqualTo0: action
			==>
		//           pic_order_cnt_lsb
		TypeOfVLD :[  READ_BITS  ],
		VLDParam  :[ SzMaxPocLsb ]
	guard
		pic_order_cnt_type = 0
	end

	ReadPocLsb.Done.IsNewPic: action ValVLD :[ValueOfVLD] ==> Poc :[POC_val]
	guard
		IsNewPic
	var
		int MaxPicOrderCntLsb,
		int POC_val
	do
		MaxPicOrderCntLsb := (1 << SzMaxPocLsb) / 2;
		if Idr_flag = true then
			PicOrderCntMsb := 0;
			prevPicOrderCntLsb := 0;
		else
			prevPicOrderCntLsb := pic_order_cnt_lsb;
		end
		pic_order_cnt_lsb := ValueOfVLD;
		if  (pic_order_cnt_lsb < prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) >= MaxPicOrderCntLsb) then
			PicOrderCntMsb     :=  PicOrderCntMsb + MaxPicOrderCntLsb;
			prevPicOrderCntLsb := 0;
		else 
			if (pic_order_cnt_lsb > prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) > MaxPicOrderCntLsb) then 
				PicOrderCntMsb := PicOrderCntMsb - MaxPicOrderCntLsb;
			end
		end
		POC_val := PicOrderCntMsb + pic_order_cnt_lsb;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tpic_order_cnt_lsb: "+ValueOfVLD);
		end
		if(DEBUG_FLAG_DECODED)then
			println("PocVal: "+POC_val);
		end
	end

	ReadPocLsb.Done.IsNewSlice: action ValVLD :[ValueOfVLD] ==>
	guard
		not IsNewPic
	end

	//                                 delta_pic_order_cnt_bottom
	//                                            or
	//                                  delta_pic_order_cnt[ 1 ]
	Check_PicOrPres_FieldPic: action ==> TypeOfVLD :[ VLD_SE ]
	guard
		pic_order_present_flag = true,
		field_pic_flag         = false
	end

	ReadDeltaPicOrderCntBottom.Done: action ValVLD :[ValueOfVLD] ==>
	do
		delta_pic_order_cnt_bottom := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tdelta_pic_order_cnt_bottom: "+delta_pic_order_cnt_bottom);
		end
	end

	PocType.IsEqualTo2.IsNewPic: action ==> Poc :[POC_val]
	guard
		IsNewPic
	var
		int POC_val
	do
		POC_val :=
			if(Idr_flag = true) then
				0
			else
				if(nal_ref_idc > 0) then
					(frame_num_offset + frame_num) * 2
				else
					((frame_num_offset + frame_num) * 2) - 1
				end
			end;
		if(DEBUG_FLAG_DECODED)then
			println("PocVal: "+POC_val);
		end
	end

	PocType.IsEqualTo2.IsNewSlice: action ==>
	guard
		not IsNewPic
	end

	PocType.IsEqualTo1: action ==>
	guard
		pic_order_cnt_type = 1
	var
		int abs_frame_num,
		int idx
	do
		abs_frame_num :=
			if(num_ref_frames_in_pic_order_cnt_cycle != 0) then
				frame_num_offset + frame_num
			else
				0
			end ;
		if( (nal_ref_idc = 0) and (abs_frame_num > 0) ) then
			abs_frame_num := abs_frame_num -1;
		end
		if(abs_frame_num > 0) then
			expectedpoc := expected_delta_per_poc_cycle * ((abs_frame_num - 1) / num_ref_frames_in_pic_order_cnt_cycle);
			idx         := (abs_frame_num - 1) mod num_ref_frames_in_pic_order_cnt_cycle;
			expectedpoc := expectedpoc + offset_for_ref_frame_accumul[idx];
		else
			expectedpoc :=0;
		end
		if(nal_ref_idc = 0) then
			expectedpoc := expectedpoc + offset_for_non_ref_pic;
		end
		delta_pic_order_cnt[0] := 0;
	end

	//                                      delta_pic_order_cnt[ 0 ]
	ReadDeltaPicOrCnt0.Asked: action ==> TypeOfVLD :[ VLD_SE ]
	guard
		pic_order_cnt_type               = 1,
		not delta_pic_order_always_zero_flag
	end

	ReadDeltaPicOrCnt0.Done: action ValVLD :[ValueOfVLD] ==>
	do
		delta_pic_order_cnt[0] := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tdelta_pic_order_cnt[0]: "+delta_pic_order_cnt[0]);
		end
	end

	ReadDeltaPicOrCnt1.Done: action ValVLD :[ValueOfVLD] ==>
	do
		delta_pic_order_cnt[1] := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tdelta_pic_order_cnt[1]: "+delta_pic_order_cnt[1]);
		end
	end

	CalcPOC4PocType1.IsNewPic: action ==> Poc :[expectedpoc + 
	                                             delta_pic_order_cnt[0]]
	guard
		IsNewPic
	do
		if(DEBUG_FLAG_DECODED)then
			println("PocVal: "+(expectedpoc+delta_pic_order_cnt[0]));
		end
	end

	CalcPOC4PocType1.IsNewSlice: action ==>
	guard
		not IsNewPic
	end

	//                                                redundant_pic_cnt
	RedundPicCntPres.IsEqualToTrue: action ==> TypeOfVLD :[ VLD_UE ]
	guard
		redundant_pic_cnt_present_flag = true
	end

	ReadRedunPicCnt.Done: action ValVLD :[ValueOfVLD] ==>
	do
		redundant_pic_cnt := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tredundant_pic_cnt: "+redundant_pic_cnt);
		end
	end

	SendEndSliceHeader: action ==> TypeOfVLD :[LAUNCH_ACTOR, SKIP_NAL],
		VLDParam:[SLICE_HEADER2]
	end

	schedule fsm ReadSliceTypeAsked:
		ReadResetPrevFrameNum          (ResetPrevFrameNum                 )--> ReadSliceTypeAsked;

		ReadSliceTypeAsked             (ReadSliceType.Asked               )--> ReadSliceTypeDone;

		ReadSliceTypeDone              (ReadSliceType.Done                )--> CheckSeparateColourPlane;

		CheckSeparateColourPlane       (SeparateColourPlane.IsEqualToTrue )--> undefined; //Not implemented yet
		CheckSeparateColourPlane       (ReadFrameNum.Asked                )--> ReadFrameNumDone;

		ReadFrameNumDone               (ReadFrameNum.Done                 )--> GetOff4RefFrameAcc;

		GetOff4RefFrameAcc             (GetOff4RefFrameAcc.Launch         )--> GetOff4RefFrameAcc;
		GetOff4RefFrameAcc             (GetOff4RefFrameAcc.Done           )--> CheckFrameMbsOnly;

		CheckFrameMbsOnly              (FrameMbsOnly.IsEqToFalse          )--> ReadFieldPicFlagDone;
		CheckFrameMbsOnly              (IdrFlag.IsEqualToFalse            )--> CheckPocType;
		CheckFrameMbsOnly              (IdrFlag.IsEqualToTrue             )--> ReadIdrPicIdDone;
	

		ReadFieldPicFlagDone           (ReadFieldPicFlag.Done             )-->CheckFieldPicFlag;

		CheckFieldPicFlag              (FieldPicFlag.IsEqualToTrue        )--> ReadBottomFieldDone;
		CheckFieldPicFlag              (IdrFlag.IsEqualToFalse            )--> CheckPocType;
		CheckFieldPicFlag              (IdrFlag.IsEqualToTrue             )--> ReadIdrPicIdDone;

		ReadBottomFieldDone            (ReadBottomField.Done              )--> CheckIdrFlag;

		CheckIdrFlag                   (IdrFlag.IsEqualToFalse            )--> CheckPocType;
		CheckIdrFlag                   (IdrFlag.IsEqualToTrue             )--> ReadIdrPicIdDone;

		ReadIdrPicIdDone               (ReadIdrPicId.Done                 )--> CheckPocType;

		CheckPocType                   (PocType.IsEqualTo0                )--> ReadPocLsbDone;
		CheckPocType                   (PocType.IsEqualTo1                )--> CheckDeltaPicOrderFlag;
		CheckPocType                   (PocType.IsEqualTo2                )--> CheckRedundPicCntPres;

		ReadPocLsbDone                 (ReadPocLsb.Done                   )--> Check4DeltPicOrdCntBot;

		Check4DeltPicOrdCntBot         (Check_PicOrPres_FieldPic          )--> ReadDeltaPicOrderCntBottomDone;
		Check4DeltPicOrdCntBot         (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		Check4DeltPicOrdCntBot         (SendEndSliceHeader                )--> ReadResetPrevFrameNum;

		ReadDeltaPicOrderCntBottomDone (ReadDeltaPicOrderCntBottom.Done   )--> CheckRedundPicCntPres;

		CheckDeltaPicOrderFlag         (ReadDeltaPicOrCnt0.Asked          )--> ReadDeltaPicOrCnt0Done;
		CheckDeltaPicOrderFlag         (CalcPOC4PocType1                  )--> CheckRedundPicCntPres;

		ReadDeltaPicOrCnt0Done         (ReadDeltaPicOrCnt0.Done           )--> Check4DeltaPicOrCnt1;

		Check4DeltaPicOrCnt1           (Check_PicOrPres_FieldPic          )--> ReadDeltaPicOrCnt1Done;
		Check4DeltaPicOrCnt1           (CalcPOC4PocType1                  )--> CheckRedundPicCntPres;

		ReadDeltaPicOrCnt1Done         (ReadDeltaPicOrCnt1.Done           )--> CalcPOC4PocType1;

		CalcPOC4PocType1               (CalcPOC4PocType1                  )--> CheckRedundPicCntPres;

		CheckRedundPicCntPres          (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		CheckRedundPicCntPres          (SendEndSliceHeader                )--> ReadResetPrevFrameNum;

		ReadRedunPicCntDone            (ReadRedunPicCnt.Done              )--> EndSliceHeader;

		EndSliceHeader                 (SendEndSliceHeader                )--> ReadResetPrevFrameNum;
	end
	priority
		SeparateColourPlane              > ReadFrameNum;
		FrameMbsOnly.IsEqToFalse         > IdrFlag.IsEqualToFalse;
		FieldPicFlag.IsEqualToTrue       > IdrFlag.IsEqualToFalse;
		IdrFlag.IsEqualToFalse           > IdrFlag.IsEqualToTrue;
		PocType.IsEqualTo0               > PocType.IsEqualTo1;
		PocType.IsEqualTo1               > PocType.IsEqualTo2;
		ReadDeltaPicOrCnt0.Asked         > CalcPOC4PocType1;
		Check_PicOrPres_FieldPic         > CalcPOC4PocType1;
		RedundPicCntPres.IsEqualToTrue   > SendEndSliceHeader;
	end
end
