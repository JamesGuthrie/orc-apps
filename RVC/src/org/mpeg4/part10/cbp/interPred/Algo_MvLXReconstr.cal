/********************************************************************************

This software module was originally developed by 
Damien de Saint Jorre (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
*****************************************************************************/
package org.mpeg4.part10.cbp.interPred;

import org.mpeg4.part10.cbp.MacroBlockInfo.*;
import std.util.Math.*;
import org.mpeg4.part10.Imp_PictureInfo.*;

//Clean me !!!
actor Algo_MvLXReconstr(bool IsPredL0)
	uint(size=6)  MbType,
	uint(size=4)  sub_mb_type,
	uint(size=2)  IsMbSliceOrPic,

	uint(size=7)  MbLocation,
	bool          NeighbourAvail,
	uint(size=13) CurrMbAddr,
	uint(size=7)  PicWidthInMb,

	uint(size=4)  MbPredRefIdx,
	uint(size=4)  SubMbPredRefIdx,

	int (size=16) MbPredMvRes,
	int (size=16) SubMbPredMvRes
		==>
	bool          NewMbPic,
	bool          NewMbPicSlice,
	int (size=16) MvOut,
	uint(size=11) Location,
	uint(size=4)  RefIdxOut
		:

	uint(size=2) NEW_PIC   = 0;
	uint(size=2) NEW_SLICE = 1;
	uint(size=2) NEW_MB    = 2;

	uint(size=2) tabIdxToX[16] =
		[ 0, 1, 0, 1, 2, 3, 2, 3, 0, 1,
		  0, 1, 2, 3, 2, 3];

	uint(size=2) tabIdxToY[16] =
		[ 0, 0, 1, 1, 0, 0, 1, 1, 2, 2,
		  3, 3, 2, 2, 3, 3];
	uint(size=4) locXYToTabIdx[4][4] =
	[
		[0,2,8,10],
		[1,3,9,11],
		[4,6,12,14],
		[5,7,13,15]
	];

	//Size of mvTab must be >= PicWidthInMb + 1 and must be equal to pow(2,n) for masking bits easily.
	int(size=16) mvTab[POW2_PICWIDTH_BLK_PLUS1][16][2];
	int(size=5)  refIdxTab[POW2_PICWIDTH_BLK_PLUS1][16];

	bool neighbourAAvail;
	bool neighbourBAvail;
	bool neighbourCAvail;
	bool neighbourDAvail;

	uint(size=3) mbPartIdxMax;
	uint(size=3) mbPartIdx;
	uint(size=3) sizeMbMv;
	uint(size=3) subMbPartIdxMax;
	uint(size=3) subMbPartIdx;
	uint(size=3) sizeSubMbMv;
	uint(size=6) mbType;
	uint(size=4) subMbType;
	uint(size=LOG2_POW2_PICWIDTH_BLK_PLUS1) idxCurrBlk;
	uint(size=1) idxSubTab;
	bool         isPred4SubMb;
	int (size=LOG2_POW2_PICWIDTH_BLK_PLUS1+1) idxMbAddrA;
	int (size=LOG2_POW2_PICWIDTH_BLK_PLUS1+1) idxMbAddrB;
	int (size=LOG2_POW2_PICWIDTH_BLK_PLUS1+1) idxMbAddrC;
	int (size=LOG2_POW2_PICWIDTH_BLK_PLUS1+1) idxMbAddrD;

	uint(size=11) mbXInPix;
	uint(size=11) mbYInPix;

		List(type: int (size=16),size=2) mvA;
		List(type: int (size=16),size=2) mvB;
		List(type: int (size=16),size=2) mvC;	
		List(type: int (size=16),size=2) oMv;
	procedure computeMvPredL0(int(size=5) RefIdxCurr, int(size=5) Ref_Idx_A, int(size=5) Ref_Idx_B, int(size=5) Ref_Idx_C)
		begin
			oMv :=
				if(Idx_B = -1 and Idx_C = -1)then
					[mvA[0],mvA[1]]
				else
					if(   RefIdxCurr  = Ref_Idx_A and RefIdxCurr != Ref_Idx_B and RefIdxCurr != Ref_Idx_C
					   or RefIdxCurr != Ref_Idx_A and RefIdxCurr  = Ref_Idx_B and RefIdxCurr != Ref_Idx_C
					   or RefIdxCurr != Ref_Idx_A and RefIdxCurr != Ref_Idx_B and RefIdxCurr  = Ref_Idx_C	)then
						if(RefIdxCurr = Ref_Idx_A)then
							[mvA[0],mvA[1]]
						else
							if(RefIdxCurr = Ref_Idx_B)then
								[mvB[0],mvB[1]]
							else
								[mvC[0],mvC[1]]
							end
						end
					else
						[ median(mvA[0],mvB[0],mvC[0]),
						  median(mvA[1],mvB[1],mvC[1]) ]
					end
				end;
		end

			int (size=5) refIdxA;
			int (size=5) refIdxB;
			int (size=5) refIdxC;
			int (size=5) Idx_A;
			int (size=5) Idx_B;
			int (size=5) Idx_C;

	procedure getNeighbourBlockParameters (int(size=5) IdxBlk, uint(size=5) SzBlkMv)
	var
			int (size=4) loc_x,
			int (size=4) loc_y
	begin
		loc_x   := tabIdxToX[IdxBlk&15];
		loc_y   := tabIdxToY[IdxBlk&15];
		SzBlkMv := SzBlkMv / 4;
		if(loc_x != 0 and loc_y != 0)then
			Idx_A   := locXYToTabIdx[(loc_x-1)&3][loc_y];
			Idx_B   := locXYToTabIdx[loc_x]      [(loc_y-1)&3];
			Idx_C   := locXYToTabIdx[(loc_x-1)&3][(loc_y-1)&3];
			refIdxA := refIdxTab[idxCurrBlk][Idx_A];
			refIdxB := refIdxTab[idxCurrBlk][Idx_B];
			refIdxC := refIdxTab[idxCurrBlk][Idx_C];
			mvA     := [mvTab[idxCurrBlk][Idx_A][0],mvTab[idxCurrBlk][Idx_A][1]];
			mvB     := [mvTab[idxCurrBlk][Idx_B][0],mvTab[idxCurrBlk][Idx_B][1]];
			mvC     := [mvTab[idxCurrBlk][Idx_C][0],mvTab[idxCurrBlk][Idx_C][1]];
		else
			if(loc_x = 0 and loc_y = 0)then
				if(idxMbAddrA = -1)then
					Idx_A   := -1;
					refIdxA := -1;
					mvA     := [0,0];
				else
					Idx_A   := 5;
					refIdxA := refIdxTab[idxMbAddrA][5];
					mvA     := [mvTab[idxMbAddrA][5][0],mvTab[idxMbAddrA][5][1]];
				end
				if(idxMbAddrB = -1)then
					Idx_B   := -1;
					refIdxB := -1;
					mvB     := [0,0];
				else
					Idx_B   := 10;
					refIdxB := refIdxTab[idxMbAddrB][10];
					mvB     := [mvTab[idxMbAddrB][10][0],mvTab[idxMbAddrB][10][1]];
				end
				if(idxMbAddrD = -1)then
					Idx_C   := -1;
					refIdxC := -1;
					mvC     := [0,0];
				else
					Idx_C   := 15;
					refIdxC := refIdxTab[idxMbAddrD][15];
					mvC     := [mvTab[idxMbAddrD][15][0],mvTab[idxMbAddrD][15][1]];
				end
			else
				if(loc_x != 0 and loc_y = 0)then
					Idx_A   := locXYToTabIdx[(loc_x-1)&3][0];
					refIdxA := refIdxTab[idxCurrBlk][Idx_A];
					mvA     := [mvTab[idxCurrBlk][Idx_A][0],mvTab[idxCurrBlk][Idx_A][1]];
					if(idxMbAddrB = -1)then
						Idx_B   := -1;
						refIdxB := -1;
						mvB     := [0,0];
						Idx_C   := -1;
						refIdxC := -1;
						mvC     := [0,0];
					else
						Idx_B   := locXYToTabIdx[loc_x][3];
						Idx_C   := locXYToTabIdx[(loc_x-1)&3][3];
						refIdxB := refIdxTab[idxMbAddrB][Idx_B];
						mvB     := [mvTab[idxMbAddrB][Idx_B][0],mvTab[idxMbAddrB][Idx_B][1]];
						refIdxC := refIdxTab[idxMbAddrB][Idx_C];
						mvC     := [mvTab[idxMbAddrB][Idx_C][0],mvTab[idxMbAddrB][Idx_C][1]];	
					end
				else//if(loc_x = 0 and loc_y != 0)
					Idx_B   := locXYToTabIdx[0][(loc_y-1)&3];
					refIdxB := refIdxTab[idxCurrBlk][Idx_B];
					mvB     := [mvTab[idxCurrBlk][Idx_B][0],mvTab[idxCurrBlk][Idx_B][1]];
					if(idxMbAddrA = -1)then
						Idx_A   := -1;
						refIdxA := -1;
						mvA     := [0,0];
						Idx_C   := -1;
						refIdxC := -1;
						mvC     := [0,0];
					else
						Idx_A   := locXYToTabIdx[3][loc_y];
						Idx_C   := locXYToTabIdx[3][(loc_y-1)&3];
						refIdxA := refIdxTab[idxMbAddrA][Idx_A];
						mvA     := [mvTab[idxMbAddrA][Idx_A][0],mvTab[idxMbAddrA][Idx_A][1]];
						refIdxC := refIdxTab[idxMbAddrA][Idx_C];
						mvC     := [mvTab[idxMbAddrA][Idx_C][0],mvTab[idxMbAddrA][Idx_C][1]];
					end
				end
			end
		end
		loc_x := loc_x + SzBlkMv;
		loc_y := loc_y - 1;
		if(loc_y < 0)then
			if(loc_x <= 3)then
				if(idxMbAddrB != -1)then
					Idx_C   := locXYToTabIdx[loc_x][3];
					refIdxC := refIdxTab[idxMbAddrB][Idx_C];
					mvC     := [mvTab[idxMbAddrB][Idx_C][0],mvTab[idxMbAddrB][Idx_C][1]];	
				end
			else
				if(idxMbAddrC != -1)then
					Idx_C   := locXYToTabIdx[loc_x&3][3];
					refIdxC := refIdxTab[idxMbAddrC][Idx_C];
					mvC     := [mvTab[idxMbAddrC][Idx_C][0],mvTab[idxMbAddrC][Idx_C][1]];
				end
			end
		else
			if(loc_x <= 3)then
				//if the macroblock have already been decoded
				if(locXYToTabIdx[loc_x][loc_y&3] < IdxBlk)then
					//We update the values
					Idx_C   := locXYToTabIdx[loc_x][loc_y&3];
					refIdxC := refIdxTab[idxCurrBlk][Idx_C];
					mvC     := [mvTab[idxCurrBlk][Idx_C][0],mvTab[idxCurrBlk][Idx_C][1]];
				end
			end
		end
	end

	getNewPic: action IsMbSliceOrPic:[newPic] ==> NewMbPic:[false],
		NewMbPicSlice:[false]
	guard
		newPic = NEW_PIC
	end

	getNewSlice: action IsMbSliceOrPic:[newSlice] ==> NewMbPicSlice:[false]
	guard
		newSlice = NEW_SLICE
	end

	GetMbType: action CurrMbAddr:[Curr_Mb_Addr], MbLocation:[MbLocxInPic,
		MbLocyInPic], MbType:[macroBlkType], IsMbSliceOrPic:[newMb],
		NeighbourAvail:[neighbourA_Avail, neighbourB_Avail, neighbourC_Avail,
		neighbourD_Avail], PicWidthInMb:[picWidthInMb] ==>
	guard
		newMb = NEW_MB
	do
		mbType := macroBlkType;
		
		idxCurrBlk := Curr_Mb_Addr & MASK_POW2_PICWIDTH_BLK_PLUS1;
		if(not Mb_IsIntra(mbType)) then
			idxMbAddrA :=
				if(neighbourA_Avail) then
					(Curr_Mb_Addr - 1) & MASK_POW2_PICWIDTH_BLK_PLUS1
				else
					-1
				end;
			idxMbAddrB :=
				if(neighbourB_Avail) then
					(Curr_Mb_Addr - picWidthInMb) & MASK_POW2_PICWIDTH_BLK_PLUS1
				else
					-1
				end;
			idxMbAddrC :=
				if(neighbourC_Avail)then
					(Curr_Mb_Addr - picWidthInMb + 1) & MASK_POW2_PICWIDTH_BLK_PLUS1
				else
					-1
				end;
			idxMbAddrD :=
				if(neighbourD_Avail)then
					(Curr_Mb_Addr - picWidthInMb - 1) & MASK_POW2_PICWIDTH_BLK_PLUS1
				else
					-1
				end;
			neighbourAAvail := neighbourA_Avail;
			neighbourBAvail := neighbourB_Avail;
			neighbourCAvail := neighbourC_Avail;
			neighbourDAvail := neighbourD_Avail;
			mbXInPix  := MbLocxInPic*16;
			mbYInPix  := MbLocyInPic*16;
			mbPartIdx     := 0;
			mbPartIdxMax  := numMbPart(mbType);
			sizeMbMv      := sizeMbPart(mbType);
		end
	end

	checkMbType.isIorSI: action	==>
	guard
		Mb_IsIntra(mbType)
	do
		refIdxTab[idxCurrBlk] := [-1: for int i in 0 .. 15];
		mvTab[idxCurrBlk]     := [[0,0]: for int i in 0 .. 15];	
	end

	checkMbType.isPSkipL0: action ==> RefIdxOut :[0], NewMbPic:[true],
		NewMbPicSlice:[true], MvOut :[mvpL0] repeat 2, Location:[mbXInPix,mbYInPix]
	guard
		mbType = BLOCK_TYPE_P_SKIP,
		IsPredL0
	do
		int(size=5)  refIdxA;
		int(size=5)  refIdxB;
		int(size=5)  refIdxC;
		int(size=16) mvpL0[2];

		refIdxTab[idxCurrBlk] := [0: for int i in 0 .. 15];
		//if mbAddrA or mbAddrB is not available
		if(not neighbourAAvail or not neighbourBAvail
		      //if refIdxL0A is equal to 0 and both components of mvL0A are
		      //equal to 0
		   or refIdxTab[idxMbAddrA][5] = 0 and mvTab[idxMbAddrA][5][0] = 0
		      and mvTab[idxMbAddrA][5][1] = 0
			  //if refIdxL0B is equal to 0 and both components of mvL0B are
			  //equal to 0	
		   or refIdxTab[idxMbAddrB][10] = 0 and mvTab[idxMbAddrB][10][0] = 0
		      and mvTab[idxMbAddrB][10][1] = 0
		) then
			mvpL0 := [0,0];
		else
			if(neighbourCAvail)then
				Idx_C       := 10;
				mvC         := [mvTab [idxMbAddrC][10][0],mvTab [idxMbAddrC][10][1]];
				refIdxC     := refIdxTab[idxMbAddrC][10];
			else
				if(neighbourDAvail)then
					Idx_C       := 15;
					mvC         := [mvTab [idxMbAddrD][15][0],mvTab [idxMbAddrD][15][1]];
					refIdxC     := refIdxTab[idxMbAddrD][15];
				else
					Idx_C   := -1;
					mvC     := [0,0];
					refIdxC := -1;
				end
			end
			Idx_A   := 5;	
			refIdxA := refIdxTab[idxMbAddrA][5];
			mvA     := [mvTab[idxMbAddrA][5][0] , mvTab [idxMbAddrA][5][1]];
			Idx_B   := 10;
			refIdxB := refIdxTab[idxMbAddrB][10];
			mvB     := [mvTab[idxMbAddrB][10][0],mvTab[idxMbAddrB][10][1]];
			computeMvPredL0(0,refIdxA,refIdxB,refIdxC);
			mvpL0   := [oMv[0],oMv[1]];
		end
		foreach int i in 0 .. 15
		do
			mvTab[idxCurrBlk][i][0] := mvpL0[0];
			mvTab[idxCurrBlk][i][1] := mvpL0[1];
		end
	end

	checkMbType.isPSkipL1: action ==>
	guard
		mbType = BLOCK_TYPE_P_SKIP,
		not IsPredL0
	do
		refIdxTab[idxCurrBlk] := [-1: for int i in 0 .. 15];
		mvTab[idxCurrBlk]     := [[0,0]: for int i in 0 .. 15];	
	end

	checkMbType.isOthers: action ==>
	guard
		mbType != BLOCK_TYPE_B_SKIP,
		mbType != BLOCK_TYPE_B_DIRECT_16x16
	do
		idxSubTab   :=
			if(mbIsBiPred(mbType)) then
				0
			else
				1
			end;
		mvTab[idxCurrBlk]     := [[0,0]: for int i in 0 .. 15];
		refIdxTab[idxCurrBlk] := [-1: for int i in 0 .. 15];
	end

	ComputeMvLX.Launch16x16: action
			MbPredRefIdx :[RefIdxCurr],
			MbPredMvRes      :[mv_res] repeat 2
				==>
			Location  :[mbXInPix,mbYInPix],
			MvOut     :[mvpL0] repeat 2,
			RefIdxOut :[RefIdxCurr],
			NewMbPic:[true],
			NewMbPicSlice:[true]
		guard
			mbPartIdx < mbPartIdxMax,
			   Mb_Is_PredL0(mbType, mbPartIdx) and IsPredL0
			or Mb_Is_PredL1(mbType, mbPartIdx) and not IsPredL0,
			sizeMbMv = SZ_16x16
		var
			List(type: int(size=16), size=2) mvpL0
		do
			foreach int i in 0 .. 15
			do
				refIdxTab[idxCurrBlk][i] := RefIdxCurr;
			end

			getNeighbourBlockParameters (0,16);
			computeMvPredL0(RefIdxCurr,refIdxA,refIdxB,refIdxC);

			mvpL0[0]:= oMv[0]+mv_res[0];
			mvpL0[1]:= oMv[1]+mv_res[1];

			foreach int i in 0 .. 15
			do
				mvTab[idxCurrBlk][i] := [mvpL0[0],mvpL0[1]];
			end

			mbPartIdx := mbPartIdx + 1;
		end

	ComputeMvLX.Launch16x8: action
			MbPredRefIdx :[RefIdxCurr],
			MbPredMvRes  :[mv_res] repeat 2
				==>
			Location      :[Blk_x_in_pix,Blk_y_in_pix],
			MvOut         :[mvpL0] repeat 2,
			RefIdxOut     :[RefIdxCurr],
			NewMbPic      :[true],
			NewMbPicSlice :[true]
		guard
			mbPartIdx < mbPartIdxMax,
			   Mb_Is_PredL0(mbType, mbPartIdx) and IsPredL0
			or Mb_Is_PredL1(mbType, mbPartIdx) and not IsPredL0,
			sizeMbMv = SZ_16x8
		var
			List(type: int(size=16), size=2) mvpL0,
			uint(size=11) Blk_x_in_pix = mbXInPix,
			uint(size=11) Blk_y_in_pix := mbYInPix
		do
			foreach int i in 0 .. 7
			do
				refIdxTab[idxCurrBlk][i + 8 * (mbPartIdx&1)] := RefIdxCurr;
			end

			getNeighbourBlockParameters (8*(mbPartIdx&1),16);
			if(mbPartIdx = 0)then
				if(RefIdxCurr = refIdxB)then
					mvpL0 := [mvB[0],mvB[1]];
				else
					computeMvPredL0(RefIdxCurr,refIdxA,refIdxB,refIdxC);
					mvpL0 := [oMv[0],oMv[1]];	
				end
			else
				Blk_y_in_pix := Blk_y_in_pix + 8;
				if(RefIdxCurr = refIdxA)then
					mvpL0 := [mvA[0],mvA[1]];
				else
					computeMvPredL0(RefIdxCurr,refIdxA,refIdxB,refIdxC);
					mvpL0 := [oMv[0],oMv[1]];
				end
			end

			mvpL0[0] := mvpL0[0] + mv_res[0];
			mvpL0[1] := mvpL0[1] + mv_res[1];

			foreach int i in 0 .. 7
			do
				mvTab[idxCurrBlk][i+(8*(mbPartIdx & 1))] := [mvpL0[0],mvpL0[1]];
			end

			mbPartIdx := mbPartIdx + 1;
		end

	ComputeMvLX.Launch8x16: action
			MbPredRefIdx :[RefIdxCurr],
			MbPredMvRes      :[mv_res] repeat 2
				==>
			Location :[Blk_x_in_pix,Blk_y_in_pix],
			MvOut :[mvpL0] repeat 2,
			RefIdxOut :[RefIdxCurr],
			NewMbPic      :[true],
			NewMbPicSlice :[true]
		guard
			mbPartIdx < mbPartIdxMax,
			   Mb_Is_PredL0(mbType, mbPartIdx) and IsPredL0
			or Mb_Is_PredL1(mbType, mbPartIdx) and not IsPredL0,
			sizeMbMv = SZ_8x16
		var
			List(type: int(size=16), size=2) mvpL0,
			uint(size=11) Blk_x_in_pix := mbXInPix,
			uint(size=11) Blk_y_in_pix = mbYInPix
		do
			foreach int i in 0 .. 3
			do
				refIdxTab[idxCurrBlk][i + 4 * (mbPartIdx&1)] := RefIdxCurr;
			end
			foreach int i in 8 .. 11
			do
				refIdxTab[idxCurrBlk][i + 4 * (mbPartIdx&1)] := RefIdxCurr;
			end

			getNeighbourBlockParameters (4*(mbPartIdx&1),8);
			if(mbPartIdx = 0)then
				if(RefIdxCurr = refIdxA)then
					mvpL0 := [mvA[0],mvA[1]];
				else
					computeMvPredL0(RefIdxCurr,refIdxA,refIdxB,refIdxC);
					mvpL0 := [oMv[0],oMv[1]];
				end
			else
				Blk_x_in_pix := Blk_x_in_pix + 8;
				if(RefIdxCurr = refIdxC)then
					mvpL0 := [mvC[0],mvC[1]];
				else
					computeMvPredL0(RefIdxCurr,refIdxA,refIdxB,refIdxC);
					mvpL0 := [oMv[0],oMv[1]];
				end
			end

			mvpL0[0] := mvpL0[0] + mv_res[0];
			mvpL0[1] := mvpL0[1] + mv_res[1];

			foreach int i in 0 .. 3
			do
				mvTab[idxCurrBlk][    i+(4*(mbPartIdx & 1))] := [mvpL0[0],mvpL0[1]];
				mvTab[idxCurrBlk][8 + i+(4*(mbPartIdx & 1))] := [mvpL0[0],mvpL0[1]];
			end

			mbPartIdx := mbPartIdx + 1;
		end

	ComputeMvLX.Launch8x8: action
			sub_mb_type :[ValSubMbType]
				==>
		guard
			mbPartIdx < mbPartIdxMax,
			sizeMbMv = SZ_8x8
		do
			subMbPartIdx    := 0;
			subMbPartIdxMax := numSubMbPart(mbType,ValSubMbType);
			isPred4SubMb    :=    ((SubMbPartPredMode[idxSubTab][ValSubMbType & 15] & PRED_L0) != 0) and IsPredL0
			                   or ((SubMbPartPredMode[idxSubTab][ValSubMbType & 15] & PRED_L1) != 0) and not IsPredL0;
			sizeSubMbMv     := SizeSubMbPart(mbType,ValSubMbType);
			subMbType       := ValSubMbType;
		end

	ComputeMvLX.Skip: action
				==>
		guard
			mbPartIdx < mbPartIdxMax,
			not (    Mb_Is_PredL0(mbType, mbPartIdx) and IsPredL0
			      or Mb_Is_PredL1(mbType, mbPartIdx) and not IsPredL0),
			sizeMbMv != SZ_8x8
		do
			mbPartIdx := mbPartIdx + 1;
		end

	ComputeMvLX.Done: action ==>
		guard
			mbPartIdx = mbPartIdxMax
		end

	ComputeSubMvLX.Launch8x8: action
			SubMbPredRefIdx :[RefIdxCurr],
			SubMbPredMvRes  :[mv_res] repeat 2
				==>
			Location  :[Blk_x_in_pix,Blk_y_in_pix],
			MvOut     :[mvpL0]repeat 2,
			RefIdxOut :[RefIdxCurr],
			NewMbPic      :[true],
			NewMbPicSlice :[true]
		guard
			subMbPartIdx < subMbPartIdxMax,
			isPred4SubMb,
			sizeSubMbMv = SZ_8x8,
			SubMbPartPredMode[idxSubTab][subMbType & 15] != DIRECT
		var
			List(type: int(size=16), size=2) mvpL0,
			uint(size=11) Blk_x_in_pix := mbXInPix,
			uint(size=11) Blk_y_in_pix := mbYInPix
		do
			Blk_x_in_pix := Blk_x_in_pix + 8 * (mbPartIdx&1);
			Blk_y_in_pix := Blk_y_in_pix + 8 * ((mbPartIdx>>1)&1);

			foreach int i in 0 .. 3
			do
				refIdxTab[idxCurrBlk][4 * (mbPartIdx&3) + i] := RefIdxCurr;
			end

			getNeighbourBlockParameters (4*(mbPartIdx&3),8);
			computeMvPredL0(RefIdxCurr,refIdxA,refIdxB,refIdxC);

			mvpL0[0] := oMv[0]+mv_res[0];
			mvpL0[1] := oMv[1]+mv_res[1];

			foreach int i in 0 .. 3
			do
				mvTab[idxCurrBlk][i + 4*(mbPartIdx&3)] := [mvpL0[0],mvpL0[1]];
			end

			subMbPartIdx := subMbPartIdx + 1;
		end

	ComputeSubMvLX.Launch8x4: action
			SubMbPredRefIdx :[RefIdxCurr],
			SubMbPredMvRes  :[mv_res] repeat 2
				==>
			Location  :[Blk_x_in_pix,Blk_y_in_pix],
			MvOut     :[mvpL0] repeat 2,
			RefIdxOut :[RefIdxCurr],
			NewMbPic      :[true],
			NewMbPicSlice :[true]
		guard
			subMbPartIdx < subMbPartIdxMax,
			isPred4SubMb,
			sizeSubMbMv = SZ_8x4
		var
			List(type: int(size=16), size=2) mvpL0,
			uint(size=11) Blk_x_in_pix := mbXInPix,
			uint(size=11) Blk_y_in_pix := mbYInPix
		do
			Blk_x_in_pix := Blk_x_in_pix + 8 * (mbPartIdx&1);
			Blk_y_in_pix := Blk_y_in_pix + 8 * ((mbPartIdx>>1)&1) + 4 * (subMbPartIdx&1);

			refIdxTab[idxCurrBlk][4 * (mbPartIdx&3) + 2 * (subMbPartIdx&1)]     := RefIdxCurr;
			refIdxTab[idxCurrBlk][4 * (mbPartIdx&3) + 2 * (subMbPartIdx&1) + 1] := RefIdxCurr;

			getNeighbourBlockParameters (4*(mbPartIdx&3) + 2*(subMbPartIdx&1),8);
			computeMvPredL0(RefIdxCurr,refIdxA,refIdxB,refIdxC);

			mvpL0[0] := oMv[0]+mv_res[0];
			mvpL0[1] := oMv[1]+mv_res[1];

			mvTab[idxCurrBlk][4*(mbPartIdx&3) + 2*(subMbPartIdx&1)]     := [mvpL0[0],mvpL0[1]];
			mvTab[idxCurrBlk][4*(mbPartIdx&3) + 2*(subMbPartIdx&1) + 1] := [mvpL0[0],mvpL0[1]];

			subMbPartIdx := subMbPartIdx + 1;
		end

	ComputeSubMvLX.Launch4x8: action
			SubMbPredRefIdx :[RefIdxCurr],
			SubMbPredMvRes  :[mv_res] repeat 2
				==>
			Location  :[Blk_x_in_pix,Blk_y_in_pix],
			MvOut     :[mvpL0]repeat 2,
			RefIdxOut :[RefIdxCurr],
			NewMbPic      :[true],
			NewMbPicSlice :[true]
		guard
			subMbPartIdx < subMbPartIdxMax,
			isPred4SubMb,
			sizeSubMbMv = SZ_4x8
		var
			List(type: int(size=16), size=2) mvpL0,
			uint(size=11) Blk_x_in_pix := mbXInPix,
			uint(size=11) Blk_y_in_pix := mbYInPix
		do
			Blk_x_in_pix := Blk_x_in_pix + 8 * (mbPartIdx&1) + 4 * (subMbPartIdx&1);
			Blk_y_in_pix := Blk_y_in_pix + 8 * ((mbPartIdx>>1)&1);

			refIdxTab[idxCurrBlk][4 * (mbPartIdx&3) + (subMbPartIdx&1)]     := RefIdxCurr;
			refIdxTab[idxCurrBlk][4 * (mbPartIdx&3) + (subMbPartIdx&1) + 2] := RefIdxCurr;
	
			getNeighbourBlockParameters (4*(mbPartIdx&3) + 1*(subMbPartIdx&1),4);
			computeMvPredL0(RefIdxCurr,refIdxA,refIdxB,refIdxC);

			mvpL0[0] := oMv[0]+mv_res[0];
			mvpL0[1] := oMv[1]+mv_res[1];

			mvTab[idxCurrBlk][4*(mbPartIdx&3) + (subMbPartIdx&1)]     := [mvpL0[0],mvpL0[1]];
			mvTab[idxCurrBlk][4*(mbPartIdx&3) + (subMbPartIdx&1) + 2] := [mvpL0[0],mvpL0[1]];

			subMbPartIdx := subMbPartIdx + 1;
		end

	ComputeSubMvLX.Launch4x4: action
			SubMbPredRefIdx :[RefIdxCurr],
			SubMbPredMvRes  :[mv_res] repeat 2
				==>
			Location  :[Blk_x_in_pix,Blk_y_in_pix],
			MvOut     :[mvpL0]repeat 2,
			RefIdxOut :[RefIdxCurr],
			NewMbPic      :[true],
			NewMbPicSlice :[true]
		guard
			subMbPartIdx < subMbPartIdxMax,
			isPred4SubMb,
			sizeSubMbMv = SZ_4x4
		var
			List(type: int(size=16), size=2) mvpL0,
			uint(size=11) Blk_x_in_pix := mbXInPix,
			uint(size=11) Blk_y_in_pix := mbYInPix
		do
			Blk_x_in_pix := Blk_x_in_pix + 8 * (mbPartIdx&1) + 4 * (subMbPartIdx&1);
			Blk_y_in_pix := Blk_y_in_pix + 8 * ((mbPartIdx>>1)&1) + 4 * ((subMbPartIdx>>1)&1);

			refIdxTab[idxCurrBlk][4 * (mbPartIdx&3) + (subMbPartIdx&3)]     := RefIdxCurr;

			getNeighbourBlockParameters (4*(mbPartIdx&3) + 1*(subMbPartIdx&3),4);
			computeMvPredL0(RefIdxCurr,refIdxA,refIdxB,refIdxC);

			mvpL0[0]:= oMv[0]+mv_res[0];
			mvpL0[1]:= oMv[1]+mv_res[1];

			mvTab[idxCurrBlk][4*(mbPartIdx&3) + (subMbPartIdx&3)]     := [mvpL0[0],mvpL0[1]];

			subMbPartIdx := subMbPartIdx + 1;
		end

	ComputeSubMvLX.Skip: action ==>
	guard
		subMbPartIdx < subMbPartIdxMax,
		not isPred4SubMb,
		SubMbPartPredMode[idxSubTab][subMbType & 15] != DIRECT
	do
		subMbPartIdx := subMbPartIdx + 1;
	end

	ComputeSubMvLX.Done: action ==>
	guard
		subMbPartIdx = subMbPartIdxMax
	do
		mbPartIdx := mbPartIdx + 1;
	end

	schedule fsm GetMbType:
		GetMbType (getNewPic   )--> GetMbType;
		GetMbType (getNewSlice )--> GetMbType;
		GetMbType (GetMbType   )--> CheckMbType;

		CheckMbType (checkMbType.isIorSI   )--> GetMbType;
		CheckMbType (checkMbType.isPSkipL0 )--> GetMbType;
		CheckMbType (checkMbType.isPSkipL1 )--> GetMbType;
		CheckMbType (checkMbType.isOthers  )--> ComputeMvpL0;

		ComputeMvpL0 (ComputeMvLX.Skip        )--> ComputeMvpL0;
		ComputeMvpL0 (ComputeMvLX.Launch16x16 )--> ComputeMvpL0;
		ComputeMvpL0 (ComputeMvLX.Launch16x8  )--> ComputeMvpL0;
		ComputeMvpL0 (ComputeMvLX.Launch8x16  )--> ComputeMvpL0;
		ComputeMvpL0 (ComputeMvLX.Launch8x8   )--> ComputeSubMvpL0;
		ComputeMvpL0 (ComputeMvLX.Done        )--> GetMbType;

		ComputeSubMvpL0 (ComputeSubMvLX.Launch8x8 )--> ComputeSubMvpL0;
		ComputeSubMvpL0 (ComputeSubMvLX.Launch8x4 )--> ComputeSubMvpL0;
		ComputeSubMvpL0 (ComputeSubMvLX.Launch4x8 )--> ComputeSubMvpL0;
		ComputeSubMvpL0 (ComputeSubMvLX.Launch4x4 )--> ComputeSubMvpL0;
		ComputeSubMvpL0 (ComputeSubMvLX.Skip      )--> ComputeSubMvpL0;
		ComputeSubMvpL0 (ComputeSubMvLX.Done      )--> ComputeMvpL0;
	end

	priority
		checkMbType.isIorSI   > checkMbType.isOthers;
		checkMbType.isPSkipL0 > checkMbType.isOthers;
		checkMbType.isPSkipL1 > checkMbType.isOthers;
		GetMbType             > getNewPic;
	end
end