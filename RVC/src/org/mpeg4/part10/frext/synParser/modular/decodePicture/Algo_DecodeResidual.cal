/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
package org.mpeg4.part10.frext.synParser.modular.decodePicture;

import org.mpeg4.part10.cbp.MacroBlockInfo.*;
import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import std.util.BitOps.*;

//Clean me !!
actor Algo_DecodeResidual()
	bool          CodedBlockFlag,
	uint(size=6)  Parameters,
	uint(size=5)  TotalCoeffCavlc
		==>
	int (size=6)  TypeOfVLD,
	int (size=32) ActorLaunched,
	int (size=8)  ResBlkParamCavlc,
	int (size=8)  ResBlkParamCabac,
	int (size=32) Feedback,
	bool          Skip_Block
		:

	bool         CAVLC_ENTROPY = false;
//	bool         CABAC_ENTROPY = true;
	uint(size=2) LUMA_COMPONENT      = 0;
	uint(size=2) CHROMA_DC_COMPONENT = 1;
	uint(size=2) CHROMA_AC_COMPONENT = 2;
	uint(size=1) iCb = 0;
	uint(size=1) iCr = 1;

	uint(size=2) RESIDUAL_LUMA_LUMA_OUTPUT = 0;
//	uint(size=2) RESIDUAL_LUMA_CHROMA1_OUTPUT := 0;
//	uint(size=2) RESIDUAL_LUMA_CHROMA2_OUTPUT := 0;

	bool          bmFlag;
	int (size=5)  startIdx;
	uint(size=4)  endIdx;
	uint(size=4)  StartIdxSent;
	uint(size=4)  EndIdxSent;
	uint(size=2)  chroma_array_type;
	uint(size=2)  NumC8x8;
	bool          entropyCodingMode;
	uint(size=6)  mb_type;
	bool          transform_size_8x8_flag;
	uint(size=6)  CodedBlockPatternLuma;
	uint(size=6)  CodedBlockPatternChroma;
	uint(size=4)  ActorSelected;
	List(type: uint(size=5), size = 24 ) TotalCoeffTabLuma;
	List(type: List(type: uint(size=5), size = 24 ), size=2) TotalCoeffTabChroma;
	List(type: bool        , size = 24 ) MbExists := [true : for int s in 0 .. 23];
	List(type: uint(size=5), size = 16 ) IdxLeftNeighbour  = [16, 0,17, 2, 1, 4, 3, 6,18, 8,19,10, 9,12,11,14];
	List(type: uint(size=5), size = 16 ) IdxAboveNeighbour = [20,21, 0, 1,22,23, 4, 5, 2, 3, 8, 9, 6, 7,12,13];
	uint(size=5)  IdxCurrMb := 0;
	uint(size=3)  i8x8Loop;
	uint(size=3)  iCbCrLoop;
	uint(size=2)  Component_type := 0;
	uint(size=5)  maxNumCoeff;
	uint(size=2)  ResidualLumaOutput := 0;
	uint(size=4)  ctxBlkCat;
	uint(size=16) cbfLuma;
	uint(size=16) cbfChroma;

	GetParameters: action Parameters :[param] repeat 32 ==>
	do
		bool LeftMbExists;
		bool AboveMbExists;

		entropyCodingMode := getFlag(param[0],0);
		transform_size_8x8_flag  := getFlag(param[0],1);
		bmFlag                   := getFlag(param[0],2);
		LeftMbExists             := getFlag(param[0],3);
		AboveMbExists            := getFlag(param[0],4);
		mb_type                  := param[1];
		startIdx                 := param[2];
		endIdx                   := param[3];
		CodedBlockPatternLuma    := param[4];
		CodedBlockPatternChroma  := param[5];
		chroma_array_type        := param[6];
		NumC8x8                  := param[7];
		ActorSelected :=
			if(entropyCodingMode = CAVLC_ENTROPY)then
				RESIDUAL_BLOCK_CAVLC
			else
				RESIDUAL_BLOCK_CABAC
			end;
		TotalCoeffTabLuma   :=  [0: for int i in 0 .. 23];
		TotalCoeffTabChroma := [[0: for int i in 0 .. 23]: for int j in 0 .. 1];
		foreach int i in 0 .. 3
		do
			TotalCoeffTabLuma  [16+i]      := param[8 + i];
			TotalCoeffTabChroma[iCb][16+i] := param[8 + 4 + i];
			TotalCoeffTabChroma[iCr][16+i] := param[8 + 8 + i];
			MbExists           [16+i]      := LeftMbExists;

			TotalCoeffTabLuma  [20+i]      := param[20 + i];
			TotalCoeffTabChroma[iCb][20+i] := param[20 + 4 + i];
			TotalCoeffTabChroma[iCr][20+i] := param[20 + 8 + i];
			MbExists           [20+i]      := AboveMbExists;
		end
		ResidualLumaOutput := RESIDUAL_LUMA_LUMA_OUTPUT;
		i8x8Loop   := 1;
		IdxCurrMb  := 0;
		cbfLuma    := 0;
		cbfChroma  := 0;
	end

	ResLumaOutput.IsLuma: action ==> Feedback:[TotalCoeffTabLuma] repeat 16
	guard
		ResidualLumaOutput = RESIDUAL_LUMA_LUMA_OUTPUT
	do
		i8x8Loop := 0;
	end

	ResLuma_Launch16x16DCResBlock: action
			==>
		TypeOfVLD     :[LAUNCH_ACTOR],
		ActorLaunched :[ActorSelected]
	guard
		bmFlag   = false and startIdx = 0 and Is_Intra_16x16(mb_type),
		not entropyCodingMode
	do
		Component_type := LUMA_COMPONENT;
		maxNumCoeff    := 16;
		StartIdxSent   :=  0;
		EndIdxSent     := 15;
		ctxBlkCat      :=  0;
	end

	ResLuma_CheckTransfSzAndCavlc: action ==>
	guard
		not transform_size_8x8_flag or not entropyCodingMode
	do
		IdxCurrMb      := 0;
		ctxBlkCat :=
			if(Is_Intra_16x16(mb_type)) then
				1
			else
				2
			end;
	end

	

	ResLuma_CheckCodedBlockPattern: action ==>
	guard
		(CodedBlockPatternLuma & 1) = 1
	end

	ResLuma_LaunchResBlk_1: action
			==>
		TypeOfVLD     :[ LAUNCH_ACTOR  , LAUNCH_ACTOR  , LAUNCH_ACTOR  , LAUNCH_ACTOR  ],
		ActorLaunched :[ ActorSelected , ActorSelected , ActorSelected , ActorSelected ]
	do
		Component_type := LUMA_COMPONENT;
		if(not bmFlag and endIdx > 0 and Is_Intra_16x16(mb_type)) then
			maxNumCoeff    := 15;
			StartIdxSent   :=
				if(0 > startIdx - 1) then
					0
				else
					startIdx - 1
				end;
			EndIdxSent     :=  endIdx - 1;
		else
			maxNumCoeff    := 16;
			StartIdxSent   := startIdx;
			EndIdxSent     := endIdx;
		end
	end

	resLumaLaunchResCabac: action ==> TypeOfVLD:[LAUNCH_ACTOR],
		ActorLaunched:[ActorSelected]
	do
		Component_type := LUMA_COMPONENT;
		maxNumCoeff    := 64;
		StartIdxSent   := 4*startIdx;
		EndIdxSent     := 4*endIdx + 3;
		//ctxBlkCat :=
	end

	ResetLevelTab: action ==> Skip_Block :[true , true , true , true]
	do
		TotalCoeffTabLuma[IdxCurrMb    ]   := 0;
		TotalCoeffTabLuma[IdxCurrMb + 1]   := 0;
		TotalCoeffTabLuma[IdxCurrMb + 2]   := 0;
		TotalCoeffTabLuma[IdxCurrMb + 3]   := 0;
		if(Component_type = LUMA_COMPONENT) then
			cbfLuma := setFlag(false, IdxCurrMb - 1, cbfLuma);
			cbfLuma := setFlag(false, IdxCurrMb    , cbfLuma);
			cbfLuma := setFlag(false, IdxCurrMb + 1, cbfLuma);
			cbfLuma := setFlag(false, IdxCurrMb + 2, cbfLuma);
		end
		IdxCurrMb := IdxCurrMb + 4;
	end

	EndLoop8x8.IsEqualToFalse: action ==>
	guard
		i8x8Loop < 4
	do
		i8x8Loop := i8x8Loop + 1;
		CodedBlockPatternLuma := (CodedBlockPatternLuma >> 1);
	end

	ResLuma_CheckCavlc8x8: action ==>
	guard
		entropyCodingMode = CAVLC_ENTROPY,
		transform_size_8x8_flag  = true
	end

	/*Not implemented yet: CABAC
	else
		for(i8x8=0;i8x8<4;i8x8++)
		{
			if(CodeBlockPatternLuma & (1<<i8x8)) // ==> action CheckCodedBlockPattern
				residual_block(...);
			else
				for(i=0;i<64;i++)
					level8x8[i8x8][i]=0;
		}
*/
	SendResBlockParameters.cavlc: action ==> ResBlkParamCavlc:[nC, maxNumCoeff,
		StartIdxSent, EndIdxSent], Skip_Block:[false]
	guard
		not entropyCodingMode
	do
		int(size=8) nC =
			if(Component_type = LUMA_COMPONENT)then
				if(MbExists[IdxLeftNeighbour[IdxCurrMb]] and 
					MbExists[IdxAboveNeighbour[IdxCurrMb]])then
						(TotalCoeffTabLuma[IdxLeftNeighbour[IdxCurrMb]] +
						TotalCoeffTabLuma[IdxAboveNeighbour[IdxCurrMb]] + 1)
						>> 1
				else
					TotalCoeffTabLuma[IdxLeftNeighbour[IdxCurrMb]] +
					TotalCoeffTabLuma[IdxAboveNeighbour[IdxCurrMb]]
				end
			else if(Component_type = CHROMA_DC_COMPONENT) then
				if(chroma_array_type = 1) then
					-1
				else
					-2
				end
			else
				if(MbExists[IdxLeftNeighbour[IdxCurrMb]] and
					MbExists[IdxAboveNeighbour[IdxCurrMb]])then
						(TotalCoeffTabChroma[iCbCrLoop - 1]
							[IdxLeftNeighbour[IdxCurrMb]] +
						TotalCoeffTabChroma[iCbCrLoop - 1]
							[IdxAboveNeighbour[IdxCurrMb]] + 1) >> 1
				else
					TotalCoeffTabChroma[iCbCrLoop - 1]
						[IdxLeftNeighbour[IdxCurrMb]] +
					TotalCoeffTabChroma[iCbCrLoop - 1]
						[IdxAboveNeighbour[IdxCurrMb]]
				end
			end end;
		IdxCurrMb := IdxCurrMb + 1;
	end

	SendResBlockParameters.cabac: action ==> ResBlkParamCabac:[ctxBlkCat,
		maxNumCoeff, StartIdxSent, EndIdxSent, IdxCurrMb - 1,
		CodedBlockPatternLuma, CodedBlockPatternChroma], Skip_Block:[false]
	guard
		entropyCodingMode
	do
		if(Component_type != CHROMA_DC_COMPONENT or IdxCurrMb = 0) then
			IdxCurrMb := IdxCurrMb + 1;
		end
	end

	GetFeedback.cavlc: action TotalCoeffCavlc:[valTotalCoeff] ==>
	guard
		not entropyCodingMode
	do
		if(Component_type = LUMA_COMPONENT) then
			TotalCoeffTabLuma[IdxCurrMb - 1]   := valTotalCoeff;
		else if(Component_type = CHROMA_AC_COMPONENT)then
			TotalCoeffTabChroma[iCbCrLoop - 1][IdxCurrMb - 1] := valTotalCoeff;
		end end
	end

	GetFeedback.cabac: action CodedBlockFlag:[codedBlock] ==>
	guard
		entropyCodingMode
	do
		if(Component_type = LUMA_COMPONENT) then
			cbfLuma := setFlag(codedBlock, IdxCurrMb - 1, cbfLuma);
		else if(Component_type = CHROMA_AC_COMPONENT) then
			cbfChroma := setFlag(codedBlock, IdxCurrMb - 1, cbfChroma);
		end end
	end

	ChromaArrayTypeVal.IsEqualTo1or2: action ==>
	guard
		chroma_array_type = 1 or chroma_array_type= 2
	do
		iCbCrLoop := 0;
		i8x8Loop  := 0;
	end

	ChromaDCResBlk: action
			==>
		TypeOfVLD     :[ LAUNCH_ACTOR  , LAUNCH_ACTOR  ],
		ActorLaunched :[ ActorSelected , ActorSelected ]
	guard
		(CodedBlockPatternChroma & 3) != 0,
		startIdx = 0
	do
		Component_type := CHROMA_DC_COMPONENT;
		StartIdxSent   := 0;
		EndIdxSent     := 4 * NumC8x8 - 1;
		maxNumCoeff    := 4 * NumC8x8;
		ctxBlkCat      := 3;
		IdxCurrMb      := 0;
	end

	ChromaAcComponentPresent: action ==>
	guard
		(CodedBlockPatternChroma & 2) != 0,
		endIdx > 0
	do
		Component_type := CHROMA_AC_COMPONENT;
		StartIdxSent :=
			if(0 > startIdx - 1) then
				0
			else
				startIdx - 1
			end;
		EndIdxSent   := endIdx - 1;
		maxNumCoeff  := 15;
		ctxBlkCat    := 4;
	end

	ChromaLoopiCbCr: action ==>
	guard
		iCbCrLoop < 2
	do
		iCbCrLoop := iCbCrLoop + 1;
		i8x8Loop  := 0;
		IdxCurrMb := 0;
	end

	SendChromaCoeffToken: action ==> Feedback:[TotCoefChrm] repeat 16
	var
		List(type:uint(size=5), size=16) TotCoefChrm
	do
		if(NumC8x8 = 1)then
			foreach int i in 0 .. 3
			do
				TotCoefChrm[i]    := TotalCoeffTabChroma[iCbCrLoop - 1][i];
				TotCoefChrm[4+i]  := TotalCoeffTabChroma[iCbCrLoop - 1][i];
				TotCoefChrm[8+i]  := TotalCoeffTabChroma[iCbCrLoop - 1][i];
				TotCoefChrm[12+i] := TotalCoeffTabChroma[iCbCrLoop - 1][i];
			end
		else
			println("NumC8x8 != 1 :"+NumC8x8+" not implemented yet in a lot of actor !");
			while true do end
		end
	end

	ChromaAcLoopi8x8: action
			==>
		TypeOfVLD     :[ LAUNCH_ACTOR  , LAUNCH_ACTOR  , LAUNCH_ACTOR  , LAUNCH_ACTOR  ],
		ActorLaunched :[ ActorSelected , ActorSelected , ActorSelected , ActorSelected ]
	guard
		i8x8Loop < NumC8x8
	do
		i8x8Loop := i8x8Loop + 1;
	end

	ChromaAcLoopi4x4: action
			==>
		TypeOfVLD     :[ LAUNCH_ACTOR  , LAUNCH_ACTOR  , LAUNCH_ACTOR  , LAUNCH_ACTOR  ],
		ActorLaunched :[ ActorSelected , ActorSelected , ActorSelected , ActorSelected ]
	end

	SendSkipChromaDc: action ==> Skip_Block :[ true , true ]
	end

	ChromaAcComponentNotPresent: action
			==>
		Feedback :[[   0: for int i in 0 .. 31]] repeat 32,
		Skip_Block       :[[true: for int i in 0 ..  7]] repeat  8
	guard
		i8x8Loop < NumC8x8
	do
		i8x8Loop := i8x8Loop + 1;
	end

	ChromaArrayTypeVal.IsEqualTo3: action ==>
	guard
		chroma_array_type = 3
	do
		println("ChromaArrayTypeVal.IsEqualTo3 not implemented yet !");
	end


	SendEndResidual: action ==> TypeOfVLD :[SKIP_NAL],
		Feedback:[cbfLuma, cbfChroma]
	end

	//remove me !!
	bool actorNotFinished := true;
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("DecodeResidual doesn't manage this case yet");
		actorNotFinished := false;
	end

	schedule fsm GetParameters:
		GetParameters (GetParameters )--> ResLumaCheckIntra16x16;

				/* residual_luma()*/
				ResLumaCheckIntra16x16       (ResLuma_Launch16x16DCResBlock         )--> ResLumaSendResBlkPar1;
				ResLumaCheckIntra16x16       (ResLuma_CheckTransfSzAndCavlc         )--> CheckCodeBlockBmFlag;
				ResLumaCheckIntra16x16       (ResLuma_CheckCodedBlockPattern        )--> ResLumaLaunchCabac;
	
				ResLumaSendResBlkPar1        (SendResBlockParameters                )--> ResLumaGetTotalCoeff1;
				ResLumaGetTotalCoeff1        (GetFeedback                           )--> ResLumaCheckTrnsSzAndEntropy;

				ResLumaCheckTrnsSzAndEntropy (ResLuma_CheckTransfSzAndCavlc         )--> CheckCodeBlockBmFlag;
				ResLumaCheckTrnsSzAndEntropy (ResLuma_CheckCodedBlockPattern        )--> ResLumaLaunchCabac;

				CheckCodeBlockBmFlag         (ResLuma_CheckCodedBlockPattern        )--> CheckBmFlagEndIx;
				CheckCodeBlockBmFlag         (ResetLevelTab                         )--> CheckEndLoop8x8;
	
				CheckBmFlagEndIx             (ResLuma_LaunchResBlk_1                )--> ResLumaSendResBlkPar2_0;

				ResLumaLaunchCabac (resLumaLaunchResCabac )--> ResLumaSendResBlkPar2_3;

				ResLumaSendResBlkPar2_0      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_0;
				ResLumaGetTotalCoeff2_0      (GetFeedback                         )--> ResLumaSendResBlkPar2_1;
				ResLumaSendResBlkPar2_1      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_1;
				ResLumaGetTotalCoeff2_1      (GetFeedback                         )--> ResLumaSendResBlkPar2_2;
				ResLumaSendResBlkPar2_2      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_2;
				ResLumaGetTotalCoeff2_2      (GetFeedback                         )--> ResLumaSendResBlkPar2_3;
				ResLumaSendResBlkPar2_3      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_3;
				ResLumaGetTotalCoeff2_3      (GetFeedback                         )--> CheckEndLoop8x8;

				CheckEndLoop8x8              (EndLoop8x8.IsEqualToFalse             )--> CheckCodeBlockBmFlag;
				CheckEndLoop8x8              (ResLuma_CheckCavlc8x8                 )--> ResidualLumaFinished;


			CheckEndLoop8x8 (ResLumaOutput.IsLuma      )--> CheckChromaArrayType;
			CheckEndLoop8x8 (undefined )--> undefined;

			ResidualLumaFinished (ResLumaOutput.IsLuma )--> CheckChromaArrayType;
			ResidualLumaFinished (undefined )-->undefined;


		CheckChromaArrayType        (ChromaArrayTypeVal.IsEqualTo1or2 )--> CheckChromaDc;
		CheckChromaArrayType        (ChromaArrayTypeVal.IsEqualTo3    )--> undefined;
		CheckChromaArrayType        (SendEndResidual                  )--> GetParameters;


		CheckChromaDc               (ChromaDCResBlk                   )--> ChromaDCSendResBlockParam_1;
		CheckChromaDc               (SendSkipChromaDc                 )--> CheckChromaAC;

		ChromaDCSendResBlockParam_1 (SendResBlockParameters           )--> ChromaDCGetTotalCoeff_1;
		ChromaDCGetTotalCoeff_1     (GetFeedback                      )--> ChromaDCSendResBlockParam_2;
		ChromaDCSendResBlockParam_2 (SendResBlockParameters           )--> ChromaDCGetTotalCoeff_2;
		ChromaDCGetTotalCoeff_2     (GetFeedback                      )--> CheckChromaAC;


		CheckChromaAC               (ChromaAcComponentPresent         )--> CheckLoopiCbCr;
		CheckChromaAC               (ChromaAcComponentNotPresent      )--> SendEndResidual;

		CheckLoopiCbCr              (ChromaLoopiCbCr                  )--> CheckLoopi8x8;
		CheckLoopiCbCr              (SendEndResidual                  )--> GetParameters;

		CheckLoopi8x8               (ChromaAcLoopi8x8                 )--> ChromaAcSendResBlockPar_1;
		CheckLoopi8x8               (SendChromaCoeffToken             )--> CheckLoopiCbCr;
	
		ChromaAcSendResBlockPar_1   (SendResBlockParameters           )--> ChromaAcGetTotalCoeff_1;
		ChromaAcGetTotalCoeff_1     (GetFeedback                    )--> ChromaAcSendResBlockPar_2;
		ChromaAcSendResBlockPar_2   (SendResBlockParameters           )--> ChromaAcGetTotalCoeff_2;
		ChromaAcGetTotalCoeff_2     (GetFeedback                    )--> ChromaAcSendResBlockPar_3;
		ChromaAcSendResBlockPar_3   (SendResBlockParameters           )--> ChromaAcGetTotalCoeff_3;
		ChromaAcGetTotalCoeff_3     (GetFeedback                    )--> ChromaAcSendResBlockPar_4;
		ChromaAcSendResBlockPar_4   (SendResBlockParameters           )--> ChromaAcGetTotalCoeff_4;
		ChromaAcGetTotalCoeff_4     (GetFeedback                    )--> CheckLoopi8x8;

		ChromaAcComponentNotPresent (ChromaAcComponentNotPresent      )--> ChromaAcComponentNotPresent;
		ChromaAcComponentNotPresent (SendEndResidual                  )--> GetParameters;

		SendEndResidual             (SendEndResidual )--> GetParameters;

		undefined (undefined )--> undefined;
	end
	priority
		ResLuma_Launch16x16DCResBlock         > ResLuma_CheckTransfSzAndCavlc;
		ResLuma_CheckTransfSzAndCavlc         > ResLuma_CheckCodedBlockPattern;
		ResLuma_CheckCodedBlockPattern        > ResetLevelTab;
		EndLoop8x8.IsEqualToFalse             > ResLuma_CheckCavlc8x8           > ResLumaOutput.IsLuma;
		ResLumaOutput.IsLuma                  > undefined;
		ChromaArrayTypeVal.IsEqualTo1or2      > ChromaArrayTypeVal.IsEqualTo3   > SendEndResidual;
		ChromaDCResBlk                        > SendSkipChromaDc;
		ChromaAcComponentPresent              > ChromaAcComponentNotPresent;
		ChromaAcLoopi8x8                      > SendChromaCoeffToken;
		ChromaLoopiCbCr                       > SendEndResidual;
		ChromaAcComponentNotPresent           > SendEndResidual;
	end
end