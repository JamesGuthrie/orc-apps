/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package org.mpeg4.part10.frext.synParser.modular.decodePicture;

import org.sc29.wg11.mpeg4.part10.MacroBlockInfo.*;
import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import std.util.BitOps.*;
import org.sc29.wg11.mpeg4.part10.Imp_PictureInfo.*;

actor Algo_DecodeMbPred()
	int (size=32) ValVLD,

	uint(size=6)  Parameters
		==>
	uint(size=5)  TypeOfVLD,
	int (size=32) NbBitsToRead,

	uint(size=4)  RemIntraYxYPredMode,

	uint(size=4)  RefIdxL0,
	uint(size=4)  RefIdxL1,

	uint(size=4)  IntraPredModeC, 
	int(size=16)  MvResl0, 
	int(size=16)  MvResl1
		:

	bool DEBUG_MV           = false;
	bool DEBUG_FLAG_DECODED = false;

	List (type:uint(size=4),size=16) rem_intraYxY_pred_mode := [ 0 : for int i in 0 .. 15];

	uint(size=5)  lumaYxYBlkIdx := 0;
	uint(size=5)  mbPartIdx     := 0;
	uint(size=5)  mbPartIdxMax  := 0;
	//MbLayer Parameters
	uint(size=6)  mb_type;
	uint(size=2)  chroma_Array_Type;
	uint(size=5)  num_ref_idx_l0_active;
	uint(size=5)  num_ref_idx_l1_active;
	bool          mb_field_decoding_flag;

	uint(size=32) picWidthInMbs;
	uint(size=32) currMbAddr;
	bool          entropyCodingMode;
	uint(size=4)  intraPredModeChTab[POW2_PICWIDTH_BLK_PLUS1];

	readParameters: action
			Parameters :[ MbType            , ChromaArrayType , 
			              NumRefIdxL0Active , NumRefIdxL1Active ,
			              Flags, picWidthInMbsVal, currMbAddrVal]
				==>
		do
			mb_type                 := MbType;
			chroma_Array_Type       := ChromaArrayType;
			num_ref_idx_l0_active   := NumRefIdxL0Active;
			num_ref_idx_l1_active   := NumRefIdxL1Active;
			entropyCodingMode       := getFlag(Flags,2);
			mb_field_decoding_flag  := getFlag(Flags,0);
			lumaYxYBlkIdx           := 0;
			picWidthInMbs           := picWidthInMbsVal;
			currMbAddr              := currMbAddrVal;
		end

	mbType.IsIntra_YxY: action ==>
	guard
		Mb_IsIntra(mb_type) and mb_type != BLOCK_TYPE_I_PCM
	end


/*for( luma4x4BlkIdx=0; luma4x4BlkIdx<16; luma4x4BlkIdx++ ) {
   prev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ]
   if( !prev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ] )
       rem_intra4x4_pred_mode[ luma4x4BlkIdx ]
}*/

	mbType.IsIntra_4x4.cabac: action ==>
		TypeOfVLD:[CABAC_PREV_INTRA4x4_8x8_PRED_MODE_FLAG]
	guard
		lumaYxYBlkIdx < 16 and mb_type = BLOCK_TYPE_I_4x4 and entropyCodingMode
	end


	mbType.IsIntra_4x4.cavlc: action ==> TypeOfVLD:[READ_BITS],
		NbBitsToRead:[1]
	guard
		lumaYxYBlkIdx < 16 and mb_type = BLOCK_TYPE_I_4x4 and not entropyCodingMode
	end

	readPrevAndRem.finished_I4x4: action ==>
		RemIntraYxYPredMode:[rem_intraYxY_pred_mode] repeat 16
	guard
		lumaYxYBlkIdx = 16 and mb_type = BLOCK_TYPE_I_4x4
	end
	readPrevAndRem.finished_I8x8: action ==>
		RemIntraYxYPredMode:[rem_intraYxY_pred_mode] repeat 4
	guard
		lumaYxYBlkIdx = 4 and mb_type = BLOCK_TYPE_I_8x8
	end

	readRemIntraYxY.asked.cabac: action ValVLD:[prevIntraYxY] ==>
		TypeOfVLD:[CABAC_REM_INTRA4x4_8x8_PRED_MODE]
	guard
		prevIntraYxY = 0 and entropyCodingMode
	do
		if(DEBUG_FLAG_DECODED)then
			println("prev_intraYxY_pred_mode_flag["+lumaYxYBlkIdx+"] : 0");
		end
	end

	readRemIntraYxY.asked.cavlc: action ValVLD:[prevIntraYxY] ==>
		TypeOfVLD:[READ_BITS], NbBitsToRead:[3]
	guard
		prevIntraYxY = 0 and not entropyCodingMode
	do
		if(DEBUG_FLAG_DECODED)then
			println("prev_intraYxY_pred_mode_flag["+lumaYxYBlkIdx+"] : 0");
		end
	end

	readRemIntraYxY.skip: action ValVLD:[prevIntraYxY] ==>
	guard
		prevIntraYxY = 1
	do
		if(DEBUG_FLAG_DECODED)then
			println("prev_intraYxY_pred_mode_flag["+lumaYxYBlkIdx+"] : 1");
		end
		rem_intraYxY_pred_mode[lumaYxYBlkIdx] := 15;
		lumaYxYBlkIdx := lumaYxYBlkIdx + 1;
	end

	getRemIntraYxY: action ValVLD:[remIntraYxY] ==> 
	do
		if(DEBUG_FLAG_DECODED)then
			println("rem_intraYxY_pred_mode : " + remIntraYxY);
		end
		rem_intraYxY_pred_mode[lumaYxYBlkIdx] := remIntraYxY;
		lumaYxYBlkIdx := lumaYxYBlkIdx + 1;
	end

	mbType.IsIntra_8x8: action ==>
			//  prev_intra8x8_pred_mode_flag
			TypeOfVLD    :[ READ_BITS ],
			NbBitsToRead :[ 1 ]
		guard
			lumaYxYBlkIdx < 4 and mb_type = BLOCK_TYPE_I_8x8
		end
	//                                           intra_chroma_pred_mode
	chromaArrayTp.IsEqualTo1or2.cavlc: action ==> TypeOfVLD:[VLD_UE]
	guard
	   chroma_Array_Type = 1 or chroma_Array_Type = 2,
	   not entropyCodingMode
	end

	//          intra_chroma_pred_mode
	chromaArrayTp.IsEqualTo1or2.cabac: action ==>
		TypeOfVLD:[CABAC_INTRA_CHROMA_PRED_MODE],
		NbBitsToRead:[chromaArray] repeat 2
	guard
		chroma_Array_Type = 1 or chroma_Array_Type = 2,
		entropyCodingMode
	do
		uint(size=4) chromaArray[2];

		chromaArray[0] := intraPredModeChTab[(currMbAddr - 1) &
			MASK_POW2_PICWIDTH_BLK_PLUS1];
		chromaArray[1] := intraPredModeChTab[(currMbAddr - picWidthInMbs) &
			 MASK_POW2_PICWIDTH_BLK_PLUS1];
	end

	readIntraChroma: action ValVLD:[ValueOfVLD] ==>
		IntraPredModeC :[ValueOfVLD]
	do
		intraPredModeChTab[currMbAddr & MASK_POW2_PICWIDTH_BLK_PLUS1] :=
			ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("intra_chroma_pred_mode : "+ValueOfVLD);
		end
	end

	mb_Type.IsNotEqualToDirect: action
				==>
		guard
			   mbIsPred(mb_type)
			or mbIsBiPred(mb_type) and mb_type != BLOCK_TYPE_B_DIRECT_16x16
		do
			mbPartIdxMax:= numMbPart(mb_type);
			mbPartIdx    := 0;
		end

/*for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
   if( ( num_ref_idx_l0_active_minus1 > 0 | |
          mb_field_decoding_flag ) &&
       MbPartPredMode( mb_type, mbPartIdx ) != Pred_L1 )
       ref_idx_l0[ mbPartIdx ]
*/

	//                                 ref_idx_l0
	readRefIdxl0: action ==> TypeOfVLD:[typeOfVld], NbBitsToRead :[param]
	guard
		mbPartIdx < mbPartIdxMax,
		(num_ref_idx_l0_active > 1) or (mb_field_decoding_flag = true),
		Mb_Is_PredL0(mb_type,mbPartIdx)
	do
		uint(size=6) typeOfVld =
			if(not entropyCodingMode) then
				VLD_TE
			else
				CABAC_REF_IDX_LX
			end;
		int(size=32) param =
			if(not entropyCodingMode) then
				num_ref_idx_l0_active - 1
			else
			//  isL0  + mbPartIdx
				 0x08 + mbPartIdx
			end;
		mbPartIdx := mbPartIdx + 1;
	end

/*for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
   if( ( num_ref_idx_l1_active_minus1 > 0 | |
          mb_field_decoding_flag ) &&
       MbPartPredMode( mb_type, mbPartIdx ) != Pred_L0 )
       ref_idx_l1[ mbPartIdx ]
*/
	/*Not used with I and P Blocks*/
	//                                 ref_idx_l1
	readRefIdxl1: action ==> TypeOfVLD:[typeOfVld], NbBitsToRead:[param]
	guard
		mbPartIdx < mbPartIdxMax,
		(num_ref_idx_l1_active > 1) or (mb_field_decoding_flag = true),
		Mb_Is_PredL1(mb_type,mbPartIdx)
	do
		uint(size=6) typeOfVld =
			if(not entropyCodingMode) then
				VLD_TE
			else
				CABAC_REF_IDX_LX
			end;
		int(size=32) param =
			if(not entropyCodingMode) then
				 num_ref_idx_l1_active - 1
			else
				mbPartIdx
			end;
		mbPartIdx := mbPartIdx + 1;
	end

	readParam.Skip1Parameter: action
				==>
			//            We read nothing
			TypeOfVLD    :[ READ_BITS ],
			NbBitsToRead :[     0     ]
		guard
			mbPartIdx < mbPartIdxMax
		do
			mbPartIdx := mbPartIdx + 1;
		end

/*for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
   if( MbPartPredMode ( mb_type, mbPartIdx ) != Pred_L1 )
       for( compIdx = 0; compIdx < 2; compIdx++ )
          mvd_l0[ mbPartIdx ][ 0 ][ compIdx ]
*/
	//                   mvd_l0
	readMvdL0.Asked.cavlc: action ==> TypeOfVLD:[VLD_SE, VLD_SE]
	guard
		mbPartIdx < mbPartIdxMax and Mb_Is_PredL0(mb_type,mbPartIdx),
		not entropyCodingMode
	do
		mbPartIdx := mbPartIdx + 1;
	end

	readMvdL0.Asked.cabac: action ==> TypeOfVLD:[CABAC_MVD_LX_0,
		CABAC_MVD_LX_1], NbBitsToRead:[partsIdx, partsIdx]
	guard
		mbPartIdx < mbPartIdxMax and Mb_Is_PredL0(mb_type,mbPartIdx),
		entropyCodingMode
	do
		uint(size=6) partsIdx = setFlag(true, 6, mbPartIdx << 3);
		mbPartIdx := mbPartIdx + 1;
	end

	readMvdL0.Skip: action ==>
	guard
		mbPartIdx < mbPartIdxMax and not Mb_Is_PredL0(mb_type,mbPartIdx)
	do
		mbPartIdx := mbPartIdx + 1;
	end

/*for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
   if( MbPartPredMode( mb_type, mbPartIdx ) != Pred_L0 )
       for( compIdx = 0; compIdx < 2; compIdx++ )
          mvd_l1[ mbPartIdx ][ 0 ][ compIdx ]
*/
	/*Not used with I and P Blocks*/
	//             mvd_l1
	readMvdL1.Asked.cavlc: action ==> TypeOfVLD:[VLD_SE, VLD_SE]
	guard
		mbPartIdx < mbPartIdxMax and Mb_Is_PredL1(mb_type,mbPartIdx),
		not entropyCodingMode
	do
		mbPartIdx := mbPartIdx + 1;
	end

	readMvdL1.Asked.cabac: action ==> TypeOfVLD:[CABAC_MVD_LX_0,
		CABAC_MVD_LX_1], NbBitsToRead:[partsIdx, partsIdx]
	guard
		mbPartIdx < mbPartIdxMax and Mb_Is_PredL1(mb_type,mbPartIdx),
		entropyCodingMode
	do
		uint(size=6) partsIdx = mbPartIdx << 3;
		mbPartIdx := mbPartIdx + 1;
	end

	readMvdL1.Skip: action ==>
	guard
		mbPartIdx < mbPartIdxMax and not Mb_Is_PredL1(mb_type,mbPartIdx)
	do
		mbPartIdx := mbPartIdx + 1;
	end

	sendOrReadDone: action ==>
	guard
		mbPartIdx = mbPartIdxMax
	do
		mbPartIdx    := 0;
	end

	readRefIdxL0.Done: action
			ValVLD   :[val_ref_idx]
				==>
			RefIdxL0     :[val_ref_idx]
		guard
			mbPartIdx < mbPartIdxMax,
			Mb_Is_PredL0(mb_type,mbPartIdx)
		do
			if(DEBUG_MV)then
				println("ReadRefIdxL0["+mbPartIdx+"] : "+val_ref_idx);
			end
			mbPartIdx := mbPartIdx + 1;
		end
//Delete me!!
	readRefIdxL0.DoneSkip: action
			ValVLD   :[val_ref_idx]
				==>
		guard
			mbPartIdx < mbPartIdxMax,
			not Mb_Is_PredL0(mb_type,mbPartIdx)
		do
			if(DEBUG_MV)then
				println("ReadRefIdxL0["+mbPartIdx+"] : "+val_ref_idx);
			end
			mbPartIdx := mbPartIdx + 1;
		end

	readRefIdxL1.Done: action
			ValVLD :[val_ref_idx]
				==>
			RefIdxL1 :[val_ref_idx]
		guard
			mbPartIdx < mbPartIdxMax,
			Mb_Is_PredL1(mb_type,mbPartIdx)
		do
			if(DEBUG_MV)then
				println("ReadRefIdxL1["+mbPartIdx+"] : "+val_ref_idx);
			end
			mbPartIdx := mbPartIdx + 1;
		end
//Delete me!!
	readRefIdxL1.DoneSkip: action
			ValVLD   :[val_ref_idx]
				==>
		guard
			mbPartIdx < mbPartIdxMax,
			not Mb_Is_PredL1(mb_type,mbPartIdx)
		do
			if(DEBUG_MV)then
				println("ReadRefIdxL1["+mbPartIdx+"] : "+val_ref_idx);
			end
			mbPartIdx := mbPartIdx + 1;
		end

	readMvdL0.Done: action
			ValVLD   :[ValueOfVLD] repeat 2
				==>
			MvResl0  :[ValueOfVLD] repeat 2
		guard
			mbPartIdx < mbPartIdxMax,
			Mb_Is_PredL0(mb_type,mbPartIdx)
		do
			if(DEBUG_MV)then
				println("ReadMvdL0["+mbPartIdx+"] : "+ValueOfVLD[0]+" ; "+ValueOfVLD[1]);
			end
			mbPartIdx := mbPartIdx + 1;
		end

	readMvdL1.Done: action
			ValVLD :[ValueOfVLD] repeat 2
				==>
			MvResl1 :[ValueOfVLD] repeat 2
		guard
			mbPartIdx < mbPartIdxMax,
			Mb_Is_PredL1(mb_type,mbPartIdx)
		do
			if(DEBUG_MV)then
				println("ReadMvdL1["+mbPartIdx+"] : "+ValueOfVLD[0]+" ; "+ValueOfVLD[1]);
			end
			mbPartIdx := mbPartIdx + 1;
		end


	sendEndMbPred: action
				==>
			TypeOfVLD   :[ SKIP_NAL ]
		end

	schedule fsm ReadParameters:
		ReadParameters        ( readParameters               ) --> CheckMbType;

		CheckMbType           ( mbType.IsIntra_YxY           ) --> CheckMbTypeYxY;
		CheckMbType           ( mb_Type.IsNotEqualToDirect   ) --> ReadRefIdxl0Asked;
		CheckMbType           ( sendEndMbPred                ) --> ReadParameters;
		// prev_rem_loop
		CheckMbTypeYxY        ( mbType.IsIntra_4x4           ) --> ReadRemIntraYxY;
		CheckMbTypeYxY        ( mbType.IsIntra_8x8           ) --> ReadRemIntraYxY;
		CheckMbTypeYxY        ( chromaArrayTp.IsEqualTo1or2  ) --> ReadIntraChroma;
		CheckMbTypeYxY        ( sendEndMbPred                ) --> ReadParameters;
		ReadRemIntraYxY       ( readRemIntraYxY.asked        ) --> GetRemIntraYxY;
		ReadRemIntraYxY       ( readRemIntraYxY.skip         ) --> CheckEndOfReadPrevYxY;
		GetRemIntraYxY        ( getRemIntraYxY               ) --> CheckEndOfReadPrevYxY;
		CheckEndOfReadPrevYxY ( mbType.IsIntra_4x4           ) --> ReadRemIntraYxY;
		CheckEndOfReadPrevYxY ( mbType.IsIntra_8x8           ) --> ReadRemIntraYxY;
		CheckEndOfReadPrevYxY ( readPrevAndRem               ) --> CheckChromaArrayTp;
		// get intra_chroma_pred_mode
		CheckChromaArrayTp    ( chromaArrayTp.IsEqualTo1or2   ) --> ReadIntraChroma;
		CheckChromaArrayTp    ( sendEndMbPred                 ) --> ReadParameters;
		ReadIntraChroma       ( readIntraChroma               ) --> SendEndMbPred;
		// refIdxL0 asked loop
		ReadRefIdxl0Asked     ( readRefIdxl0                  ) --> ReadRefIdxl0Asked;
		ReadRefIdxl0Asked     ( readParam.Skip1Parameter      ) --> ReadRefIdxl0Asked;
		ReadRefIdxl0Asked     ( sendOrReadDone                ) --> ReadRefIdxl1Asked;
		// refIdxL1 asked loop
		ReadRefIdxl1Asked     ( readRefIdxl1                  ) --> ReadRefIdxl1Asked;
		ReadRefIdxl1Asked     ( readParam.Skip1Parameter      ) --> ReadRefIdxl1Asked;
		ReadRefIdxl1Asked     ( sendOrReadDone                ) --> ReadMvdL0Asked;
		// mvdL0 asked loop
		ReadMvdL0Asked        ( readMvdL0.Asked               ) --> ReadMvdL0Asked;
		ReadMvdL0Asked        ( readMvdL0.Skip                ) --> ReadMvdL0Asked;
		ReadMvdL0Asked        ( sendOrReadDone                ) --> ReadMvdL1Asked;
		// mvdL1 asked loop
		ReadMvdL1Asked        ( readMvdL1.Asked               ) --> ReadMvdL1Asked;
		ReadMvdL1Asked        ( readMvdL1.Skip                ) --> ReadMvdL1Asked;
		ReadMvdL1Asked        ( sendOrReadDone                ) --> ReadRefIdxL0Done;
		// refIdxL0 done loop
		ReadRefIdxL0Done      ( readRefIdxL0.Done             ) --> ReadRefIdxL0Done;
		ReadRefIdxL0Done      ( readRefIdxL0.DoneSkip         ) --> ReadRefIdxL0Done;
		ReadRefIdxL0Done      ( sendOrReadDone                ) --> ReadRefIdxL1Done;
		// refIdxL1 done loop
		ReadRefIdxL1Done      ( readRefIdxL1.Done             ) --> ReadRefIdxL1Done;
		ReadRefIdxL1Done      ( readRefIdxL1.DoneSkip         ) --> ReadRefIdxL1Done;
		ReadRefIdxL1Done      ( sendOrReadDone                ) --> ReadMvdL0Done;
		// mvdL0 done loop
		ReadMvdL0Done         ( readMvdL0.Done                ) --> ReadMvdL0Done;
		ReadMvdL0Done         ( readMvdL0.Skip                ) --> ReadMvdL0Done;
		ReadMvdL0Done         ( sendOrReadDone                ) --> ReadMvdL1Done;
		// mvdL1 done loop
		ReadMvdL1Done         ( readMvdL1.Done                ) --> ReadMvdL1Done;
		ReadMvdL1Done         ( readMvdL1.Skip                ) --> ReadMvdL1Done;
		ReadMvdL1Done         ( sendOrReadDone                ) --> SendEndMbPred;
		// end
		SendEndMbPred         ( sendEndMbPred                 ) --> ReadParameters;
	end

	priority
		mbType.IsIntra_YxY          > mb_Type.IsNotEqualToDirect > sendEndMbPred;
		mbType.IsIntra_4x4          > mbType.IsIntra_8x8         > chromaArrayTp.IsEqualTo1or2;
		chromaArrayTp.IsEqualTo1or2 > sendEndMbPred;
		readRefIdxl0                > readParam.Skip1Parameter;
		readRefIdxl1                > readParam.Skip1Parameter;
		readParam.Skip1Parameter    > sendOrReadDone;
		readMvdL0                   > sendOrReadDone;
		readMvdL1                   > sendOrReadDone;
		readMvdL0.Skip              > sendOrReadDone;
		readMvdL1.Skip              > sendOrReadDone;
		readRefIdxL0.DoneSkip       > sendOrReadDone;
		readRefIdxL0.Done           > sendOrReadDone;
		readRefIdxL1.Done           > sendOrReadDone;
		readRefIdxL1.DoneSkip       > sendOrReadDone;
		readMvdL0.Done              > sendOrReadDone;
		readMvdL1.Done              > sendOrReadDone;
	end
end