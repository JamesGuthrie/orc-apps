/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>

package org.mpeg4.part10.frext.synParser.modular.decodePicture;

import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import org.mpeg4.part10.cbp.synParser.modular.cavlcLookUpTables.*;
import org.mpeg4.part10.frext.synParser.modular.decodePicture.cabacDecoding.*;
import org.mpeg4.part10.cbp.MacroBlockInfo.*;
import std.util.BitOps.*;

actor Algo_VariableLengthDecoding()
	uint(size=8)  RbspByte,
	bool          NewNal,

	uint(size=5)   TypeOfVLD,
	int (size=32)  VLD_Param
		==>
	int (size=32)  ValDecoded
		:

	bool DEBUG_FLAG_DECODED = false;


	//Contains the Byte which is currently read.
	uint(size=16) WorkingByte      := 0;
	//Contains the number of bit which are not read yet in WorkingByte
	uint(size=4)  CountBufferRbsp  := 0;
	//Contains up to 4 next byte in the flow. It helps for more_rbsp_data()
	//and Cabac initialisation
	uint(size=3)  SizeBufferRbsp   := 0;
	List(type: uint(size=8), size=4) BufferRbsp := [0: for int s in 0 .. 3];
	/* ue(v) and Cavlc coeff_token()*/
	bool          Bit1Found       := false;
	uint(size=5)  leadingZeroBits := 0;
	/* ue(v) only */
	int (size=31) CodeNum         := 0;
	/* u(n) */
	uint(size=5)  BitsCount       := 0;
	uint(size=31) ReadValue       := 0;
	uint(size=1)  TeVal           := 0;
	/* more_rbsp_data() */
	bool          NewNalAlreadyDetected  := false;

	/* Cavlc */
	uint(size=5) NbBitsRead;
	/* Cavlc coeff_token */
	uint(size=3) Idx_nC;
	uint(size=6) coeff_token;
	/* Cavlc total_zeros and run_before */
	uint(size=3) ValRead         := 0;
	/* Cavlc total_zeros */
	uint(size=2) IdxmaxNumCoeff  := 0;
	uint(size=4) TotalCoeffParam := 0;
	/* Cavlc run_before */
	uint(size=8) IdxzerosLeft    := 0;

	/* Cabac inittialisation */
	int (size=3) cabacInitIdc;
	int (size=6) pStateIdx[640];
	int (size=8) sliceQpY;
	uint(size=1) valMPS[640];
	/* Cabac Arithmetic Decoding */
	int (size=16) codIRange;
	int (size=16) codIOffset;
	/* Cabac Mb type parsing */
	int (size=6)  binIdx;
	uint(size=1)  binVal;
	uint(size=32) binString;
	uint(size=6) mbTypeNeighbourA;
	uint(size=6) mbTypeNeighbourB;
	bool         neighbourAAvail;
	bool         neighbourBAvail;
	uint(size=16) neighbourAAddr;
	uint(size=16) neighbourBAddr;

	uint(size=11) ctxIdx;
	bool          byPass = false;

	/* Cabac procedures */

	// Table 9-39
	procedure getCtxIdx(uint(size=11) ctxIdxOffset)
	begin
		uint(size=2)  ctxIdxInc;

		if(binIdx = 0) then
			if(ctxIdxOffset = 0 or ctxIdxOffset = 3 or ctxIdxOffset = 27) then
//				ctxIdxInc := getCtxIdxIncMbType([neighbourAAvail, neighbourBAvail],
//					[mbTypeNeighbourA, mbTypeNeighbourB],
//					ctxIdxOffset);
			elsif(ctxIdxOffset = 11 or ctxIdxOffset = 24) then
//				ctxIdxInc := getCtxIdxIncMbSkipFlag([neighbourAAvail,
//					neighbourBAvail], [mbTypeNeighbourA, mbTypeNeighbourB]);
			elsif(ctxIdxOffset = 40 or ctxIdxOffset = 47) then
				/*ctxIdxInc := getCtxIdxIncMvdLX(uint(size=11) ctxIdxOffset,
					bool neighbourAvail[2], uint(size=6) neighbourMbType[2],
					uint(size=1) neighbourMbPartIdx[2], bool isL0,
					uint(size=4) subMbType[2], int(size=16) mvdLX[2][2]);*/
			elsif(ctxIdxOffset = 54) then
				/*ctxIdxInc := getCtxIdxIncRefIdx();*/
			elsif(ctxIdxOffset = 60) then
				/*ctxIdxInc := getCtxIdxIncMbQpDelta(bool prevMbAvail,
					uint(size=6) prevMbType, uint(size=8) prevCbp, int(size=8)
					prevMbQpDelta);*/
			elsif(ctxIdxOffset = 64) then
				/*ctxIdxInc := getCtxIdxIncIntraChromPred(bool neighbourAvail[2],
					uint(size=6) neighbourMbType[2], uint(size=4) neighbourIntraPredC[2]);*/
			elsif(ctxIdxOffset = 70) then
				/* We don't manage field */
//				ctxIdxInc := getCtxIdxIncMbFieldDec([neighbourAAvail,
//					neighbourBAvail], [true, true]);
			elsif(ctxIdxOffset = 73 or ctxIdxOffset = 77) then
				/*ctxIdxInc := getCtxIdxIncCodBlkPattern(int(size=6)binIdx,
					uint(size=11) ctxIdxOffset, bool neighbourAAvail, bool neighbourBAvail,
					uint(size=6) neighbourAMbType, uint(size=6) neighbourBMbType,
					bool AIsCurrMb, bool BIsCurrMb, bool blkALumaAvail,
					uint(size=1) APriorDecBinVal, uint(size=1) BPriorDecBinVal,
					uint(size=4) ACodedBlkPatternChroma,
					uint(size=4) BCodedBlkPatternChroma);*/
			elsif(ctxIdxOffset = 399) then
				/*ctxIdxInc := getCtxIdxIncTrsfSz8x8(bool neighbourAvail[2],
					bool neighbourTrsfSz8x8[2]);*/
			else
				ctxIdxInc := 0;
			end
		elsif(binIdx = 1)then
			if(ctxIdxOffset = 3 or ctxIdxOffset = 17 or ctxIdxOffset = 32) then
				ctxIdxInc    := 0;
				ctxIdxOffset := 276;
			elsif(ctxIdxOffset = 73 or ctxIdxOffset = 77) then
				/*ctxIdxInc := getCtxIdxIncCodBlkPattern(int(size=6)binIdx,
					uint(size=11) ctxIdxOffset, bool neighbourAAvail, bool neighbourBAvail,
					uint(size=6) neighbourAMbType, uint(size=6) neighbourBMbType,
					bool AIsCurrMb, bool BIsCurrMb, bool blkALumaAvail,
					uint(size=1) APriorDecBinVal, uint(size=1) BPriorDecBinVal,
					uint(size=4) ACodedBlkPatternChroma,
					uint(size=4) BCodedBlkPatternChroma)*/
			elsif(ctxIdxOffset = 14 or ctxIdxOffset = 21 or ctxIdxOffset = 36)
				then
				ctxIdxInc := 1;
			elsif(ctxIdxOffset = 27 or ctxIdxOffset = 40 or ctxIdxOffset = 47
				or ctxIdxOffset = 64) then
				ctxIdxInc := 3;
			elsif(ctxIdxOffset = 54) then
				ctxIdxInc := 4;
			elsif(ctxIdxOffset = 60) then
				ctxIdxInc := 2;
			else
				ctxIdxInc := 0;
			end
		elsif(binIdx = 2) then
			if(ctxIdxOffset = 14 or ctxIdxOffset = 27 or ctxIdxOffset = 36)
				then
				/* We don't manage field */
//				ctxIdxInc := getCtxIdxIncMbFieldDec([neighbourAAvail,
//					neighbourBAvail], [true, true]);
			elsif(ctxIdxOffset = 73) then
				/*ctxIdxInc := getCtxIdxIncCodBlkPattern(int(size=6)binIdx,
					uint(size=11) ctxIdxOffset, bool neighbourAAvail, bool neighbourBAvail,
					uint(size=6) neighbourAMbType, uint(size=6) neighbourBMbType,
					bool AIsCurrMb, bool BIsCurrMb, bool blkALumaAvail,
					uint(size=1) APriorDecBinVal, uint(size=1) BPriorDecBinVal,
					uint(size=4) ACodedBlkPatternChroma,
					uint(size=4) BCodedBlkPatternChroma);*/
			elsif(ctxIdxOffset = 3 or ctxIdxOffset = 60 or ctxIdxOffset = 64)
				then
				ctxIdxInc := 3;
			elsif(ctxIdxOffset = 17 or ctxIdxOffset = 32) then
				ctxIdxInc := 1;
			elsif(ctxIdxOffset = 21) then
				ctxIdxInc := 2;
			elsif(ctxIdxOffset = 40 or ctxIdxOffset = 47) then
				ctxIdxInc := 4;
			elsif(ctxIdxOffset = 54) then
				ctxIdxInc := 5;
			else
				ctxIdxInc := 0;
			end
		elsif(binIdx = 3) then
			if(ctxIdxOffset = 3) then
				ctxIdxInc := 4;
			elsif(ctxIdxOffset = 17 or ctxIdxOffset = 32) then
				ctxIdxInc := 2;
			elsif(ctxIdxOffset = 27 or ctxIdxOffset = 40 or ctxIdxOffset = 47
				or ctxIdxOffset = 54) then
				ctxIdxInc := 5;
			elsif(ctxIdxOffset = 36 or ctxIdxOffset = 60) then
				ctxIdxInc := 3;
			else
				/*ctxIdxInc := getCtxIdxIncCodBlkPattern(int(size=6)binIdx,
					uint(size=11) ctxIdxOffset, bool neighbourAAvail, bool neighbourBAvail,
					uint(size=6) neighbourAMbType, uint(size=6) neighbourBMbType,
					bool AIsCurrMb, bool BIsCurrMb, bool blkALumaAvail,
					uint(size=1) APriorDecBinVal, uint(size=1) BPriorDecBinVal,
					uint(size=4) ACodedBlkPatternChroma,
					uint(size=4) BCodedBlkPatternChroma);*/
			end
		elsif(binIdx = 4) then
			if(ctxIdxOffset = 3 or ctxIdxOffset = 17 or ctxIdxOffset = 32) then
				/* We don't manage field */
//				ctxIdxInc := getCtxIdxIncMbFieldDec([neighbourAAvail,
//					neighbourBAvail], [true, true]);
			elsif(ctxIdxOffset = 27 or ctxIdxOffset = 54) then
				ctxIdxInc := 5;
			elsif(ctxIdxOffset = 36 or ctxIdxOffset = 60) then
				ctxIdxInc := 3;
			elsif(ctxIdxOffset = 40 or ctxIdxOffset = 47) then
				ctxIdxInc := 6;
			end
		elsif(binIdx = 5) then
			if(ctxIdxOffset = 3) then
				/* We don't manage field */
//				ctxIdxInc := getCtxIdxIncMbFieldDec([neighbourAAvail,
//					neighbourBAvail], [true, true]);
			elsif(ctxIdxOffset = 17 or ctxIdxOffset = 32 or ctxIdxOffset = 36
				or ctxIdxOffset = 60) then
				ctxIdxInc := 3;
			elsif(ctxIdxOffset = 27 or ctxIdxOffset = 54) then
				ctxIdxInc := 5;
			elsif(ctxIdxOffset = 40 or ctxIdxOffset = 47) then
				ctxIdxInc := 6;
			end
		else
			if(ctxIdxOffset = 3) then
				ctxIdxInc := 7;
			elsif(ctxIdxOffset = 17 or ctxIdxOffset = 32 or ctxIdxOffset = 60)
				then
				ctxIdxInc := 3;
			elsif(ctxIdxOffset = 27 or ctxIdxOffset = 54) then
				ctxIdxInc := 5;
			elsif(ctxIdxOffset = 40 or ctxIdxOffset = 47) then
				ctxIdxInc := 6;
			end
		end
		ctxIdx := ctxIdxOffset + ctxIdxInc;
	end

	/* @see 9.3.3.1.1.9 in h.264 standard */
	procedure ctxIdxCodedBlockFlag(uint(size=4) ctxBlockCat)
/*	var
		int transBlockA,
		int transBlockB,
		int mbAddrA,
		int mbAddrB,
		bool AvailMbA,
		bool AvailMbB,
		int luma4x4BlkIdxA,
		int luma4x4BlkIdxB,
		int chroma4x4BlkIdxA,
		int chroma4x4BlkIdxB,
		int condTermFlagA,
		int condTermFlagB
*/	begin
		uint(size=2) ctxIdxInc;
		int (size=6) transBlockA := -1;
		int (size=6) transBlockB := -1;

		ctxIdxInc := 0;
		println("ctxIdxCodedBlockFlag !");		
		/**********************************************************************
		    Luma 16x16 Block DC
		 *********************************************************************/
		if ctxBlockCat = 0 then
			if(neighbourAAvail and Is_Intra_16x16(mbTypeNeighbourA)) then
				transBlockA := neighbourAAddr;
			end

			if(neighbourBAvail and Is_Intra_16x16(mbTypeNeighbourB)) then
				transBlockB := neighbourBAddr;
			end
		end
		
		/**********************************************************************
		    Luma 4x4 Block AC, luma4x4BlkIdx
		 *********************************************************************/
		if ctxBlockCat = 1 or ctxBlockCat = 2 then
			println("ctxBlockCat = 1 or 2");
			while true do end
/*			luma4x4BlkIdxN
			if(neighbourAAvail and mbTypeNeighbourA != BLOCK_TYPE_P_SKIP and
				mbTypeNeighbourA != BLOCK_TYPE_B_SKIP and
				mbTypeNeighbourA != BLOCK_TYPE_I_PCM and
				((CodedBlockPatternLumaNA >>(luma4x4BlkIdxN >> 2))&1) and
				not trsfSz8x8) then
				transBlockA := luma4x4BlkIdxA;
			end
			luma4x4BlkIdxN
			if(neighbourBAvail and mbTypeNeighbourB != BLOCK_TYPE_P_SKIP and
				mbTypeNeighbourB != BLOCK_TYPE_B_SKIP and
				mbTypeNeighbourB != BLOCK_TYPE_I_PCM and
				((CodedBlockPatternLumaNB >>(luma4x4BlkIdxN >> 2))&1) and
				not trsfSz8x8) then
				transBlockA := luma4x4BlkIdxA;
			end
*/		end
		
		/* ************************************************************************************************
		    Chroma DC, chroma component index iCbCr
		 ************************************************************************************************* */
		if ctxBlockCat = 3  then
			println("ctxBlockCat = 3");
			while true do end
/*			if(neighbourAAvail and mbTypeNeighbourA != BLOCK_TYPE_P_SKIP and
				mbTypeNeighbourA != BLOCK_TYPE_B_SKIP and
				mbTypeNeighbourA != BLOCK_TYPE_I_PCM and
					CodedBlockPatternChromaNA != 0) then
				transBlockA := ;
			end
			if(neighbourBAvail and mbTypeNeighbourB != BLOCK_TYPE_P_SKIP and
				mbTypeNeighbourB != BLOCK_TYPE_B_SKIP and
				mbTypeNeighbourB != BLOCK_TYPE_I_PCM and
					CodedBlockPatternChromaNA != 0) then
				transBlockB := ;
			end
*/		end
		
		/* ************************************************************************************************
		    Chroma AC, chroma component i ndex iCbCr
		 ************************************************************************************************* */
		
/*		if ctxBlockCat = 4  then
			// N = A
			//Get Neighbouring for MB A
			getNeighbouring( GetMb4x4_Chroma_X() - 1, GetMb4x4_Chroma_Y(), 8, 8);
			  
			//Associate Values
			mbAddrA  := NeighMbAddr;
			AvailMbA := NeighMbAvail;
			if AvailMbA then
				chroma4x4BlkIdxA := ( (NeighMb_yW >> 2) * 2 ) + (NeighMb_xW >> 2);
				if ( (mbTab[mbAddrA][mbTabMbtype]  != P_Skip) or 
				     (mbTab[mbAddrA][mbTabMbtype]  != B_Skip) or 
				     (mbTab[mbAddrA][mbTabMbtype]  != 25) or
				     (mbTab[mbAddrA][mbCBPChroma] = 2) ) then	     
					transBlockA := chroma4x4BlkIdxA;
				else
					transBlockA := -1;
				end
			else
			      chroma4x4BlkIdxA := 0;
			      transBlockA := -1;
			end
			
			// N = B
			//Get Neighbouring for MB A
			getNeighbouring( GetMb4x4_Chroma_X(), GetMb4x4_Chroma_Y() - 1, 8, 8);
			  
			//Associate ValuesL
			mbAddrB  := NeighMbAddr;
			AvailMbB := NeighMbAvail;
			if AvailMbB then
				chroma4x4BlkIdxB := ( (NeighMb_yW >> 2) * 2 ) + (NeighMb_xW >> 2);
				if ( (mbTab[mbAddrB][mbTabMbtype]  != P_Skip) or 
				     (mbTab[mbAddrB][mbTabMbtype]  != B_Skip) or 
				     (mbTab[mbAddrB][mbTabMbtype]  != 25) or
				     (mbTab[mbAddrB][mbCBPChroma] = 2) ) then
				     
					transBlockB := chroma4x4BlkIdxB;
				else
					transBlockB := -1;
				end
			else
			      chroma4x4BlkIdxB := 0;
			      transBlockB := -1;
			end
		end		
		
		/* ************************************************************************************************
		    CtxIdxInc
		 ************************************************************************************************* */
		
		
		// condTermFlagA
		
/*		if not AvailMbA and IS_Inter(CabacCurrMbAddr()) or
		   AvailMbA and transBlockA = -1 and IS_IPCM_Tab(mbAddrA,mbTabMbtype) = false then
			condTermFlagA := 0;
		else
			if not AvailMbA and IS_Intra(CabacCurrMbAddr()) or
			  IS_IPCM_Tab(mbAddrA,mbTabMbtype) then
				condTermFlagA := 1;
			else
				
				if ctxBlockCat = 0 then
					condTermFlagA := mbTab[mbAddrA][mbCBF];
				end
				
				if ctxBlockCat = 1 or ctxBlockCat = 2 then
					condTermFlagA := transblock_cbf[mbAddrA][InverseScan4x4Tab[luma4x4BlkIdxA]];
				end
				
				if ctxBlockCat = 3 then
					condTermFlagA := transblock_cbf_dc_cr_cb[transBlockA][iCbCr];
				end
				
				if ctxBlockCat = 4 then
					if iCbCr = 0 then
						condTermFlagA := transblock_cbf_cb[mbAddrA][chroma4x4BlkIdxA];
					else
						condTermFlagA := transblock_cbf_cr[mbAddrA][chroma4x4BlkIdxA];
					end
				end				
			end
		end
		
		// condTermFlagB

		if not AvailMbB and IS_Inter(CabacCurrMbAddr()) or
		   AvailMbB and transBlockB = -1 and IS_IPCM_Tab(mbAddrB,mbTabMbtype) = false then
			condTermFlagB := 0;
		else
			if not AvailMbB and IS_Intra(CabacCurrMbAddr()) or
			   IS_IPCM_Tab(mbAddrB,mbTabMbtype) then
				condTermFlagB := 1;
			else
				
				if ctxBlockCat = 0 then
					condTermFlagB := mbTab[mbAddrB][mbCBF];
				end
				
				if ctxBlockCat = 1 or ctxBlockCat = 2 then
					condTermFlagB := transblock_cbf[mbAddrB][InverseScan4x4Tab[luma4x4BlkIdxB]];
				end
				
				if ctxBlockCat = 3 then
					condTermFlagB := transblock_cbf_dc_cr_cb[transBlockB][iCbCr];
				end
				
				if ctxBlockCat = 4 then
					if iCbCr = 0 then
						condTermFlagB := transblock_cbf_cb[mbAddrB][chroma4x4BlkIdxB];
					else
						condTermFlagB := transblock_cbf_cr[mbAddrB][chroma4x4BlkIdxB];
					end
				end
			end
		end
		
		ctxIdxInc := condTermFlagA + 2*condTermFlagB;
*/	end


	//9.3.3.2.1
	procedure decodeDecision()
	begin
		uint(size=2) qCodIRangeIdx;
		uint(size=8) codIRangeLPS;

		qCodIRangeIdx := (codIRange >> 6) & 0x03;
		codIRangeLPS  := rangeTabLPS[pStateIdx[ctxIdx]][qCodIRangeIdx];
		codIRange     := codIRange - codIRangeLPS;

		if(codIOffset >= codIRange) then
			binVal     := 1 - valMPS[ctxIdx];
			codIOffset := codIOffset - codIRange;
			codIRange  := codIRangeLPS;
			
			if pStateIdx[ctxIdx] = 0 then
				valMPS[ctxIdx] := 1 - valMPS[ctxIdx];
			end
			pStateIdx[ctxIdx] := transIdxLPS[pStateIdx[ctxIdx]];
		else
			binVal := valMPS[ctxIdx]; 
			pStateIdx[ctxIdx] := transIdxMPS[pStateIdx[ctxIdx]];
		end
		binString := binString << 1;
		binString := binString + binVal;
	end

	/* Read bits procedure */
	uint(size=32) Out_ReadNBits;
	procedure ReadNBitsInWorkingByte(uint(size=32) InitialValue, uint(size=4) NbBitsToRead)
	begin
			Out_ReadNBits    := InitialValue << NbBitsToRead;
			Out_ReadNBits    := Out_ReadNBits + selectBits(WorkingByte >> (8-NbBitsToRead), 0 , NbBitsToRead);
			WorkingByte     := WorkingByte << NbBitsToRead;
			CountBufferRbsp := CountBufferRbsp - NbBitsToRead;
	end


	//Syntaxe decoding have finished the decoding of this Nal
	IsEndOfNal: action TypeOfVLD :[Func] ==>
	guard
		Func    = SKIP_NAL
	do
		CountBufferRbsp := 0;
		SizeBufferRbsp  := 0;
	end

	//We skip all bytes in the current nal
	WaitForNewNal: action NewNal :[IsNewNal], RbspByte :[ValRbsp] ==>
	guard
		IsNewNal = false
	end

	NewNalDetected: action NewNal :[IsNewNal] ==>
	guard
		IsNewNal = true
	do
		SizeBufferRbsp := 0;
	end

	NewNalHasBeenSent: action ==>
	guard
		NewNalAlreadyDetected = true
	end

	ResetNewNalAlreadyDetected: action ==>
	do
		NewNalAlreadyDetected := false;
	end

	IsMoreRbspData: action TypeOfVLD :[ValTypeOfVLD] ==>
	guard
		ValTypeOfVLD = MORE_RBSP_DATA
	end

	CheckSizeBufferRbsp.IsEqualOrSupTo2: action ==> ValDecoded :[1]
	guard
		SizeBufferRbsp >= 2
	end

	CheckSizeBufferRbsp.IsEqualTo1: action ==> ValDecoded :[IsMoreDataInRbsp]
	guard
		SizeBufferRbsp = 1
	var
		uint(size=1) IsMoreDataInRbsp
	do
		if(((WorkingByte = 0 and (BufferRbsp[0] & 0xFF) = 0x03) or 
		   ((BufferRbsp[0] & 0xFF) = 0x80)) and (CountBufferRbsp = 0) )then
			IsMoreDataInRbsp := 0;
		else
			IsMoreDataInRbsp := 1;
		end
	end

	CheckSizeBufferRbsp.IsEqualTo0: action ==> ValDecoded :[IsMoreDataInRbsp]
	guard
		SizeBufferRbsp = 0
	var
		uint(size=1) IsMoreDataInRbsp
	do
		IsMoreDataInRbsp :=
			if( (WorkingByte & 0xFF) = 0x80 )then
				 0
			else
				1
			end;
	end

	FillBufferRbsp: action RbspByte :[ValRbspByte], NewNal :[ValNewNal] ==>
	guard
		SizeBufferRbsp        < 4,
		ValNewNal             = false,
		NewNalAlreadyDetected = false
	do
		BufferRbsp[3]  := BufferRbsp[2];
		BufferRbsp[2]  := BufferRbsp[1];
		BufferRbsp[1]  := BufferRbsp[0];
		BufferRbsp[0]  := ValRbspByte;
		SizeBufferRbsp := SizeBufferRbsp + 1;
	end

	FutureNewNalDetected: action NewNal :[IsNewNal] ==>
	guard
		IsNewNal              = true,
		NewNalAlreadyDetected = false
	do
		NewNalAlreadyDetected := true;
	end

	IsVldUe: action TypeOfVLD :[ValTypeOfVLD] ==>
	guard
		ValTypeOfVLD = VLD_UE
	do
		Bit1Found       := false;
		leadingZeroBits := 0;
		CodeNum         := 0;
	end


	IsVldSe: action TypeOfVLD :[ValTypeOfVLD] ==>
	guard
		ValTypeOfVLD = VLD_SE
	do
		Bit1Found       := false;
		leadingZeroBits := 0;
		CodeNum         := 0;
	end

	IsReadBits: action TypeOfVLD :[ValTypeOfVLD], VLD_Param :[ValNbBits] ==>
	guard
		ValTypeOfVLD = READ_BITS
	do
		BitsCount := ValNbBits;
		ReadValue := 0;
		TeVal     := 0;
	end

	IsVldTe.u: action TypeOfVLD :[ValTypeOfVLD], VLD_Param :[TypeOfVld] ==>
	guard
		ValTypeOfVLD = VLD_TE,
		TypeOfVld    = 1
	do
		BitsCount := 1;
		ReadValue := 0;
		TeVal     := 1;
	end

	IsVldTe.ue: action TypeOfVLD :[ValTypeOfVLD], VLD_Param :[TypeOfVld] ==>
	guard
		ValTypeOfVLD = VLD_TE,
		TypeOfVld    > 1
	do
		Bit1Found       := false;
		leadingZeroBits := 0;
		CodeNum         := 0;
	end

	IsCavlcCoeffToken: action TypeOfVLD :[ValTypeOfVLD], VLD_Param :[nC] ==>
	guard
		ValTypeOfVLD = CAVLC_COEFF_TOKEN
	do
		Idx_nC :=
			if(nC < 0)then
				if(nC = -1)then
					 4
				else
					5
				end
			else
				if(nC >=8)then
					3
				else
					if(nC >=4)then
						2
					else
						nC/2
					end
				end
			end;
		coeff_token := 0;
		NbBitsRead := 0;
	end

	IsCavlcTotalZeros: action TypeOfVLD :[ValTypeOfVLD], 
		VLD_Param :[maxNumCoeff , TotalCoeff] ==>
	guard
		ValTypeOfVLD = CAVLC_TOTAL_ZEROS
	do
		IdxmaxNumCoeff :=
			if(maxNumCoeff = 4) then
				0
			else
				if(maxNumCoeff=8) then
					1
				else
					2
				end
			end;
		NbBitsRead      := 0;
		ValRead         := 0;
		TotalCoeffParam := TotalCoeff & 0x0F;
	end

	IsCavlcRunBefore: action TypeOfVLD :[ValTypOfVLD], VLD_Param :[zerosLeft] ==>
	guard
		ValTypOfVLD = CAVLC_RUN_BEFORE
	do
		IdxzerosLeft :=
			if(zerosLeft > 0 and zerosLeft <= 6) then
				zerosLeft - 1
			else
				6
			end;
		NbBitsRead      := 0;
		ValRead         := 0;
	end

	isCabacInit: action TypeOfVLD:[typeOfVld], VLD_Param:[cabacInit, qpValue] ==>
	guard
		typeOfVld = CABAC_INIT
	do
		cabacInitIdc := cabacInit;
		sliceQpY     := qpValue;
	end

	isCabacMbType: action TypeOfVLD:[typeOfVld] ==>
	guard
		typeOfVld = CABAC_MB_TYPE_I
	do
		binIdx        := -1;
		binString     :=  0;
	end

	IsCavlcLevelPrefix: action TypeOfVLD :[ValTypeOfVLD] ==>
	guard
		ValTypeOfVLD = CAVLC_LEVEL_PREFIX
	do
		Bit1Found       := false;
		leadingZeroBits := 0;
	end

	IsByteAligned: action TypeOfVLD :[ValTypeOfVLD] ==>
	guard
		ValTypeOfVLD = BYTE_ALIGNED_REQUIRED
	do
		if(CountBufferRbsp != 8)then
			CountBufferRbsp := 0;
		end
	end

	isCabacInitMbVal: action TypeOfVLD:[typeOfVld], VLD_Param:[param] repeat 3
		==>
	guard
		typeOfVld = CABAC_INIT_MB_VAL
	do
		neighbourAAvail := getFlag(param[0], 0);
		neighbourBAvail := getFlag(param[0], 1);
		mbTypeNeighbourA := param[1];
		mbTypeNeighbourB := param[2];
	end

	Buffer.IsEmpty: action ==>
	guard
		CountBufferRbsp = 0,
		SizeBufferRbsp  > 0
	do
		CountBufferRbsp := 8;
		SizeBufferRbsp  := SizeBufferRbsp - 1;
		WorkingByte     := BufferRbsp[SizeBufferRbsp];
	end

	Buffer.IsNotEmpty: action ==>
	guard
		CountBufferRbsp > 0
	end

	GetCodeNum.Launch: action ==>
	var
		uint(size=5) NbBitsToAdd
	do
		if(not Bit1Found)then
			while( ((WorkingByte & 0x80) = 0) and (CountBufferRbsp > 0))
			do
				CountBufferRbsp := CountBufferRbsp - 1;
				WorkingByte     := WorkingByte << 1;
				leadingZeroBits := leadingZeroBits + 1;
			end
			if(CountBufferRbsp > 0)then
				leadingZeroBits := leadingZeroBits + 1;
				Bit1Found       := true;
			end
		end
		if(Bit1Found)then
			NbBitsToAdd :=
				if(CountBufferRbsp < leadingZeroBits)then
					CountBufferRbsp
				else
					leadingZeroBits
				end;
			ReadNBitsInWorkingByte(CodeNum,NbBitsToAdd);
			CodeNum         := Out_ReadNBits;
			leadingZeroBits := leadingZeroBits - NbBitsToAdd;
		end
	end

	GetCodeNum.Finished: action ==>
	guard
		leadingZeroBits = 0
	end

	GetCodeNum.NotFinished: action ==>
	guard
		leadingZeroBits != 0
	end

	SendUeValue: action ==> ValDecoded :[CodeNum]
	do
		CodeNum := CodeNum - 1;
	end

	SendSeValue: action ==> ValDecoded :[CodeNum]
	do
		//CodeNum computed is equal to CodeNum + 1
		if( (CodeNum mod 2) = 0 )then
			CodeNum := CodeNum / 2;
		else
			CodeNum := -CodeNum / 2;
		end
	end

	Get_u.Launch: action ==>
	var
		uint(size=5) NbBitsToAdd
	do
		NbBitsToAdd :=
			if(CountBufferRbsp < BitsCount)then
				CountBufferRbsp
			else
				BitsCount
			end;
		ReadNBitsInWorkingByte(ReadValue,NbBitsToAdd);
		ReadValue       := Out_ReadNBits;
		BitsCount       := BitsCount - NbBitsToAdd;
	end

	Get_u.Finished: action ==>
	guard
		BitsCount = 0
	end

	Get_u.NotFinished: action ==>
	guard
		BitsCount != 0
	end

	SendUValue: action ==> ValDecoded :[ValueDec]
	var
		uint(size=31) ValueDec
	do
		ValueDec := ReadValue ^ TeVal;
	end

	GetCavlcCoeffToken.Launch: action ==>
	var
		//delete me! (Bug in the front-end)
		bool titi
	do
		ReadNBitsInWorkingByte(coeff_token,1);
		coeff_token := Out_ReadNBits;
		NbBitsRead  := NbBitsRead + 1;
		titi := TotalCoeffValid[Idx_nC][(NbBitsRead - 1) & 0x0F][coeff_token & 0x3F];
		while((not titi) and (CountBufferRbsp > 0))
		do
			ReadNBitsInWorkingByte(coeff_token,1);
			coeff_token := Out_ReadNBits;
			NbBitsRead  := NbBitsRead + 1;
			titi := TotalCoeffValid[Idx_nC][(NbBitsRead - 1) & 0x0F][coeff_token & 0x3F];
		end
	end

	GetCavlcCoeffToken.NotFinished: action ==>
	guard
		TotalCoeffValid[Idx_nC][(NbBitsRead - 1) & 0x0F][coeff_token & 0x3F] = false
	end

	GetCavlcCoeffToken.Finished: action ==>
		ValDecoded:[ TotalCoeffValue[Idx_nC][(NbBitsRead-1) & 0x0F][coeff_token & 0x3F] ]
	do
		if(DEBUG_FLAG_DECODED)then
			println("Cavlc CoeffToken; Idx_nc :" + Idx_nC + " ; NbBitsRead : "+NbBitsRead+ " ; coeff_token : "+coeff_token);
		end
	end

	GetCavlcLevelPrefix.Launch: action ==>
	do
		while( ((WorkingByte & 0x80) = 0) and (CountBufferRbsp > 0))
		do
			CountBufferRbsp := CountBufferRbsp - 1;
			WorkingByte     := WorkingByte << 1;
			leadingZeroBits := leadingZeroBits + 1;
		end
		if(CountBufferRbsp > 0)then
			Bit1Found       := true;
			/* We read the one bit value */
			CountBufferRbsp := CountBufferRbsp - 1;
			WorkingByte     := WorkingByte << 1;
		end
	end

	GetCavlcLevelPrefix.NotFinished: action ==>
	guard
		not Bit1Found
	end

	GetCavlcLevelPrefix.Finished: action ==> ValDecoded :[leadingZeroBits]
	guard
		Bit1Found
	end

	GetCavlcTotalZeros.Launch: action ==>
	var
		//delete me!
		bool titi
	do
		ReadNBitsInWorkingByte(ValRead,1);
		ValRead := Out_ReadNBits;
		NbBitsRead      := NbBitsRead + 1;
		titi := TotalZerosValid[IdxmaxNumCoeff][TotalCoeffParam][NbBitsRead & 0x0F][ValRead & 0x07];
		while((not titi) and (CountBufferRbsp > 0))
		do
			ReadNBitsInWorkingByte(ValRead,1);
			ValRead    := Out_ReadNBits;
			NbBitsRead := NbBitsRead + 1;
			titi := TotalZerosValid[IdxmaxNumCoeff][TotalCoeffParam][NbBitsRead & 0x0F][ValRead & 0x07];
		end
	end

	GetCavlcTotalZeros.NotFinished: action ==>
	guard
		not TotalZerosValid[IdxmaxNumCoeff][TotalCoeffParam][NbBitsRead & 0x0F][ValRead & 0x07]
	end

	GetCavlcTotalZeros.Finished: action ==>
		ValDecoded :[TotalZerosValue[IdxmaxNumCoeff][TotalCoeffParam][NbBitsRead & 0x0F][ValRead & 0x07]]
	do
		if(DEBUG_FLAG_DECODED)then
			println("Cavlc TotalZeros; Idx :" + IdxmaxNumCoeff +" ; TotalCoeff :"+TotalCoeffParam+ " ; NbBitsRead : "+NbBitsRead+ " ; Codeword : "+ValRead);
		end
	end

	GetCavlcRunBefore.Launch: action ==>
	var
		//delete me!
		bool titi
	do
		ReadNBitsInWorkingByte(ValRead,1);
		ValRead    := Out_ReadNBits;
		NbBitsRead := NbBitsRead + 1;
		titi := RunBeforeValid[IdxzerosLeft][NbBitsRead & 0x0F][ValRead & 0x07];
		while((not titi) and (CountBufferRbsp > 0))
		do
			ReadNBitsInWorkingByte(ValRead,1);
			ValRead    := Out_ReadNBits;
			NbBitsRead := NbBitsRead + 1;
			titi := RunBeforeValid[IdxzerosLeft][NbBitsRead & 0x0F][ValRead & 0x07];
		end
	end

	GetCavlcRunBefore.NotFinished: action ==>
	guard
		not RunBeforeValid[IdxzerosLeft][NbBitsRead & 0x0F][ValRead & 0x07]
	end

	GetCavlcRunBefore.Finished: action ==>
		ValDecoded :[RunBeforeValue[IdxzerosLeft][NbBitsRead & 0x0F][ValRead & 0x07]]
	do
		if(DEBUG_FLAG_DECODED)then
			print("Run Before; Idx :" + IdxzerosLeft +" ; Run Before :"+RunBeforeValue[IdxzerosLeft][NbBitsRead & 0x0F][ValRead & 0x07]);
			println(" ; NbBitsRead : "+NbBitsRead+ " ; Codeword : "+ValRead);
		end
	end

/******* Cabac Decoding *******/

	/* Initialization process */
	cabacInitContextVar: action ==>
	do
		int preCtxState;

		foreach int i in 0 .. 459 do
			//Should be modify : CabacContextInit I and PB should be merged and
			//we should use the index cabacInitIdc + 1
			preCtxState :=
				if(cabacInitIdc = -1) then
					computePreCtxState(sliceQpY, Cabac_Context_Init_I[i][0],
						Cabac_Context_Init_I[i][1])
				else
					computePreCtxState(sliceQpY, Cabac_Context_Init_PB
						[cabacInitIdc][i][0], Cabac_Context_Init_PB
						[cabacInitIdc][i][1])
				end;				
			if(preCtxState  <=  63)  then
				pStateIdx[i] := 63 - preCtxState;
				valMPS[i]    := 0 ;
			else 
				pStateIdx[i] := preCtxState - 64;
				valMPS[i]    := 1;
			end
		end
	end

	cabacInitArithDecod: action ==>
	guard
		SizeBufferRbsp >= 2
	do
		uint(size=4) nbBitInFirstByte = CountBufferRbsp;

		codIRange	:= 0x01FE;
		ReadNBitsInWorkingByte(0, CountBufferRbsp);

		CountBufferRbsp := 8;
		SizeBufferRbsp  := SizeBufferRbsp - 1;
		WorkingByte     := BufferRbsp[SizeBufferRbsp];

		ReadNBitsInWorkingByte(Out_ReadNBits, 9- nbBitInFirstByte);
		codIOffset := Out_ReadNBits;
	end

	cabacGetCtxIdx: action ==>
	do
		uint(size=11) ctxIdxOffset;

		binIdx := binIdx + 1;
		ctxIdxOffset := getCtxIdxOff(CABAC_MB_TYPE_I);
		getCtxIdx(ctxIdxOffset);
		//Begining of DecodeBin(ctxIdx)
//		if(byPass) then
			
//		elsif(ctxIdx = 276)then

/*		else*/ if(ctxIdx != 276 and not byPass) then
			decodeDecision();
		end
	end

	cabacRenormD.launch: action ==>
	guard
		codIRange < 0x0100
	do
		codIRange := codIRange << 1;
		ReadNBitsInWorkingByte(codIOffset, 1);
		codIOffset := Out_ReadNBits;
	end

	cabacRenormD.skip: action ==>
	guard
		codIRange >= 0x0100
	end

	cabacCheckBinarization.done: action ==> ValDecoded:[decodedVal]
	guard
		binarizationDone(binIdx, binString)
	do
		int(size=32) decodedVal;

		decodedVal := getBinarizationValue(binIdx, binString);
	end

	cabacCheckBinarization.notFinished: action ==>
	end
/*
*
* Scheduler
*
*/

	schedule fsm CheckVLDType:
		CheckVLDType    (IsEndOfNal         )--> WaitForNewNal;
		CheckVLDType    (IsByteAligned      )--> CheckVLDType;
		CheckVLDType    (IsVldUe            )--> VLDecoding_Ue;
		CheckVLDType    (IsVldSe            )--> VLDecoding_Se;
		CheckVLDType    (IsVldTe.ue         )--> VLDecoding_Ue;
		CheckVLDType    (IsVldTe.u          )--> Decode_u;
		CheckVLDType    (IsReadBits         )--> Decode_u;
		CheckVLDType    (IsMoreRbspData     )--> FillBuffer;
		CheckVLDType    (IsCavlcLevelPrefix )--> DecCavlcLevPre;
		CheckVLDType    (IsCavlcCoeffToken  )--> DecCavlcCofTkn;
		CheckVLDType    (IsCavlcTotalZeros  )--> DecCavlcTotZer;
		CheckVLDType    (IsCavlcRunBefore   )--> DecCavlcRunBef;
		CheckVLDType    (isCabacInit        )--> CabacInitContextVar;
		CheckVLDType    (isCabacInitMbVal   )--> CheckVLDType;
		CheckVLDType    (isCabacMbType      )--> CabacGetCtxIdx;

		/* more_rbsp_data() */
		FillBuffer      (FillBufferRbsp                      )--> FillBuffer;
		FillBuffer      (FutureNewNalDetected                )--> CheckBuffer;
		FillBuffer      (CheckSizeBufferRbsp.IsEqualOrSupTo2 )--> CheckVLDType;
		FillBuffer      (NewNalHasBeenSent                   )--> CheckBuffer;
		CheckBuffer     (CheckSizeBufferRbsp                 )--> CheckVLDType;

		/* Skip the others values of the Rbsp */
		WaitForNewNal   (NewNalHasBeenSent          )--> ResetNewNal;
		WaitForNewNal   (WaitForNewNal              )--> WaitForNewNal2;
		WaitForNewNal   (NewNalDetected             )--> CheckVLDType;
		ResetNewNal     (ResetNewNalAlreadyDetected )--> CheckVLDType;
		WaitForNewNal2  (WaitForNewNal              )--> WaitForNewNal2;
		WaitForNewNal2  (NewNalDetected             )--> CheckVLDType;

		/* ue(v) decoding process */
			/*Fill in the WorkingByte if it's empty*/
		VLDecoding_Ue   (Buffer                 )--> GetCodeNum4ue;
		VLDecoding_Ue   (FillBufferRbsp         )--> VLDecoding_Ue;
		GetCodeNum4ue   (GetCodeNum.Launch      )--> CheckCodeNum4ue;
		CheckCodeNum4ue (GetCodeNum.NotFinished )--> VLDecoding_Ue;
		CheckCodeNum4ue (GetCodeNum.Finished    )--> SendUeValue;
		SendUeValue     (SendUeValue            )--> CheckVLDType;

		/* se(v) decoding process */
			/*Fill in the WorkingByte if it's empty*/
		VLDecoding_Se   (Buffer                 )--> GetCodeNum4se;
		VLDecoding_Se   (FillBufferRbsp         )--> VLDecoding_Se;
		GetCodeNum4se   (GetCodeNum.Launch      )--> CheckCodeNum4se;
		CheckCodeNum4se (GetCodeNum.NotFinished )--> VLDecoding_Se;
		CheckCodeNum4se (GetCodeNum.Finished    )--> SendUeValse;
		SendUeValse     (SendSeValue            )--> CheckVLDType;

		/* u(n) decoding process */
			/*Fill in the WorkingByte if it's empty*/
		Decode_u        (Buffer            )--> Get_u;
		Decode_u        (FillBufferRbsp    )--> Decode_u;
		Get_u           (Get_u.Launch      )--> Check_u_Val;
		Check_u_Val     (Get_u.NotFinished )--> Decode_u;
		Check_u_Val     (Get_u.Finished    )--> SendUValue;
		SendUValue      (SendUValue        )--> CheckVLDType;

		/* Cavlc coeff_token() decoding process */
			/*Fill in the WorkingByte if it's empty*/
		DecCavlcCofTkn  (Buffer                         )--> GetCavlcCofTkn;
		DecCavlcCofTkn  (FillBufferRbsp                 )--> DecCavlcCofTkn;
		GetCavlcCofTkn   (GetCavlcCoeffToken.Launch     )--> ChckCavlcCofTkn;
		ChckCavlcCofTkn (GetCavlcCoeffToken.NotFinished )--> DecCavlcCofTkn;
		ChckCavlcCofTkn (GetCavlcCoeffToken.Finished    )--> CheckVLDType;

		/* Cavlc level_prefix decoding process */
			/*Fill in the WorkingByte if it's empty*/
		DecCavlcLevPre  (Buffer                          )--> GetCavlcLevPre;
		DecCavlcLevPre  (FillBufferRbsp                  )--> DecCavlcLevPre;
		GetCavlcLevPre  (GetCavlcLevelPrefix.Launch      )--> ChckCavlcLevPre;
		ChckCavlcLevPre (GetCavlcLevelPrefix.NotFinished )--> DecCavlcLevPre;
		ChckCavlcLevPre (GetCavlcLevelPrefix.Finished    )--> CheckVLDType;

		/* Cavlc total_zeros decoding process */
			/*Fill in the WorkingByte if it's empty*/
		DecCavlcTotZer  (Buffer                         )--> GetCavlcTotZer;
		DecCavlcTotZer  (FillBufferRbsp                 )--> DecCavlcTotZer;
		GetCavlcTotZer  (GetCavlcTotalZeros.Launch      )--> ChckCavlcTotZer;
		ChckCavlcTotZer (GetCavlcTotalZeros.NotFinished )--> DecCavlcTotZer;
		ChckCavlcTotZer (GetCavlcTotalZeros.Finished    )--> CheckVLDType;

		/* Cavlc run_before decoding process */
			/*Fill in the WorkingByte if it's empty*/
		DecCavlcRunBef  (Buffer                        )--> GetCavlcRunBef;
		DecCavlcRunBef  (FillBufferRbsp                )--> DecCavlcRunBef;
		GetCavlcRunBef  (GetCavlcRunBefore.Launch      )--> ChckCavlcRunBef;
		ChckCavlcRunBef (GetCavlcRunBefore.NotFinished )--> DecCavlcRunBef;
		ChckCavlcRunBef (GetCavlcRunBefore.Finished    )--> CheckVLDType;

		/* Cabac Init */
		CabacInitContextVar (cabacInitContextVar )--> CabacInitArithDecod;
		CabacInitArithDecod (Buffer.IsEmpty      )--> CabacInitArithDecod;
		CabacInitArithDecod (cabacInitArithDecod )--> CheckVLDType;
		CabacInitArithDecod (FillBufferRbsp      )--> CabacInitArithDecod;

		/* Cabac Decode Syntax Element */
		CabacGetCtxIdx     (cabacGetCtxIdx )--> CabacFillOutBuffer;
		CabacFillOutBuffer (Buffer         )--> RenormD;
		CabacFillOutBuffer (FillBufferRbsp )--> CabacFillOutBuffer;
		RenormD (cabacRenormD.launch )--> CabacFillOutBuffer;
		RenormD (cabacRenormD.skip   )--> CabacCheckBinarization;
		CabacCheckBinarization (cabacCheckBinarization.notFinished )--> CabacGetCtxIdx;
		CabacCheckBinarization (cabacCheckBinarization.done        )--> CheckVLDType;
	end
	
	priority
		NewNalHasBeenSent               > WaitForNewNal                        > NewNalDetected;
		IsVldUe                         > IsReadBits                           > IsCavlcLevelPrefix;  
		IsCavlcLevelPrefix              > IsCavlcRunBefore > IsCavlcCoeffToken > IsVldSe;
		IsVldSe                         > IsVldTe.ue       > IsVldTe.u         > FillBufferRbsp;
		FillBufferRbsp                  > IsMoreRbspData   > IsByteAligned     > IsEndOfNal;
		CheckSizeBufferRbsp             > FillBufferRbsp                       > FutureNewNalDetected > NewNalHasBeenSent;
		GetCodeNum.NotFinished          > GetCodeNum.Finished;
		Buffer.IsNotEmpty               > Buffer.IsEmpty                       > FillBufferRbsp;
		GetCavlcCoeffToken.NotFinished  > GetCavlcCoeffToken.Finished;
		GetCavlcLevelPrefix.NotFinished > GetCavlcLevelPrefix.Finished;
		GetCavlcTotalZeros.NotFinished  > GetCavlcTotalZeros.Finished;
		GetCavlcRunBefore.NotFinished   > GetCavlcRunBefore.Finished;
		Buffer > cabacInitArithDecod    > FillBufferRbsp;
		cabacCheckBinarization.done     > cabacCheckBinarization.notFinished;
	end
end
