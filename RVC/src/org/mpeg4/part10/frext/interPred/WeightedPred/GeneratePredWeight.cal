/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package org.mpeg4.part10.frext.interPred.WeightedPred;

import org.mpeg4.part10.cbp.MacroBlockInfo.*;

actor GeneratePredWeight()
	bool         NewMbL0,
	bool         NewMbL1,
	uint(size=5) NumRefIdxLXActive,
	uint(size=4) RefIdxL0,
	uint(size=4) RefIdxL1,
	uint(size=2) SelectList,
	uint(size=2) WeightedPredIdc,
	int (size=9) WeightedParam
		==>
	int (size=9) PredWeightY,
	int (size=9) PredWeightU,
	int (size=9) PredWeightV
		:

	// [Component][LX][ref_idx]
	int(size=8) offset[3][2][32];
	int(size=9) weight[3][2][32];

	uint(size=3) chrLog2WeightDenom;
	uint(size=5) iLoop;
	bool         isL0;
	uint(size=3) lumaLog2WeightDenom;
	uint(size=5) numRefIdxL0Active;
	uint(size=5) numRefIdxL1Active;
	uint(size=2) wpIdc;

	SendWeightParam.launch.l0: action NewMbL0:[isNewMb], RefIdxL0:[refIdx],
		SelectList:[listSelected] ==> PredWeightY:[predInfoY] repeat 3,
		PredWeightU:[predInfoU] repeat 3, PredWeightV:[predInfoV] repeat 3
	guard
		isNewMb and wpIdc != 0 and listSelected = PRED_L0
	do
		int(size=9) predInfoY[3];
		int(size=9) predInfoU[3];
		int(size=9) predInfoV[3];
		uint(size=1) idxL0 = 0;

		predInfoY[0] := lumaLog2WeightDenom;
		predInfoY[1] := weight[0][idxL0][refIdx];
		predInfoY[2] := offset[0][idxL0][refIdx];

		predInfoU[0] := chrLog2WeightDenom;
		predInfoU[1] := weight[1][idxL0][refIdx];
		predInfoU[2] := offset[1][idxL0][refIdx];

		predInfoV[0] := chrLog2WeightDenom;
		predInfoV[1] := weight[2][idxL0][refIdx];
		predInfoV[2] := offset[2][idxL0][refIdx];
	end

	SendWeightParam.launch.l1: action NewMbL1:[isNewMb], RefIdxL1:[refIdx],
		SelectList:[listSelected] ==> PredWeightY:[predInfoY] repeat 3,
		PredWeightU:[predInfoU] repeat 3, PredWeightV:[predInfoV] repeat 3
	guard
		isNewMb and wpIdc != 0 and listSelected = PRED_L1
	do
		int(size=9) predInfoY[3];
		int(size=9) predInfoU[3];
		int(size=9) predInfoV[3];
		uint(size=1) idxL1 = 1;

		predInfoY[0] := lumaLog2WeightDenom;
		predInfoY[1] := weight[0][idxL1][refIdx];
		predInfoY[2] := offset[0][idxL1][refIdx];

		predInfoU[0] := chrLog2WeightDenom;
		predInfoU[1] := weight[1][idxL1][refIdx];
		predInfoU[2] := offset[1][idxL1][refIdx];

		predInfoV[0] := chrLog2WeightDenom;
		predInfoV[1] := weight[2][idxL1][refIdx];
		predInfoV[2] := offset[2][idxL1][refIdx];
	end

	SendWeightParam.launch.biPred: action NewMbL0:[isNewMbL0],
		NewMbL1:[isNewMbL1], RefIdxL0:[refIdxl0], RefIdxL1:[refIdxl1],
		SelectList:[listSelected] ==> PredWeightY:[predInfoY] repeat 6,
		PredWeightU:[predInfoU] repeat 6, PredWeightV:[predInfoV] repeat 6
	guard
		isNewMbL0 and isNewMbL1 and wpIdc != 0 and listSelected = BIPRED
	do
		int(size=9) predInfoY[6];
		int(size=9) predInfoU[6];
		int(size=9) predInfoV[6];
		uint(size=1) idxL0 = 0;
		uint(size=1) idxL1 = 1;

		predInfoY[0] := lumaLog2WeightDenom;
		predInfoY[1] := weight[0][idxL0][refIdxl0];
		predInfoY[2] := offset[0][idxL0][refIdxl0];
		predInfoY[3] := lumaLog2WeightDenom;
		predInfoY[4] := weight[0][idxL1][refIdxl1];
		predInfoY[5] := offset[0][idxL1][refIdxl1];

		predInfoU[0] := chrLog2WeightDenom;
		predInfoU[1] := weight[1][idxL0][refIdxl0];
		predInfoU[2] := offset[1][idxL0][refIdxl0];
		predInfoU[3] := chrLog2WeightDenom;
		predInfoU[4] := weight[1][idxL1][refIdxl1];
		predInfoU[5] := offset[1][idxL1][refIdxl1];

		predInfoV[0] := chrLog2WeightDenom;
		predInfoV[1] := weight[2][idxL0][refIdxl0];
		predInfoV[2] := offset[2][idxL0][refIdxl0];
		predInfoV[3] := chrLog2WeightDenom;
		predInfoV[4] := weight[2][idxL1][refIdxl1];
		predInfoV[5] := offset[2][idxL1][refIdxl1];
	end

	SendWeightParam.skip.l0: action NewMbL0:[isNewMb], RefIdxL0:[refIdx],
		SelectList:[listSelected] ==>
	guard
		isNewMb and wpIdc = 0 and listSelected = PRED_L0
	end

	SendWeightParam.skip.l1: action NewMbL1:[isNewMb], RefIdxL1:[refIdx],
		SelectList:[listSelected] ==>
	guard
		isNewMb and wpIdc = 0 and listSelected = PRED_L1
	end

	SendWeightParam.skip.biPred: action NewMbL0:[isNewMbL0],
		NewMbL1:[isNewMbL1], RefIdxL0:[refIdxl0], RefIdxL1:[refIdxl1],
		SelectList:[listSelected] ==>
	guard
		isNewMbL0 and isNewMbL1 and wpIdc = 0 and listSelected = BIPRED
	end

	getWeightedPredIdc: action NewMbL0:[isNewMbL0], NewMbL1:[isNewMbL1],
		WeightedPredIdc:[weightPredIdc], NumRefIdxLXActive:[numRefIdxLXAct]
		repeat 2 ==>
	guard
		not isNewMbL0 and not isNewMbL1
	do
		wpIdc := weightPredIdc;
		numRefIdxL0Active := numRefIdxLXAct[0];
		numRefIdxL1Active := numRefIdxLXAct[1];
	end

	getWeightDenom.skip: action ==>
	guard
		wpIdc != 1
	end

	getWeightDenom.launch: action WeightedParam:[lumaDenom, chromaDenom] ==>
	guard
		wpIdc = 1
	do
		lumaLog2WeightDenom := lumaDenom;
		chrLog2WeightDenom  := chromaDenom;
		isL0 := true;
		iLoop := 0;
	end

	getWeightAndOffset.launch: action WeightedParam:[param] repeat 6 ==>
	guard
		iLoop < numRefIdxL0Active and isL0 or
		iLoop < numRefIdxL1Active and not isL0
	do
		uint(size=1) idxLX := if(isL0) then 0 else 1 end;

		foreach uint Component in 0 .. 2
		do
			weight[Component][idxLX][iLoop] := param[2*Component];
			offset[Component][idxLX][iLoop] := param[2*Component + 1];
		end
		iLoop := iLoop + 1;
	end

	getWeightAndOffset.endLoop: action ==>
	guard
		not(iLoop < numRefIdxL0Active and isL0) and
		not(iLoop < numRefIdxL1Active and not isL0)
	end

	getHasL1Comp.isTrue: action WeightedParam:[hasL1Comp] ==>
	guard
		hasL1Comp = 1
	do
		isL0 := false;
		iLoop := 0;
	end

	getHasL1Comp.isFalse: action WeightedParam:[hasL1Comp] ==>
	guard
		hasL1Comp = 0
	end

	schedule fsm GetCommand:
		GetCommand (getWeightedPredIdc )--> GetWeightDenom;
		GetCommand (SendWeightParam    )--> GetCommand;

		GetWeightDenom     (getWeightDenom.launch )--> GetWeightAndOffL0;
		GetWeightDenom     (getWeightDenom.skip   )--> GetCommand;

		GetWeightAndOffL0 (getWeightAndOffset.launch  )--> GetWeightAndOffL0;
		GetWeightAndOffL0 (getWeightAndOffset.endLoop )--> CheckHasL1;
		CheckHasL1        (getHasL1Comp.isTrue        )--> GetWeightAndOffL1;
		CheckHasL1        (getHasL1Comp.isFalse       )--> GetCommand;

		GetWeightAndOffL1 (getWeightAndOffset.launch  )--> GetWeightAndOffL1;
		GetWeightAndOffL1 (getWeightAndOffset.endLoop )--> GetCommand;
	end
end