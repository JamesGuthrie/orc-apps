/********************************************************************************

This software module was originally developed by 
Damien de Saint Jorre (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
*****************************************************************************/
package org.mpeg4.part10.frext.interPred;

import org.mpeg4.part10.cbp.MacroBlockInfo.*;
import org.mpeg4.part10.Imp_PictureInfo.*;
import std.util.Math.*;

actor Algo_MvBuffer()
	uint(size=6)  MbType,
	uint(size=4)  SubMbType,

	bool          NewPic,

	uint(size=31) FrameNum,
	uint(size=32) Poc,
	bool          Direct8x8Inference,

	uint(size=7)  MbLocation,

	uint(size=4)  RefIdx,
	int (size=16) Mv,

	bool          Empty_DPB,
	int (size=32) DelList,
	int (size=32) LongTermList,

	int (size=32) RefList0,
	int (size=32) RefList1
		==>
	bool         ColZeroFlag,
	int(size=32) TemporalInfo
		:

	int (size=32) SENT_DONE = -2;

	uint(size=4) B_DIRECT_8x8 = 0;

	int (size=5)  refIdxList [16][2][MAX_PICWIDTH_PX/4][MAX_PICHEIGHT_PX/4];
	int (size=16) mvList[16][2][MAX_PICWIDTH_PX/4][MAX_PICHEIGHT_PX/4][2];
	bool          IsReference[16];
	int (size=32) listFrameNum[16];
	uint(size=32) listPicOrdCnt[16];
	int (size=32) longTermList[16];
	int (size=32) refList0 [16];
	int (size=32) refList1 [16];

	uint(size=3)  MbPartIdxMax;
	uint(size=3)  MbPartIdx;
	uint(size=3)  SizeMbMv;
	uint(size=3)  SubMbPartIdxMax;
	uint(size=3)  SubMbPartIdx;
	uint(size=3)  SizeSubMbMv;
	uint(size=1)  Idx_Sub_Tab;
	uint(size=6)  mb_type;
	uint(size=6)  sub_mb_type;
	bool          IsPredL0;
	bool          IsPredL1;
	uint(size=5)  Size_RefList;
	uint(size=5)  Idx_RefList;
	uint(size=5)  WriteListIdx;
	uint(size=5)  ReadListIdx;
	bool          colPic_IsShortTermRef;
	uint(size=32) Mbx;
	uint(size=32) Mby;
	bool          direct_8x8_inference_flag;

	uint(size=4)  NbPartitionsToWrite;
	uint(size=32) Partition_Mbx[16];
	uint(size=32) Partition_Mby[16];
	bool          colZeroFlag;
	int (size=32) refIdxL0Temporal;
	int (size=16) mvCol[2];
	int (size=16) mvL0[2];
	int (size=16) mvL1[2];

	procedure computeColInfo(uint Idx_x, uint Idx_y)
	begin
		uint Idx_x_Infer =
			if(direct_8x8_inference_flag)then
				getDirect8x8InfIdx(Idx_x)
			else
				Idx_x
			end;
		uint Idx_y_Infer =
			if(direct_8x8_inference_flag)then
				getDirect8x8InfIdx(Idx_y)
			else
				Idx_y
			end;
		int(size=32) colPic;
		int(size=5)  refIdxCol;

		//for spatial prediction, we need : colZeroFlag
		//for temporal prediction, we need : refIdxL0Temporal, MvL0, MvL1
		if(refIdxList[ReadListIdx][0][Idx_x_Infer][Idx_y_Infer] != -1)then
			refIdxCol := refIdxList[ReadListIdx][0][Idx_x_Infer][Idx_y_Infer];
			mvCol[0]  := mvList[ReadListIdx][0][Idx_x_Infer][Idx_y_Infer][0];
			mvCol[1]  := mvList[ReadListIdx][0][Idx_x_Infer][Idx_y_Infer][1];
			refIdxL0Temporal := refIdxList[ReadListIdx][0][Idx_x_Infer][Idx_y_Infer];
		else
			if(refIdxList[ReadListIdx][1][Idx_x_Infer][Idx_y_Infer] != -1)then
				refIdxCol := refIdxList[ReadListIdx][1][Idx_x_Infer][Idx_y_Infer];
				mvCol[0]  := mvList[ReadListIdx][1][Idx_x_Infer][Idx_y_Infer][0];
				mvCol[1]  := mvList[ReadListIdx][1][Idx_x_Infer][Idx_y_Infer][1];

				colPic := refList1[refIdxCol];
				refIdxL0Temporal := 0;
				foreach int i in 15 .. 0
				do
					if(refList0[i] = colPic)then
						refIdxL0Temporal := i;
					end
				end
			else
				refIdxCol := -1;
				mvCol     := [0,0];
				refIdxL0Temporal := 0;
			end
		end

		colZeroFlag :=
			if(not colPic_IsShortTermRef or refIdxCol = -1)then
				false
			else
				refIdxCol =  0 and mvCol[0] >= -1 and mvCol[0] <= 1
				   and mvCol[1] >= -1 and mvCol[1] <=  1
			end;

		computeMvComponent4Temporal(refList0[refIdxL0Temporal]);
	end

	procedure computeMvComponent4Temporal(int(size=32) ref0)
	begin
		int(size=32) curPicOrField = listPicOrdCnt[WriteListIdx];

		bool isLongTermRef := false;
		int (size=8)  td;
		int (size=8)  tb;
		uint(size=14) tx;
		int (size=11) distScaleFactor;
		int (size=32) pic0 := 0;
		int (size=32) pic1 := 0;
		
		isLongTermRef := false;
		foreach int i in 0 .. 15
		do
			if(longTermList[i] = pic0)then
				isLongTermRef := true;
			end
		end

		foreach int i in 0 .. 15
		do
			if(IsReference[i] and listFrameNum[i] = refList1[0]) then
				pic1 := listPicOrdCnt[i];
			end
			if(IsReference[i] and listFrameNum[i] = ref0) then
				pic0 := listPicOrdCnt[i];
			end
		end

		if(isLongTermRef or pic0 = pic1)then
			mvL0[0] := mvCol[0];
			mvL0[1] := mvCol[1];
			mvL1    := [0,0];
		else
			tb := clip_i32(curPicOrField - pic0,-128,127);
			td := clip_i32(pic1 - pic0,-128,127);
			tx := (16384 + abs(td/2))/td;
			distScaleFactor := clip_i32((tb*tx+32)>>6, -1024, 1023);
			mvL0[0] := (distScaleFactor * mvCol[0] + 128) >> 8;
			mvL0[1] := (distScaleFactor * mvCol[1] + 128) >> 8;
			mvL1[0] := mvL0[0] - mvCol[0];
			mvL1[1] := mvL0[1] - mvCol[1];
		end
	end


	function getDirect8x8InfIdx(uint Idx) --> uint :
		//XXXXXX00 -> XXXXXX00
		//XXXXXX01 -> XXXXXX00
		//XXXXXX10 -> XXXXXX11
		//XXXXXX11 -> XXXXXX11
		(Idx & 0xFFFFFFFE) + ((Idx >> 1)&1)
	end

	getNewPic: action NewPic:[isNewPic], FrameNum :[frameNum], Poc :[poc],
			Direct8x8Inference :[direct8x8InferFlag] ==>
	guard
		isNewPic
	var
		bool EndLoop//Delete me when the bug in Orcc will be solved
	do
		foreach int i in 0 .. 15
		do
			if(listFrameNum[i] = frameNum)then
				IsReference[i] := false;
			end
		end

		WriteListIdx := 0;
		EndLoop := IsReference[0];
		while( EndLoop /*IsReference[WriteListIdx]*/ and WriteListIdx < 15)
		do
			WriteListIdx := WriteListIdx + 1;
			EndLoop := IsReference[WriteListIdx];
		end

		IsReference [WriteListIdx]  := true;
		listFrameNum[WriteListIdx]  := frameNum;
		listPicOrdCnt[WriteListIdx] := poc;
		direct_8x8_inference_flag   := direct8x8InferFlag;
	end

	getMbType: action MbType :[macroBlkType], NewPic :[isNewPic],
		MbLocation :[mbLocX, mbLocY] ==>
	guard
		not isNewPic
	do
		mb_type := macroBlkType;

		//There are 16 Partitions in a macroblock
		Mbx := mbLocX * 4;
		Mby := mbLocY * 4;

		MbPartIdx    := 0;
		MbPartIdxMax := NumMbPart(mb_type);
		SizeMbMv     := SizeMbPart(mb_type);
	end

	checkMbType.macroBlkIorSI: action ==>
	guard
		Mb_IsIntra(mb_type)
	do
		foreach int i in Mbx .. Mbx + 3
		do
			foreach int j in Mby .. Mby + 3
			do
				refIdxList[WriteListIdx][0][i][j]    := -1;
				refIdxList[WriteListIdx][1][i][j]    := -1;
				mvList[WriteListIdx][0][i][j][0] :=  0;
				mvList[WriteListIdx][0][i][j][1] :=  0;
				mvList[WriteListIdx][1][i][j][0] :=  0;
				mvList[WriteListIdx][1][i][j][1] :=  0;
			end
		end
	end

	checkMbType.B_Skip_B_Direct_16x16: action ==>
		ColZeroFlag :[isColZero] repeat 16,
		TemporalInfo :[temporalInfo] repeat 80
	guard
		mb_type = BLOCK_TYPE_B_SKIP or mb_type = BLOCK_TYPE_B_DIRECT_16x16
	do
		bool          isColZero[16];
		int (size=32) temporalInfo[80];
		uint(size=2)  blkIdx;

		foreach uint j in 0 .. 3
		do
			foreach uint i in 0 .. 3
			do
				computeColInfo(Mbx+i,Mby+j);
				blkIdx := 4*j+i;
				isColZero[blkIdx]    := colZeroFlag;
				temporalInfo[blkIdx] := refIdxL0Temporal;
				temporalInfo[16+ 2*blkIdx]    := mvL0[0];
				temporalInfo[16+ 2*blkIdx +1] := mvL0[1];
				temporalInfo[48+ 2*blkIdx]    := mvL1[0];
				temporalInfo[48+ 2*blkIdx +1] := mvL1[1];
			end
		end
	end

	checkMbType.others: action ==>
	guard
		not Mb_IsIntra(mb_type) and mb_type != BLOCK_TYPE_B_SKIP,
		mb_type != BLOCK_TYPE_B_DIRECT_16x16
	do
		Idx_Sub_Tab  :=
			if mbIsBiPred(mb_type) then
				0
			else
				1
			end;
	end

	GetMbParameters.Block16x16: action
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			SizeMbMv  = SZ_16x16
		var
			uint(size=4) Idx := 0
		do
			NbPartitionsToWrite := 16;
			foreach int i in Mbx .. Mbx + 3
			do
				foreach int j in Mby .. Mby + 3
				do
					Partition_Mbx[Idx] := i;
					Partition_Mby[Idx] := j;
					Idx                := Idx + 1;
				end
			end
			IsPredL0  := Mb_Is_PredL0(mb_type, MbPartIdx);
			IsPredL1  := Mb_Is_PredL1(mb_type, MbPartIdx);
			MbPartIdx := MbPartIdx + 1;
		end

	GetMbParameters.Block16x8: action
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			SizeMbMv  = SZ_16x8
		var
			uint(size=4) Idx := 0
		do
			NbPartitionsToWrite := 8;
			foreach int i in Mbx .. Mbx + 3
			do
				foreach int j in Mby + 2* (MbPartIdx&1) .. Mby + 2* (MbPartIdx&1) + 1
				do
					Partition_Mbx[Idx] := i;
					Partition_Mby[Idx] := j;
					Idx                := Idx + 1;
				end
			end
			IsPredL0  := Mb_Is_PredL0(mb_type, MbPartIdx);
			IsPredL1  := Mb_Is_PredL1(mb_type, MbPartIdx);
			MbPartIdx := MbPartIdx + 1;
		end

	GetMbParameters.Block8x16: action
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			SizeMbMv  = SZ_8x16
		var
			uint(size=4) Idx := 0
		do
			NbPartitionsToWrite := 8;
			foreach int i in Mbx + 2* (MbPartIdx&1) .. Mbx + 2* (MbPartIdx&1) + 1
			do
				foreach int j in Mby .. Mby + 3
				do
					Partition_Mbx[Idx] := i;
					Partition_Mby[Idx] := j;
					Idx                := Idx + 1;
				end
			end
			IsPredL0  := Mb_Is_PredL0(mb_type, MbPartIdx);
			IsPredL1  := Mb_Is_PredL1(mb_type, MbPartIdx);
			MbPartIdx := MbPartIdx + 1;
		end

	GetMbParameters.Launch_B_Direct: action
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			   mb_type = BLOCK_TYPE_B_SKIP
			or mb_type = BLOCK_TYPE_B_DIRECT_16x16
		var
			uint(size=3) localMbPartIdx    = MbPartIdx  /  4,
			uint(size=3) localSubMbPartIdx = MbPartIdx mod 4
		do
			NbPartitionsToWrite := 1;
			Partition_Mbx[0]    := Mbx + 2* (localMbPartIdx&1)      + (localSubMbPartIdx&1);
			Partition_Mby[0]    := Mby + 2* ((localMbPartIdx>>1)&1) + ((localSubMbPartIdx>>1)&1);
			IsPredL0  := false;
			IsPredL1  := false;
			MbPartIdx := MbPartIdx + 1;
		end

	LaunchGetSubMbParameters: action
			SubMbType :[ValSubMbType]
				==>
		guard
			MbPartIdx  < MbPartIdxMax,
			SizeMbMv   = SZ_8x8
		do
			SubMbPartIdx    :=  0;
			SubMbPartIdxMax :=  NumSubMbPart(mb_type,ValSubMbType);
			SizeSubMbMv     :=  SizeSubMbPart(mb_type,ValSubMbType);
			IsPredL0        := (SubMbPartPredMode[Idx_Sub_Tab][ValSubMbType & 15] & PRED_L0) != 0;
			IsPredL1        := (SubMbPartPredMode[Idx_Sub_Tab][ValSubMbType & 15] & PRED_L1) != 0;
			sub_mb_type     := ValSubMbType;
		end

	GetMbParametersFinished: action ==>
		guard
			MbPartIdx = MbPartIdxMax
		end

	GetSubMbParameters.Launch_B_Direct_8x8: action
				==>
			ColZeroFlag  :[IsColZero],
			TemporalInfo :[temporalInfo] repeat 5
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			mb_type     = BLOCK_TYPE_B_8x8,
			sub_mb_type = B_DIRECT_8x8
		do
			bool         IsColZero;
			int(size=32) temporalInfo[5];

			computeColInfo(Mbx + 2* (MbPartIdx&1) + (SubMbPartIdx&1) ,Mby + 2* ((MbPartIdx >>1)&1) +  ((SubMbPartIdx >>1)&1));
			IsColZero := colZeroFlag;
			temporalInfo[0] := refIdxL0Temporal;
			temporalInfo[1] := mvL0[0];
			temporalInfo[2] := mvL0[1];
			temporalInfo[3] := mvL1[0];
			temporalInfo[4] := mvL1[1];

			NbPartitionsToWrite := 1;
			Partition_Mbx[0] := Mbx + 2* (MbPartIdx&1) + (SubMbPartIdx&1);
			Partition_Mby[0] := Mby + 2* ((MbPartIdx>>1)&1) +  ((SubMbPartIdx >>1)&1);

			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParameters.Launch8x8: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SizeSubMbMv  = SZ_8x8,
			   mb_type     != BLOCK_TYPE_B_8x8
			or sub_mb_type != B_DIRECT_8x8
		var
			uint(size=4) Idx := 0
		do
			NbPartitionsToWrite := 4;
			foreach int i in Mbx + 2* (MbPartIdx&1) .. Mbx + 2* (MbPartIdx&1) + 1
			do
				foreach int j in Mby + 2* ((MbPartIdx>>1)&1) .. Mby + 2* ((MbPartIdx>>1)&1) + 1
				do
					Partition_Mbx[Idx] := i;
					Partition_Mby[Idx] := j;
					Idx                := Idx + 1;
				end
			end
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParameters.Launch8x4: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SizeSubMbMv  = SZ_8x4
		do
			NbPartitionsToWrite := 2;
			Partition_Mbx[0]    := Mbx + 2* (MbPartIdx&1);
			Partition_Mby[0]    := Mby + 2* ((MbPartIdx>>1)&1) + (SubMbPartIdx&1);
			Partition_Mbx[1]    := Mbx + 2* (MbPartIdx&1) + 1;
			Partition_Mby[1]    := Mby + 2* ((MbPartIdx>>1)&1) + (SubMbPartIdx&1);
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParameters.Launch4x8: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SizeSubMbMv  = SZ_4x8
		do
			NbPartitionsToWrite := 2;
			Partition_Mbx[0]    := Mbx + 2* (MbPartIdx&1) + (SubMbPartIdx&1);
			Partition_Mby[0]    := Mby + 2* ((MbPartIdx>>1)&1);
			Partition_Mbx[1]    := Mbx + 2* (MbPartIdx&1) + (SubMbPartIdx&1);
			Partition_Mby[1]    := Mby + 2* ((MbPartIdx>>1)&1) + 1;
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParameters.Launch4x4: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SizeSubMbMv  = SZ_4x4
		do
			NbPartitionsToWrite := 1;
			Partition_Mbx[0]    := Mbx + 2* (MbPartIdx&1)      + (SubMbPartIdx&1);
			Partition_Mby[0]    := Mby + 2* ((MbPartIdx>>1)&1) + ((SubMbPartIdx>>1)&1);
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParametersFinished: action ==>
		guard
			SubMbPartIdx = SubMbPartIdxMax
		do
			MbPartIdx := MbPartIdx + 1;
		end

	ReadDelList.Launch: action
			DelList:[DelFrame]
				==>
		guard
			DelFrame != SENT_DONE
		do
			foreach int i in 0 .. 15
			do
				if(DelFrame = listFrameNum[i] and i != WriteListIdx)then
					IsReference[i] := false;
				end
			end
		end

	ReadDelList.Done: action
			DelList   :[DelVal],
			Empty_DPB :[EmptyList]
				==>
		guard
			DelVal = SENT_DONE
		do
			if(EmptyList)then
				foreach int i in 0 .. 15
				do
					if(i != WriteListIdx)then
						IsReference[i] := false;
					end
				end
			end
		end

	ReadSizeRefList0: action RefList0 :[SizeRefList] ==>
	do
		Size_RefList := SizeRefList;
		Idx_RefList  := 0;
		refList0     := [-1 : for int i in 0 .. 15];
	end

	ReadRefList0.Launch: action RefList0 :[ValRefList] ==>
	guard
		Idx_RefList < Size_RefList
	do
		refList0[Idx_RefList] := ValRefList;
		Idx_RefList := Idx_RefList + 1;
	end

	ReadRefList0.Done: action ==>
	guard
		Idx_RefList = Size_RefList
	end

	ReadSizeRefList1: action RefList1 :[SizeRefList] ==>
	do
		Size_RefList := SizeRefList;
		Idx_RefList  := 0;
		refList1     := [-1 : for int i in 0 .. 15];
	end

	ReadRefList1.Launch: action RefList1 :[ValRefList] ==>
	guard
		Idx_RefList < Size_RefList
	var
		bool IdxNotFound//Delete me when the bug in Orcc will be solved
	do
		if(Idx_RefList   = 0)then
			ReadListIdx := 0;
			IdxNotFound := (listFrameNum[ReadListIdx] != ValRefList) or (not IsReference[ReadListIdx]);
			while(/*(ListPoc[ReadListIdx] != ValRefList) or (not IsReference[ReadListIdx])*/IdxNotFound and ReadListIdx < 15)
			do
				ReadListIdx := ReadListIdx + 1;
				IdxNotFound := (listFrameNum[ReadListIdx] != ValRefList)  or (not IsReference[ReadListIdx]);
			end
		end
		refList1[Idx_RefList] := ValRefList;
		Idx_RefList := Idx_RefList + 1;
	end

	ReadRefList1.Done: action ==>
	guard
		Idx_RefList = Size_RefList
	end

	ReadLTList: action LongTermList :[LTList] repeat 16 ==>
	do
		colPic_IsShortTermRef := true;
		foreach int i in 0 .. 15
		do
			longTermList[i] := LTList[i];
			if(LTList[i] = listFrameNum[ReadListIdx])then
				colPic_IsShortTermRef := false;
			end
		end
	end

	getMvVectors: action Mv:[mv] repeat 64, RefIdx :[refIdx] repeat 32 ==>
	do
		//Clean me : the actor in mvReconstr should be modified
		uint(size=4) InverseScan4x4Tab[16] =
			[ 0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15 ];

		foreach int numList in 0 .. 1
		do
			foreach int y in 0 .. 3
			do
				foreach int x in 0 .. 3
				do
					refIdxList[WriteListIdx][numList][Mbx+x][Mby+y] :=
						refIdx[numList*16 + InverseScan4x4Tab[y*4+x]];
					mvList[WriteListIdx][numList][Mbx+x][Mby+y][0] :=
						mv[numList*32 + InverseScan4x4Tab[y*4+x]];
					mvList[WriteListIdx][numList][Mbx+x][Mby+y][1] :=
						mv[numList*32 + InverseScan4x4Tab[y*4+x] + 16];
				end
			end
		end
	end

	schedule fsm GetMbType:

		GetMbType          (getNewPic                       )--> ReadSizeRefList0;
		GetMbType          (getMbType                       )--> CheckMbType;

		CheckMbType        (checkMbType.macroBlkIorSI         )--> GetMbType;
		CheckMbType        (checkMbType.B_Skip_B_Direct_16x16 )--> GetMbParameters;
		CheckMbType        (checkMbType.others                )--> GetMbParameters;

		GetMbParameters    (GetMbParameters                 )--> GetMbParameters;
		GetMbParameters    (LaunchGetSubMbParameters        )--> GetSubMbParameters;
		GetMbParameters    (GetMbParametersFinished         )--> GetMvVectors;

		GetMvVectors       (getMvVectors                    )--> GetMbType;

		GetSubMbParameters (GetSubMbParameters              )--> GetSubMbParameters;
		GetSubMbParameters (GetSubMbParametersFinished      )--> GetMbParameters;

		ReadSizeRefList0   (ReadSizeRefList0                 )--> ReadRefList0;
		ReadRefList0       (ReadRefList0.Launch              )--> ReadRefList0;
		ReadRefList0       (ReadRefList0.Done                )--> ReadSizeRefList1;

		ReadSizeRefList1   (ReadSizeRefList1                 )--> ReadRefList1;
		ReadRefList1       (ReadRefList1.Launch              )--> ReadRefList1;
		ReadRefList1       (ReadRefList1.Done                )--> ReadLTList;

		ReadLTList         (ReadLTList                      )--> ReadDelList;

		ReadDelList        (ReadDelList.Launch              )--> ReadDelList;
		ReadDelList        (ReadDelList.Done                )--> GetMbType;
	end
end