/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package org.mpeg4.part10.svc.synParser.modular;

import std.util.BitOps.*;

actor CheckNaluType()
	bool         NewNal,
	uint(size=8) RbspByte
		==>
	uint(size=2) AvcNalRefIdc,
	bool         AvcNewNal,
	uint(size=8) AvcRbsp,
	bool         AvcSlcIsAnIdr,
	uint(size=4) HeadSvcExt,
	uint(size=5) NalUnitType,
	bool         PpsNewNal,
	uint(size=8) PpsRbsp,
	uint(size=2) PrefixNalRefIdc,
	uint(size=8) PrefixRbsp,
	bool         PrefixNewNal,
	bool         SeiNewNal,
	uint(size=8) SeiRbsp,
	bool         SpsNewNal,
	uint(size=8) SpsRbsp,
	uint(size=2) SvcNalRefIdc,
	bool         SvcNewNal,
	uint(size=8) SvcRbsp,
	bool         SvcSlcIsAnIdr
		:


/*
* 
* Constants 
*
*/
	uint(size=5) NAL_SLICE_NON_IDR =  1;
	uint(size=5) NAL_SLICE_IDR     =  5;
	uint(size=5) NAL_SPS           =  7;
	uint(size=5) NAL_PPS           =  8;
	uint(size=5) NAL_PREFIX_NAL    = 14;
	uint(size=5) NAL_SUBSET_SPS    = 15;
	uint(size=5) NAL_SVC_SLICE     = 20;

	bool DEBUG_FLAG_DECODED = false;

/*
* 
* State variables 
*
*/

	uint(size=5) nalUnitType := 0;
	uint(size=2) nalRefIdc   := 0;


/*
* 
* Actions 
*
*/

	waitForNewNal: action NewNal:[IsNewNal], RbspByte:[ValRbsp] ==>
	guard
		IsNewNal = false
	end

	newNalDetected: action NewNal:[IsNewNal] ==>
	guard
		IsNewNal = true
	end

	readNaluType: action NewNal:[IsNewNal], RbspByte:[ValRbsp] ==>
		NalUnitType:[nalUnitType]
	do
		nalUnitType := (ValRbsp & 0x1F);
		nalRefIdc   := (ValRbsp >> 5) & 0x03;
		if(DEBUG_FLAG_DECODED)then
			println("nal_unit_type:"+nalUnitType+"; nalRefIdc:"+nalRefIdc);
		end
	end

	isSps: action ==>
	guard
		(nalUnitType = NAL_SPS) or (nalUnitType = NAL_SUBSET_SPS)
	do
		if(DEBUG_FLAG_DECODED)then
			if(nalUnitType = NAL_SPS) then
				println("Is Sps");
			else
				println("Is SubsetSps");
			end
		end	
	end

	isPps: action ==>
	guard
		nalUnitType = NAL_PPS
	do
		if(DEBUG_FLAG_DECODED)then
			println("Is Pps");
		end	
	end

	isAvcSlice: action ==> AvcSlcIsAnIdr:[isIdrSlice], AvcNalRefIdc:[nalRefIdc]
	guard
		nalUnitType = NAL_SLICE_IDR or nalUnitType = NAL_SLICE_NON_IDR
	do
		bool isIdrSlice = (nalUnitType = NAL_SLICE_IDR);
		
		if(DEBUG_FLAG_DECODED)then
			if(isIdrSlice) then
				println("Is SliceIdr");
			else
				println("Is SliceNonIdr");
			end
		end	
	end

	isSvcSlice: action NewNal:[IsNewNal] repeat 3, RbspByte:[ValRbsp]repeat 3
		==> SvcSlcIsAnIdr:[isIdrSlice], SvcNalRefIdc:[nalRefIdc],
		HeadSvcExt:[headSvcExt] repeat 2
	guard
		nalUnitType = NAL_SVC_SLICE
	do
		bool isIdrSlice = ( (ValRbsp[0]&0x40) != 0 );
		uint(size=4) headSvcExt[2];
		bool idr = ((ValRbsp[0] & 0x40) != 0);
		bool noInterLayPred = ((ValRbsp[1] & 0x80) != 0);
		bool useRefBasePicMark = ((ValRbsp[2] & 0x10) != 0);

		headSvcExt[0] := (ValRbsp[1] & 0x0F);
		headSvcExt[1] := setFlag(noInterLayPred, 0,
			setFlag(useRefBasePicMark, 1, setFlag(idr, 2, 0)));
		if(DEBUG_FLAG_DECODED)then
			if(isIdrSlice) then
				println("Is SliceIdr");
			else
				println("Is SliceNonIdr");
			end
		end	
	end

	isPrefix: action ==> PrefixNalRefIdc:[nalRefIdc]
	guard
		nalUnitType = NAL_PREFIX_NAL
	do
		if(DEBUG_FLAG_DECODED)then
			println("Is Prefix");
		end	
	end

	nalUnitTypeUnknown: action ==>
	guard
		nalUnitType != NAL_SVC_SLICE
	do
		if(DEBUG_FLAG_DECODED)then
			println("NalUnitType_Unknown");
		end
	end

	sps.readData: action NewNal:[IsNewNal], RbspByte:[ValRbsp] ==>
		SpsNewNal:[false], SpsRbsp:[ValRbsp]
	guard
		IsNewNal = false
	end

	sps.endOfNal: action NewNal:[IsNewNal] ==> SpsNewNal:[true]
	guard
		IsNewNal = true
	end

	pps.readData: action NewNal:[IsNewNal], RbspByte:[ValRbsp] ==>
		PpsNewNal:[false], PpsRbsp:[ValRbsp]
	guard
		IsNewNal = false
	end

	pps.endOfNal: action NewNal:[IsNewNal] ==> PpsNewNal:[true]
	guard
		IsNewNal = true
	end

	avcSlice.readData: action NewNal:[IsNewNal], RbspByte:[ValRbsp] ==>
		AvcNewNal:[false], AvcRbsp:[ValRbsp]
	guard
		IsNewNal = false
	end

	avcSlice.endOfNal: action NewNal:[IsNewNal] ==> AvcNewNal:[true]
	guard
		IsNewNal = true
	end

	prefix.readData: action NewNal:[IsNewNal], RbspByte:[ValRbsp] ==>
		PrefixNewNal:[false], PrefixRbsp:[ValRbsp]
	guard
		IsNewNal = false
	end

	prefix.endOfNal: action NewNal:[IsNewNal] ==> PrefixNewNal:[true]
	guard
		IsNewNal = true
	end

	svcSlice.readData: action NewNal:[IsNewNal], RbspByte:[ValRbsp] ==>
		SvcNewNal:[false], SvcRbsp:[ValRbsp]
	guard
		IsNewNal = false
	end

	svcSlice.endOfNal: action NewNal:[IsNewNal] ==> SvcNewNal:[true]
	guard
		IsNewNal = true
	end

	schedule fsm WaitForNewNal:
		WaitForNewNal (waitForNewNal  )--> WaitForNewNal;
		WaitForNewNal (newNalDetected )--> ReadNaluType;

		ReadNaluType (readNaluType )--> CheckNaluType;

		CheckNaluType (isAvcSlice          )--> ReadDataAvc;
		CheckNaluType (isSvcSlice          )--> ReadDataSvc;
		CheckNaluType (isSps               )--> ReadData4Sps;
		CheckNaluType (isPps               )--> ReadData4Pps;
//		CheckNaluType (isSei               )--> undefined;
		CheckNaluType (isPrefix            )--> ReadDataPrefix;
		CheckNaluType (nalUnitTypeUnknown )--> WaitForNewNal;

		ReadData4Sps (sps.readData )--> ReadData4Sps;
		ReadData4Sps (sps.endOfNal )--> ReadNaluType;

		ReadData4Pps (pps.readData )--> ReadData4Pps;
		ReadData4Pps (pps.endOfNal )--> ReadNaluType;

		ReadDataAvc (avcSlice.readData )--> ReadDataAvc;
		ReadDataAvc (avcSlice.endOfNal )--> ReadNaluType;

		ReadDataPrefix (prefix.readData )--> ReadDataPrefix;
		ReadDataPrefix (prefix.endOfNal )--> ReadNaluType;

		ReadDataSvc (svcSlice.readData )--> ReadDataSvc;
		ReadDataSvc (svcSlice.endOfNal )--> ReadNaluType;
	end
	priority
		isSvcSlice        > isAvcSlice > isPps  >  isSps;
		isSps             > isPrefix   > nalUnitTypeUnknown;
		sps.readData      > sps.endOfNal;
		pps.readData      > pps.endOfNal;
		avcSlice.readData > avcSlice.endOfNal;
		prefix.readData   > prefix.endOfNal;
	end
end