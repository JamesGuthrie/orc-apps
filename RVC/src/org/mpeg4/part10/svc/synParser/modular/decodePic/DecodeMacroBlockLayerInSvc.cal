/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>

package org.mpeg4.part10.svc.synParser.modular.decodePic;

import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import org.mpeg4.part10.cbp.MacroBlockInfo.*;

actor DecodeMacroBlockLayerInSvc()
	int (size=32) ValVLD
		==>
	int (size=6)  TypeOfVLD,
	int (size=32) VLDParam
		:

	uint(size=4) SLICE_TYPE_P  = 0;
	uint(size=4) SLICE_TYPE_B  = 1;
	uint(size=4) SLICE_TYPE_I  = 2;
	uint(size=4) SLICE_TYPE_SP = 3;
	uint(size=4) SLICE_TYPE_SI = 4;

	uint(size=4) SLICE_TYPE_EI  = 2;

	uint(size=6) VLD_ME_TABLE[4][48][2] =
		[
			[[15, 0], [ 0, 1], [ 7, 2], [11, 4], [13, 8], [14, 3], [ 3, 5], [ 5,10], [10,12], [12,15],
			 [ 1, 7], [ 2,11], [ 4,13], [ 8,14], [ 6, 6], [ 9, 9], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0],
			 [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0],
			 [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0],
			 [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]
			],
			[[47, 0], [31,16], [15, 1], [ 0, 2], [23, 4], [27, 8], [29,32], [30, 3], [ 7, 5], [11, 10],
			 [13,12], [14,15], [39,47], [43, 7], [45,11], [46,13], [16,14], [ 3, 6], [ 5, 9], [10,31],
			 [12,35], [19,37], [21,42], [26,44], [28,33], [35,34], [37,36], [42,40], [44,39], [ 1,43],
			 [ 2,45], [ 4,46], [ 8,17], [17,18], [18,20], [20,24], [24,19], [ 6,21], [ 9,26], [22,28],
			 [25,23], [32,27], [33,29], [34,30], [36,22], [40,25], [38,38], [41,41]
			],
			[[47, 0], [31,16], [15, 1], [ 0, 2], [23, 4], [27, 8], [29,32], [30, 3], [ 7, 5], [11, 10],
			 [13,12], [14,15], [39,47], [43, 7], [45,11], [46,13], [16,14], [ 3, 6], [ 5, 9], [10,31],
			 [12,35], [19,37], [21,42], [26,44], [28,33], [35,34], [37,36], [42,40], [44,39], [ 1,43],
			 [ 2,45], [ 4,46], [ 8,17], [17,18], [18,20], [20,24], [24,19], [ 6,21], [ 9,26], [22,28],
			 [25,23], [32,27], [33,29], [34,30], [36,22], [40,25], [38,38], [41,41]
			],
			[[15, 0], [ 0, 1], [ 7, 2], [11, 4], [13, 8], [14, 3], [ 3, 5], [ 5,10], [10,12], [12,15],
			 [ 1, 7], [ 2,11], [ 4,13], [ 8,14], [ 6, 6], [ 9, 9], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0],
			 [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0],
			 [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0],
			 [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]
			]
		];

	bool         adaptivBaseMode; // !!!!!!
	bool         adaptResidualPred; // !!!!!!!!
	bool         transform8x8Mode;//!!!!!!!!
	bool         baseMode;
	uint(size=4) bitDepthChroma;// !!!!!!!!!!!!
	uint(size=2) chromaArrayType; //!!!!!!!!!!
	uint(size=9) chromaReadIdx;
	uint(size=9) chromaWriteIdx;
	uint(size=6) codedBlkPattern;// init is missing
	uint(size=6) codedBlkPatternLuma;// init is missing
	uint(size=6) codedBlkPatternChrom;// init is missing
	bool         direct8x8Inference;//!!!!!!!!!
	uint(size=6) mbType;
	bool         noSubMbPtSzLssThn8x8; // true init is missing
	uint(size=9) nbCoeffChroma;//!!!!!!!!!!!!!!
	uint(size=4) scanIdxEnd; // !!!!!!!
	uint(size=4) scanIdxStart; // !!!!!!!
	uint(size=4) sliceType;//!!!!!!!!!!!!!!

	//Not implemented yet !!
	function inCropWindow(uint(size=13) currMbAddress) --> bool :
		currMbAddress != 42
	end

	askBaseMode: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		inCropWindow(42) and adaptivBaseMode
	end

	getBaseMode: action ValVLD:[baseModeFlag] ==>
	do
		baseMode := (baseModeFlag != 0);
	end

	askMbType: action ==> TypeOfVLD:[VLD_UE]
	guard
		baseMode
	end

	getMbType: action ValVLD:[ValueOfVLD] ==>
	do
		mbType :=
				if((sliceType = SLICE_TYPE_SI) or (sliceType = SLICE_TYPE_I))then
					ValueOfVLD
				else
					if((sliceType = SLICE_TYPE_SP) or (sliceType = SLICE_TYPE_P))then
						if(ValueOfVLD >= 5) then
							if(ValueOfVLD < 31)then
								ValueOfVLD - 5
							else
								0
							end
						else
							ValueOfVLD + BLOCK_TYPE_P_MIN
						end
					else
						if(ValueOfVLD < 23) then
							ValueOfVLD + BLOCK_TYPE_B_MIN
						else
							if(ValueOfVLD < 49) then
								ValueOfVLD - 23
							else
								0
							end
						end
					end
				end;
	end

	askAlignByte: action ==> TypeOfVLD:[BYTE_ALIGNED_REQUIRED]
	guard
		baseMode and mbType = BLOCK_TYPE_I_PCM
	end

	askPcmSampleLuma: action ==> TypeOfVLD:[[READ_BITS : for int s in 0 .. 255]] repeat 256,
		VLDParam:[[bitDepthChroma : for int s in 0 .. 255]] repeat 256
	end

	getPcmSampleLuma: action ValVLD:[lumaPcm] repeat 256 ==>
	do
		chromaReadIdx  := 0;
		chromaWriteIdx := 0;
	end
	
	askPcmSampleChroma: action ==> TypeOfVLD:[READ_BITS], VLDParam:[bitDepthChroma]
	guard
		chromaWriteIdx < nbCoeffChroma
	do
		chromaWriteIdx  := chromaWriteIdx + 1;
	end
	
	getPcmSampleChroma.launch: action ValVLD:[ValueOfVLD] ==>
	guard
		chromaReadIdx < chromaWriteIdx
	do
		chromaReadIdx := chromaReadIdx + 1;
	end
	
	getPcmSampleChroma.done: action ==>
	guard
		chromaReadIdx = nbCoeffChroma
	end

	subMbPred.launch: action ==> TypeOfVLD:[LAUNCH_ACTOR],
		VLDParam:[SUB_MB_PRED]
	guard
		not baseMode and NumMbPart(mbType) = 4
	end

	checkSubMbType: action /*SubMbType :[subMbType] repeat 4*/ ==>
	do
		uint(size=4) subMbType [4]; // !!!!

		if(sliceType = SLICE_TYPE_B) then
			foreach int mbPartIdx in 0 .. 3
			do	//if(sub_mb_type != B_DIRECT_8x8
			    // && NumSubMbPart(sub_mb_type) > 1)
				if(subMbType[mbPartIdx] > 3)then
					noSubMbPtSzLssThn8x8 := false;
				else//if(sub_mb_type = B_DIRECT_8x8
					// && !direct_8x8_inference_flag)
					if((subMbType[mbPartIdx] = 0) and (not direct8x8Inference))then
						noSubMbPtSzLssThn8x8 := false;
					end
				end
			end
		else
			//if(sub_mb_type != B_DIRECT_8x8)
			if((sliceType = SLICE_TYPE_P) or (sliceType = SLICE_TYPE_SP))then
				foreach int mbPartIdx in 0 .. 3
				do  //if(NumSubMbPart(sub_mb_type) > 1)
					if(subMbType[mbPartIdx] != 0)then
						noSubMbPtSzLssThn8x8 := false;
					end
				end
			end
		end
	end

	askTransfSize8x8: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		transform8x8Mode and mbType = BLOCK_TYPE_I_NxN
	end

	getTransfSize8x8: action ValVLD:[transfSz8x8] ==>
	end

	LaunchMbPred: action ==> TypeOfVLD:[LAUNCH_ACTOR], VLDParam:[MB_PRED_SVC]
	end

	askResidualPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		adaptResidualPred and sliceType != SLICE_TYPE_EI and
		(baseMode or (not Mb_IsIntra(mbType) and inCropWindow(42)))
	end

	getResidualPred: action ValVLD:[residualPrediction] ==>
	end


	askCodedBlkPattern: action ==> TypeOfVLD:[VLD_UE]
	guard
		(scanIdxEnd >= scanIdxStart) and
		(baseMode or not(Is_Intra_16x16(mbType)))
	end

	getCodeBlkPattern: action ValVLD :[CodeNum] ==>
	do
		codedBlkPattern :=
			if( mbType = BLOCK_TYPE_I_NxN)then
				VLD_ME_TABLE[chromaArrayType][CodeNum][0]
			else
				VLD_ME_TABLE[chromaArrayType][CodeNum][1]
			end;
		codedBlkPatternLuma   := codedBlkPattern mod 16;
		codedBlkPatternChrom  := codedBlkPattern  /  16;
	end

	askTransfSize8x8Flag: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		(codedBlkPatternLuma > 0) and transform8x8Mode,
		baseMode or (mbType != BLOCK_TYPE_I_NxN and noSubMbPtSzLssThn8x8
		  and (mbType != BLOCK_TYPE_B_DIRECT_16x16 or direct8x8Inference))
	end

	getTransfSize8x8Flage: action ValVLD:[transfSize8x8] ==>
	end

	askMbQpDelta: action ==> TypeOfVLD:[VLD_SE]
	guard
		scanIdxEnd >= scanIdxStart,
	   (codedBlkPatternLuma   > 0) or (codedBlkPatternChrom > 0)
		or not baseMode and Is_Intra_16x16(mbType)
	end

	getMbQpDelta: action ValVLD:[mbQpDelta] ==>
	end

	LaunchResidual: action ==> TypeOfVLD:[LAUNCH_ACTOR], VLDParam:[RESIDUAL]
	end

end