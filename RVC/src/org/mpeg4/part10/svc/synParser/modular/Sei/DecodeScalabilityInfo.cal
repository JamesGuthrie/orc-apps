/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its contributors may be used 
 *     to endorse or promote products derived from this software without specific 
 *     prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
 /**
 * This actor get the scalability informations.
 * 
 * @input ValVLD
 * 		Result of the entropy decoding
 * 
 * @output TypeOfVLD, VLD_Param
 *		Information given in order to realize the entropy decoding
 * 
 * @see implements the table located in 7.3.2.3, 7.3.2.3.1 and D.1 in the SVC
 *      standard
 *  
 * @author : Damien de Saint Jorre
 */
 
package org.mpeg4.part10.svc.synParser.modular.Sei;

import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;

actor DecodeScalabilityInfo()
	int (size=32) ValVLD
		==>
	int (size=6)  TypeOfVLD,
	int (size=32) VLD_Param
		:

	bool          bitrateInfoPres;
	bool          bitstrmRestrInfoPres;
	bool          dynamicRect;
	bool          frmRateInfoPres;
	bool          frmSizeInfoPres;
	uint(size=12) iLoop;
	uint(size=12) jLoop;
	bool          iroiDivInfoPres;
	bool          layerConversion;
	bool          layerDependInfoPres;
	uint(size=8)  numDirectlyDependLay;
	uint(size=12) numLayer;
	uint(size=5)  numPps;
	uint(size=12) numRoi;
	uint(size=5)  numSubSps;
	uint(size=5)  numSps;
	bool          paramSetInfoPres;
	bool          priorityIdSetting;
	bool          priorityLayInfoPres;
	uint(size=12) prNum;
	uint(size=12) prNumDId;
	bool          profileLvlInfoPres;
	bool          rewritingInfo;
	bool          subPicLayer;
	bool          subRegionLayer;

	askTemporalId: action ==>TypeOfVLD:[READ_BITS, READ_BITS, READ_BITS,
		VLD_UE], VLD_Param :[1, 1, 1]
	end

	getTemporalId: action ValVLD:[temporalId, priorityLayer, priorityId,
		numLayerMinus1] ==>
	do
		priorityLayInfoPres := (priorityLayer != 0);
		priorityIdSetting   := (priorityId != 0);
		numLayer := numLayerMinus1 + 1;
		iLoop := 0;
	end

	askLayerId: action ==> TypeOfVLD:[VLD_UE, READ_BITS, READ_BITS, READ_BITS,
		READ_BITS, READ_BITS, READ_BITS, READ_BITS, READ_BITS, READ_BITS,
		READ_BITS, READ_BITS, READ_BITS, READ_BITS, READ_BITS, READ_BITS,
		READ_BITS], VLD_Param:[6, 1, 3, 4, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
	guard
		iLoop < numLayer
	end

	getLayerId: action ValVLD:[layerId, priorId, discardableFlag, dependencyId,
		qualityId, temporalId, subPicLayerFlag, subRegionLayerFlag,
		iroiDivisionFlag, profileLevelFlag, bitrateInfoFlag, frmRateFlag,
		frmSizeFlag, layerDependFlag, parameterSetsFlag,
		bitstreamRestrictionFlag, exactInterFlag] ==>
	do
		subPicLayer     := (subPicLayerFlag  != 0);
		subRegionLayer  := (subRegionLayerFlag != 0);
		iroiDivInfoPres := (iroiDivisionFlag != 0);
		profileLvlInfoPres   := (profileLevelFlag != 0);
		bitrateInfoPres      := (bitrateInfoFlag != 0);
		frmRateInfoPres      := (frmRateFlag != 0);
		frmSizeInfoPres      := (frmSizeFlag != 0);
		layerDependInfoPres  := (layerDependFlag != 0);
		paramSetInfoPres     := (parameterSetsFlag != 0);
		bitstrmRestrInfoPres := (bitstreamRestrictionFlag != 0);
	end

	askExactSample: action ==> TypeOfVLD:[READ_BITS], VLD_Param:[1]
	guard
		subPicLayer or iroiDivInfoPres
	end

	getExactSample: action ValVLD:[exactSampleValueMatchFlag] ==>
	end

	askLayerConversion: action ==> TypeOfVLD:[READ_BITS, READ_BITS],
		VLD_Param:[1, 1]
	end

	getLayerConversion: action ValVLD:[layerConversionFlag, layerOutputFlag]
		==>
	do
		layerConversion := (layerConversionFlag != 0);
	end

	askLayerProfil: action ==> TypeOfVLD:[READ_BITS], VLD_Param:[24]
	guard
		profileLvlInfoPres
	end

	getLayerProfil: action ValVLD:[layerProfLvlIdc] ==>
	end

	askAvgBitrate: action ==> TypeOfVLD:[READ_BITS, READ_BITS, READ_BITS, READ_BITS], VLD_Param:[16, 16, 16, 16]
	guard
		bitrateInfoPres
	end

	getAvgBitrate: action ValVLD:[avgBitrate, maxBitrateLayer,
		maxBitrateLayRepr, maxBitrateCalc] ==>
	end

	askConstantFrm: action ==> TypeOfVLD:[READ_BITS, READ_BITS],
		VLD_Param:[2, 16]
	guard
		frmRateInfoPres
	end

	getConstantFrm: action ValVLD:[constFrameRateIdc, avgFrameRate] ==>
	end

	conditions.areFalse:action ==>
	end

	askFrmWidth: action ==> TypeOfVLD:[VLD_UE, VLD_UE]
	guard
		frmSizeInfoPres or iroiDivInfoPres
	end

	getFrmWidth: action ValVLD:[frmWith, frmHeight] ==>
	end

	askBaseRegion: action ==> TypeOfVLD:[VLD_UE, READ_BITS], VLD_Param:[1]
	end

	getBaseRegion: action ValVLD:[baseRegionLayer, dynamicRectFlag] ==>
	do
		dynamicRect := (dynamicRectFlag != 0);
	end

	askHorizOff: action ==> TypeOfVLD:[READ_BITS, READ_BITS, READ_BITS,
		READ_BITS], VLD_Param:[16, 16, 16, 16]
	guard
		dynamicRect
	end

	getHorizOff: action ValVLD:[horizontalOff, verticalOff, regionWidth,
		regionHeight] ==>
	end

	askRoiId: action ==> TypeOfVLD:[VLD_UE]
	guard
		subPicLayer
	end

	getRoiId: action ValVLD:[roiId] ==>
	end

	askIroiGrid: action ==> TypeOfVLD:[READ_BITS], VLD_Param:[1]
	guard
		iroiDivInfoPres
	end

	askGridWidth: action ValVLD:[iroiGrid] ==> TypeOfVLD:[VLD_UE, VLD_UE]
	guard
		iroiGrid != 0
	end

	getGridWidth: action ValVLD:[gridWidthMinus1, gridHeightMinus1] ==>
	end

	askNumRoi: action ValVLD:[iroiGrid] ==> TypeOfVLD:[VLD_UE]
	end

	getNumRoi: action ValVLD:[numRoiMinus1] ==>
	do
		numRoi := numRoiMinus1 + 1;
		jLoop  := 0;
	end

	askFirstMbInRoi: action ==> TypeOfVLD:[VLD_UE, VLD_UE, VLD_UE]
	guard
		jLoop < numRoi
	end

	getFirstMbInRoi: action ValVLD:[firstMbInRoi, roiWidthMinus1,
		roiHeightMinus1] ==>
	do
		jLoop := jLoop + 1;
	end

	askNumDirDependLay: action ==> TypeOfVLD:[VLD_UE]
	guard
		layerDependInfoPres
	end

	getNumDirDependLay: action ValVLD:[NumDirDepLay] ==>
	do
		numDirectlyDependLay := NumDirDepLay;
		jLoop := 0;
	end

	askDirDepLayId: action ==> TypeOfVLD:[VLD_UE]
	guard
		jLoop < numDirectlyDependLay
	end

	endJLoop: action ==>
	end

	getDirDepLayId: action ValVLD:[dirDepLayId] ==>
	do
		jLoop := jLoop + 1;
	end

	askLayDepInfo: action ==> TypeOfVLD:[VLD_UE]
	end

	getLayDepInfo: action ValVLD:[layerDependInfoSrc] ==>
	end

	askNumSps: action ==> TypeOfVLD:[VLD_UE]
	guard
		paramSetInfoPres
	end

	getNumSps: action ValVLD:[numSpsMinus1] ==>
	do
		numSps := numSpsMinus1 + 1;
		jLoop  := 0;
	end

	askSpsIdDelta: action ==> TypeOfVLD:[VLD_UE]
	guard
		jLoop < numSps
	end

	getSpsIdDelta: action ValVLD:[spsIdDelta] ==>
	do
		jLoop := jLoop + 1;
	end

	askNumSubSps: action ==> TypeOfVLD:[VLD_UE]
	end

	getNumSubSps: action ValVLD:[numSubSpsMinus1] ==>
	do
		numSubSps := numSubSpsMinus1 + 1;
		jLoop := 0;
	end

	askSubSpsIdDelta: action ==> TypeOfVLD:[VLD_UE]
	guard
		jLoop < numSubSps
	end

	getSubSpsIdDelta: action ValVLD:[subSpsIdDelta] ==>
	do
		jLoop := jLoop + 1;
	end

	askNumPps: action ==> TypeOfVLD:[VLD_UE]
	end

	getNumPps: action ValVLD:[numPpsMinus1] ==>
	do
		numPps := numPpsMinus1 + 1;
		jLoop  := 0;
	end

	askPpsIdDelta: action ==> TypeOfVLD:[VLD_UE]
	guard
		jLoop < numPps
	end

	getPpsIdDelta: action ValVLD:[ppsIdDelta] ==>
	do
		jLoop := jLoop + 1;
	end

	askParameterSetInfo: action ==> TypeOfVLD:[VLD_UE]
	end

	getParameterSetInfo: action ValVLD:[paramSetInfoSrc] ==>
	end

	askMotionVectOverPic: action ==> TypeOfVLD:[READ_BITS, VLD_UE, VLD_UE,
		VLD_UE, VLD_UE, VLD_UE, VLD_UE], VLD_Param:[1]
	guard
		bitstrmRestrInfoPres
	end

	getMotionVectOverPic: action ValVLD:[motVectOvPic, maxBytesPerPic,
		maxMbPerMb, log2MaxMvHor, log2MaxMvVert, NumReordFrm, maxDecFrmBuf] ==>
	end

	askConvTypeIdc: action ==> TypeOfVLD:[VLD_UE]
	guard
		layerConversion
	end

	getConvTypeIdc: action ValVLD:[convTypeIdc] ==>
	do
		jLoop := 0;
	end

	askRewritInfo: action ==> TypeOfVLD:[READ_BITS], VLD_Param:[1]
	guard
		jLoop < 2
	end

	getRewritInfo: action ValVLD:[rewritInfoFlag] ==>
	do
		rewritingInfo := (rewritInfoFlag != 0);
	end

	askRewritProfil.launch: action ==> TypeOfVLD:[READ_BITS, READ_BITS, READ_BITS],
		VLD_Param:[24, 16, 16]
	guard
		rewritingInfo
	end

	getRewritProfil: action ValVLD:[rewritProfil, rewritAvg, rewritMaxBitrate] ==>
	end

	askRewritProfil.skip: action ==>
	do
		jLoop := jLoop + 1;
	end

	incILoop: action ==>
	do
		iLoop := iLoop + 1;
	end

	askPrNumDId: action ==> TypeOfVLD:[VLD_UE]
	guard
		priorityLayInfoPres
	end

	getPrNumDId: action ValVLD:[prNumDIdMinus1] ==>
	do
		prNumDId := prNumDIdMinus1 + 1;
		iLoop := 0;
	end

	askPrDepId: action ==> TypeOfVLD:[READ_BITS, VLD_UE], VLD_Param:[3]
	guard
		iLoop < prNumDId
	end

	getPrDepId: action ValVLD:[prDepId, prNumMinus1] ==>
	do
		prNum := prNumMinus1 + 1;
		jLoop := 0;
	end

	askPrId: action ==> TypeOfVLD:[VLD_UE, READ_BITS, READ_BITS, READ_BITS],
		VLD_Param:[24, 16, 16]
	guard
		jLoop < prNum
	end

	getPrId: action ValVLD:[prId, prProfLvlIdc, prAvg, prMaxBitrate] ==>
	do
		jLoop := jLoop + 1;
	end

	askPriorIdSetting: action ==> TypeOfVLD:[READ_BITS], VLD_Param:[8]
	guard
		priorityIdSetting
	end

	whileLoop.continue: action ValVLD:[priorIdSettingUri] ==> TypeOfVLD:[READ_BITS], VLD_Param:[8]
	guard
		priorIdSettingUri != 0
	end

	whileLoop.stop: action ValVLD:[priorIdSettingUri] ==>
	guard
		priorIdSettingUri = 0
	end

	endDecodeScalInfo: action ==> TypeOfVLD:[SKIP_NAL]
	end

	schedule fsm AskTemporalId:
		AskTemporalId     (askTemporalId     )--> GetTemporalId;
		GetTemporalId     (getTemporalId     )--> CheckLoopNumLayer;
		CheckLoopNumLayer (askLayerId        )--> GetLayerId;
		CheckPriorLayInfo (askPrNumDId       )--> GetPrNumDId;
		CheckPriorLayInfo (askPriorIdSetting )--> CheckWhileLoop;
		CheckPriorLayInfo (endDecodeScalInfo )--> AskTemporalId;

		GetLayerId       (getLayerId         )--> CheckSubPicLayer;
		CheckSubPicLayer (askExactSample     )--> GetExactSample;
		CheckSubPicLayer (askLayerConversion )--> GetLayerConversion;

		GetExactSample     (getExactSample     )--> AskLayerConversion;
		AskLayerConversion (askLayerConversion )--> GetLayerConversion;
	
		GetLayerConversion (getLayerConversion    )--> CheckProfilLvlInfo;
		CheckProfilLvlInfo (askLayerProfil        )--> GetLayerProfil;
		CheckProfilLvlInfo (askAvgBitrate         )--> GetAvgBitrate;
		CheckProfilLvlInfo (askConstantFrm        )--> GetConstantFrm;
		CheckProfilLvlInfo (conditions.areFalse )--> CheckFrmSize;

		GetLayerProfil       (getLayerProfil        )--> CheckBitrateInfoPres;
		CheckBitrateInfoPres (askAvgBitrate         )--> GetAvgBitrate;
		CheckBitrateInfoPres (askConstantFrm        )--> GetConstantFrm;
		CheckBitrateInfoPres (conditions.areFalse )--> CheckFrmSize;

		GetAvgBitrate    (getAvgBitrate         )--> CheckFrmRateInfo;
		CheckFrmRateInfo (askConstantFrm        )--> GetConstantFrm;
		CheckFrmRateInfo (conditions.areFalse )--> CheckFrmSize;

		GetConstantFrm (getConstantFrm        )--> CheckFrmSize;
		CheckFrmSize   (askFrmWidth           )--> GetFrmWidth;
		CheckFrmSize   (askBaseRegion         )--> GetBaseRegion;
		CheckFrmSize   (askRoiId              )--> GetRoiId;
		CheckFrmSize   (conditions.areFalse )--> CheckIroiDivision;

		GetFrmWidth    (getFrmWidth           )--> CheckSubRegion;
		CheckSubRegion (askBaseRegion         )--> GetBaseRegion;
		CheckSubRegion (askRoiId              )--> GetRoiId;
		CheckSubRegion (conditions.areFalse )--> CheckIroiDivision;

		GetBaseRegion    (getBaseRegion         )--> CheckDynamicRect;
		CheckDynamicRect (askHorizOff           )--> GetHorizOff;
		CheckDynamicRect (askRoiId              )--> GetRoiId;
		CheckDynamicRect (conditions.areFalse )--> CheckIroiDivision;

		GetHorizOff    (getHorizOff           )--> CheckSubPicLay;
		CheckSubPicLay (askRoiId              )--> GetRoiId;
		CheckSubPicLay (conditions.areFalse )--> CheckIroiDivision;

		GetRoiId          (getRoiId           )--> CheckIroiDivision;
		CheckIroiDivision (askIroiGrid        )--> CheckIroiGrid;
		CheckIroiDivision (askNumDirDependLay )--> GetNumDirDependLay;
		CheckIroiDivision (askLayDepInfo      )--> GetLayDepInfo;

		CheckIroiGrid (askGridWidth )--> GetGridWidth;
		CheckIroiGrid (askNumRoi    )--> GetNumRoi;

		GetNumRoi       (getNumRoi          )--> AskFirstMbInRoi;
		AskFirstMbInRoi (askFirstMbInRoi    )--> GetFirstMbInRoi;
		AskFirstMbInRoi (askNumDirDependLay )--> GetNumDirDependLay;
		AskFirstMbInRoi (askLayDepInfo      )--> GetLayDepInfo;

		GetFirstMbinRoi (getFirstMbInRoi    )--> AskFirstMbInRoi;

		GetGridWidth      (getGridWidth       )--> CheckLayerDepInfo;
		CheckLayerDepInfo (askNumDirDependLay )--> GetNumDirDependLay;
		CheckLayerDepInfo (askLayDepInfo      )--> GetLayDepInfo;

		GetNumDirDependLay (getNumDirDependLay )--> AskDirDepLayId;
		AskDirDepLayId     (askDirDepLayId     )--> GetDirDepLayId;
		AskDirDepLayId     (endJLoop           )--> CheckParamSetsInfo;

		GetDirDepLayId (getDirDepLayId )--> AskDirDepLayId;

		GetLayDepInfo      (getLayDepInfo       )--> CheckParamSetsInfo;
		CheckParamSetsInfo (askNumSps           )--> GetNumSps;
		CheckParamSetsInfo (askParameterSetInfo )--> GetParameterSetInfo;

		GetNumSps     (getNumSps     )--> AskSpsIdDelta;
		AskSpsIdDelta (askSpsIdDelta )--> GetSpsIdDelta;
		AskSpsIdDelta (askNumSubSps  )--> GetNumSubSps;

		GetSpsIdDelta (getSpsIdDelta )--> AskSpsIdDelta;

		GetNumSubSps     (getNumSubSps     )--> AskSubSpsIdDelta;
		AskSubSpsIdDelta (askSubSpsIdDelta )--> GetSubSpsIdDelta;
		AskSubSpsIdDelta (askNumPps        )--> GetNumPps;

		GetSubSpsIdDelta (getSubSpsIdDelta )--> AskSubSpsIdDelta;

		GetNumPps     (getNumPps     )--> AskPpsIdDelta;
		AskPpsIdDelta (askPpsIdDelta )--> GetPpsIdDelta;
		AskPpsIdDelta (endJLoop      )--> CheckBitstreamRestr;

		GetParameterSetInfo (getParameterSetInfo )--> CheckBitstreamRestr;

		CheckBitstreamRestr (askMotionVectOverPic )--> GetMotionVectOverPic;
		CheckBitstreamRestr (askConvTypeIdc       )--> GetConvTypeIdc;
		CheckBitstreamRestr (incILoop             )--> CheckLoopNumLayer;

		GetMotionVectOverPic (getMotionVectOverPic )--> CheckLayerConv;
		CheckLayerConv       (askConvTypeIdc       )--> GetConvTypeIdc;
		CheckLayerConv       (incILoop             )--> CheckLoopNumLayer;

		GetConvTypeIdc (getConvTypeIdc )--> AskRewritInfo;
		AskRewritInfo  (askRewritInfo  )--> GetRewritInfo;
		AskRewritInfo  (incILoop       )--> CheckLoopNumLayer;

		GetRewritInfo   (getRewritInfo          )--> CheckRewritInfo;
		CheckRewritInfo (askRewritProfil.launch )--> GetRewritProfil;
		CheckRewritInfo (askRewritProfil.skip   )--> AskRewritInfo;

		GetRewritProfil (getRewritProfil )--> AskRewritInfo;

		GetPrNumDId (getPrNumDId       )--> AskPrDepId;
		AskPrDepId  (askPrDepId        )--> GetPrDepId;
		AskPrDepId  (askPriorIdSetting )--> CheckWhileLoop;
		AskPrDepId  (endDecodeScalInfo )--> AskTemporalId;

		GetPrDepId (getPrDepId )--> AskPrId;
		AskPrId    (askPrId    )--> GetPrId;
		AskPrId    (incILoop   )--> AskPrDepId;

		GetPrId (getPrId )--> AskPrId;

		CheckWhileLoop (whileLoop.continue )--> CheckWhileLoop;
		CheckWhileLoop (whileLoop.stop     )--> EndDecodeScalInfo;

		EndDecodeScalInfo (endDecodeScalInfo )--> AskTemporalId;
	end
	priority
		askLayerId       > askPrNumDId > askPriorIdSetting > endDecodeScalInfo;
		askExactSample   > askLayerConversion;
		askLayerProfil   > askAvgBitrate > askConstantFrm > conditions.areFalse;
		askFrmWidth      > askBaseRegion > askRoiId       > conditions.areFalse;
		askHorizOff      > askRoiId;
		askIroiGrid      > askNumDirDependLay > askLayDepInfo;
		askGridWidth     > askNumRoi;
		askFirstMbInRoi  > askNumDirDependLay;
		askDirDepLayId   > endJLoop;
		askNumSps        > askParameterSetInfo;
		askSpsIdDelta    > askNumSubSps;
		askSubSpsIdDelta > askNumPps;
		askPpsIdDelta    > endJLoop;
		askMotionVectOverPic > askConvTypeIdc;
		askConvTypeIdc   > incILoop;
		askRewritInfo    > incILoop;
		askRewritProfil.launch > askRewritProfil.skip;
		askPrDepId       > askPriorIdSetting;
		askPrId          > incILoop;
	end
end