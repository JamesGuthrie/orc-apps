/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package org.mpeg4.part10.svc.synParser.modular.decodePic;

import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import std.util.BitOps.*;

actor DecodeSliceHeaderPart2()
	uint(size=32) Header1Param,
	uint(size=4)  HeadSvcExt,
	int (size=32) PpsParameters,
	uint(size=2)  SpsExtParam,
	uint(size=32) SpsParameters,
	int (size=32) ValVLD
		==>
	int (size=6)  TypeOfVLD,
	int (size=32) VLDParam
		:

	uint(size=4) SLICE_TYPE_EI  = 2;

	bool          adaptBaseMode;
	bool          adaptMotionPred;
	bool          adaptResidualPred;
	bool          adaptTcoeffLvlPred;
	uint(size=2)  chromaArrayType;
	bool          deblockFiltCtrlPres;
	bool          defaultBaseMode;
	uint(size=2)  disDeblocFiltIdc;
	uint(size=3)  disIntLayDbfIdc;
	bool          entropyCodingMode;
	uint(size=2)  extSpatScal;
	bool          intLayDbfCtrlPres;
	bool          noInterLayPred;
	uint(size=4)  numSliceGrp;
	uint(size=4)  qualityId;
	bool          slcHeadRestr;
	uint(size=3)  slcGrpMapType;
	bool          sliceSkip;
	uint(size=4)  sliceType;
	uint(size=32) szSlcGrpChgCycle;

	getParameters: action Header1Param:[header1Param] repeat 3,
		HeadSvcExt:[headSvcExt] repeat 2, PpsParameters:[ppsParam] repeat 5,
		SpsParameters:[spsParam] repeat 9, SpsExtParam:[spsExtParam] repeat 2
		==>
	do
		sliceType := header1Param[0];
		qualityId := headSvcExt[0];
		noInterLayPred := getFlag(headSvcExt[1],0);
		numSliceGrp         := ppsParam[0];
		szSlcGrpChgCycle    := ppsParam[2];
		slcGrpMapType       := ppsParam[3];
		deblockFiltCtrlPres := getFlag(ppsParam[4],0);
		entropyCodingMode   := getFlag(ppsParam[4],3);
		chromaArrayType     := spsParam[2];
		extSpatScal         := spsExtParam[0];
		intLayDbfCtrlPres   := getFlag(spsExtParam[1],0);
		adaptTcoeffLvlPred  := getFlag(spsExtParam[1],1);
		slcHeadRestr        := getFlag(spsExtParam[1],2);
	end

	refPicList.launch: action ==> TypeOfVLD:[LAUNCH_ACTOR],
		VLDParam:[REF_PIC_LIST]
	guard
		qualityId = 0
	end

	decRefPicMarking.launch: action ==> TypeOfVLD:[LAUNCH_ACTOR, LAUNCH_ACTOR],
		VLDParam:[REF_PIC_MARKING, REF_BASE_PIC_MARKING]
	end

	askCabacInitIdc: action ==> TypeOfVLD:[VLD_UE]
	guard
		entropyCodingMode and sliceType != SLICE_TYPE_EI
	end

	getCabacInitIdc: action ValVLD:[cabacInitIdc] ==>
	end

	askSlcQpDelt: action ==> TypeOfVLD:[VLD_SE]
	end

	getSlcQpDelt: action ValVLD:[sliceQpDelta] ==>
	end

	askDisDbfIdc: action ==> TypeOfVLD:[VLD_UE]
	guard
		deblockFiltCtrlPres
	end

	getDisDbfIdc: action ValVLD:[disDbfIdc] ==>
	do
		disDeblocFiltIdc := disDbfIdc;
	end

	askSlcAlphaOff: action ==> TypeOfVLD:[VLD_SE, VLD_SE]
	guard
		disDeblocFiltIdc != 1
	end

	getSlcAlphaOff: action ValVLD:[sliceAlpha, sliceBeta] ==>
	end

	askSlcGrpChg: action ==> TypeOfVLD:[READ_BITS], VLDParam:[szSlcGrpChgCycle]
	guard
		qualityId = 0 and numSliceGrp > 1 and slcGrpMapType >=3 and slcGrpMapType <=5
	end

	getSlcGrpChg: action ValVLD:[sliceGrpChgCycle] ==>
	end

	askRefLayDqId: action ==> TypeOfVLD:[VLD_UE]
	guard
		not noInterLayPred and qualityId = 0
	end

	getRefLayDqIdc: action ValVLD:[refLayDqId] ==>
	end

	askDisIntLayDbfIdc: action ==> TypeOfVLD:[VLD_UE]
	guard
		intLayDbfCtrlPres
	end
	
	getDisIntLayDbfIdc: action ValVLD:[disInterLayDbfIdc] ==>
	do
		disIntLayDbfIdc := disInterLayDbfIdc;
	end

	askIntLaySlcAlpha: action ==> TypeOfVLD:[VLD_SE, VLD_SE]
	guard
		disIntLayDbfIdc != 1
	end

	getIntLaySlcAlpha: action ValVLD:[intLaySlcAlpha, intLaySlcBeta] ==>
	end

	askConstrIntraResamp: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	end

	getConstrIntraResamp: action ValVLD:[constrIntraResampl] ==>
	end

	askRefLayChrPhase: action ==> TypeOfVLD:[READ_BITS, READ_BITS], VLDParam:[1, 2]
	guard
		extSpatScal = 2 and chromaArrayType > 0
	end

	getRefLayChrPhase: action ValVLD:[refLayChrmPhaseX, refLayChrmPhaseY] ==>
	end

	askScaleRefLay: action ==> TypeOfVLD:[VLD_SE, VLD_SE, VLD_SE, VLD_SE]
	guard
		extSpatScal = 2
	end

	getScaleRefLay: action ValVLD:[scaledRefLayLeft, scaledRefLayTop,
		scaledRefLayRight, scaledRefLayBottom] ==>
	end

	askSliceSkipFlag: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not noInterLayPred
	end

	getSliceSkipFlag: action ValVLD:[sliceSkipFlag] ==>
	do
		sliceSkip := (sliceSkipFlag != 0);
	end

	askNumMbsSlc: action ==> TypeOfVLD:[VLD_UE]
	guard
		sliceSkip
	end

	getNumMbsSlc: action ValVLD:[numMbsMinus1] ==>
	end

	askAdaptBaseMode: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	end

	getAdaptBaseMode: action ValVLD:[adaptBaseMod] ==>
	do
		adaptBaseMode := (adaptBaseMod != 0);
	end

	askDefBaseFlag: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not adaptBaseMode
	end

	getDefBaseFlag: action ValVLD:[defBaseMode] ==>
	do
		defaultBaseMode := (defBaseMode != 0);
	end

	askAdaptMotPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not defaultBaseMode
	end

	getAdaptMotPred: action ValVLD:[adaptMotPred] ==>
	do
		adaptMotionPred := (adaptMotPred != 0);
	end

	askDefMotPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not adaptMotionPred
	end

	getDefMotPred: action ValVLD:[defMotPred] ==>
	end

	askAdaptResPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	end

	getAdaptResPred: action ValVLD:[adaptResPred] ==>
	do
		adaptResidualPred := (adaptResPred != 0);
	end

	askDefResPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		adaptResidualPred
	end

	getDefResPred: action ValVLD:[defResidualPred] ==>
	end

	askTcoeffLvlPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		adaptTcoeffLvlPred
	end

	getTcoeffLvlPred: action ValVLD:[tcoeffLvlPred] ==>
	end

	askScanIdx: action ==> TypeOfVLD:[READ_BITS, READ_BITS], VLDParam:[4, 4]
	guard
		not slcHeadRestr
	end

	getScanIdx: action ValVLD:[scanIdxStart, scanIdxEnd] ==>
	end

	conditions.areFalse:action ==>
	end

	endOfSliceHeader: action ==> TypeOfVLD:[SKIP_NAL]
	end

	schedule fsm GetParameters:
		GetParameters          (getParameters    )--> LaunchRefPicList;
		                                  //should be LaunchPredWeightTable;
		LaunchRefPicList       (refPicList       )--> LaunchDecRefPicMarking;
		//LaunchPredWeightTable  (predWeightTable  )--> LaunchDecRefPicMarking;
		LaunchDecRefPicMarking (decRefPicMarking )--> CheckEntropCodMode;
		CheckEntropCodMode     (askCabacInitIdc  )--> GetCabacInitIdc;
		CheckEntropCodMode     (askSlcQpDelt     )--> GetSlcQpDelt;

		GetCabacInitIdc  (getCabacInitIdc     )--> AskSlcQpDelt;
		AskSlcQpDelt     (askSlcQpDelt        )--> GetSlcQpDelt;
		GetSlcQpDelt     (getSlcQpDelt        )--> CheckDbfCtrlPres;
		CheckDbfCtrlPres (askDisDbfIdc        )--> GetDisDbfIdc;
		CheckDbfCtrlPres (askSlcGrpChg        )--> GetSlcGrpChg;
		CheckDbfCtrlPres (askRefLayDqId       )--> GetRefLayDqId;
		CheckDbfCtrlPres (conditions.areFalse )--> CheckNoInterLayPred;

		GetDisDbfIdc   (getDisDbfIdc          )--> CheckDisDbfIdc;
		CheckDisDbfIdc (askSlcAlphaOff        )--> GetSlcAlphaOff;
		CheckDisDbfIdc (askSlcGrpChg          )--> GetSlcGrpChg;
		CheckDisDbfIdc (askRefLayDqId         )--> GetRefLayDqId;
		CheckDisDbfIdc (conditions.areFalse   )--> CheckNoInterLayPred;

		GetSlcAlphaOff  (getSlcAlphaOff        )--> CheckSliceGroup;
		CheckSliceGroup (askSlcGrpChg          )--> GetSlcGrpChg;
		CheckSliceGroup (askRefLayDqId         )--> GetRefLayDqId;
		CheckSliceGroup (conditions.areFalse   )--> CheckNoInterLayPred;

		GetSlcGrpChg  (getSlcGrpChg          )--> AskRefLayDqId;
		AskRefLayDqId (askRefLayDqId         )--> GetRefLayDqId;
		AskRefLayDqId (conditions.areFalse   )--> CheckNoInterLayPred;

		GetRefLayDqId        (getRefLayDqIdc       )--> CheckInterLayDbfCtrl;
		CheckInterLayDbfCtrl (askDisIntLayDbfIdc   )--> GetDisIntLayDbfIdc;
		CheckInterLayDbfCtrl (askConstrIntraResamp )--> GetConstrIntraResamp;

		GetDisIntLayDbfIdc   (getDisIntLayDbfIdc   )--> CheckDisIntLayDbfIdc;
		CheckDisIntLayDbfIdc (askIntLaySlcAlpha    )--> GetIntLaySlcAlpha;
		CheckDisIntLayDbfIdc (askConstrIntraResamp )--> GetConstrIntraResamp;

		GetIntLaySlcAlpha    (getIntLaySlcAlpha    )--> AskConstrIntraResamp;
		AskConstrIntraResamp (askConstrIntraResamp )--> GetConstrIntraResamp;
		GetConstrIntraResamp (getConstrIntraResamp )--> CheckExtendSpatScal;

		CheckExtendSpatScal (askRefLayChrPhase   )--> GetRefLayChrPhase;
		CheckExtendSpatScal (askScaleRefLay      )--> GetScaleRefLay;
		CheckExtendSpatScal (conditions.areFalse )--> CheckNoInterLayPred;

		GetRefLayChrPhase (getRefLayChrPhase )--> AskScaleRefLay;
		AskScaleRefLay    (askScaleRefLay    )--> GetScaleRefLay;
		GetScaleRefLay    (getScaleRefLay    )--> CheckNoInterLayPred;

		CheckNoInterLayPred (askSliceSkipFlag )--> GetSliceSkipFlag;
		CheckNoInterLayPred (askScanIdx       )--> GetScanIdx;
		CheckNoInterLayPred (endOfSliceHeader )--> GetParameters;

		GetSliceSkipFlag   (getSliceSkipFlag )--> CheckSliceSkipFlag;
		CheckSliceSkipFlag (askNumMbsSlc     )--> GetNumMbsSlc;
		CheckSliceSkipFlag (askAdaptBaseMode )--> GetAdaptBaseMode;

		GetNumMbsSlc (getNumMbsSlc )--> CheckAdaptTcoefLvl;

		GetAdaptBaseMode   (getAdaptBaseMode )--> CheckAdaptBaseMode;
		CheckAdaptBaseMode (askDefBaseFlag   )--> GetDefBaseFlag;
		CheckAdaptBaseMode (askAdaptMotPred  )--> GetAdaptMotPred;
		CheckAdaptBaseMode (askAdaptResPred  )--> GetAdaptResPred;

		GetDefBaseFlag  (getDefBaseFlag  )--> CheckDefBaseMod;
		CheckDefBaseMod (askAdaptMotPred )--> GetAdaptMotPred;
		CheckDefBaseMod (askAdaptResPred )--> GetAdaptResPred;

		GetAdaptMotPred   (getAdaptMotPred )--> CheckAdaptMotPred;
		CheckAdaptMotPred (askDefMotPred   )--> GetDefMotPred;
		CheckAdaptMotPred (askAdaptResPred )--> GetAdaptResPred;

		GetAdaptResPred   (getAdaptResPred  )--> CheckAdaptResPred;
		CheckAdaptResPred (askDefResPred    )--> GetDefResPred;
		CheckAdaptResPred (askTcoeffLvlPred )--> GetTcoeffLvlPred;
		CheckAdaptResPred (askScanIdx       )--> GetScanIdx;
		CheckAdaptResPred (endOfSliceHeader )--> GetParameters;

		GetDefResPred      (getDefResPred    )--> CheckAdaptTcoefLvl;
		CheckAdaptTcoefLvl (askTcoeffLvlPred )--> GetTcoeffLvlPred;
		CheckAdaptTcoefLvl (askScanIdx       )--> GetScanIdx;
		CheckAdaptTcoefLvl (endOfSliceHeader )--> GetParameters;

		GetTcoeffLvlPred  (getTcoeffLvlPred )--> CheckSlcHeadRestr;
		CheckSlcHeadRestr (askScanIdx       )--> GetScanIdx;
		CheckSlcHeadRestr (endOfSliceHeader )--> GetParameters;

		GetScanIdx       (getScanIdx       )--> EndOfSliceHeader;
		EndOfSliceHeader (endOfSliceHeader )--> GetParameters;
	end
	priority
		askCabacInitIdc > askSlcQpDelt;
		askDisDbfIdc    > askSlcGrpChg > askRefLayDqId > conditions.areFalse;
		askSlcAlphaOff  > askSlcGrpChg;
		askDisIntLayDbfIdc > askConstrIntraResamp;
		askIntLaySlcAlpha  > askConstrIntraResamp;
		askRefLayChrPhase  > askScaleRefLay > conditions.areFalse;
		askSliceSkipFlag   > askScanIdx > endOfSliceHeader;
		askNumMbsSlc       > askAdaptBaseMode;
		askDefBaseFlag     > askAdaptMotPred > askAdaptResPred;
		askDefMotPred      > askAdaptResPred;
		askDefResPred > askTcoeffLvlPred > askScanIdx > endOfSliceHeader;
	end
end