/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package org.mpeg4.part10.svc.synParser.modular.decodePic;

import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import std.util.BitOps.*;

actor DecodeSliceHeaderPart2()
	uint(size=4) QualityId,
	int (size=32) ValVLD
		==>
	int (size=6)  TypeOfVLD,
	int (size=32) VLDParam
		:

	bool          adaptBaseMode;
	bool          adaptMotionPred;
	bool          adaptResidualPred;
	bool          adaptTcoeffLvlPred; ///////////////!!
	uint(size=2)  chromaArrayType; ///!!!!!!!
	bool          deblockFiltCtrlPres; //!!!
	bool          defaultBaseMode;
	uint(size=2)  disDeblocFiltIdc;
	bool          disIntLayCtrlPres;
	bool          disIntLayDbfIdc;
	bool          entropyCodingMode; // !!!!
	uint extSpatScal;//!!!!!
	bool          noInterLayPred;// !!!!!!!!!!
	uint(size=4)  numSliceGrp; // PpsParam !!!!!!!!!
	uint(size=4)  qualityId;
	bool          slcHeadRestr; /////////////!!!!!
	uint(size=3)  slcGrpMapType; //PpsParam !!!!!!!!!!
	bool          sliceSkip;
	uint(size=32) szSlcGrpChgCycle; // PpsParam !!!!!!!!!

	getQualityId: action QualityId:[qualId] ==>
	do
		qualityId := qualId;
	end

	refPicList.launch: action ==> TypeOfVLD:[LAUNCH_ACTOR],
		VLDParam:[REF_PIC_LIST]
	guard
		qualityId = 0
	end

	DecRefPicMarking.Launch: action ==> TypeOfVLD:[LAUNCH_ACTOR],
		VLDParam:[DEC_REF_PIC_MARKING]//, RefPicMrk_IsNewPic:[IsNewPic]
	end

	askCabacInitIdc: action ==> TypeOfVLD:[VLD_UE]
	guard
		entropyCodingMode
	end

	getCabacInitIdc: action ValVLD:[cabacInitIdc] ==>
	end

	askSlcQpDelt: action ==> TypeOfVLD:[VLD_SE]
	end

	getSlcQpDelt: action ValVLD:[sliceQpDelta] ==>
	end

	askDisDbfIdc: action ==> TypeOfVLD:[VLD_UE]
	guard
		deblockFiltCtrlPres
	end

	getDisDbfIdc: action ValVLD:[disDbfIdc] ==>
	do
		disDeblocFiltIdc := disDbfIdc;
	end

	askSlcAlphaOff: action ==> TypeOfVLD:[VLD_SE, VLD_SE]
	guard
		disDeblocFiltIdc != 1
	end

	getSlcAlphaOff: action VLDParam:[sliceAlpha, sliceBeta] ==>
	end

	askSlcGrpChg: action ==> TypeOfVLD:[READ_BITS], VLDParam:[szSlcGrpChgCycle]
	guard
		qualityId = 0 and numSliceGrp > 0 and slcGrpMapType >=3 and slcGrpMapType <=5
	end

	getSlcGrpChg: action ValVLD:[sliceGrpChgCycle] ==>
	end

	askRefLayDqId: action ==> TypeOfVLD:[VLD_UE]
	guard
		not noInterLayPred and qualityId = 0
	end

	getRefLayDqIdc: action ValVLD:[refLayDqId] ==>
	end

	askDisIntLayDbfIdc: action ==> TypeOfVLD:[VLD_UE]
	guard
		disIntLayCtrlPres
	end
	
	getDisIntLayDbfIdc: action ValVLD:[disInterLayDbfIdc] ==>
	do
		disIntLayDbfIdc := (disInterLayDbfIdc != 0);
	end

	askIntLaySlcAlpha: action ==> TypeOfVLD:[VLD_SE, VLD_SE]
	guard
		disIntLayDbfIdc
	end

	getIntLaySlcAlpha: action ValVLD:[intLaySlcAlpha, intLaySlcBeta] ==>
	end

	askConstrIntraResamp: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	end

	getConstrIntraResamp: action ValVLD:[constrIntraResampl] ==>
	end

	askRefLayChrPhase: action ==> TypeOfVLD:[READ_BITS, READ_BITS], VLDParam:[1, 2]
	guard
		extSpatScal = 2 and chromaArrayType > 0
	end

	getRefLayChrPhase: action ValVLD:[refLayChrmPhaseX, refLayChrmPhaseY] ==>
	end

	askScaleRefLay: action ==> TypeOfVLD:[VLD_SE, VLD_SE, VLD_SE, VLD_SE]
	guard
		extSpatScal = 2
	end

	getScaleRefLay: action ValVLD:[scaledRefLayLeft, scaledRefLayTop,
		scaledRefLayRight, scaledRefLayBottom] ==>
	end

	askSliceSkipFlag: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not noInterLayPred
	end

	getSliceSkipFlag: action ValVLD:[sliceSkipFlag] ==>
	do
		sliceSkip := (sliceSkipFlag != 0);
	end

	askNumMbsSlc: action ==> TypeOfVLD:[VLD_UE]
	guard
		sliceSkip
	end

	getNumMbsSlc: action ValVLD:[numMbsMinus1] ==>
	end

	askAdaptBaseMode: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	end

	getAdaptBaseMode: action ValVLD:[adaptBaseMod] ==>
	do
		adaptBaseMode := (adaptBaseMod != 0);
	end

	askDefBaseFlag: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not adaptBaseMode
	end

	getDefBaseFlag: action ValVLD:[defBaseMode] ==>
	do
		defaultBaseMode := (defBaseMode != 0);
	end

	askAdaptMotPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not defaultBaseMode
	end

	getAdaptMotPred: action ValVLD:[adaptMotPred] ==>
	do
		adaptMotionPred := (adaptMotPred != 0);
	end

	askDefMotPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not adaptMotionPred
	end

	getDefMotPred: action ValVLD:[defMotPred] ==>
	end

	askAdaptResPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	end

	getAdaptResPred: action ValVLD:[adaptResPred] ==>
	do
		adaptResidualPred := (adaptResPred != 0);
	end

	askDefResPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		adaptResidualPred
	end

	askTcoeffLvlPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		adaptTcoeffLvlPred
	end

	getTcoeffLvlPred: action ValVLD:[tcoeffLvlPred] ==>
	end

	askScanIdx: action ==> TypeOfVLD:[READ_BITS, READ_BITS], VLDParam:[4, 4]
	guard
		slcHeadRestr
	end

	getScanIdx: action ValVLD:[scanIdxStart, scanIdxEnd] ==>
	end
end