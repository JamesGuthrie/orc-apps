/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package org.mpeg4.part10.svc.synParser.modular.decodePic;

import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import std.util.BitOps.*;

actor DecodeSliceHeaderPart2()
	uint(size=32) Header1Param,
	uint(size=4)  HeadSvcExt,
	uint(size=2)  NalRefIdc,
	int (size=32) PpsParameters,
	uint(size=2)  SpsExtParam,
	uint(size=32) SpsParameters,
	int (size=32) ValVLD
		==>
	bool          SkipRefBase,
	int (size=6)  TypeOfVLD,
	int (size=32) VLDParam,
	int (size=14) SliceDataParam
		:

	bool DEBUG = true;

	uint(size=4) SLICE_TYPE_EI  = 2;

	bool          adaptBaseMode;
	bool          adaptMotionPred;
	bool          adaptResidualPred;
	bool          adaptTcoeffLvlPred;
	uint(size=2)  chromaArrayType;
	bool          deblockFiltCtrlPres;
	bool          defaultBaseMode;
	uint(size=2)  disDeblocFiltIdc;
	uint(size=3)  disIntLayDbfIdc;
	bool          entropyCodingMode;
	uint(size=2)  extSpatScal;
	bool          idr;
	bool          intLayDbfCtrlPres;
	uint(size=2)  nalRefIdc;
	bool          noInterLayPred;
	uint(size=4)  numSliceGrp;
	uint(size=4)  qualityId;
	int(size=6)   slcAlphaC0Off;
	int(size=6)   slcBetaOff;
	bool          slcHeadRestr;
	uint(size=3)  slcGrpMapType;
	bool          sliceSkip;
	uint(size=4)  sliceType;
	bool          storeRefBasePic;
	uint(size=32) szSlcGrpChgCycle;
	bool          useRefBasePic;

	getParameters: action Header1Param:[header1Param] repeat 3,
		HeadSvcExt:[headSvcExt] repeat 2, PpsParameters:[ppsParam] repeat 5,
		SpsParameters:[spsParam] repeat 9, SpsExtParam:[spsExtParam] repeat 2,
		NalRefIdc:[nalRef] ==> SliceDataParam :[header1Param] repeat 3
	do
		sliceType := header1Param[0];
		qualityId := headSvcExt[0];
		noInterLayPred := getFlag(headSvcExt[1],0);
		useRefBasePic  := getFlag(headSvcExt[1],1);
		idr            := getFlag(headSvcExt[1],2);
		numSliceGrp         := ppsParam[0];
		szSlcGrpChgCycle    := ppsParam[2];
		slcGrpMapType       := ppsParam[3];
		deblockFiltCtrlPres := getFlag(ppsParam[4],0);
		entropyCodingMode   := getFlag(ppsParam[4],3);
		chromaArrayType     := spsParam[2];
		extSpatScal         := spsExtParam[0];
		intLayDbfCtrlPres   := getFlag(spsExtParam[1],0);
		adaptTcoeffLvlPred  := getFlag(spsExtParam[1],1);
		slcHeadRestr        := getFlag(spsExtParam[1],2);
		nalRefIdc           := nalRef;
	end

	refPicList.launch: action ==> TypeOfVLD:[SKIP_NAL/*,LAUNCH_ACTOR*/]//,
//		VLDParam:[REF_PIC_LIST]
//	guard
//		qualityId = 0
	end

	decRefPicMarking.launch: action ==> TypeOfVLD:[LAUNCH_ACTOR],
		VLDParam:[REF_PIC_MARKING]
	end

	askStoreRefBasePic: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		nalRefIdc != 0 and not slcHeadRestr
	end

	getStoreRefBasePic: action ValVLD:[storeRefBsPic] ==>
	do
		if(DEBUG) then
			println("\t\tstore_ref_base_pic_flag : "+storeRefBsPic);
		end
		storeRefBasePic := (storeRefBsPic != 0);
	end

	decRefBasePicMarking.launch: action ==> TypeOfVLD:[LAUNCH_ACTOR],
		VLDParam:[REF_BASE_PIC_MARKING], SkipRefBase:[false]
	guard
		(useRefBasePic or storeRefBasePic) and not idr
	end

	decRefBasePicMarking.skip: action ==> SkipRefBase:[true]
	end

	askCabacInitIdc: action ==> TypeOfVLD:[VLD_UE]
	guard
		entropyCodingMode and sliceType != SLICE_TYPE_EI
	end

	getCabacInitIdc: action ValVLD:[cabacInitIdc] ==>
	do
		if(DEBUG) then
			println("\t\tcabac_init_idc : "+cabacInitIdc);
		end
	end

	askSlcQpDelt: action ==> TypeOfVLD:[VLD_SE]
	end

	getSlcQpDelt: action ValVLD:[slcQpDelta] ==> SliceDataParam:[slcQpDelta]
	do
		if(DEBUG) then
			println("\t\tslice_qp_delta : "+slcQpDelta);
		end
	end

	askDisDbfIdc: action ==> TypeOfVLD:[VLD_UE]
	guard
		deblockFiltCtrlPres
	end

	getDisDbfIdc: action ValVLD:[disDbfIdc] ==>
	do
		if(DEBUG) then
			println("\t\tdisable_deblocking_filter_idc : "+disDbfIdc);
		end
		disDeblocFiltIdc := disDbfIdc;
	end

	askSlcAlphaOff: action ==> TypeOfVLD:[VLD_SE, VLD_SE]
	guard
		disDeblocFiltIdc != 1
	end

	getSlcAlphaOff: action ValVLD:[sliceAlpha, sliceBeta] ==>
	do
		slcAlphaC0Off := sliceAlpha;
		slcBetaOff    := sliceBeta;
		if(DEBUG) then
			println("\t\tslice_alpha_c0_offset_div2 : "+sliceAlpha);
			println("\t\tslice_beta_offset_div2 : "+sliceBeta);
		end
	end

	askSlcGrpChg: action ==> TypeOfVLD:[READ_BITS], VLDParam:[szSlcGrpChgCycle]
	guard
		qualityId = 0 and numSliceGrp > 1 and slcGrpMapType >=3 and slcGrpMapType <=5
	end

	getSlcGrpChg: action ValVLD:[sliceGrpChgCycle] ==>
	do
		if(DEBUG) then
			println("\t\tslice_group_change_cycle : "+sliceGrpChgCycle);
		end
	end

	askRefLayDqId: action ==> TypeOfVLD:[VLD_UE]
	guard
		not noInterLayPred and qualityId = 0
	end

	getRefLayDqIdc: action ValVLD:[refLayDqId] ==>
	do
		if(DEBUG) then
			println("\t\tref_layer_dq_id : "+refLayDqId);
		end
	end

	askDisIntLayDbfIdc: action ==> TypeOfVLD:[VLD_UE]
	guard
		intLayDbfCtrlPres
	end
	
	getDisIntLayDbfIdc: action ValVLD:[disInterLayDbfIdc] ==>
	do
		if(DEBUG) then
			println("\t\tdisable_inter_layer_deblocking_filter_idc : "+disInterLayDbfIdc);
		end
		disIntLayDbfIdc := disInterLayDbfIdc;
	end

	askIntLaySlcAlpha: action ==> TypeOfVLD:[VLD_SE, VLD_SE]
	guard
		disIntLayDbfIdc != 1
	end

	getIntLaySlcAlpha: action ValVLD:[intLaySlcAlpha, intLaySlcBeta] ==>
	do
		if(DEBUG) then
			println("\t\tinter_layer_slice_alpha_c0_offset_div2 : "+intLaySlcAlpha);
			println("\t\tinter_layer_slice_beta_offset_div2 : "+intLaySlcBeta);
		end
	end

	askConstrIntraResamp: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	end

	getConstrIntraResamp: action ValVLD:[constrIntraResampl] ==>
	do
		if(DEBUG) then
			println("\t\tconstrained_intra_resampling_flag : "+constrIntraResampl);
		end
	end

	askRefLayChrPhase: action ==> TypeOfVLD:[READ_BITS, READ_BITS], VLDParam:[1, 2]
	guard
		extSpatScal = 2 and chromaArrayType > 0
	end

	getRefLayChrPhase: action ValVLD:[refLayChrmPhaseX, refLayChrmPhaseY] ==>
	do
		if(DEBUG) then
			println("\t\tref_layer_chroma_phase_x_plus1_flag : "+refLayChrmPhaseX);
			println("\t\tref_layer_chroma_phase_y_plus1 : "+refLayChrmPhaseY);
		end
	end

	askScaleRefLay: action ==> TypeOfVLD:[VLD_SE, VLD_SE, VLD_SE, VLD_SE]
	guard
		extSpatScal = 2
	end

	getScaleRefLay: action ValVLD:[scaledRefLayLeft, scaledRefLayTop,
		scaledRefLayRight, scaledRefLayBottom] ==>
	do
		if(DEBUG) then
			println("\t\tscaled_ref_layer_left_offset : "+scaledRefLayLeft);
			println("\t\tscaled_ref_layer_top_offset : "+scaledRefLayTop);
			println("\t\tscaled_ref_layer_right_offset : "+scaledRefLayRight);
			println("\t\tscaled_ref_layer_bottom_offset : "+scaledRefLayBottom);
		end
	end

	askSliceSkipFlag: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not noInterLayPred
	end

	getSliceSkipFlag: action ValVLD:[sliceSkipFlag] ==>
	do
		if(DEBUG) then
			println("\t\tslice_skip_flag : "+sliceSkipFlag);
		end
		sliceSkip := (sliceSkipFlag != 0);
	end

	askNumMbsSlc: action ==> TypeOfVLD:[VLD_UE]
	guard
		sliceSkip
	end

	getNumMbsSlc: action ValVLD:[numMbsMinus1] ==>
	do
		if(DEBUG) then
			println("\t\tnum_mbs_in_slice_minus1 : "+numMbsMinus1);
		end
	end

	askAdaptBaseMode: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	end

	getAdaptBaseMode: action ValVLD:[adaptBaseMod] ==>
	do
		if(DEBUG) then
			println("\t\tadaptive_base_mode_base : "+adaptBaseMod);
		end
		adaptBaseMode := (adaptBaseMod != 0);
	end

	askDefBaseFlag: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not adaptBaseMode
	end

	getDefBaseFlag: action ValVLD:[defBaseMode] ==>
	do
		if(DEBUG) then
			println("\t\tdefault_base_mode_flag : "+defBaseMode);
		end
		defaultBaseMode := (defBaseMode != 0);
	end

	askAdaptMotPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not defaultBaseMode
	end

	getAdaptMotPred: action ValVLD:[adaptMotPred] ==>
	do
		if(DEBUG) then
			println("\t\tadaptive_motion_prediction_flag : "+adaptMotPred);
		end
		adaptMotionPred := (adaptMotPred != 0);
	end

	askDefMotPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not adaptMotionPred
	end

	getDefMotPred: action ValVLD:[defMotPred] ==>
	do
		if(DEBUG) then
			println("\t\tdefault_motion_prediction_flag : "+defMotPred);
		end
	end

	askAdaptResPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	end

	getAdaptResPred: action ValVLD:[adaptResPred] ==>
	do
		if(DEBUG) then
			println("\t\tadaptive_residual_prediction_flag : "+adaptResPred);
		end
		adaptResidualPred := (adaptResPred != 0);
	end

	askDefResPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		not adaptResidualPred
	end

	getDefResPred: action ValVLD:[defResidualPred] ==>
	do
		if(DEBUG) then
			println("\t\tdefault_residual_prediction_flag : "+defResidualPred);
		end
	end

	askTcoeffLvlPred: action ==> TypeOfVLD:[READ_BITS], VLDParam:[1]
	guard
		adaptTcoeffLvlPred
	end

	getTcoeffLvlPred: action ValVLD:[tcoeffLvlPred] ==>
	do
		if(DEBUG) then
			println("\t\ttcoeff_level_prediction_flag : "+tcoeffLvlPred);
		end
	end

	askScanIdx: action ==> TypeOfVLD:[READ_BITS, READ_BITS], VLDParam:[4, 4]
	guard
		not slcHeadRestr
	end

	getScanIdx: action ValVLD:[scanIdxStart, scanIdxEnd] ==>
	do
		if(DEBUG) then
			println("\t\tscan_idx_start : "+scanIdxStart);
			println("\t\tscan_idx_end : "+scanIdxEnd);
		end
	end

	conditions.areFalse:action ==>
	end

	endOfSliceHeader: action ==> TypeOfVLD:[LAUNCH_ACTOR, SKIP_NAL],
		VLDParam:[SLICE_DATA_SVC], SliceDataParam:[disDeblocFiltIdc,
		slcBetaOff, slcAlphaC0Off]
	end

	schedule fsm GetParameters:
	GetParameters (refPicList.launch )--> GetParameters;
/*		GetParameters          (getParameters    )--> LaunchRefPicList;
		                                  //should be LaunchPredWeightTable;
		LaunchRefPicList       (refPicList       )--> LaunchDecRefPicMarking;
		//LaunchPredWeightTable  (predWeightTable  )--> LaunchDecRefPicMarking;
		LaunchDecRefPicMarking (decRefPicMarking          )--> AskStoreRefBasePic;
		AskStoreRefBasePic     (askStoreRefBasePic        )--> GetStoreRefBasePic;
		AskStoreRefBasePic     (decRefBasePicMarking.skip )--> CheckEntropCodMode;

		GetStoreRefBasePic (getStoreRefBasePic )--> TryLchRefBasePicMark;
		TryLchRefBasePicMark (decRefBasePicMarking )--> CheckEntropCodMode;

		CheckEntropCodMode     (askCabacInitIdc  )--> GetCabacInitIdc;
		CheckEntropCodMode     (askSlcQpDelt     )--> GetSlcQpDelt;

		GetCabacInitIdc  (getCabacInitIdc     )--> AskSlcQpDelt;
		AskSlcQpDelt     (askSlcQpDelt        )--> GetSlcQpDelt;
		GetSlcQpDelt     (getSlcQpDelt        )--> CheckDbfCtrlPres;
		CheckDbfCtrlPres (askDisDbfIdc        )--> GetDisDbfIdc;
		CheckDbfCtrlPres (askSlcGrpChg        )--> GetSlcGrpChg;
		CheckDbfCtrlPres (askRefLayDqId       )--> GetRefLayDqId;
		CheckDbfCtrlPres (conditions.areFalse )--> CheckNoInterLayPred;

		GetDisDbfIdc   (getDisDbfIdc          )--> CheckDisDbfIdc;
		CheckDisDbfIdc (askSlcAlphaOff        )--> GetSlcAlphaOff;
		CheckDisDbfIdc (askSlcGrpChg          )--> GetSlcGrpChg;
		CheckDisDbfIdc (askRefLayDqId         )--> GetRefLayDqId;
		CheckDisDbfIdc (conditions.areFalse   )--> CheckNoInterLayPred;

		GetSlcAlphaOff  (getSlcAlphaOff        )--> CheckSliceGroup;
		CheckSliceGroup (askSlcGrpChg          )--> GetSlcGrpChg;
		CheckSliceGroup (askRefLayDqId         )--> GetRefLayDqId;
		CheckSliceGroup (conditions.areFalse   )--> CheckNoInterLayPred;

		GetSlcGrpChg  (getSlcGrpChg          )--> AskRefLayDqId;
		AskRefLayDqId (askRefLayDqId         )--> GetRefLayDqId;
		AskRefLayDqId (conditions.areFalse   )--> CheckNoInterLayPred;

		GetRefLayDqId        (getRefLayDqIdc       )--> CheckInterLayDbfCtrl;
		CheckInterLayDbfCtrl (askDisIntLayDbfIdc   )--> GetDisIntLayDbfIdc;
		CheckInterLayDbfCtrl (askConstrIntraResamp )--> GetConstrIntraResamp;

		GetDisIntLayDbfIdc   (getDisIntLayDbfIdc   )--> CheckDisIntLayDbfIdc;
		CheckDisIntLayDbfIdc (askIntLaySlcAlpha    )--> GetIntLaySlcAlpha;
		CheckDisIntLayDbfIdc (askConstrIntraResamp )--> GetConstrIntraResamp;

		GetIntLaySlcAlpha    (getIntLaySlcAlpha    )--> AskConstrIntraResamp;
		AskConstrIntraResamp (askConstrIntraResamp )--> GetConstrIntraResamp;
		GetConstrIntraResamp (getConstrIntraResamp )--> CheckExtendSpatScal;

		CheckExtendSpatScal (askRefLayChrPhase   )--> GetRefLayChrPhase;
		CheckExtendSpatScal (askScaleRefLay      )--> GetScaleRefLay;
		CheckExtendSpatScal (conditions.areFalse )--> CheckNoInterLayPred;

		GetRefLayChrPhase (getRefLayChrPhase )--> AskScaleRefLay;
		AskScaleRefLay    (askScaleRefLay    )--> GetScaleRefLay;
		GetScaleRefLay    (getScaleRefLay    )--> CheckNoInterLayPred;

		CheckNoInterLayPred (askSliceSkipFlag )--> GetSliceSkipFlag;
		CheckNoInterLayPred (askScanIdx       )--> GetScanIdx;
		CheckNoInterLayPred (endOfSliceHeader )--> GetParameters;

		GetSliceSkipFlag   (getSliceSkipFlag )--> CheckSliceSkipFlag;
		CheckSliceSkipFlag (askNumMbsSlc     )--> GetNumMbsSlc;
		CheckSliceSkipFlag (askAdaptBaseMode )--> GetAdaptBaseMode;

		GetNumMbsSlc (getNumMbsSlc )--> CheckAdaptTcoefLvl;

		GetAdaptBaseMode   (getAdaptBaseMode )--> CheckAdaptBaseMode;
		CheckAdaptBaseMode (askDefBaseFlag   )--> GetDefBaseFlag;
		CheckAdaptBaseMode (askAdaptMotPred  )--> GetAdaptMotPred;
		CheckAdaptBaseMode (askAdaptResPred  )--> GetAdaptResPred;

		GetDefBaseFlag  (getDefBaseFlag  )--> CheckDefBaseMod;
		CheckDefBaseMod (askAdaptMotPred )--> GetAdaptMotPred;
		CheckDefBaseMod (askAdaptResPred )--> GetAdaptResPred;

		GetAdaptMotPred   (getAdaptMotPred )--> CheckAdaptMotPred;
		CheckAdaptMotPred (askDefMotPred   )--> GetDefMotPred;
		CheckAdaptMotPred (askAdaptResPred )--> GetAdaptResPred;

		GetAdaptResPred   (getAdaptResPred  )--> CheckAdaptResPred;
		CheckAdaptResPred (askDefResPred    )--> GetDefResPred;
		CheckAdaptResPred (askTcoeffLvlPred )--> GetTcoeffLvlPred;
		CheckAdaptResPred (askScanIdx       )--> GetScanIdx;
		CheckAdaptResPred (endOfSliceHeader )--> GetParameters;

		GetDefResPred      (getDefResPred    )--> CheckAdaptTcoefLvl;
		CheckAdaptTcoefLvl (askTcoeffLvlPred )--> GetTcoeffLvlPred;
		CheckAdaptTcoefLvl (askScanIdx       )--> GetScanIdx;
		CheckAdaptTcoefLvl (endOfSliceHeader )--> GetParameters;

		GetTcoeffLvlPred  (getTcoeffLvlPred )--> CheckSlcHeadRestr;
		CheckSlcHeadRestr (askScanIdx       )--> GetScanIdx;
		CheckSlcHeadRestr (endOfSliceHeader )--> GetParameters;

		GetScanIdx       (getScanIdx       )--> EndOfSliceHeader;
		EndOfSliceHeader (endOfSliceHeader )--> GetParameters;*/
	end
	priority
		askStoreRefBasePic > decRefBasePicMarking.skip;
		decRefBasePicMarking.launch > decRefBasePicMarking.skip;
		askCabacInitIdc > askSlcQpDelt;
		askDisDbfIdc    > askSlcGrpChg > askRefLayDqId > conditions.areFalse;
		askSlcAlphaOff  > askSlcGrpChg;
		askDisIntLayDbfIdc > askConstrIntraResamp;
		askIntLaySlcAlpha  > askConstrIntraResamp;
		askRefLayChrPhase  > askScaleRefLay > conditions.areFalse;
		askSliceSkipFlag   > askScanIdx > endOfSliceHeader;
		askNumMbsSlc       > askAdaptBaseMode;
		askDefBaseFlag     > askAdaptMotPred > askAdaptResPred;
		askDefMotPred      > askAdaptResPred;
		askDefResPred > askTcoeffLvlPred > askScanIdx > endOfSliceHeader;
	end
end