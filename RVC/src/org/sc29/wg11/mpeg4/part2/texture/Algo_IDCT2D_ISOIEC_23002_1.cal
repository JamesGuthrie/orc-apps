package org.sc29.wg11.mpeg4.part2.texture;

import std.util.BitOps.* ;

import org.sc29.wg11.mpeg4.part2.Constants.* ;

actor Algo_IDCT2D_ISOIEC_23002_1 () int(size=13) IN, // defined as X
	bool SIGNED // not defined in MPEGC
	==> int(size=PIX_SZ) OUT : //defined as Y
	int A = 1024;

	int B = 1138;

	int C = 1730;

	int D = 1609;

	int E = 1264;

	int F = 1922;

	int G = 1788;

	int H = 2923;

	int I = 2718;

	int J = 2528;

	List(type: int, size=64) scale = [ A, B, C, D, A, D, C, B, B, E, F, G, B, G,
	F, E, C, F, H, I, C, I, H, F, D, G, I, J, D, J, I, G, A, B, C, D, A, D, C, B,
	D, G, I, J, D, J, I, G, C, F, H, I, C, I, H, F, B, E, F, G, B, G, F, E ];

	action IN:[ x ] repeat 64, SIGNED:[ s ] ==> OUT:[ block1 ] repeat 64
	do // multiplier-based scaling
		int block1 [ 64 ] := [ scale[n] * x[n] : for int n in 0 .. 63 ] ; 
		int block2 [ 64 ] ; 
		block1[0] := block1[0] + (1 << 12); // scaled 1D IDCT for rows and columns
		idct1d(block1, block2);
		idct1d(block2, block1); // downshifting
		block1 := [ (block1[n] >> 13) : for int n in 0 .. 63 ]; // clipping
		if s then
			block1 := [ clip(block1[n], -255) : for int n in 0 .. 63 ];
		else
			block1 := [ clip(block1[n], 0) : for int n in 0 .. 63 ];
		end
	end

	procedure idct1d(int X [ 64 ], int Y [ 64 ])
	var
		int temp1,
		int temp2,
		int temp3,
		int temp4,
		int xa,
		int xb
	begin
		foreach int i in 0 .. 7 do
			xa := X[8 * i + 1] + X[8 * i + 7];
			xb := X[8 * i + 1] - X[8 * i + 7];
			X[8 * i + 1] := xa + X[8 * i + 3];
			X[8 * i + 3] := xa - X[8 * i + 3];
			X[8 * i + 7] := xb + X[8 * i + 5];
			X[8 * i + 5] := xb - X[8 * i + 5];
			temp1 := pmul_1_1(X[8 * i + 3]);
			temp4 := pmul_1_2(X[8 * i + 3]);
			temp3 := pmul_1_1(X[8 * i + 5]);
			temp2 := pmul_1_2(X[8 * i + 5]);
			X[8 * i + 3] := temp1 - temp2;
			X[8 * i + 5] := temp3 + temp4;
			temp1 := pmul_2_1(X[8 * i + 1]);
			temp4 := pmul_2_2(X[8 * i + 1]);
			temp3 := pmul_2_1(X[8 * i + 7]);
			temp2 := pmul_2_2(X[8 * i + 7]);
			X[8 * i + 1] := temp1 + temp2;
			X[8 * i + 7] := temp3 - temp4;
			temp1 := pmul_3_1(X[8 * i + 2]);
			temp4 := pmul_3_2(X[8 * i + 2]);
			temp3 := pmul_3_1(X[8 * i + 6]);
			temp2 := pmul_3_2(X[8 * i + 6]);
			X[8 * i + 2] := temp1 - temp2;
			X[8 * i + 6] := temp3 + temp4;
			xa := X[8 * i + 0] + X[8 * i + 4];
			xb := X[8 * i + 0] - X[8 * i + 4];
			X[8 * i + 0] := xa + X[8 * i + 6];
			X[8 * i + 6] := xa - X[8 * i + 6];
			X[8 * i + 4] := xb + X[8 * i + 2];
			X[8 * i + 2] := xb - X[8 * i + 2];
			Y[i + 8 * 0] := X[8 * i + 0] + X[8 * i + 1];
			Y[i + 8 * 1] := X[8 * i + 4] + X[8 * i + 5];
			Y[i + 8 * 2] := X[8 * i + 2] + X[8 * i + 3];
			Y[i + 8 * 3] := X[8 * i + 6] + X[8 * i + 7];
			Y[i + 8 * 4] := X[8 * i + 6] - X[8 * i + 7];
			Y[i + 8 * 5] := X[8 * i + 2] - X[8 * i + 3];
			Y[i + 8 * 6] := X[8 * i + 4] - X[8 * i + 5];
			Y[i + 8 * 7] := X[8 * i + 0] - X[8 * i + 1];
		end
	end

	function pmul_1_1(int X) --> int :
		int Temp1 = (X >> 3) - (X >> 7) ; X - Temp1
	end

	function pmul_1_2(int X) --> int :
		int Temp1 = (X >> 3) - (X >> 7) ; int Temp2 = Temp1 - (X >> 11) ; Temp1 +
		(Temp2 >> 1)
	end

	function pmul_2_1(int X) --> int :
		int Temp1 = (X >> 9) - X ; (Temp1 >> 2) - Temp1
	end

	function pmul_2_2(int X) --> int :
		(X >> 1)
	end

	function pmul_3_1(int X) --> int :
		int Temp1 = X + (X >> 5) ; int Temp2 = (Temp1 >> 2) ; Temp2 + (X >> 4)
	end

	function pmul_3_2(int X) --> int :
		int Temp1 = X + (X >> 5) ; int Temp2 = (Temp1 >> 2) ; Temp1 - Temp2
	end

	function clip(int x, int lim) --> int :
		if x < lim then
			lim
		else
			if x > 255 then
				255
			else
				x
			end
		end
	end

end