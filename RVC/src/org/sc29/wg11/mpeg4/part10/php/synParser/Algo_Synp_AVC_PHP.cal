/********************************************************************************

This software module was originally developed by 
Florian Decologne (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
 
FU realizing Syntax Parsing for AVC
*****************************************************************************/

// This FU has been modified by Mickael Raulet (INSA of Rennes) Dec 2011

package org.sc29.wg11.mpeg4.part10.php.synParser;

import org.sc29.wg11.mpeg4.part10.Imp_PictureInfo.*;
import org.sc29.wg11.mpeg4.part10.MacroBlockInfo.*;
import std.util.BitOps.*;
import org.sc29.wg11.mpeg4.part10.cbp.synParser.ParserUtils.*;
import org.sc29.wg11.common.BitstreamReadUtils.*;
import org.sc29.wg11.common.CabacDecodeBinFunction.*;
import org.sc29.wg11.common.CabacContextConstantAVC.*;
import org.sc29.wg11.common.CabacContextFunctionAVC.*;
import org.sc29.wg11.common.CabacParserFunctionAVC.*;
import org.sc29.wg11.common.neighbourFunction.*;

actor Algo_Synp_AVC_PHP()
		uint(size=8) BYTE 
		==> 
		
			uint(size=31) MMCO,
			uint(size=5)  NUM_REF_FRAMES,
			uint(size=31) FRAME_NUM,

			uint(size=5)  NB_REF_FRAME_l0,
			uint(size=2)  REF_TYPE_l0,
			uint(size=31) REF_REORDERING_l0,
			
			uint(size=5)  NB_REF_FRAME_l1,
			uint(size=2)  REF_TYPE_l1,
			uint(size=31) REF_REORDERING_l1,

			uint(size=31) MAX_FRAME_NUM,
			uint(size=6)  SLICE_DBF_PARAM,
			bool 		  CONSTRAINED_IFLAG, 
			uint(size=8)  DBP_MAX_SZ,

			uint(size=7)  PIC_SIZE_IN_MB,
			int           POC, 

			uint(size=8)  SCALING_LIST_Y,
			uint(size=8)  SCALING_LIST_U,
			uint(size=8)  SCALING_LIST_V,

			uint(size=7)  MB_LOCATION,
			uint(size=6)  MB_TYPE,
			uint(size=16) CBP_BLK,
			uint(size=4)  SUB_MB_TYPE,
			int(size=9)   I_PCM,
			uint(size=4)  INTRA_PRED_MODE,
			uint(size=4)  INTRA_PRED_MODEC, 
			uint(size=4)  RUN, 
			int(size=12)  VALUE, 
			uint(size=2)  LAST, 
			int(size=8)   QP, 
			int(size=8)   QP_Cb, 
			int(size=8)   QP_Cr,
			int(size=5)   MB_PRED_REF_IDX_l0,
			int(size=16)  MB_PRED_MVD_l0, 
			int(size=5)   SUB_MB_PRED_REF_IDX_l0,
			int(size=16)  SUB_MB_PRED_MVD_l0, 
			
			int(size=5)   MB_PRED_REF_IDX_l1,
			int(size=16)  MB_PRED_MVD_l1, 
			int(size=5)   SUB_MB_PRED_REF_IDX_l1,
			int(size=16)  SUB_MB_PRED_MVD_l1, 

			bool 		  DIRECT_SPATIAL_MV_PRED_FLAG,
			bool		  DIRECT_8X8_INTERFERENCE_FLAG,
			
			int(size=16)  WIDTH, 
			int(size=16)  HEIGHT,
			bool          TRANSFORM_SIZE_8x8_FLAG,
			
			uint(size=2)  WEIGHTED_PRED_IDC,
			int (size=9)  WP_PARAM

		:

	bool DEBUG_BITSTREAM = false;
	bool MB_PRED = false;
	bool SUB_MB_PRED = false;
	
	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
	uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL];
	uint(size= 2) zeroByte := 0;
	/* */
  	action BYTE:[ b ] ==>
	guard 
		fifo[FIFO_CPT_BITS] <= (FIFO_SIZE-1)<<3
	var
		uint(size=4) fifo_idx  =  fifo[FIFO_IDX]
	do
		if zeroByte != 3 or b != EPR_VALUE then
			if b = START_CODE_VALUE and zeroByte = 3 then
				fifo[fifo_idx]      := b + START_CODE_FLAG;
			else
				fifo[fifo_idx]      := b;
			end
			fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] + 8;
			if DEBUG_BITSTREAM then
				println("fifo["+fifo_idx+"] := "+b+" \t "+fifo[FIFO_CPT_BITS]);
			end
			fifo[FIFO_IDX]      := (fifo_idx+1) & (FIFO_SIZE-1);
		end
		if b = 0 then
			zeroByte := ((zeroByte << 1) + 1) & 0x3;
		else
			zeroByte := 0;
		end
	end
	
	// ********** Read CAVLC ********** //
	uint(size=7) coeff_token:=0;
	uint(size=4) total_zeros:=0;
	uint(size=4) run_before :=0;

	/*************************************************************
	*************************************************************
	********       		Slice DATA 	  	  		    *********
	*************************************************************
	*************************************************************/
	uint val_CurrMbAddr;
	uint(size=1) moreDataFlag;
	uint mb_skip_run;
	
	uint Mb_x;
	uint Mb_y;
	uint PicWidthInMbs;
	//*************************************************************/


 	procedure more_rbsp_data()   
  	var 
  		uint(size=4) cptBits = (fifo[FIFO_CPT_BITS] - 1) & 7,
		uint(size=32) res[1],
 		uint(size=4) idx     = getFifoIdx(fifo[FIFO_CPT_BITS], fifo)
	begin
		if (fifo[(idx + 1) & 7]) != 0 or ( (fifo[(idx + 3) & 7] & 0x100) = 0 and (fifo[(idx + 4) & 7] & 0x100) = 0 ) then 
				moreDataFlag:=1; 
			else 
				showBits ((cptBits + 1), fifo, res);
				moreDataFlag:=if(res[0] = 1<< cptBits) then 0 else 1 end;
			end
	end
	  
	// ********** Read CAVLC ********** //
    function TotalCoeff(int x) --> uint(size=7) : (x >> 2) end
	function TrailingOnes(int x) --> uint(size=2) : x & 3 end
	function Abs(int x) --> uint : if x >= 0 then x else -x end end

	procedure vld_ce_coeff_token()
	var 
		uint res[1]
	begin
		bool vlcDone := false;
		int VLD_Counter:=0;
		int Codeword:=0;
		if nc >=0 and nc < 2 then
			while(not vlcDone)
			do
				vld_u_name(  1, fifo, res, " vld_ce_coeff_token1 ");
				VLD_Counter := VLD_Counter + 1;
				Codeword := (Codeword << 1) + res[0];
				foreach int i in 0 .. 61 do
					if VLD_Counter = VLC_nC_0to2[i][0] and Codeword = VLC_nC_0to2[i][1] then coeff_token := VLC_nC_0to2[i][2]; vlcDone := true; end
				end
			end
		else
			if nc >=2 and nc < 4 then
				while(not vlcDone)
				do
					vld_u_name(  1, fifo, res, " vld_ce_coeff_token2 ");
					VLD_Counter := VLD_Counter + 1;
					Codeword := (Codeword << 1) + res[0];
					foreach int i in 0 .. 61 do
						if VLD_Counter = VLC_nC_2to4[i][0] and Codeword = VLC_nC_2to4[i][1] then coeff_token := VLC_nC_2to4[i][2]; vlcDone := true; end
					end
				end
			else
				if nc >=4 and nc < 8 then
					while(not vlcDone)
					do
						vld_u_name(  1, fifo, res, " vld_ce_coeff_token3 ");
						VLD_Counter := VLD_Counter + 1;
						Codeword := (Codeword << 1) + res[0];
						foreach int i in 0 .. 61 do
							if VLD_Counter = VLC_nC_4to8[i][0] and Codeword = VLC_nC_4to8[i][1] then coeff_token := VLC_nC_4to8[i][2]; vlcDone := true; end
						end
					end
				else
					if nc >=8 then
						while(not vlcDone)
						do
							vld_u_name(  1, fifo, res, " vld_ce_coeff_token4 ");
							VLD_Counter := VLD_Counter + 1;
							Codeword := (Codeword << 1) + res[0];
							foreach int i in 0 .. 61 do
								if VLD_Counter = VLC_nC_8[i][0] and Codeword = VLC_nC_8[i][1] then coeff_token := VLC_nC_8[i][2]; vlcDone := true; end
							end
						end
					else
						while(not vlcDone)
						do
							vld_u_name(  1, fifo, res, " vld_ce_coeff_token5 ");
							VLD_Counter := VLD_Counter + 1;
							Codeword := (Codeword << 1) + res[0];
							foreach int i in 0 .. 61 do
								if nc = -1 and i <14 then
									if VLD_Counter = VLC_nC_1[i][0] and Codeword = VLC_nC_1[i][1] then coeff_token := VLC_nC_1[i][2]; vlcDone := true; end
								else
									if nc = -2 and i <30 then
										if VLD_Counter = VLC_nC_2[i][0] and Codeword = VLC_nC_2[i][1] then coeff_token := VLC_nC_2[i][2]; vlcDone := true; end
									end
								end
							end
						end
					end
				end
			end
		end
	end
  
	procedure vld_ce_total_zeros()
	var 
		uint res[1]
	begin
		bool vlcDone := false;
		int VLD_Counter:=0;
		int Codeword:=0;
		while(not vlcDone)
		do
			vld_u_name(  1, fifo, res, " vld_ce_total_zeros ");
			VLD_Counter := VLD_Counter + 1;
			Codeword := ( (Codeword << 1) | if res[0] = 1 then 1 else 0 end);
			foreach int i in 0 .. (maxNumCoeff - TotalCoeff(coeff_token) ) do
				if maxNumCoeff != 4 and maxNumCoeff !=8 then 
					if VLD_Counter = VLC_total0[TotalCoeff(coeff_token)-1][i][0] and Codeword = VLC_total0[TotalCoeff(coeff_token)-1][i][1] then 
						total_zeros := VLC_total0[TotalCoeff(coeff_token)-1][i][2]; vlcDone := true; 
					end
				else 
					if maxNumCoeff = 4 then
						if VLD_Counter = VLC_total0_Cr_DC2x2[TotalCoeff(coeff_token)-1][i][0] and Codeword = VLC_total0_Cr_DC2x2[TotalCoeff(coeff_token)-1][i][1] then 
							total_zeros := VLC_total0_Cr_DC2x2[TotalCoeff(coeff_token)-1][i][2]; vlcDone := true; 
						end
					else //maxNumCoeff = 8
						println("Chroma DC 2x4 block not implemented");
					end
				end
			end
		end
	end
			
	procedure vld_ce_run_before()
	var 
		uint res[1]
	begin
		bool vlcDone := false;
		int VLD_Counter:=0;
		int Codeword:=0;
		if zerosLeft > 6 then
			while(not vlcDone)
			do
				vld_u_name(  1, fifo, res, " run_before1 ");
				VLD_Counter := VLD_Counter + 1;
				Codeword := ( (Codeword << 1) | if res[0] = 1 then 1 else 0 end);
				foreach int i in 0 .. zerosLeft do
					if VLD_Counter = VLC_run_before[6][i][0] and Codeword = VLC_run_before[6][i][1] then 
						run_before := VLC_run_before[6][i][2]; vlcDone := true; 
					end
				end
			end
		else // zerosLeft <= 6
			while(not vlcDone)
			do
				vld_u_name(  1, fifo, res, " run_before2 ");
				VLD_Counter := VLD_Counter + 1;
				Codeword := ( (Codeword << 1) | if res[0] = 1 then 1 else 0 end);
				foreach int i in 0 .. zerosLeft do
					if VLD_Counter = VLC_run_before[zerosLeft-1][i][0] and Codeword = VLC_run_before[zerosLeft-1][i][1] then
						run_before := VLC_run_before[zerosLeft-1][i][2]; vlcDone := true; 
					end         
				end
			end
		end
	end
	
	/*************************************************************
	*************************************************************
	********              NAL Unit HEADER                ********
	*************************************************************
	*************************************************************/

	look_for_Sequence_Header: action ==>
	end

	uint(size=2) nal_ref_idc :=0;
	uint(size=5) nal_unit_type :=0;
	
	read_Nal_unit_header: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		//println("=========== NAL_UNIT ===========");
		flushBits_name( 1, fifo,   "reserved_zero_1bits                     ");
		vld_u_name(  2, fifo, res, "nal_ref_idc                             "); nal_ref_idc  := res[0];
		vld_u_name(  5, fifo, res, "nal_unit_type                           "); nal_unit_type := res[0];
	end 
 
	look_for_other_header: action ==>
	end

	uint(size=8) sps_profile_idc;
	uint(size=8) sps_level_idc;


	look_for.Sps_header: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		nal_unit_type = NAL_UNIT_SPS
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "profile_idc                             "); sps_profile_idc                := res[0];
		flushBits_name( 1, fifo,   "constraint_set0_flag                    ");
		flushBits_name( 1, fifo,   "constraint_set1_flag                    ");
		flushBits_name( 1, fifo,   "constraint_set2_flag                    ");
		flushBits_name( 1, fifo,   "constraint_set3_flag                    ");
		flushBits_name( 1, fifo,   "constraint_set4_flag                    ");
		flushBits_name( 3, fifo,   "reserved_zero_3bits                     ");
		vld_u_name(  8, fifo, res, "level_idc                               "); sps_level_idc                  := res[0];
	end

	look_for.Pps_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_PPS
	end
 
	look_for.Slice_header: action ==>
	guard
		nal_unit_type = NAL_UNIT_IDR or nal_unit_type = NAL_UNIT_NON_IDR
	end

	/*************************************************************
	*************************************************************
	********        Sequence Parameter Set HEADER        ********
	*************************************************************
	*************************************************************/

	int sps_i;
	uint(size=8) level_idc[32] := [ 0 : for int i in 0 .. 31 ];
	uint(size=5) sps_id;

	// High Profile
	uint(size=2) chroma_format_idc[32] := [ 1 : for int i in 0 .. 31 ];
	uint(size=3) bit_depth_luma_minus8[32] := [ 0 : for int i in 0 .. 31 ];
	uint(size=3) bit_depth_chroma_minus8[32] := [ 0 : for int i in 0 .. 31 ];
	uint(size=8) varScaling[6];
	uint(size=1) sps_scaling_matrix_present_flag[32];
	uint(size=1) scaling_list_present_flag;
	uint(size=8) sps_ScalingList4x4[32][6][16];
	uint(size=8) sps_ScalingList8x8[32][2][64];
	uint(size=8) DEFAULT_SCALING4[2][16] = 
	[
   		[
			 6, 13, 13, 20,
   			20, 20, 28, 28,
   			28, 28, 32, 32,
   			32, 37, 37, 42
   		],[
   			10, 14, 14, 20,
   			20, 20, 24, 24,
   			24, 24, 27, 27,
   			27, 30, 30, 34
		]
	];
	uint(size=8) DEFAULT_SCALING8[2][64] = 
	[
		[
			 6, 10, 10, 13, 11, 13, 16, 16, 
			16, 16, 18, 18, 18, 18, 18, 23, 
			23, 23, 23, 23, 23, 25, 25, 25, 
			25, 25, 25, 25, 27, 27, 27, 27, 
			27, 27, 27, 27, 29, 29, 29, 29, 
			29, 29, 29, 31, 31, 31, 31, 31, 
			31, 33, 33, 33, 33, 33, 36, 36, 
			36, 36, 38, 38, 38, 40, 40, 42
		],[
		 	 9, 13, 13, 15, 13, 15, 17, 17, 
			17, 17, 19, 19, 19, 19, 19, 21, 
			21, 21, 21, 21, 21, 22, 22, 22, 
			22, 22, 22, 22, 24, 24, 24, 24, 
			24, 24, 24, 24, 25, 25, 25, 25, 
			25, 25, 25, 27, 27, 27, 27, 27, 
			27, 28, 28, 28, 28, 28, 30, 30, 
			30, 30, 32, 32, 32, 33, 33, 35
   		]
   	];

	uint(size=4) log2_max_frame_num_minus4[32] := [ 0 : for int i in 0 .. 31 ];
	uint(size=2) pic_order_cnt_type[32] := [ 0 : for int i in 0 .. 31 ];
	uint(size=4) log2_max_pic_order_cnt_lsb_minus4[32] := [ 0 : for int i in 0 .. 31 ];
  
	uint(size=1) delta_pic_order_always_zero_flag[32] := [ 0 : for int i in 0 .. 31 ];
	int offset_for_non_ref_pic[32] := [ 0 : for int i in 0 .. 31 ];
	int offset_for_top_to_bottom_field[32] := [ 0 : for int i in 0 .. 31 ];
	uint(size=8) num_ref_frames_in_pic_order_cnt_cycle[32] := [ 0 : for int i in 0 .. 31 ];
	int offset_for_ref_frame[32][255] := [[ 0 : for int i in 0 .. 254 ]: for int j in 0 .. 31 ];

	uint num_ref_frames[32] := [ 0 : for int i in 0 .. 31 ];
	uint pic_width_in_mbs_minus1[32] := [ 0 : for int i in 0 .. 31 ];
	uint pic_height_in_map_units_minus1[32] := [ 0 : for int i in 0 .. 31 ];
	uint(size=1) frame_mbs_only_flag[32] := [ 0 : for int i in 0 .. 31 ];
	bool direct_8x8_interference_flag[32] := [ false : for int i in 0 .. 31 ];

	uint(size=5) MaxDPBSz[32] := [16 : for int i in 0 .. 31];
	uint(size=1) frame_cropping_flag;
	uint(size=1) vui_parameters_present_flag;

	read_Sps_id: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "seq_parameter_set_id                    "); sps_id                     := res[0]; // getBits(10) max
		level_idc[sps_id] := sps_level_idc;
		sps_ScalingList4x4[sps_id] := [[16 : for int i in 0 .. 15] : for int j in 0 .. 5];
		sps_ScalingList8x8[sps_id] := [[16 : for int i in 0 .. 63] : for int j in 0 .. 1];		
	end
  
	read_Sps_chroma_format_idc: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		sps_profile_idc = 100 or sps_profile_idc = 110 or
		sps_profile_idc = 122 or sps_profile_idc = 244 or sps_profile_idc = 44 or
		sps_profile_idc = 83 or sps_profile_idc = 86 or sps_profile_idc = 118
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "chroma_format_idc                       "); chroma_format_idc[sps_id] := res[0];
	end
	read_Sps_chroma_format_idc_check.IsEqualTo3: action ==>
	guard
		chroma_format_idc[sps_id] = 3
	do
		println("chroma_format_idc = 3 not managed yet !");
	end
	read_Sps_chroma_format_idc_check.IsNotEqualTo3: action ==>
	guard
		chroma_format_idc[sps_id] != 3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "bit_depth_luma_minus8                   "); bit_depth_luma_minus8[sps_id] := res[0];
		vld_ue_name(    fifo, res, "bit_depth_chroma_minus8                 "); bit_depth_chroma_minus8[sps_id] := res[0];
		vld_u_name( 1, fifo, res,  "qpprime_y_zero_transform_bypass_flag    ");
		vld_u_name( 1, fifo, res,  "seq_scaling_matrix_present_flag         "); sps_scaling_matrix_present_flag[sps_id] := res[0];
	end
	
	/******************************************************************************
	 * ScalingMatrix Loop
	 *****************************************************************************/
	read_Sps_secScalingFlag.isEqualToTrue: action ==>
	guard
		sps_scaling_matrix_present_flag[sps_id] = 1
	var
		uint(size=32) res[1]
	do
		varScaling[0]  := 0; // i index loop
		varScaling[5]  := 7; // end index loop		
		vld_u_name(1,  fifo, res, "seq_scaling_list_present_flag         ");
		scaling_list_present_flag := res[0];		
	end
	read_Sps_secScalingFlag.isEqualToFalse: action ==>
	guard
		sps_scaling_matrix_present_flag[sps_id] = 0
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "log2_max_frame_num_minus4               ");
		log2_max_frame_num_minus4[sps_id] := res[0];
		vld_ue_name(    fifo, res, "pic_order_cnt_type                      ");
		pic_order_cnt_type[sps_id] := res[0];
	end
	read_Sps_scalingMatrix.present: action ==>
	guard
		scaling_list_present_flag = 1
	do
		varScaling[1] := 0; // j index loop
		if varScaling[0] < 6 then
			varScaling[2] := 15; // j index end
		else
			varScaling[2] := 63; // j index end
		end
		varScaling[3] := 8; // lastScale
		varScaling[4] := 8; // nextScale
	end
	read_Sps_scalingMatrix.noPresent: action ==>
	guard
		scaling_list_present_flag = 0
	do
		if varScaling[0] < 6 then
			if varScaling[0] = 0 or varScaling[0] = 3 then
				foreach int i in 0 .. 15 do
					sps_ScalingList4x4[pps_id][varScaling[0]][i] := DEFAULT_SCALING4[varScaling[0]&1][i];
				end
			else
				foreach int i in 0 .. 15 do
					sps_ScalingList4x4[pps_id][varScaling[0]][i] := sps_ScalingList4x4[pps_id][varScaling[0]-1][i];
				end
			end
		else
			foreach int i in 0 .. 63 do
				sps_ScalingList8x8[pps_id][varScaling[0]-6][i] := DEFAULT_SCALING8[varScaling[0]-6][i];
			end
		end
	end
	read_Sps_scalingMatrix.loopNext: action ==>
	guard
		varScaling[0] != varScaling[5]
	var
		uint(size=32) res[1]
	do
		varScaling[0] := varScaling[0] + 1;
		vld_u_name(1,  fifo, res, "seq_scaling_list_present_flag         ");
		scaling_list_present_flag := res[0];		
	end
	read_Sps_scalingMatrix.loopEnd: action ==>
	guard
		varScaling[0] = varScaling[5]
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "log2_max_frame_num_minus4               ");
		log2_max_frame_num_minus4[sps_id] := res[0];
		vld_ue_name(    fifo, res, "pic_order_cnt_type                      ");
		pic_order_cnt_type[sps_id] := res[0];
	end
/******************************************************************************
 * ScalingList Loop
 *****************************************************************************/
	read_Sps_scalingListLoop: action ==>
	guard
		varScaling[4] != 0,
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var 
		int(size=32) res[1],
		uint(size=8) tmp := varScaling[3] 
	do
		vld_se_name(  fifo, res,   "delta_scale                                     ");
		varScaling[4] := (tmp + res[0]) & 255;		
		if varScaling[4] != 0 then
			tmp := varScaling[4];
		end
		if varScaling[0] < 6 then
			sps_ScalingList4x4[pps_id][varScaling[0]][varScaling[1]] := tmp;
		else
			sps_ScalingList8x8[pps_id][varScaling[0]-6][varScaling[1]] := tmp;
		end
		varScaling[3] := tmp;
	end
	read_Sps_scalingListNext: action ==> 
	guard
		varScaling[4] != 0 and varScaling[1] != varScaling[2]
	do
		varScaling[1] := varScaling[1] + 1;
	end
	read_Sps_scalingListEnd.nextScaleNull.noDefaultList: action ==>
	guard
		varScaling[4] = 0 and varScaling[1] != 0
	do
		if varScaling[0]<6 then
			foreach int i in varScaling[1] .. 15 do
				sps_ScalingList4x4[pps_id][varScaling[0]][i] := varScaling[3];
			end
		else
			foreach int i in varScaling[1] .. 63 do
				sps_ScalingList8x8[pps_id][varScaling[0]-6][i] := varScaling[3];
			end
		end
	end
	read_Sps_scalingListEnd.nextScaleNull.DefaultList: action ==>
	guard
		varScaling[4] = 0 and varScaling[1] = 0
	do
		if varScaling[0]<3 then
			foreach int i in 0 .. 15 do
				pps_ScalingList4x4[pps_id][varScaling[0]][i] := DEFAULT_SCALING4[0][i];
			end
		elsif varScaling[0]<6 then
			foreach int i in 0 .. 15 do
				pps_ScalingList4x4[pps_id][varScaling[0]][i] := DEFAULT_SCALING4[1][i];
			end
		else
			foreach int i in 0 .. 63 do
				pps_ScalingList8x8[pps_id][varScaling[0]-6][i] := DEFAULT_SCALING8[varScaling[0]-6][i];
			end
		end
	end
	read_Sps_scalingListEnd.nextScaleNoNull: action ==>
	guard
		varScaling[4] != 0
	end
	
	read_Sps_log2_max_frame_num_minus4: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "log2_max_frame_num_minus4               ");
		log2_max_frame_num_minus4[sps_id] := res[0];
		vld_ue_name(    fifo, res, "pic_order_cnt_type                      ");
		pic_order_cnt_type[sps_id] := res[0];
	end

	// if pic_order_cnt_type == 0
	read_Sps_log2_max_pic_order_cnt_lsb_minus4: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		pic_order_cnt_type[sps_id] = 0
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "log2_max_pic_order_cnt_lsb_minus4       ");
		log2_max_pic_order_cnt_lsb_minus4[sps_id] := res[0];
	end
 
	// else if pic_order_cnt_type == 1
	read_Sps_delta_pic_order_always_zero_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		pic_order_cnt_type[sps_id] = 1
	var
		int(size=32) res[1]
	do
		vld_u_name( 1, fifo, res,  "delta_pic_order_always_zero_flag        ");
		delta_pic_order_always_zero_flag[sps_id] := res[0];
		vld_se_name(    fifo, res, "offset_for_non_ref_pic                  ");
		offset_for_non_ref_pic[sps_id] := res[0];
	end

	read_Sps_offset_for_top_to_bottom_field: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		vld_se_name(    fifo, res, "offset_for_top_to_bottom_field          ");
		offset_for_top_to_bottom_field[sps_id] := res[0];
		vld_ue_name(    fifo, res, "num_ref_frames_in_pic_order_cnt_cycle   ");
		num_ref_frames_in_pic_order_cnt_cycle[sps_id] := res[0];
		sps_i:=0;
	end

	// for (i=0 ; i<num_ref_frames_in_pic_order_cnt_cycle ; i++) 
	read_Sps_offset_for_ref_frame.loop: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		sps_i<num_ref_frames_in_pic_order_cnt_cycle[sps_id]
	var
		int(size=32) res[1]
	do
		vld_se_name(    fifo, res, "offset_for_ref_frame                    ");
		offset_for_ref_frame[sps_id][sps_i] := res[0];
		sps_i := sps_i + 1;
	end

	read_Sps_offset_for_ref_frame.done: action ==>
	guard
		sps_i=num_ref_frames_in_pic_order_cnt_cycle[sps_id]
	end
	// end for

	// else (pic_order_cnt_type != 0 and !=1)
	read_Sps_pic_order_cnt_type_skip01: action ==>
	guard
		pic_order_cnt_type[sps_id] !=0,
		pic_order_cnt_type[sps_id] !=1
	end
	// end if

	read_Sps_num_ref_frames: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res,   "num_ref_frames                          ");
		num_ref_frames[sps_id] := res[0];
		flushBits_name(1,  fifo,   "gaps_in_frame_num_value_allowed_flag    ");
		vld_ue_name(    fifo, res, "pic_width_in_mbs_minus1                 ");
		pic_width_in_mbs_minus1[sps_id] := res[0];
		vld_ue_name(    fifo, res, "pic_height_in_map_units_minus1          ");
		pic_height_in_map_units_minus1[sps_id] := res[0];
	end

	read_Sps_frame_mbs_only_flag: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(1, fifo, res,   "frame_mbs_only_flag                     ");
		frame_mbs_only_flag[sps_id] := res[0];
	end

	// if (!frame_mbs_only_flag)
	read_Sps_mb_adaptive_frame_field_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) PicWidthInMacroBs,
		uint(size=32) FrameHeightInMacroBs,
		uint(size=8)  Val_Level_IDC,
		int(size=32)  MaxDPB_x_2,
		uint(size=32) MaxFS,
		uint(size=32) Sqrt_8MaxFS,
		uint(size=32) FrameHeight_x_PicWidth,
		uint(size=32) MaxDPBSize,
		uint(size=32) res[1]
	do
		if (frame_mbs_only_flag[sps_id] = 0) then
			frame_mbs_only_flag[sps_id] := 0;
			Val_Level_IDC := level_idc[sps_id];
			if(Val_Level_IDC < 31) then                          // 1 <= Level Number <= 3
				if(Val_Level_IDC < 12) then                           // 1 <= Level Number <= 1.1
					if(   Val_Level_IDC = 10 
					   or ((level_idc[sps_id] & 0x10) = 0)) then            // Level Number = 1 or 1b
						MaxFS       := 99;
						Sqrt_8MaxFS := 28;
						MaxDPB_x_2  := 297;
					else                                                        // Level Number = 1.1
						MaxFS       := 396;
						Sqrt_8MaxFS := 56;
						MaxDPB_x_2  := 675;
					end
				else                                                  // 1.2 <= Level Number <= 3
					if(Val_Level_IDC < 21) then                                 // 1.2 <= Level Number <= 2
						MaxFS       := 396;
						Sqrt_8MaxFS := 56;
						MaxDPB_x_2  := 1782;
					else                                              // 2.1 <= Level Number <= 3
						if(Val_Level_IDC = 21) then                             // Level Number = 2.1
							MaxFS       := 792;
							Sqrt_8MaxFS := 80;//79.5989
							MaxDPB_x_2  := 3564;
						else                                                    // Level Number = 2.2 or 3
							MaxFS       := 1620;
							Sqrt_8MaxFS := 114;//113.8419
							MaxDPB_x_2  := 6075;
						end
					end
				end
			else                                                 // 3.1 <= Level Number <= 5.1
				if(Val_Level_IDC < 42) then                           // 3.1 <= Level Number <= 4.1
					if(Val_Level_IDC < 33) then                            // 3.1 <= Level Number <= 3.2
						if(Val_Level_IDC = 31) then                             // Level Number = 3.1
							MaxFS       := 3600;
							Sqrt_8MaxFS := 170;//169.7056
							MaxDPB_x_2  := 13500;
						else                                                    // Level Number = 3.2
							MaxFS       := 5120;
							Sqrt_8MaxFS := 202;//202.3858
							MaxDPB_x_2  := 15360;
						end
					else                                                        // Level Number = 4 or 4.1
						MaxFS       := 8192;
						Sqrt_8MaxFS := 256;//256
						MaxDPB_x_2  := 24576;
					end
				else                                                  // 4.2 <= Level Number <= 5.1
					if(Val_Level_IDC = 42) then                                 // Level Number = 4.2
						MaxFS       := 8704;
						Sqrt_8MaxFS := 264;//263.8788
						MaxDPB_x_2  := 26112;
					else
						if(Val_Level_IDC = 50) then                             // Level Number = 5
							MaxFS       := 22080;
							Sqrt_8MaxFS := 420;//420.2856
							MaxDPB_x_2  := 82800;
						else                                                    // Level Number = 5.1
							MaxFS       := 36864;
							Sqrt_8MaxFS := 543;//543.0580
							MaxDPB_x_2  := 138240;
						end
					end
				end
			end
			PicWidthInMacroBs    := pic_width_in_mbs_minus1[sps_id] + 1;
			FrameHeightInMacroBs := (2 - 0) * (pic_height_in_map_units_minus1[sps_id] + 1);
			if(PicWidthInMacroBs > Sqrt_8MaxFS) then
				PicWidthInMacroBs := Sqrt_8MaxFS;
			end
			if(FrameHeightInMacroBs > Sqrt_8MaxFS) then
				FrameHeightInMacroBs := Sqrt_8MaxFS;
			end
			FrameHeight_x_PicWidth := FrameHeightInMacroBs * PicWidthInMacroBs;
			if(FrameHeight_x_PicWidth > MaxFS) then
				FrameHeight_x_PicWidth := MaxFS;
			end
			MaxDPBSize := (512 * MaxDPB_x_2) / (FrameHeight_x_PicWidth * 384);
			if(MaxDPBSize >= 16) then
				MaxDPBSz[sps_id] := 16;
			else
				MaxDPBSz[sps_id] := MaxDPBSize;
			end
			vld_u_name(1, fifo, res,   "mb_adaptive_frame_field_flag                             ");
		else //frame_mbs_only_flag[sps_id] != 0
			Val_Level_IDC := level_idc[sps_id];
			if(Val_Level_IDC < 31) then                          // 1 <= Level Number <= 3
				if(Val_Level_IDC < 12) then                           // 1 <= Level Number <= 1.1
					if(   Val_Level_IDC = 10 
					   or ((level_idc[sps_id] & 0x10) = 0)) then            // Level Number = 1 or 1b
						MaxFS       := 99;
						Sqrt_8MaxFS := 28;
						MaxDPB_x_2  := 297;
					else                                                        // Level Number = 1.1
						MaxFS       := 396;
						Sqrt_8MaxFS := 56;
						MaxDPB_x_2  := 675;
					end
				else                                                  // 1.2 <= Level Number <= 3
					if(Val_Level_IDC < 21) then                                 // 1.2 <= Level Number <= 2
						MaxFS       := 396;
						Sqrt_8MaxFS := 56;
						MaxDPB_x_2  := 1782;
					else                                              // 2.1 <= Level Number <= 3
						if(Val_Level_IDC = 21) then                             // Level Number = 2.1
							MaxFS       := 792;
							Sqrt_8MaxFS := 80;//79.5989
							MaxDPB_x_2  := 3564;
						else                                                    // Level Number = 2.2 or 3
							MaxFS       := 1620;
							Sqrt_8MaxFS := 114;//113.8419
							MaxDPB_x_2  := 6075;
						end
					end
				end
			else                                                 // 3.1 <= Level Number <= 5.1
				if(Val_Level_IDC < 42) then                           // 3.1 <= Level Number <= 4.1
					if(Val_Level_IDC < 33) then                            // 3.1 <= Level Number <= 3.2
						if(Val_Level_IDC = 31) then                             // Level Number = 3.1
							MaxFS       := 3600;
							Sqrt_8MaxFS := 170;//169.7056
							MaxDPB_x_2  := 13500;
						else                                                    // Level Number = 3.2
							MaxFS       := 5120;
							Sqrt_8MaxFS := 202;//202.3858
							MaxDPB_x_2  := 15360;
						end
					else                                                        // Level Number = 4 or 4.1
						MaxFS       := 8192;
						Sqrt_8MaxFS := 256;//256
						MaxDPB_x_2  := 24576;
					end
				else                                                  // 4.2 <= Level Number <= 5.1
					if(Val_Level_IDC = 42) then                                 // Level Number = 4.2
						MaxFS       := 8704;
						Sqrt_8MaxFS := 264;//263.8788
						MaxDPB_x_2  := 26112;
					else
						if(Val_Level_IDC = 50) then                             // Level Number = 5
							MaxFS       := 22080;
							Sqrt_8MaxFS := 420;//420.2856
							MaxDPB_x_2  := 82800;
						else                                                    // Level Number = 5.1
							MaxFS       := 36864;
							Sqrt_8MaxFS := 543;//543.0580
							MaxDPB_x_2  := 138240;
						end
					end
				end
			end
			PicWidthInMacroBs    := pic_width_in_mbs_minus1[sps_id] + 1;
			FrameHeightInMacroBs := (2 - 0) * (pic_height_in_map_units_minus1[sps_id] + 1);
			if(PicWidthInMacroBs > Sqrt_8MaxFS) then
				PicWidthInMacroBs := Sqrt_8MaxFS;
			end
			if(FrameHeightInMacroBs > Sqrt_8MaxFS) then
				FrameHeightInMacroBs := Sqrt_8MaxFS;
			end
			FrameHeight_x_PicWidth := FrameHeightInMacroBs * PicWidthInMacroBs;
			if(FrameHeight_x_PicWidth > MaxFS) then
				FrameHeight_x_PicWidth := MaxFS;
			end
			MaxDPBSize := (512 * MaxDPB_x_2) / (FrameHeight_x_PicWidth * 384);
			if(MaxDPBSize >= 16) then
				MaxDPBSz[sps_id] := 16;
			else
				MaxDPBSz[sps_id] := MaxDPBSize;
			end
		end
	end

	read_Sps_direct_8x8_interference_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(1, fifo, res,   "direct_8x8_interference_flag                    ");
		direct_8x8_interference_flag[sps_id] := if res[0] = 1 then true else false end;
		vld_u_name(1, fifo, res,   "frame_cropping_flag                             ");
		frame_cropping_flag := res[0];
	end

	// if (frame_cropping_flag)
	read_Sps_frame_crop_left_offset: action ==>
	guard
		frame_cropping_flag = 1
	var
		uint(size=32) res[1]
	do 
		vld_ue_name( fifo, res,   "frame_crop_left_offset                    ");
		println("frame_crop_left_offset :=" +  res[0]);
		vld_ue_name( fifo, res,   "frame_crop_right_offset                    ");
		println("frame_crop_right_offset :=" +  res[0]);
		vld_ue_name( fifo, res,   "frame_crop_top_offset                    ");
		println("frame_crop_top_offset :=" +  res[0]);
		vld_ue_name( fifo, res,   "frame_crop_bottom_offset                    ");
		println("frame_crop_bottom_offset :=" +  res[0]);
	end


	// else (!frame_cropping_flag)
	read_Sps_skip_frame_crop_left_offset: action ==>
	guard
		frame_cropping_flag = 0
	end
	//end if 

	read_Sps_vui_parameters_present_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(1, fifo, res,   "vui_parameters_present_flag                             ");
		vui_parameters_present_flag := res[0];
	end

	read_Sps_vui_parameters: action ==>
	guard
		vui_parameters_present_flag=1
	do
		println("vui_parameters_present_flag not not managed yet !");	
	end
		
	read_Sps_done: action ==>
	guard
		vui_parameters_present_flag=0
	end
	/******* End of Sequence Parameter Set HEADER  ********/

	/*************************************************************
	*************************************************************
	********        Picture Parameter Set HEADER        *********
	*************************************************************
	*************************************************************/
	uint(size=8) pps_id;
	uint(size=5) sequence_parameter_set_id[255] := [ 0 : for int i in 0 .. 254];
	uint(size=1) entropy_coding_mode_flag[255] := [ 0 : for int i in 0 .. 254];
	uint(size=1) bottom_field_pic_order_in_frame_present_flag[255] := [ 0 : for int i in 0 .. 254];
	uint(size=3) num_slice_groups_minus1[255] := [ 0 : for int i in 0 .. 254];
	uint(size=3) slice_group_map_type[255] := [ 0 : for int i in 0 .. 254];

	uint slice_group_change_rate_minus1[255] := [ 0 : for int i in 0 .. 254];

	uint(size=5) num_ref_idx_l0_active_minus1[255] := [ 0 : for int i in 0 .. 254];
	uint(size=5) num_ref_idx_l1_active_minus1[255] := [ 0 : for int i in 0 .. 254];
	bool weighted_pred_flag[255] := [ false : for int i in 0 .. 254];
	uint(size=2) weighted_bipred_idc[255] := [ 0 : for int i in 0 .. 254];
	int(size=6) pic_init_qp_minus26[255] := [ 0 : for int i in 0 .. 254];
	int(size=5) chroma_qp_index_offset[255] := [ 0 : for int i in 0 .. 254];
	uint(size=1) deblocking_filter_control_present_flag[255] := [ 0 : for int i in 0 .. 254];
	bool constrained_intra_pred_flag[255] := [ false : for int i in 0 .. 254];
	uint(size=1) redundant_pic_cnt_present_flag[255] := [ 0 : for int i in 0 .. 254];

	//High profile 
	uint(size=1) transform_8x8_mode_flag[255] := [ 0 : for int i in 0 .. 254];
	uint(size=1) pps_scaling_matrix_present_flag;
	uint(size=8) pps_ScalingList4x4[255][6][16];
	uint(size=8) pps_ScalingList8x8[255][2][64];
	int(size=5) second_chroma_qp_index_offset[255] := [ 0 : for int i in 0 .. 254];


	//*************************************
	read_Pps_seq_parameter_set_id: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res,   "pps_id                             ");
		pps_id := res[0];
		vld_ue_name(  fifo, res,   "sequence_parameter_set_id                             ");
		sequence_parameter_set_id[pps_id] := res[0];
		sps_id := res[0];
		foreach int i in 0 .. 5 do
			foreach int j in 0 .. 15 do
				pps_ScalingList4x4[pps_id][i][j] := sps_ScalingList4x4[res[0]][i][j];
			end
		end
		foreach int i in 0 .. 1 do
			foreach int j in 0 .. 63 do
				pps_ScalingList8x8[pps_id][i][j] := sps_ScalingList8x8[res[0]][i][j];
			end
		end
	end

	read_Pps_num_slice_groups_minus1: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(1,  fifo, res,  "entropy_coding_mode_flag                             ");
		entropy_coding_mode_flag[pps_id] := res[0];
		vld_u_name(1,  fifo, res,  "bottom_field_pic_order_in_frame_present_flag                             ");
		bottom_field_pic_order_in_frame_present_flag[pps_id] := res[0];
		vld_ue_name(  fifo, res,   "num_slice_groups_minus1                             ");
		num_slice_groups_minus1[pps_id] := res[0];
	end

	// if (num_slice_groups_minus1 <=0)
	read_Pps_slice_group_map_type_skip: action ==>
	guard
		num_slice_groups_minus1[pps_id] = 0
	end

	// if (num_slice_groups_minus1 >0)
	read_Pps_slice_group_map_type: action ==>
	guard
		num_slice_groups_minus1[pps_id] > 0
	do
		println("num_slice_groups_minus1 > 0 not yet implemented");
	end
	// end if

	read_Pps_num_ref_idx_l0_active_minus1: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res,   "num_ref_idx_l0_active_minus1                    ");
		num_ref_idx_l0_active_minus1[pps_id] := res[0];
		vld_ue_name(  fifo, res,   "num_ref_idx_l1_active_minus1                    ");
		num_ref_idx_l1_active_minus1[pps_id] := res[0];
		vld_u_name(1,  fifo, res,  "weighted_pred_flag                              ");
		weighted_pred_flag[pps_id] := res[0] = 1;
		vld_u_name(2,  fifo, res,  "weighted_bipred_idc                             ");
		weighted_bipred_idc[pps_id] := res[0];
	end

	read_Pps_pic_init_qp_minus26: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		vld_se_name(  fifo, res,   "pic_init_qp_minus26                             ");
		pic_init_qp_minus26[pps_id] := res[0];
		vld_se_name(  fifo, res,   "pic_init_qs_minus26                             ");
	end

	read_Pps_chroma_qp_index_offset: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		vld_se_name(  fifo, res,   "chroma_qp_index_offset                          ");
		chroma_qp_index_offset[pps_id] := res[0];
		second_chroma_qp_index_offset[pps_id]:=res[0];
		vld_u_name(1,  fifo, res,  "deblocking_filter_control_present_flag          ");
		deblocking_filter_control_present_flag[pps_id] := res[0];
		vld_u_name(1,  fifo, res,  "constrained_intra_pred_flag                     ");
		constrained_intra_pred_flag[pps_id] := if (res[0] = 1) then true else false end ;
		vld_u_name(1,  fifo, res,  "redundant_pic_cnt_present_flag                  ");
		redundant_pic_cnt_present_flag[pps_id] := res[0];
	end

	read_Pps_more_rbsp_data: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
		more_rbsp_data();
	end 

	read_Pps_High_Profile: action ==>
	guard
		moreDataFlag = 1,
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_u_name(1,  fifo, res, "transform_8x8_mode_flag               ");
		transform_8x8_mode_flag[pps_id] := res[0];
		vld_u_name(1,  fifo, res, "pic_scaling_matrix_present_flag       ");
		pps_scaling_matrix_present_flag := res[0];		
	end

	read_Pps_not_High_Profile: action ==>
	guard
		moreDataFlag = 0
	end
	/******************************************************************************
	 * ScalingMatrix Loop
	 *****************************************************************************/
	read_Pps_secScalingFlag.isEqualToTrue: action ==>
	guard
		pps_scaling_matrix_present_flag = 1
	var
		uint(size=32) res[1]
	do
		varScaling[0]  := 0; // i index loop
		varScaling[5]  := 5 + (transform_8x8_mode_flag[pps_id]<<1); // end index loop
		vld_u_name(1,  fifo, res, "pic_scaling_list_present_flag         ");
		scaling_list_present_flag := res[0];		
	end
	read_Pps_secScalingFlag.isEqualToFalse: action ==>
	guard
		pps_scaling_matrix_present_flag = 0
	var
		int(size=32) res[1]
	do
		vld_se_name(  fifo, res,   "second_chroma_qp_index_offset                   ");
		second_chroma_qp_index_offset[pps_id] := res[0];
	end
	read_Pps_scalingMatrix.present: action ==>
	guard
		scaling_list_present_flag = 1
	do
		varScaling[1] := 0; // j index loop
		if varScaling[0] < 6 then
			varScaling[2] := 15; // j index end
		else
			varScaling[2] := 63; // j index end
		end
		varScaling[3] := 8; // lastScale
		varScaling[4] := 8; // nextScale
	end
	read_Pps_scalingMatrix.noPresent.spsPresent: action ==>
	guard
		scaling_list_present_flag = 0 and sps_scaling_matrix_present_flag[sps_id] = 1
	do
		if varScaling[0] < 6 then
			if varScaling[0] = 0 or varScaling[0] = 3 then
				foreach int i in 0 .. 15 do
					pps_ScalingList4x4[pps_id][varScaling[0]][i] := sps_ScalingList4x4[sps_id][varScaling[0]][i];
				end
			else
				foreach int i in 0 .. 15 do
					pps_ScalingList4x4[pps_id][varScaling[0]][i] := pps_ScalingList4x4[pps_id][varScaling[0]-1][i];
				end
			end
		else
			foreach int i in 0 .. 63 do
				pps_ScalingList8x8[pps_id][varScaling[0]-6][i] := sps_ScalingList8x8[sps_id][varScaling[0]-6][i];
			end
		end
	end
	read_Pps_scalingMatrix.noPresent.spsNoPresent: action ==>
	guard
		scaling_list_present_flag = 0 and sps_scaling_matrix_present_flag[sps_id] = 0
	do
		if varScaling[0] < 6 then
			if varScaling[0] = 0 or varScaling[0] = 3 then
				foreach int i in 0 .. 15 do
					pps_ScalingList4x4[pps_id][varScaling[0]][i] := DEFAULT_SCALING4[varScaling[0]&1][i];
				end
			else
				foreach int i in 0 .. 15 do
					pps_ScalingList4x4[pps_id][varScaling[0]][i] := pps_ScalingList4x4[pps_id][varScaling[0]-1][i];
				end
			end
		else
			foreach int i in 0 .. 63 do
				pps_ScalingList8x8[pps_id][varScaling[0]-6][i] := DEFAULT_SCALING8[varScaling[0]-6][i];
			end
		end
	end
	read_Pps_scalingMatrix.loopNext: action ==>
	guard
		varScaling[0] != varScaling[5]
	var
		uint(size=32) res[1]
	do
		varScaling[0] := varScaling[0] + 1;
		vld_u_name(1,  fifo, res, "pic_scaling_list_present_flag         ");
		scaling_list_present_flag := res[0];
	end
	read_Pps_scalingMatrix.loopEnd: action ==>
	guard
		varScaling[0] = varScaling[5]
	var
		int(size=32) res[1]
	do
		vld_se_name(  fifo, res,   "second_chroma_qp_index_offset                   ");
		second_chroma_qp_index_offset[pps_id] := res[0];
	end
/******************************************************************************
 * ScalingList Loop
 *****************************************************************************/
	read_Pps_scalingListLoop: action ==>
	guard
		varScaling[4] != 0,
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var 
		int(size=32) res[1],
		uint(size= 8) tmp := varScaling[3] 
	do
		vld_se_name(  fifo, res,   "delta_scale                                     ");
		varScaling[4] := (tmp + res[0]) & 255;		
		if varScaling[4] != 0 then
			tmp := varScaling[4];
		end
		if varScaling[0] < 6 then
			pps_ScalingList4x4[pps_id][varScaling[0]][varScaling[1]] := tmp;
		else
			pps_ScalingList8x8[pps_id][varScaling[0]-6][varScaling[1]] := tmp;
		end
		varScaling[3] := tmp;
	end
	read_Pps_scalingListNext: action ==> 
	guard
		varScaling[4] != 0 and varScaling[1] != varScaling[2]
	do
		varScaling[1] := varScaling[1] + 1;
	end
	read_Pps_scalingListEnd.nextScaleNull.noDefaultList: action ==>
	guard
		varScaling[4] = 0 and varScaling[1] != 0
	do
		if varScaling[0]<6 then
			foreach int i in varScaling[1] .. 15 do
				pps_ScalingList4x4[pps_id][varScaling[0]][i] := varScaling[3];
			end
		else
			foreach int i in varScaling[1] .. 63 do
				pps_ScalingList8x8[pps_id][varScaling[0]-6][i] := varScaling[3];
			end
		end
	end
	read_Pps_scalingListEnd.nextScaleNull.DefaultList: action ==>
	guard
		varScaling[4] = 0 and varScaling[1] = 0
	do
		if varScaling[0]<3 then
			foreach int i in 0 .. 15 do
				pps_ScalingList4x4[pps_id][varScaling[0]][i] := DEFAULT_SCALING4[0][i];
			end
		elsif varScaling[0]<6 then
			foreach int i in 0 .. 15 do
				pps_ScalingList4x4[pps_id][varScaling[0]][i] := DEFAULT_SCALING4[1][i];
			end
		else
			foreach int i in 0 .. 63 do
				pps_ScalingList8x8[pps_id][varScaling[0]-6][i] := DEFAULT_SCALING8[varScaling[0]-6][i];
			end
		end
	end
	read_Pps_scalingListEnd.nextScaleNoNull: action ==>
	guard
		varScaling[4] != 0
	end
	

	/******* End of Picture Parameter Set HEADER  ********/
  
	/*************************************************************
	*************************************************************
	********       Slice HEADER  	      *********
	*************************************************************
	*************************************************************/
	uint first_mb_in_slice ;
	uint(size=4) slice_type ;
	uint frame_num;
	uint(size=1) field_pic_flag := 0;
	int pic_order_cnt_lsb := 0;
	int delta_pic_order_cnt[2]  := [ 0 : for int i in 0 .. 1];
	uint(size=5) slice_num_ref_idx_l0_active_minus1 := 0;
	uint(size=5) slice_num_ref_idx_l1_active_minus1 := 0;
	uint(size=2) disable_deblocking_filter_idc := 0;
	int(size=5) slice_alpha_c0_offset_div2 := 0;
	int(size=5) slice_beta_offset_div2 := 0;
	int(size=6) val_slice_alpha_c0_offset := 0;
	int(size=6) val_slice_beta_offset := 0;

	 int(size=3) cabac_init_idc;
	uint(size=6) val_QP_Y;
	uint(size=6) val_QP_Cb;
	uint(size=6) val_QP_Cr;

	uint(size=3) SLICE_TYPE_P = 0;
	uint(size=3) SLICE_TYPE_B = 1;
	uint(size=3) SLICE_TYPE_I = 2;
	uint(size=3) SLICE_TYPE_SP = 3;
	uint(size=3) SLICE_TYPE_SI = 4;
	uint(size=1) isIDR;

	read_SliceH_slice_type: action ==> CONSTRAINED_IFLAG:[constrained_intra_pred_flag[pps_id]],
									   DIRECT_8X8_INTERFERENCE_FLAG:[direct_8x8_interference_flag[sps_id]],
									   WEIGHTED_PRED_IDC:[weightedPredOutput]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=2)  weightedPredOutput
	do
		vld_ue_name(  fifo, res,   "first_mb_in_slice                               ");
		first_mb_in_slice := res[0];
		vld_ue_name(  fifo, res,   "slice_type                                      ");
		slice_type := res[0];
		slice_type := slice_type mod 5;
		vld_ue_name(  fifo, res,   "pps_id                                          ");
		pps_id := res[0];
		sps_id := sequence_parameter_set_id[pps_id];
		weightedPredOutput :=
			if(slice_type = SLICE_TYPE_B) then
				weighted_bipred_idc[pps_id]
			else if(slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP) then
				if(weighted_pred_flag[pps_id]) then
					1
				else
					0
				end
			else
				0
			end end;
		
	end

	read_SliceH_picSize: action ==> 
		PIC_SIZE_IN_MB:[pic_width_in_mbs_minus1[sps_id] + 1, pic_height_in_map_units_minus1[sps_id] + 1], 
		WIDTH:[pic_width_in_mbs_minus1[sps_id] + 1], HEIGHT:[pic_height_in_map_units_minus1[sps_id] + 1]
	guard
		first_mb_in_slice = 0
	end

	read_SliceH_skip_picSize: action ==> 
	guard
		first_mb_in_slice != 0
	end

	read_SliceH_frame_num: action ==> NUM_REF_FRAMES:[num_ref_frames[sps_id] ],FRAME_NUM:[frame_num], MAX_FRAME_NUM:[ValMaxFrameNum]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		int(size=32) ValMaxFrameNum
	do
		vld_u_name(4+log2_max_frame_num_minus4[sps_id],  fifo, res, "frame_num                             ");
		frame_num := res[0];
		ValMaxFrameNum := 1 << (log2_max_frame_num_minus4[sps_id] + 4);
		if(frame_mbs_only_flag[sps_id] = 0) then
			vld_u_name(1,  fifo, res,   "field_pic_flag                             ");
			field_pic_flag := res[0];
			if (field_pic_flag=1) then
				vld_u_name(1,  fifo, res,  "bottom_field_flag                             ");
			end
		end
	end

	//if (nal_unit_type == 5)
	read_SliceH_idr_pic_id: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		isIDR := if nal_unit_type = 5 then 1 else 0 end;
		if(nal_unit_type = 5) then
			vld_ue_name(  fifo, res, "idr_pic_id                             ");
		end
		if (pic_order_cnt_type[sps_id] = 0) then
			vld_u_name(log2_max_pic_order_cnt_lsb_minus4[sps_id] +4,  fifo, res, "pic_order_cnt_lsb                             ");
			pic_order_cnt_lsb := res[0];
			if (bottom_field_pic_order_in_frame_present_flag[pps_id] = 1 and field_pic_flag = 0) then
				vld_ue_name(  fifo, res, "delta_pic_order_cnt_bottom                             ");
			end
		end
	end

	read_SliceH_delta_pic_order_cnt0: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		if (pic_order_cnt_type[sps_id] = 1 and delta_pic_order_always_zero_flag[sps_id] = 0) then
			vld_se_name(  fifo, res, "idr_pic_id[0]                             ");
			delta_pic_order_cnt[0] := res[0];
			if( bottom_field_pic_order_in_frame_present_flag[sps_id] = 1 and field_pic_flag = 0 ) then
				vld_se_name(  fifo, res, "delta_pic_order_cnt[1]                             ");
				delta_pic_order_cnt[1] := res[0];
			end
		end
	end

	// MMO
	int prevPicOrderCntMsb := 0;
	int prevPicOrderCntLsb := 0;
	uint prev_frame_num := 0;
	uint prev_frame_num_offset := 0;

	CalcPOC: action ==>  
		POC :[POC_val], 
		DBP_MAX_SZ :[MaxDPBSz[sps_id]]
	var 
		int PicOrderCntMsb,
		int TopFieldOrderCnt,
		int BottomFieldOrderCnt,
		int MaxPicOrderCntLsb = (1 << (log2_max_pic_order_cnt_lsb_minus4[sps_id]+4)),
		int frame_num_offset, 
		int abs_frame_num, 
		int expected_delta_per_poc_cycle := 0, 
		int expectedpoc := 0,
		int POC_val:=0
	do
		if nal_unit_type = 5 then 
			frame_num_offset := 0;
			prev_frame_num := 0;
		else 
			if frame_num < prev_frame_num then
				frame_num_offset := prev_frame_num_offset + (1 << (4+log2_max_frame_num_minus4[sps_id]));
			else
				frame_num_offset := prev_frame_num_offset;
			end
		end
		if pic_order_cnt_type[sps_id] = 0 then 
			if nal_unit_type = 5 then
				prevPicOrderCntMsb := 0;
				prevPicOrderCntLsb := 0;
			end
			if  (pic_order_cnt_lsb < prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) >= (MaxPicOrderCntLsb / 2)) then
				PicOrderCntMsb :=  prevPicOrderCntMsb + MaxPicOrderCntLsb;
				prevPicOrderCntMsb := PicOrderCntMsb;
				prevPicOrderCntLsb := 0;
			else 
				if (pic_order_cnt_lsb > prevPicOrderCntLsb) and ((pic_order_cnt_lsb - prevPicOrderCntLsb) > (MaxPicOrderCntLsb / 2)) then 
					PicOrderCntMsb := prevPicOrderCntMsb - MaxPicOrderCntLsb;
					prevPicOrderCntMsb := PicOrderCntMsb;
				else
					PicOrderCntMsb :=  prevPicOrderCntMsb;
				end
			end
			BottomFieldOrderCnt := PicOrderCntMsb + pic_order_cnt_lsb;
			TopFieldOrderCnt := BottomFieldOrderCnt;
		else
			if pic_order_cnt_type[sps_id] = 1 then
				abs_frame_num := if num_ref_frames_in_pic_order_cnt_cycle[sps_id] != 0 then frame_num_offset + frame_num else 0 end ;
				if nal_ref_idc = 0 and abs_frame_num > 0 then abs_frame_num := abs_frame_num -1; end
				foreach int i in 0 .. num_ref_frames_in_pic_order_cnt_cycle[sps_id]-1 do
					expected_delta_per_poc_cycle := expected_delta_per_poc_cycle + offset_for_ref_frame[sps_id][ i ];
				end
				if abs_frame_num > 0 then
					expectedpoc := expected_delta_per_poc_cycle * ((abs_frame_num - 1) / num_ref_frames_in_pic_order_cnt_cycle[sps_id]);
					foreach int i in 0 .. ((abs_frame_num - 1) mod num_ref_frames_in_pic_order_cnt_cycle[sps_id]) do
						expectedpoc := expectedpoc + offset_for_ref_frame[sps_id][ i ];
					end
				else
					expectedpoc :=0;
				end
				if nal_ref_idc = 0 then expectedpoc := expectedpoc + offset_for_non_ref_pic[sps_id]; end
				TopFieldOrderCnt := expectedpoc + delta_pic_order_cnt[0];
				BottomFieldOrderCnt := TopFieldOrderCnt + offset_for_top_to_bottom_field[sps_id] + delta_pic_order_cnt[1];
			else // pic_order_cnt_type[sps_id] = 2
				TopFieldOrderCnt := if nal_unit_type = 5 then 0 else if nal_ref_idc > 0 then ((frame_num_offset + frame_num) << 1) else ((frame_num_offset + frame_num) << 1) - 1 end end;
				BottomFieldOrderCnt := TopFieldOrderCnt; 
			end 
		end
		POC_val := if TopFieldOrderCnt < BottomFieldOrderCnt then TopFieldOrderCnt else BottomFieldOrderCnt end ;
		prev_frame_num_offset := frame_num_offset;
		prev_frame_num := frame_num;
		prevPicOrderCntLsb := pic_order_cnt_lsb;
	end

	//if (redundant_pic_cnt_present_flag)
	read_SliceH_redundant_pic_cnt: action ==> DIRECT_SPATIAL_MV_PRED_FLAG:[direct_spatial_mv_pred_flag]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=1) num_ref_idx_active_override_flag,
		bool direct_spatial_mv_pred_flag := false
	do
		if(redundant_pic_cnt_present_flag[pps_id] = 1) then
			vld_ue_name(  fifo, res, "redundant_pic_cnt                             ");
		end
		if( slice_type = SLICE_TYPE_B ) then
			vld_u_name(1,  fifo, res, "direct_spatial_mv_pred_flag                             ");
			direct_spatial_mv_pred_flag:= if res[0] = 1 then true else false end;
		end
		if( slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP or slice_type = SLICE_TYPE_B ) then
			vld_u_name(1,  fifo, res, "num_ref_idx_active_override_flag                             ");
			num_ref_idx_active_override_flag := res[0];
			if( num_ref_idx_active_override_flag=1) then
				vld_ue_name(  fifo, res, "num_ref_idx_l0_active_minus1                             ");
				slice_num_ref_idx_l0_active_minus1 := res[0];
				if( slice_type = SLICE_TYPE_B ) then
					vld_ue_name(  fifo, res, "num_ref_idx_l1_active_minus1                             ");
					slice_num_ref_idx_l1_active_minus1 := res[0];
				end
			else
				slice_num_ref_idx_l0_active_minus1 := num_ref_idx_l0_active_minus1[pps_id];
				slice_num_ref_idx_l1_active_minus1 := num_ref_idx_l1_active_minus1[pps_id];
			end
		end
	end

	//*******  ref_pic_list_reordering  ********/
	uint(size=1) ref_pic_list_reordering_flag_l0;
	uint(size=2) reordering_of_pic_nums_idc;

	uint(size=2) REFLIST0_PRED    = 0;
	uint(size=2) REFLIST0_BI_PRED = 1;
	uint(size=2) REFLIST1_BI_PRED = 2;

	//if (slice_type % 5 != 2 && slice_type % 5 != 4)
	read_SliceH_ref_pic_list_reordering_flag_l0: action ==> REF_TYPE_l0:[if slice_type = SLICE_TYPE_B then REFLIST0_BI_PRED else REFLIST0_PRED end], REF_REORDERING_l0:[ref_pic_list_reordering_flag_l0], NB_REF_FRAME_l0:[slice_num_ref_idx_l0_active_minus1 + 1]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI
	var
		uint(size=32) res[1]
	do
		vld_u_name(1,  fifo, res, "ref_pic_list_reordering_flag_l0                             ");
		ref_pic_list_reordering_flag_l0 := res[0];
		reordering_of_pic_nums_idc :=0;
	end

	//if (ref_pic_list_reordering_flag_l0))
	//do
	read_SliceH_ref_pic_list_reordering_flag.l0.isl0: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		ref_pic_list_reordering_flag_l0 = 1
	end

	read_SliceH_reordering_of_pic_nums.l0: action ==> REF_REORDERING_l0:[reordering_of_pic_nums_idc]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res, "reordering_of_pic_nums_idc                             ");
		reordering_of_pic_nums_idc := res[0];
	end

	//if (reordering_of_pic_nums_idc == 0)
	read_SliceH_reordering_of_pic_nums_idc.l0.idc1: action ==> REF_REORDERING_l0:[abs_diff_pic_num_minus1]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		reordering_of_pic_nums_idc =0 or reordering_of_pic_nums_idc =1
	var
		uint(size=32) res[1],
		uint(size=32) abs_diff_pic_num_minus1
	do
		vld_ue_name(  fifo, res, "abs_diff_pic_num_minus1                             ");
		abs_diff_pic_num_minus1 := res[0];
	end

	//******* dec_ref_pic_marking  ********/
	uint(size=1) adaptative_ref_pic_marking_mode_flag;
	uint(size=3) memory_management_control_operation;
	

	// else if (reordering_of_pic_nums_idc == 2)
	read_SliceH_reordering_of_pic_nums_idc.l0.idc2: action ==> REF_REORDERING_l0:[long_term_pic_num]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		reordering_of_pic_nums_idc =2
	var
		uint(size=32) res[1],
		uint(size=5) long_term_pic_num
	do
		vld_ue_name(  fifo, res, "long_term_pic_num                             ");
		long_term_pic_num := res[0];
	end

	//else (reordering_of_pic_nums_idc == 3)
	read_SliceH_reordering_of_pic_nums_idc3.l0: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		reordering_of_pic_nums_idc = 3
	end
	//end if
	//while (reordering_of_pic_nums_idc != 3)

	read_SliceH_skip_reordering_of_pic_nums_idc.l0: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		ref_pic_list_reordering_flag_l0 = 0
	end
	//end if

	read_SliceH_skip_ref_pic_list_reordering_l0: action ==> REF_REORDERING_l0:[0], NB_REF_FRAME_l0:[0], REF_TYPE_l0:[0]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI
	end

	uint(size=1) ref_pic_list_reordering_flag_l1;

	//if (slice_type % 5 = 1)
	read_SliceH_ref_pic_list_reordering_flag_l1: action ==> REF_TYPE_l1:[REFLIST1_BI_PRED], REF_REORDERING_l1:[ref_pic_list_reordering_flag_l1], NB_REF_FRAME_l1:[slice_num_ref_idx_l1_active_minus1 + 1]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		slice_type = SLICE_TYPE_B
	var
		uint(size=32) res[1]
	do
		vld_u_name(1,  fifo, res, "ref_pic_list_reordering_flag_l1                             ");
		ref_pic_list_reordering_flag_l1 := res[0];
		reordering_of_pic_nums_idc :=0;
	end

	//if (ref_pic_list_reordering_flag_l1))
	//do
	read_SliceH_ref_pic_list_reordering_flag.l1.isl1: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		ref_pic_list_reordering_flag_l1 = 1
	end

	read_SliceH_reordering_of_pic_nums.l1: action ==> REF_REORDERING_l1:[reordering_of_pic_nums_idc]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res, "reordering_of_pic_nums_idc                             ");
		reordering_of_pic_nums_idc := res[0];
	end

	//if (reordering_of_pic_nums_idc == 0 || reordering_of_pic_nums_idc == 1)
	read_SliceH_reordering_of_pic_nums_idc.l1.idc1: action ==> REF_REORDERING_l1:[abs_diff_pic_num_minus1]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		reordering_of_pic_nums_idc =0 or reordering_of_pic_nums_idc =1
	var
		uint(size=32) res[1],
		uint(size=32) abs_diff_pic_num_minus1
	do
		vld_ue_name(  fifo, res, "abs_diff_pic_num_minus1                             ");
		abs_diff_pic_num_minus1 := res[0];
	end

	//******* dec_ref_pic_marking  ********/
	

	// else if (reordering_of_pic_nums_idc == 2)
	read_SliceH_reordering_of_pic_nums_idc.l1.idc2: action ==> REF_REORDERING_l1:[long_term_pic_num]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		reordering_of_pic_nums_idc =2
	var
		uint(size=32) res[1],
		uint(size=5) long_term_pic_num
	do
		vld_ue_name(  fifo, res, "long_term_pic_num                             ");
		long_term_pic_num := res[0];
	end

	//else (reordering_of_pic_nums_idc == 3)
	read_SliceH_reordering_of_pic_nums_idc3.l1: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		reordering_of_pic_nums_idc = 3
	end
	//end if
	//while (reordering_of_pic_nums_idc != 3)

	read_SliceH_skip_reordering_of_pic_nums_idc.l1: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		ref_pic_list_reordering_flag_l1 = 0
	end
	//end if


	read_SliceH_skip_ref_pic_list_reordering_l1: action ==> REF_REORDERING_l1:[0], NB_REF_FRAME_l1:[0], REF_TYPE_l1:[0]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	end

	//end if
	//******* End of ref_pic_list_reordering  ********/


	//******* pred_weight_table  ********/
	//if (weighted_pred_flag && (slice_type == P or slice_type == SP)) ||
	//   (weighted_bipred_idc == 1 && slice_type == B)
	int i_wp;
	int luma_log2_weight_denom;
	int chroma_log2_weight_denom;
	
	read_SliceH_pred_weight_table: action ==> WP_PARAM:[luma_log2_weight_denom, chroma_log2_weight_denom]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		(weighted_pred_flag[sps_id] and (slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP))
		or (weighted_bipred_idc[sps_id] = 1 and slice_type = SLICE_TYPE_B)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res, "luma_log2_weight_denom                             ");
		luma_log2_weight_denom := res[0];
		if (chroma_format_idc[sps_id] != 0) then
			vld_ue_name(  fifo, res, "chroma_log2_weight_denom                             ");
			chroma_log2_weight_denom := res[0];
		end
		i_wp:=0;
		wpParamTable:=[0: for int i in 1 .. 16 * 6 ];
	end
	
	read_SliceH_pred_weight_table_l0.endloop: action ==> WP_PARAM:[wpParamTable] repeat 32 * 3
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
	    i_wp = slice_num_ref_idx_l0_active_minus1 + 1
	end
	
	int (size=9) wpParamTable[16*6];
	
	read_SliceH_pred_weight_table_l0.loop: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
	    i_wp < slice_num_ref_idx_l0_active_minus1 + 1
	var
		int(size=32) res[1],
		bool luma_weight_l0_flag
	do
		vld_u_name(1,  fifo, res, "luma_weight_l0_flag                             ");
		luma_weight_l0_flag:= res[0] = 1;
		if (luma_weight_l0_flag) then
			vld_se_name(  fifo, res, "luma_weight_l0                             ");
			wpParamTable[6*i_wp + 0] := res[0];
			vld_se_name(  fifo, res, "luma_offset_l0                             ");
			wpParamTable[6*i_wp + 1] := res[0];
		else
			wpParamTable[6*i_wp + 0] := 1 << luma_log2_weight_denom;
			wpParamTable[6*i_wp + 1] := 0;
		end
	end

	bool chroma_weight_l0_flag;
	
	read_SliceH_pred_weight_table_l0_chroma_u: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		if (chroma_format_idc[sps_id] != 0) then
			vld_u_name(1,  fifo, res, "chroma_weight_l0_flag                             ");
			chroma_weight_l0_flag:= res[0] = 1;
			if (chroma_weight_l0_flag) then
				vld_se_name(  fifo, res, "chroma_weight_l0[0]                             ");
				wpParamTable[6*i_wp + 2] := res[0];
				vld_se_name(  fifo, res, "chroma_offset_l0[0]                             ");
				wpParamTable[6*i_wp + 3] := res[0];
			else
				wpParamTable[6*i_wp + 2] := 1 << chroma_log2_weight_denom;
				wpParamTable[6*i_wp + 3] := 0;
			end
		end
	end
	
	read_SliceH_pred_weight_table_l0_chroma_v: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		if (chroma_format_idc[sps_id] != 0) then
			if (chroma_weight_l0_flag) then
				vld_se_name(  fifo, res, "chroma_weight_l0[1]                             ");
				wpParamTable[6*i_wp + 4] := res[0];
				vld_se_name(  fifo, res, "chroma_offset_l0[1]                             ");
				wpParamTable[6*i_wp + 5] := res[0];
			else
				wpParamTable[6*i_wp + 4] := 1 << chroma_log2_weight_denom;
				wpParamTable[6*i_wp + 5] := 0;
			end
		end
		i_wp:=i_wp + 1;
	end

	read_SliceH_pred_weight_table_B.launch: action ==> 
	guard
		slice_type = SLICE_TYPE_B
	do
		i_wp:=0;
		wpParamTable:=[0: for int i in 1 .. 16 * 6 ];
	end 

	read_SliceH_pred_weight_table_B.skip: action ==> WP_PARAM:[wpParamTable] repeat 32 * 3
	guard
		slice_type != SLICE_TYPE_B
	do
		wpParamTable:=[0: for int i in 1 .. 16 * 6 ];
	end
	
	read_SliceH_pred_weight_table_l1.endloop: action ==> WP_PARAM:[wpParamTable] repeat 32 * 3
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
	    i_wp = slice_num_ref_idx_l1_active_minus1 + 1
	end
		
	read_SliceH_pred_weight_table_l1.loop: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
	    i_wp < slice_num_ref_idx_l1_active_minus1 + 1
	var
		int(size=32) res[1],
		bool luma_weight_l1_flag
	do
		vld_u_name(1,  fifo, res, "luma_weight_l1_flag                             ");
		luma_weight_l1_flag:= res[0] = 1;
		if (luma_weight_l1_flag) then
			vld_se_name(  fifo, res, "luma_weight_l1                             ");
			wpParamTable[6*i_wp + 0] := res[0];
			vld_se_name(  fifo, res, "luma_offset_l1                             ");
			wpParamTable[6*i_wp + 1] := res[0];
		else
			wpParamTable[6*i_wp + 0] := 1 << luma_log2_weight_denom;
			wpParamTable[6*i_wp + 1] := 0;
		end
	end

	bool chroma_weight_l1_flag;
	
	read_SliceH_pred_weight_table_l1_chroma_u: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		if (chroma_format_idc[sps_id] != 0) then
			vld_u_name(1,  fifo, res, "chroma_weight_l1_flag                             ");
			chroma_weight_l1_flag:= res[0] = 1;
			if (chroma_weight_l1_flag) then
				vld_se_name(  fifo, res, "chroma_weight_l1[0]                             ");
				wpParamTable[6*i_wp + 2] := res[0];
				vld_se_name(  fifo, res, "chroma_offset_l1[0]                             ");
				wpParamTable[6*i_wp + 3] := res[0];
			else
				wpParamTable[6*i_wp + 2] := 1 << chroma_log2_weight_denom;
				wpParamTable[6*i_wp + 3] := 0;
			end
		end
	end
	
	read_SliceH_pred_weight_table_l1_chroma_v: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		if (chroma_format_idc[sps_id] != 0) then
			if (chroma_weight_l1_flag) then
				vld_se_name(  fifo, res, "chroma_weight_l1[1]                             ");
				wpParamTable[6*i_wp + 4] := res[0];
				vld_se_name(  fifo, res, "chroma_offset_l1[1]                             ");
				wpParamTable[6*i_wp + 5] := res[0];
			else
				wpParamTable[6*i_wp + 4] := 1 << chroma_log2_weight_denom;
				wpParamTable[6*i_wp + 5] := 0;
			end
		end
		i_wp:=i_wp + 1;
	end

 
	//else
	read_SliceH_skip_pred_weight_table: action ==> 
	end
	//end if
	//******* End of pred_weight_table  ********/

	//******* dec_ref_pic_marking  ********/

	// if (nal_ref_idc !=0)
	read_SliceH_dec_ref_pic_marking: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		nal_ref_idc !=0
	end

	// if (IdrPicFlag)
	read_SliceH_no_output_of_prior_pics_flag_done: action ==> MMCO:[0, long_term_reference_flag]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		nal_unit_type = 5
	var
		uint(size=32) res[1],
		uint(size=1) long_term_reference_flag		
	do
		vld_u_name(1,  fifo, res, "no_output_of_prior_pics_flag                         ");
		vld_u_name(1,  fifo, res, "long_term_reference_flag                             ");
		long_term_reference_flag := res[0];
	end


	// else (!IdrPicFlag)
	read_SliceH_adaptative_ref_pic_marking_mode_flag_done: action ==> MMCO:[1,adaptative_ref_pic_marking_mode_flag]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		nal_unit_type != 5
	var
		uint(size=32) res[1]
	do
		vld_u_name(1,  fifo, res, "adaptative_ref_pic_marking_mode_flag                 ");
		adaptative_ref_pic_marking_mode_flag := res[0];
	end
	
	//else (nal_ref_idc == 0)
	read_SliceH_skip_dec_ref_pic_marking: action ==> MMCO :[if (nal_unit_type = 5) then 0 else 1 end,0]
	guard
		nal_ref_idc = 0
	end

	// if (adaptative_ref_pic_marking_mode_flag)
	//do
	read_SliceH_memory_management_control_operation_done: action ==> MMCO:[memory_management_control_operation]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		adaptative_ref_pic_marking_mode_flag = 1
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res, "memory_management_control_operation                   ");
		memory_management_control_operation := res[0];
	end

	// if (mmco == 1 || mmco == 3)
	read_SliceH_difference_of_pic_nums_minus1_done: action ==> MMCO:[difference_of_pic_nums_minus1]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation = 1 or memory_management_control_operation = 3
	var
		uint(size=32) res[1],
		uint(size=5) difference_of_pic_nums_minus1
	do
		vld_ue_name(  fifo, res, "difference_of_pic_nums_minus1                         ");
		difference_of_pic_nums_minus1 := res[0];
	end

	// end if

	// if (mmco == 2)
	read_SliceH_long_term_pic_num_done: action ==> MMCO:[long_term_pic_num]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation = 2
	var
		uint(size=32) res[1],
		uint(size=5) long_term_pic_num
	do
		vld_ue_name(  fifo, res, "long_term_pic_num                                   ");
		long_term_pic_num := res[0];
	end
	// end if

	// if (mmco == 3 || mmco == 6)
	read_SliceH_long_term_frame_idx_done: action ==> MMCO:[long_term_frame_idx]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation = 3 or memory_management_control_operation = 6
	var
		uint(size=32) res[1],
		uint(size=5) long_term_frame_idx
	do
		vld_ue_name(  fifo, res, "long_term_frame_idx                                ");
		long_term_frame_idx := res[0];
	end

	// if (mmco == 3 || mmco == 6)
	read_SliceH_long_not_term_frame_idx_done: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation != 3 and memory_management_control_operation != 6
	end
	// end if

	// if (mmco == 4)
	read_SliceH_max_long_term_frame_idx_plus1_done: action ==> MMCO:[max_long_term_frame_idx_plus1]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation = 4
	var
		uint(size=32) res[1],
		uint(size=5) max_long_term_frame_idx_plus1		
	do
		vld_ue_name(  fifo, res, "max_long_term_frame_idx_plus1                      ");
		max_long_term_frame_idx_plus1 := res[0];
	end

	// if (mmco == 5)
	read_SliceH_mmco_5: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation = 5
	do
		prev_frame_num:=0;
		isIDR:=1;
	end
	// end if

	// if (mmco == 0)
	read_SliceH_mmco_0: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		memory_management_control_operation = 0
	end
	// end if
	// while (mmco != 0)

	// else (!adaptative_ref_pic_marking_mode_flag)
	read_SliceH_skip_memory_management_control_operation_done: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		adaptative_ref_pic_marking_mode_flag = 0
	end

	//end if
	//******* End of dec_ref_pic_marking  ********/

	//if (entropy_coding_mode_flag && slice_type != I && slice_type != SI)
	read_SliceH_cabac_init_idc: action ==> SLICE_DBF_PARAM:[val_QP_Y, val_QP_Cb, val_QP_Cr],
										   MB_TYPE:[if first_mb_in_slice=0 then NEW_FRAME_NON_IDR + isIDR else NEW_SLICE end],
									   	   SCALING_LIST_Y:[ScalingList_Y] repeat 2*16+2*64,
									       SCALING_LIST_U:[ScalingList_U] repeat 2*16,
									       SCALING_LIST_V:[ScalingList_V] repeat 2*16
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		 uint(size= 8) ScalingList_Y[2*16+2*64],
		 uint(size= 8) ScalingList_U[2*16],
		 uint(size= 8) ScalingList_V[2*16],
		  int(size=32) res[1],
		  int slice_qp_delta
	do
		cabac_init_idc := -1;
		if (entropy_coding_mode_flag[pps_id] = 1 and
			slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI) then
			vld_ue_name(  fifo, res, "cabac_init_idc                             ");
			cabac_init_idc := res[0];
		end
		vld_se_name(  fifo, res, "slice_qp_delta                             ");
		slice_qp_delta := res[0];
		val_QP_Y  := 26 + pic_init_qp_minus26[pps_id] + slice_qp_delta;
		val_QP_Cb := qP_tab[val_QP_Y + chroma_qp_index_offset[pps_id]];
		val_QP_Cr := qP_tab[val_QP_Y + second_chroma_qp_index_offset[pps_id]];
		if (slice_type = SLICE_TYPE_SP or slice_type = SLICE_TYPE_SI) then
			if slice_type = SLICE_TYPE_SP then 
				vld_u_name(1,  fifo, res, "sp_for_switch_flag                             ");
			end
			vld_se_name(  fifo, res, "slice_qs_delta                             ");
		end
		foreach int i in 0 .. 1 do
			foreach int j in 0 .. 15 do
				ScalingList_Y[i*16+j] := pps_ScalingList4x4[pps_id][  i*3][j];
				ScalingList_U[i*16+j] := pps_ScalingList4x4[pps_id][1+i*3][j];
				ScalingList_V[i*16+j] := pps_ScalingList4x4[pps_id][2+i*3][j];
			end
			foreach int j in 0 .. 63 do
				ScalingList_Y[2*16+i*64+j] := pps_ScalingList8x8[pps_id][i][j];
			end
		end
	end


	// if ( deblocking_filter_control_present_flag )
	read_SliceH_disable_deblocking_filter_idc: action ==> SLICE_DBF_PARAM:[disable_deblocking_filter_idc, val_slice_alpha_c0_offset, val_slice_beta_offset]
	
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		if (deblocking_filter_control_present_flag[pps_id] = 1) then
			vld_ue_name(  fifo, res, "disable_deblocking_filter_idc                             ");
			disable_deblocking_filter_idc := res[0];
			if (disable_deblocking_filter_idc!=1) then
				vld_se_name(  fifo, res, "slice_alpha_c0_offset_div2                             ");
				slice_alpha_c0_offset_div2 := res[0];
				val_slice_alpha_c0_offset:=(slice_alpha_c0_offset_div2 << 1);
				vld_se_name(  fifo, res, "slice_beta_offset_div2                             ");
				slice_beta_offset_div2 := res[0];
				val_slice_beta_offset:=(slice_beta_offset_div2 << 1);
			else
				val_slice_alpha_c0_offset:=0;
				val_slice_beta_offset:=0;
			end
		else //deblocking_filter_control_present_flag[pps_id] = 0
			val_slice_alpha_c0_offset:=0;
			val_slice_beta_offset:=0;
		end
	end


	//if ( num_slice_groups_minus1 > 0 && slice_group_map_type >= 3 && slice_group_map_type <= 5 )
	read_SliceH_slice_group_change_cycle: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var 
		int x, 
		int n,
		uint(size=32) res[1]
	do
		if ( num_slice_groups_minus1[pps_id] > 0 and slice_group_map_type[pps_id] >= 3 and slice_group_map_type[pps_id] <= 5 ) then
			x := (pic_width_in_mbs_minus1[sps_id] + 1) * (pic_height_in_map_units_minus1[sps_id] +1) / slice_group_change_rate_minus1[pps_id] +1;
			//n := log_base2( x )
			x := x -1;
			n:= 0;
			while x>0 do
				x := (x >> 1);
				n := n+1;
			end
			vld_u_name(n,  fifo, res, "slice_group_change_cycle                             ");
		end
	end

	//******* End of Slice HEADER  ********/

	/*************************************************************
	*************************************************************
	********       Slice DATA 	  	      *********
	*************************************************************
	*************************************************************/

	uint(size=9) codIRange[1];
	uint(size=9) codIOffset[1];
	uint(size=9) ctxTable[MAX_NUM_CTX_MOD];
	bool		 availableA;
	bool		 availableB;
	//
	bool         skipFlagTab[MAX_PICWIDTH_BLK+2];
	uint(size=6) mbTypeTab[MAX_PICWIDTH_BLK+2];
	uint(size=4) subMbTypeTab[MAX_PICWIDTH_BLK+2][4];
	bool		 trsfSz8x8Tab[MAX_PICWIDTH_BLK+2];
	bool		 trsfSz8x8Cur;
	// mb_pred I
	uint(size=6) cbpTab[MAX_PICWIDTH_BLK+2];
	uint(size=2) intraChromaPredModeTab[MAX_PICWIDTH_BLK+2];
	// mb_pred P or B
	int(size= 5) refIdxTab[STRIDE_4 * 3][2];
	int(size=16) mvdTab[STRIDE * 5][2][2];
	// residual
	uint(size=1) cbfLumaDCTab[MAX_PICWIDTH_BLK+2];
	uint(size=1) cbfLumaACTab[STRIDE*5];
	uint(size=1) cbfChromaDCTab[MAX_PICWIDTH_BLK+2][2];
	uint(size=1) cbfChromaACTab[3*STRIDE_4][2];
 
	procedure NextMbAddress()
	begin
		foreach int i in 0 .. 3 do
			 NonZeroCount[Mb_x * 4 + 1 + i]:= NonZeroCount[4 * STRIDE + 1 + Mb_x * 4 + i];
		end
		foreach int i in 0 .. 1 do
			 NonZeroCountC[Mb_x * 2 + 1 + i]:= [
			 		NonZeroCountC[2 * STRIDE_4 + Mb_x * 2 + 1 + i][0],
			 		NonZeroCountC[2 * STRIDE_4 + Mb_x * 2 + 1 + i][1]];
		end
		val_CurrMbAddr	:= val_CurrMbAddr + 1;
		Mb_x			:= Mb_x + 1;
		availableA 		:= true;
		if Mb_x > PicWidthInMbs-1 then
			Mb_x 		:= 0;
			Mb_y 		:= Mb_y + 1;
			availableA 	:= false;
		end
		availableB := if val_CurrMbAddr < first_mb_in_slice + PicWidthInMbs then false else true end;
	end

	//if (entropy_coding_mode_flag) : CABAC
	//while( !byte_aligned())
	read_SliceD_CABAC_alignement.default: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		entropy_coding_mode_flag[pps_id] = 1
	do
		contextInit(val_QP_Y, cabac_init_idc, ctxTable);
		decodeInit(codIRange, codIOffset, fifo);
		//
		skipFlagTab				:= [false	: for int i in 0 .. MAX_PICWIDTH_BLK+1];
		mbTypeTab				:= [0		: for int i in 0 .. MAX_PICWIDTH_BLK+1];
		subMbTypeTab			:= [[0,0,0,0]: for int i in 0 .. MAX_PICWIDTH_BLK+1];
		trsfSz8x8Tab			:= [false	: for int i in 0 .. MAX_PICWIDTH_BLK+1];
		// mb_pred I
		cbpTab		 			:= [0		: for int i in 0 .. MAX_PICWIDTH_BLK+1];
		intraChromaPredModeTab	:= [0		: for int i in 0 .. MAX_PICWIDTH_BLK+1];
		// mb_pred P or B
		refIdxTab				:= [[0,0]	: for int i in 0 .. 3*STRIDE_4-1];
		mvdTab					:= [[[0,0],[0,0]]	: for int i in 0 .. 5*STRIDE-1];
		// residual
		cbfLumaDCTab			:= [0		: for int i in 0 .. MAX_PICWIDTH_BLK+1];
		cbfLumaACTab			:= [0		: for int i in 0 .. 5*STRIDE-1];
		cbfChromaDCTab			:= [[0,0]	: for int i in 0 .. MAX_PICWIDTH_BLK+1];
		cbfChromaACTab			:= [[0,0]	: for int i in 0 .. 3*STRIDE_4-1];	
	end

	read_SliceD_CABAC_alignement.skip: action ==>
	guard
		entropy_coding_mode_flag[pps_id] = 0
	end

	SliceD_init: action ==>
	do
		val_CurrMbAddr := first_mb_in_slice;
		PicWidthInMbs  := (pic_width_in_mbs_minus1[sps_id] +1);

		Mb_x 		   := val_CurrMbAddr mod PicWidthInMbs;
		Mb_y 		   := val_CurrMbAddr / PicWidthInMbs;

		availableB     := false;
		availableA     := false;
		moreDataFlag   := 1;
	end

	//do
	//if (slice_type != I && slice_type != SI)
	//  if (!entropy_coding_mode_flag) : CAVLC
	read_SliceD_mb_skip.cavlc: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI,
		entropy_coding_mode_flag[pps_id] = 0
	var
		uint(size=32) res[1]
	do
		vld_ue_name(  fifo, res, "mb_skip_run                             ");
		mb_skip_run := res[0];
	end
	
	read_SliceD_mb_skip.cabac: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI,
		entropy_coding_mode_flag[pps_id] = 1
	var
		uint(size=32) res[1]
	do
		getMbSkipFlag(codIRange, codIOffset, ctxTable, fifo, res,
 					  slice_type, availableA, skipFlagTab[Mb_x], availableB, skipFlagTab[Mb_x+1]);
 		skipFlagTab[Mb_x+1] := res[0] = 1;
 		moreDataFlag        := 1 - res[0];
	end
	
	read_SliceD_mb_skip_flag.isMBSkip: action ==>
			MB_TYPE:[mb_type],
			TRANSFORM_SIZE_8x8_FLAG:[false],
			MB_LOCATION:[Mb_x, Mb_y]
	guard
		skipFlagTab[Mb_x+1] = true
	do
		mb_type := if slice_type = SLICE_TYPE_P then BLOCK_TYPE_P_SKIP else BLOCK_TYPE_B_SKIP end;
		trsfSz8x8Cur			  := false;
		cbfLumaDCTab[Mb_x+1] 	  := 0;
	 	cbfChromaDCTab[Mb_x+1][0] := 0;
	 	cbfChromaDCTab[Mb_x+1][1] := 0;
	  	foreach int i in 0 .. 3 do
	 		cbfChromaACTab[(Mb_x << 1) + locXYToTabIdx_4[i]][0] := 0;
	 		cbfChromaACTab[(Mb_x << 1) + locXYToTabIdx_4[i]][1] := 0;
	 	end
	 	foreach int i in 0 .. 15 do
	 		cbfLumaACTab[(Mb_x << 2) + locXYToTabIdx[i]] := 0;
	 	end
	end
	
	read_SliceD_mb_skip_flag.isNotMBSkip: action ==>
	guard
		skipFlagTab[Mb_x+1] = false
	end
	
	read_SliceD_mb_skip.skip: action ==> MB_LOCATION:[Mb_x, Mb_y]
	guard
		slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI
	end
	
	// for(i=0; i < mb_skip_run; i++) CurrMbAddr = NextMbAddress(CurrMbAddr)
	read_SliceD_mb_skip_run.loop: action 
		==> 
			MB_TYPE:[if slice_type = SLICE_TYPE_P then BLOCK_TYPE_P_SKIP else BLOCK_TYPE_B_SKIP end],
			TRANSFORM_SIZE_8x8_FLAG:[false],
			MB_LOCATION:[mb_x, mb_y]
	guard
		mb_skip_run != 0
	var 
		int mb_x, int mb_y
	do
		mb_x:=Mb_x;
		mb_y:=Mb_y;
		foreach int i in 0 .. 15 do
			NonZeroCount[Mb_x * 4 + locXYToTabIdx[i]] := 0;
		end
		foreach int i in 0 .. 3 do
			NonZeroCountC[Mb_x * 2 + locXYToTabIdx_4[i]] := [0, 0];
		end
		NextMbAddress();
		mb_skip_run := mb_skip_run -1;
	end
	read_SliceD_mb_skip_run.endLoop: action 
		==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mb_skip_run = 0
	do
		more_rbsp_data();
	end

	read_SliceD_mb_skip_end.moredata_1: action ==> MB_LOCATION:[Mb_x, Mb_y]
	guard
		moreDataFlag = 1
	end

	read_SliceD_mb_skip_end.moredata_0: action ==>
	guard
		moreDataFlag = 0
	end

	//end if
	// --> macrobloc_layer()
	//end if
	//if( !entropy_coding_mode_flag ) : CAVLC
	SliceD_update.cavlc: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		entropy_coding_mode_flag[pps_id] = 0
	do
		more_rbsp_data();
	end

	SliceD_update.cabac: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		entropy_coding_mode_flag[pps_id] = 1
	var
		uint(size=32) res[1],
		uint 		  Idx
	do
		getEndOfSliceFlag(codIRange, codIOffset, ctxTable, fifo, res);
		moreDataFlag         := 1 - res[0];
		mbTypeTab[Mb_x+1]    := mb_type;
		trsfSz8x8Tab[Mb_x+1] := trsfSz8x8Cur;
		Idx			 :=  (Mb_x << 2) + 1;
		foreach int i in 0 .. 3 do
			cbfLumaACTab[Idx+i] := cbfLumaACTab[4*STRIDE+Idx+i];
			mvdTab[Idx+i][0][0]	:= mvdTab[4*STRIDE+Idx+i][0][0];
			mvdTab[Idx+i][0][1]	:= mvdTab[4*STRIDE+Idx+i][0][1];			
			mvdTab[Idx+i][1][0]	:= mvdTab[4*STRIDE+Idx+i][1][0];
			mvdTab[Idx+i][1][1]	:= mvdTab[4*STRIDE+Idx+i][1][1];
		end
		Idx			 :=  (Mb_x << 1) + 1;
		foreach int i in 0 .. 1 do
			cbfChromaACTab[Idx+i][0] := cbfChromaACTab[2*STRIDE_4+Idx+i][0];
			cbfChromaACTab[Idx+i][1] := cbfChromaACTab[2*STRIDE_4+Idx+i][1];
			refIdxTab[Idx+i][0]		 := refIdxTab[2*STRIDE_4+Idx+i][0];
			refIdxTab[Idx+i][1] 	 := refIdxTab[2*STRIDE_4+Idx+i][1];
		end
		setNeigbourSubMbType(subMbTypeTab, Mb_x+1 , mb_type, sub_mb_type);
	end

	//while( moreDataFlag )
	SliceD_while_moreDataFlag: action ==>
	guard
		moreDataFlag = 1
	do
		NextMbAddress();
		val_cbp_blk := 0;
	end

	SliceD_end: action ==>
	guard
		moreDataFlag = 0
	do
		val_cbp_blk := 0;
	end
	//******* End of Slice DATA  ********/
 
	/*************************************************************
	*************************************************************
	********       Macroblock layer    	    *********
	*************************************************************
	*************************************************************/
	uint(size=6) mb_type;
	uint         MB_inc;
	uint(size=1) noSubMbPartSizeLessThan8x8Flag;
	bool         transform_size_8x8_flag;
	uint(size=6) val_CodedBlockPatternLuma := 0;
	uint(size=6) CodedBlockPatternChroma := 0;
	 int(size=8) prevMbQpDelta;

	read_MB_layer_mb_type: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1]
	do
		if entropy_coding_mode_flag[pps_id] = 0 then
			vld_ue_name(  fifo, res, "mb_type                             ");
		else
			getMbType(codIRange, codIOffset, ctxTable, fifo, res,
					  slice_type, availableA, mbTypeTab[Mb_x], availableB, mbTypeTab[Mb_x+1]);
		end
		mb_type := res[0];
		
		mb_type :=
			if((slice_type = SLICE_TYPE_SI) or (slice_type = SLICE_TYPE_I))then
				mb_type
			else
				if((slice_type = SLICE_TYPE_SP) or (slice_type = SLICE_TYPE_P))then
					if(mb_type >= 5) then
						if(mb_type < 32)then
							mb_type - 5
						else
							0
						end
					else
						mb_type + BLOCK_TYPE_P_MIN - BLOCK_TYPE_I_8x8
					end
				else
					if(mb_type < 23) then
						mb_type + BLOCK_TYPE_B_MIN - BLOCK_TYPE_I_8x8
					else
						if(mb_type < 49) then
							mb_type - 23
						else
							0
						end
					end
				end
			end;
		if mb_type != BLOCK_TYPE_I_4x4 then
			mb_type := mb_type + BLOCK_TYPE_I_8x8;
		end
		transform_size_8x8_flag := false;
		trsfSz8x8Cur			:= false;
		sub_mb_type   			:= [0 : for int i in 0 .. 4];
		subMbPartIdx  			:= 0;
	 	foreach int i in 0 .. 3 do
	 		cbfChromaACTab[(Mb_x << 1) + locXYToTabIdx_4[i]][0] := 0;
	 		cbfChromaACTab[(Mb_x << 1) + locXYToTabIdx_4[i]][1] := 0;
	 	end
	 	foreach int i in 0 .. 15 do
	 		cbfLumaACTab[(Mb_x << 2) + locXYToTabIdx[i]] := 0;
	 	end
	end

	//if( mb_type = = I_PCM )
	// while( !byte_aligned( ) )
	read_MB_layer_I_PCM_alignement: action  ==> MB_TYPE:[mb_type],
			TRANSFORM_SIZE_8x8_FLAG:[false]
	guard
		mb_type = BLOCK_TYPE_I_PCM
	do
		byte_align(fifo);
		MB_inc := 0;
		foreach int i in 0 .. 15 do
			NonZeroCount[Mb_x * 4 + locXYToTabIdx[i]] := 16;
		end
		foreach int i in 0 .. 3 do
			NonZeroCountC[Mb_x * 2 + locXYToTabIdx_4[i]] := [16, 16];
		end
	end

	//for( i = 0; i < 256; i++ )
	read_MB_layer_pcm_sample_luma.loop: action ==>  I_PCM:[ pcm_sample_luma ]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		MB_inc < 256
	var
		uint(size=32) res[1],
		uint(size=32) pcm_sample_luma
	do
		vld_u_name(bit_depth_luma_minus8[sps_id]+8,  fifo, res, "pcm_sample_luma                             ");
		pcm_sample_luma := res[0];
		MB_inc := MB_inc + 1;
	end

	read_MB_layer_pcm_sample_luma.done: action  ==> 
	guard
		MB_inc = 256
	do
		MB_inc := 0;
	end
	
	// for( i = 0; i < 2 * MbWidthC * MbHeightC; i++ )
	read_MB_layer_pcm_sample_chroma.loop: action   ==> I_PCM:[ pcm_sample_chroma ]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		MB_inc < 2*64
	var
		uint(size=32) res[1],
		uint(size=32) pcm_sample_chroma
	do
		vld_u_name(bit_depth_chroma_minus8[sps_id]+8,  fifo, res, "pcm_sample_chroma                             ");
		pcm_sample_chroma := res[0];
		MB_inc := MB_inc + 1;
	end

	read_MB_layer_pcm_sample_chroma.done: action  ==> 
	guard
		MB_inc = 2*64
	do
		if entropy_coding_mode_flag[pps_id] = 1 then
			decodeInit(codIRange, codIOffset, fifo);
		end
	end

	//} else {
	read_MB_layer_not_I_PCM: action ==>
	guard
		not (mb_type = BLOCK_TYPE_I_PCM)
	do
		noSubMbPartSizeLessThan8x8Flag := 1;
	end

	//if( mb_type != I_NxN && MbPartPredMode( mb_type, 0 ) != Intra_16x16 && NumMbPart( mb_type ) = = 4 )
	read_MB_layer_sub_mb_pred: action ==>
	guard
		not Is_Intra_NxN(mb_type),
		not Is_Intra_16x16(mb_type),
		(numMbPart(mb_type) = 4) // numMbPart(mb_type) tests the slice_type and return 0 if slice_type is I or SI
	do
		mbPartIdx := 0;
	end
	// --> sub_mb_pred( mb_type )

	read_MB_layer_sub_mb_pred_done: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
		foreach int i in 0 .. 3 do
			mbPartIdx := i;
			//  if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 )
			if not IS_B_Direct_8x8() then
				//    if( NumSubMbPart( sub_mb_type[ mbPartIdx ] ) > 1 )
				if numSubMbPart(mb_type, sub_mb_type[mbPartIdx]) >1 then noSubMbPartSizeLessThan8x8Flag := 0; end
			else 
				if not direct_8x8_interference_flag[sps_id] then noSubMbPartSizeLessThan8x8Flag := 0; end
			end
		end
	end

	// else (! ( mb_type != I_NxN && MbPartPredMode( mb_type, 0 ) != Intra_16x16 && NumMbPart( mb_type ) = = 4 ) )
	// if( transform_8x8_mode_flag && mb_type = = I_NxN )
	read_MB_layer_transform_size_8x8_flag.read: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		transform_8x8_mode_flag[pps_id] = 1 and Is_Intra_NxN(mb_type)
	var
		uint(size=32) res[1]
	do
		if entropy_coding_mode_flag[pps_id] = 0 then
			vld_u_name(1,  fifo, res, "transform_size_8x8_flag                             ");
		else
			getTrsfSz8x8(codIRange, codIOffset, ctxTable, fifo, res,
						 availableA, trsfSz8x8Tab[Mb_x], availableB, trsfSz8x8Tab[Mb_x+1]);
			trsfSz8x8Cur := res[0] = 1;	
		end
		transform_size_8x8_flag := res[0]= 1;
		if transform_size_8x8_flag then
			mb_type := BLOCK_TYPE_I_8x8;
		end
	end

	// else
	read_MB_layer_transform_size_8x8_flag.skip: action ==>
	guard
		transform_8x8_mode_flag[pps_id] = 0 or not Is_Intra_NxN(mb_type)
	end
	// end if 
	// --> mb_pred( mb_type )
	// end if

	// if( MbPartPredMode( mb_type, 0 ) != Intra_16x16 )
	read_MB_layer_coded_block_pattern: action ==> MB_TYPE:[mb_type], TRANSFORM_SIZE_8x8_FLAG:[transform_size_8x8_flag]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		uint(size=32) res[1],
		uint(size=6) coded_block_pattern
	do
		if (not Is_Intra_16x16(mb_type)) then
			if entropy_coding_mode_flag[pps_id] = 0 then
				vld_me_name(  fifo, res, chroma_format_idc[sps_id], Is_Intra_NxN(mb_type), "coded_block_pattern                             ");
			else
				getCodedBlockPattern(codIRange, codIOffset, ctxTable, fifo, res,
									  mb_type,
									  availableA, mbTypeTab[Mb_x]  , cbpTab[Mb_x],
									  availableB, mbTypeTab[Mb_x+1], cbpTab[Mb_x+1]);
				cbpTab[Mb_x+1] := res[0];
				if res[0] = 0 then	
					cbfLumaDCTab[Mb_x+1] 	  := 0;
	 				cbfChromaDCTab[Mb_x+1][0] := 0;
	 				cbfChromaDCTab[Mb_x+1][1] := 0;
					foreach int i in 0 .. 3 do
	 					cbfChromaACTab[(Mb_x << 1) + locXYToTabIdx_4[i]][0] := 0;
	 					cbfChromaACTab[(Mb_x << 1) + locXYToTabIdx_4[i]][1] := 0;
	 				end
	 				foreach int i in 0 .. 15 do
	 					cbfLumaACTab[(Mb_x << 2) + locXYToTabIdx[i]] := 0;
	 				end
	 			end
			end
			
			coded_block_pattern := res[0];
			val_CodedBlockPatternLuma := coded_block_pattern & 15;
			CodedBlockPatternChroma := coded_block_pattern >> 4;
			if( val_CodedBlockPatternLuma > 0 and 
				transform_8x8_mode_flag[pps_id] = 1 and 
				not Is_Intra_NxN(mb_type) and
				noSubMbPartSizeLessThan8x8Flag = 1 and
				(mb_type != BLOCK_TYPE_B_DIRECT_16x16 or direct_8x8_interference_flag[sps_id]) )then 
					if entropy_coding_mode_flag[pps_id] = 0 then
						vld_u_name(1,  fifo, res, "transform_size_8x8_flag                             ");
					else
						getTrsfSz8x8(codIRange, codIOffset, ctxTable, fifo, res,
									 availableA, trsfSz8x8Tab[Mb_x], availableB, trsfSz8x8Tab[Mb_x+1]);
						trsfSz8x8Cur := res[0] = 1;
					end
					transform_size_8x8_flag := res[0] = 1;
			end
		else
			val_CodedBlockPatternLuma := Intra_16x16_tab[mb_type - BLOCK_TYPE_I_8x8][2];
			CodedBlockPatternChroma := Intra_16x16_tab[mb_type - BLOCK_TYPE_I_8x8][1];
			cbpTab[Mb_x+1] := Intra_16x16_tab[mb_type - BLOCK_TYPE_I_8x8][3];
		end
	end

	//if( val_CodedBlockPatternLuma > 0 || CodedBlockPatternChroma > 0 | | MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
	read_MB_layer_mb_qp_delta: action ==>
			QP:[val_QP_Y], 
			QP_Cb:[val_QP_Cb], 
			QP_Cr:[val_QP_Cr]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		val_CodedBlockPatternLuma > 0 or CodedBlockPatternChroma > 0 or Is_Intra_16x16(mb_type)
	var
		 int(size=32) res[1],
		uint(size=32) mb_prev := if Mb_x = 0 then PicWidthInMbs else Mb_x end,
		int mb_qp_delta		
	do
		if entropy_coding_mode_flag[pps_id] = 0 then
			vld_se_name(  fifo, res, "mb_qp_delta                             ");
		else
			getMbQpDelta(codIRange, codIOffset, ctxTable, fifo, res,
						 val_CurrMbAddr != first_mb_in_slice, mbTypeTab[mb_prev],
						 cbpTab[mb_prev], prevMbQpDelta);
			prevMbQpDelta	:= res[0];
		end
		mb_qp_delta 	:= res[0];
		val_QP_Y  		:= (val_QP_Y + mb_qp_delta + 52) mod 52;
		val_QP_Cb 		:= qP_tab[val_QP_Y + chroma_qp_index_offset[pps_id]];
		val_QP_Cr 		:= qP_tab[val_QP_Y + second_chroma_qp_index_offset[pps_id]];
	end
	// --> residual( )

	//else	
	read_MB_layer_skip_mb_qp_delta.default: action ==> 
			CBP_BLK:[val_cbp_blk],
			QP:[val_QP_Y], 
			QP_Cb:[val_QP_Cb], 
			QP_Cr:[val_QP_Cr],
			LAST:[[1: for int t in 0 .. 25 ]] repeat 26
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		( val_CodedBlockPatternLuma = 0 and CodedBlockPatternChroma = 0 and not Is_Intra_16x16(mb_type) ),
		mb_type != BLOCK_TYPE_I_8x8 or entropy_coding_mode_flag[pps_id] = 0
	do
		foreach int i in 0 .. 15 do
			NonZeroCount[Mb_x * 4 + locXYToTabIdx[i]] := 0;
		end
		foreach int i in 0 .. 3 do
			NonZeroCountC[Mb_x * 2 + locXYToTabIdx_4[i]] := [0, 0];
		end
	end
	read_MB_layer_skip_mb_qp_delta.I8x8_cabac: action ==> 
			CBP_BLK:[val_cbp_blk],
			QP:[val_QP_Y], 
			QP_Cb:[val_QP_Cb], 
			QP_Cr:[val_QP_Cr],
			LAST:[[3: for int t in 0 .. 13 ]] repeat 14
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		( val_CodedBlockPatternLuma = 0 and CodedBlockPatternChroma = 0 and not Is_Intra_16x16(mb_type) ),
		mb_type = BLOCK_TYPE_I_8x8 and entropy_coding_mode_flag[pps_id] = 1
	do
		foreach int i in 0 .. 15 do
			NonZeroCount[Mb_x * 4 + locXYToTabIdx[i]] := 0;
		end
		foreach int i in 0 .. 3 do
			NonZeroCountC[Mb_x * 2 + locXYToTabIdx_4[i]] := [0, 0];
		end
	end
	//end if

	//end if
	//******* End of Macroblock layer  ********/

	/*************************************************************
	*************************************************************
	********       	Sub Mb Pred    	    *********
	*************************************************************
	*************************************************************/
	uint(size=3) mbPartIdx;
	uint(size=3) subMbPartIdx;
	uint(size=4) sub_mb_type[5] := [ 0 : for int i in 0 .. 4];
	int ref_idx_l0[4] := [ 0 : for int i in 0 .. 3];
	int ref_idx_l1[4] := [ 0 : for int i in 0 .. 3];
 	function IS_B_Direct_8x8() --> bool : (mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX) and (sub_mb_type[mbPartIdx] = B_DIRECT_8x8) end

	procedure readRefIdxLX(uint(size=32) result[1], uint(size=1) Lx)
	var
		uint(size=32) res[1],
		bool 		  availA		= getNeigbourAvailA(availableA, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
		bool 		  availB		= getNeigbourAvailB(availableB, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
		uint(size= 6) mb_typeA		= getNeigbourMbTypeA(mbTypeTab[Mb_x  ], mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
		uint(size= 6) mb_typeB		= getNeigbourMbTypeB(mbTypeTab[Mb_x+1], mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
		uint(size= 6) sub_mb_typeA	= getNeigbourSubMbTypeA(subMbTypeTab, Mb_x  , mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
		uint(size= 6) sub_mb_typeB	= getNeigbourSubMbTypeB(subMbTypeTab, Mb_x+1, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
		uint(size= 3) mbPartIdxA	= getNeigbourMbPartIdxA(availA, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type[mbPartIdx], mb_typeA, sub_mb_typeA),
		uint(size= 3) mbPartIdxB	= getNeigbourMbPartIdxB(availB, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type[mbPartIdx], mb_typeB, sub_mb_typeB)
	begin
		getRefIdx(codIRange, codIOffset, ctxTable, fifo, res,
			availA, mb_typeA, sub_mb_typeA, getNeigbourRefIdxA(refIdxTab, Mb_x, Lx, mbPartIdx, mb_type), mbPartIdxA,
			availB, mb_typeB, sub_mb_typeB, getNeigbourRefIdxB(refIdxTab, Mb_x, Lx, mbPartIdx, mb_type), mbPartIdxB,
			Lx = 0
		);
		setNeigbourRefIdx(refIdxTab, Mb_x, Lx, mb_type, mbPartIdx, res[0]);
		result[0] := res[0];
	end
	procedure readMvdLX(int(size=32) mvd_lx[2], uint(size=1) Lx)
	var
		uint(size=32) res[1],
		bool 		  availA		= getNeigbourAvailA(availableA, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
		bool 		  availB		= getNeigbourAvailB(availableB, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
		uint(size= 6) mb_typeA		= getNeigbourMbTypeA(mbTypeTab[Mb_x  ], mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
		uint(size= 6) mb_typeB		= getNeigbourMbTypeB(mbTypeTab[Mb_x+1], mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
		uint(size= 6) sub_mb_typeA	= getNeigbourSubMbTypeA(subMbTypeTab, Mb_x  , mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
		uint(size= 6) sub_mb_typeB	= getNeigbourSubMbTypeB(subMbTypeTab, Mb_x+1, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
		uint(size= 3) mbPartIdxA	= getNeigbourMbPartIdxA(availA, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type[mbPartIdx], mb_typeA, sub_mb_typeA),
		uint(size= 3) mbPartIdxB	= getNeigbourMbPartIdxB(availB, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type[mbPartIdx], mb_typeB, sub_mb_typeB)
	begin
		getMvd(codIRange, codIOffset, ctxTable, fifo, res,
			availA, mb_typeA, sub_mb_typeA, mbPartIdxA, getNeigbourMvdA(mvdTab, Mb_x, Lx, 0, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
			availB, mb_typeB, sub_mb_typeB, mbPartIdxB, getNeigbourMvdB(mvdTab, Mb_x, Lx, 0, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
			Lx = 0, true
		);
		mvd_lx[0] := res[0];
		getMvd(codIRange, codIOffset, ctxTable, fifo, res,
			availA, mb_typeA, sub_mb_typeA, mbPartIdxA, getNeigbourMvdA(mvdTab, Mb_x, Lx, 1, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
			availB, mb_typeB, sub_mb_typeB, mbPartIdxB, getNeigbourMvdB(mvdTab, Mb_x, Lx, 1, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type),
			Lx = 0, false
		);
		mvd_lx[1] := res[0];
		setNeigbourMvd(mvdTab, Mb_x, Lx, mbPartIdx, subMbPartIdx, mb_type, sub_mb_type, mvd_lx);
	end


	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	read_sub_MB_pred_sub_mb_type.loop: action ==> SUB_MB_TYPE :[subMbType]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < 4
	var
		uint(size= 4) subMbType,
		uint(size=32) res[1]
	do
		if entropy_coding_mode_flag[pps_id] = 0 then
			vld_ue_name(  fifo, res, "sub_mb_type[mbPartIdx]                             ");
		else
			getSubMbType(codIRange, codIOffset, ctxTable, fifo, res, slice_type);
		end
		sub_mb_type[mbPartIdx] := res[0];
		subMbType := sub_mb_type[mbPartIdx];
if SUB_MB_PRED then
				println("sub_mb_type[ "+mbPartIdx+" ] : "+subMbType);
end
		mbPartIdx := mbPartIdx +1;
	end
	//end for

	read_sub_MB_pred_sub_mb_type.done: action ==>
	guard
		mbPartIdx = 4
	do
		mbPartIdx := 0;
	end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	//if( ( num_ref_idx_l0_active_minus1 > 0 | | mb_field_decoding_flag ) && mb_type != P_8x8ref0 && sub_mb_type[ mbPartIdx ] != B_Direct_8x8 && SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L1 )
	read_sub_MB_pred_ref_idx_l0.loop: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < 4
	var
		uint(size=32) res[1]
	do
		if ((slice_num_ref_idx_l0_active_minus1 > 0) and
			not IS_B_Direct_8x8() and 
			not (mb_type = BLOCK_TYPE_P_8x8ref0) and 
			(subMbPredMode(mb_type, sub_mb_type[ mbPartIdx ] ) != PRED_L1)) then
			if entropy_coding_mode_flag[pps_id] = 0 then
				if slice_num_ref_idx_l0_active_minus1 = 1 then 
					vld_u_name(1,  fifo, res, "ref_idx_lx[mbPartIdx]                            ");
					ref_idx_l0[mbPartIdx] := 1 - res[0];
				else 
					vld_ue_name(  fifo, res, "ref_idx_lx[mbPartIdx]                             ");
					ref_idx_l0[mbPartIdx] := res[0];
				end
			else
				readRefIdxLX(res, 0);
				ref_idx_l0[mbPartIdx] := res[0];
			end
		else
			ref_idx_l0[mbPartIdx] := 0;
		end
if(SUB_MB_PRED)then
		println("refidxl0["+mbPartIdx+"] :"+ref_idx_l0[mbPartIdx]);
end
		mbPartIdx := mbPartIdx +1;
	end
	//end for

	read_sub_MB_pred_ref_idx_l0.done: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx = 4
	do
		mbPartIdx := 0;
	end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	//if( ( num_ref_idx_l0_active_minus1 > 0 | | mb_field_decoding_flag ) && mb_type != P_8x8ref0 && sub_mb_type[ mbPartIdx ] != B_Direct_8x8 && SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L0 )
	read_sub_MB_pred_ref_idx_l1.loop: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < 4
	var
		uint(size=32) res[1]
	do
		if ((slice_num_ref_idx_l1_active_minus1 > 0) 
			and not IS_B_Direct_8x8() 
			and not (mb_type = BLOCK_TYPE_P_8x8ref0)
			and (subMbPredMode(mb_type, sub_mb_type[ mbPartIdx ] ) != PRED_L0)) then
			if entropy_coding_mode_flag[pps_id] = 0 then
				if slice_num_ref_idx_l1_active_minus1 = 1 then 
					vld_u_name(1,  fifo, res, "ref_idx_lx[mbPartIdx]                            ");
					ref_idx_l1[mbPartIdx] := 1 - res[0];
				else 
					vld_ue_name(  fifo, res, "ref_idx_lx[mbPartIdx]                             ");
					ref_idx_l1[mbPartIdx] := res[0];
				end
			else
				readRefIdxLX(res, 1);
				ref_idx_l1[mbPartIdx] := res[0];
			end
		else
			ref_idx_l1[mbPartIdx] := 0;
		end
if(SUB_MB_PRED)then
		println("refidxl1["+mbPartIdx+"] :"+ref_idx_l1[mbPartIdx]);
end
		mbPartIdx := mbPartIdx +1;
	end

	//end for
	read_sub_MB_pred_ref_idx_l1.done: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx = 4
	do
		mbPartIdx := 0;
	end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	// if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 && SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L1 )
	read_sub_MB_pred_mvd_l0.loop: action ==> 
	guard
		mbPartIdx < 4,
		not IS_B_Direct_8x8(), (subMbPredMode(mb_type, sub_mb_type[ mbPartIdx ] ) != PRED_L1)
	do
		subMbPartIdx := 0;
	end
	//   for( subMbPartIdx = 0; subMbPartIdx < NumSubMbPart( sub_mb_type[ mbPartIdx ] ); subMbPartIdx++)
	//     for( compIdx = 0; compIdx < 2; compIdx++ )
	read_sub_MB_pred_mvd_l0.inner.loop: action ==> 
		SUB_MB_PRED_REF_IDX_l0:[ref_idx_l0[mbPartIdx]],
		SUB_MB_PRED_MVD_l0:[mvd_l0[0], mvd_l0[1]]		
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		subMbPartIdx < numSubMbPart(mb_type, sub_mb_type[mbPartIdx])
	var
		int res[1],
		int mvd_l0[2]
	do
		if entropy_coding_mode_flag[pps_id] = 0 then	
			vld_se_name(  fifo, res, "mvd_lx                                ");
			mvd_l0[0] := res[0];
			vld_se_name(  fifo, res, "mvd_lx                                ");
			mvd_l0[1] := res[0];
		else			
			readMvdLX(mvd_l0, 0);
		end
if(SUB_MB_PRED)then
		println("sub_mb_pred mvld0["+ (mbPartIdx) +"]["+subMbPartIdx+"][0]:"+mvd_l0[0]);
		println("sub_mb_pred mvld0["+ (mbPartIdx) +"]["+subMbPartIdx+"][1]:"+mvd_l0[1]);
end
		subMbPartIdx := subMbPartIdx +1;
	end
	//end for

	read_sub_MB_pred_mvd_l0.inner.done: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		subMbPartIdx = numSubMbPart(mb_type, sub_mb_type[mbPartIdx])
	do
		mbPartIdx := mbPartIdx+1;
	end

	//else
	read_sub_MB_pred_mvd_l0.skip: action ==> 
	guard
		mbPartIdx < 4,
		IS_B_Direct_8x8() or (subMbPredMode(mb_type, sub_mb_type[ mbPartIdx ] ) = PRED_L1)
	do
		mbPartIdx := mbPartIdx+1;
	end
	//end if
	//end for

	read_sub_MB_pred_mvd_l0.done: action ==>
	guard
		mbPartIdx = 4
	do
		mbPartIdx := 0;
	end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	// if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 && SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L0 )
	read_sub_MB_pred_mvd_l1.loop: action ==> 
	guard
		mbPartIdx < 4,
		not IS_B_Direct_8x8(), (subMbPredMode(mb_type, sub_mb_type[ mbPartIdx ] ) != PRED_L0)
	do
		subMbPartIdx := 0;
	end
	//   for( subMbPartIdx = 0; subMbPartIdx < NumSubMbPart( sub_mb_type[ mbPartIdx ] ); subMbPartIdx++)
	//     for( compIdx = 0; compIdx < 2; compIdx++ )
	read_sub_MB_pred_mvd_l1.inner.loop: action ==> 
		SUB_MB_PRED_REF_IDX_l1:[ref_idx_l1[mbPartIdx]],
		SUB_MB_PRED_MVD_l1:[mvd_l1[0], mvd_l1[1]]		
	guard
		subMbPartIdx < numSubMbPart(mb_type, sub_mb_type[mbPartIdx]),
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1],
		int mvd_l1[2]
	do
		if entropy_coding_mode_flag[pps_id] = 0 then	
			vld_se_name(  fifo, res, "mvd_lx                                ");
			mvd_l1[0] := res[0];
			vld_se_name(  fifo, res, "mvd_lx                                ");
			mvd_l1[1] := res[0];
		else			
			readMvdLX(mvd_l1, 1);
		end
if(SUB_MB_PRED)then
		println("mvld1["+ (mbPartIdx) +"]["+subMbPartIdx+"][0]:"+mvd_l1[0]);
		println("mvld1["+ (mbPartIdx) +"]["+subMbPartIdx+"][1]:"+mvd_l1[1]);
end
		subMbPartIdx := subMbPartIdx +1;
	end
	//end for

	read_sub_MB_pred_mvd_l1.inner.done: action ==> 
	guard
		subMbPartIdx = numSubMbPart(mb_type, sub_mb_type[mbPartIdx])
	do
		mbPartIdx := mbPartIdx+1;
	end

	//else
	read_sub_MB_pred_mvd_l1.skip: action ==> 
	guard
		mbPartIdx < 4,
		IS_B_Direct_8x8() or (subMbPredMode(mb_type, sub_mb_type[ mbPartIdx ] ) = PRED_L0)
	do
		mbPartIdx := mbPartIdx+1;
	end
	//end if
	//end for

	sub_MB_pred_done: action ==>
	guard
		mbPartIdx = 4
	end
	//******* End of Sub Mb pred  ********/
 
	/*************************************************************
	*************************************************************
	********       	Mb Pred    	    *********
	*************************************************************
	*************************************************************/

	uint(size=5) luma4x4BlkIdx;
	uint(size=1) prev_intra4x4_pred_mode_flag := 0;
	uint(size=4) rem_intra4x4_pred_mode[16];
	uint(size=2) intra_chroma_pred_mode;

	//if( MbPartPredMode( mb_type, 0 ) = = Intra_4x4 )
	MB_pred_init_Intra_4x4: action ==> 
	guard
		mb_type = BLOCK_TYPE_I_4x4
	do
		luma4x4BlkIdx := 0;
	end

	//for( luma4x4BlkIdx=0; luma4x4BlkIdx<16; luma4x4BlkIdx++ )
	read_MB_pred_rem_intra4x4_pred_mode.loop: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		luma4x4BlkIdx < 16
	var
		uint(size=32) res[1]
	do
		foreach int i in 0 .. 3 do	
			if entropy_coding_mode_flag[pps_id] = 0 then
				vld_u_name(1,  fifo, res, "prev_intra4x4_pred_mode_flag                             ");
			else
				getPrevIntraPredModeFlag(codIRange, codIOffset, ctxTable, fifo, res);
			end
			prev_intra4x4_pred_mode_flag := res[0];
			if prev_intra4x4_pred_mode_flag = 0 then 
				if entropy_coding_mode_flag[pps_id] = 0 then
					vld_u_name(3,  fifo, res, "rem_intra4x4_pred_mode                                   ");
				else
					getRemIntraPredMode(codIRange, codIOffset, ctxTable, fifo, res);
				end
				rem_intra4x4_pred_mode[ luma4x4BlkIdx + i] := res[0];
			else
				rem_intra4x4_pred_mode[ luma4x4BlkIdx + i] := 15; // indicates that the mode is predicted using the neighbourhood 
			end
		end
		luma4x4BlkIdx := luma4x4BlkIdx + 4;
	end

	read_MB_pred_rem_intra4x4_pred_mode.done: action ==> INTRA_PRED_MODE: [ [ rem_intra4x4_pred_mode[ s ] :for int s in 0 .. 15] ] repeat 16
	guard
		luma4x4BlkIdx = 16
	end
	//end for

	//else if( MbPartPredMode( mb_type, 0 ) = = Intra_8x8 )
	//for( luma8x8BlkIdx=0; luma8x8BlkIdx<4; luma8x8BlkIdx++ )
	MB_pred_init_Intra_8x8: action ==> INTRA_PRED_MODE: [ [ rem_intra4x4_pred_mode[ s ] :for int s in 0 .. 3] ] repeat 4 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mb_type = BLOCK_TYPE_I_8x8
	var
		uint(size=32) res[1]
	do
		foreach int i in 0 .. 3 do
			if entropy_coding_mode_flag[pps_id] = 0 then
				vld_u_name(1,  fifo, res, "prev_intra8x8_pred_mode_flag                             ");
			else
				getPrevIntraPredModeFlag(codIRange, codIOffset, ctxTable, fifo, res);
			end
			prev_intra4x4_pred_mode_flag := res[0];
			if prev_intra4x4_pred_mode_flag = 0 then 
				if entropy_coding_mode_flag[pps_id] = 0 then
					vld_u_name(3,  fifo, res, "rem_intra8x8_pred_mode                                   ");
				else
					getRemIntraPredMode(codIRange, codIOffset, ctxTable, fifo, res);
				end
				rem_intra4x4_pred_mode[ i ] := res[0];
			else
				rem_intra4x4_pred_mode[ i ] := 15; // indicates that the mode is predicted using the neighbourhood 
			end
		end
	end
	//end for
	//else
	MB_pred_init_Intra_16x16: action ==> INTRA_PRED_MODE: [ Intra_16x16_tab[mb_type - BLOCK_TYPE_I_8x8][0] ]
	guard
		Is_Intra_16x16(mb_type)
	end
	//end if

	//if( ChromaArrayType = = 1 | | ChromaArrayType = = 2 )
	read_MB_pred_intra_chroma_pred_mode.launch: action ==> INTRA_PRED_MODEC: [intra_chroma_pred_mode]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		chroma_format_idc[sps_id] = 1 or chroma_format_idc[sps_id] = 2
	var
		uint(size=32) res[1]
	do
		if entropy_coding_mode_flag[pps_id] = 0 then
			vld_ue_name(  fifo, res, "intra_chroma_pred_mode                             ");
		else
			getIntraChromaPredMode(codIRange, codIOffset, ctxTable, fifo, res,
								   availableA, mbTypeTab[Mb_x]  , intraChromaPredModeTab[Mb_x],
								   availableB, mbTypeTab[Mb_x+1], intraChromaPredModeTab[Mb_x+1]);
			intraChromaPredModeTab[Mb_x+1] :=  res[0];
		end
		intra_chroma_pred_mode := res[0];
	end

	//else
	read_MB_pred_intra_chroma_pred_mode.skip: action ==>
	guard
		chroma_format_idc[sps_id] = 0
	end
	// end if

	// else (INTER pred)
	// if( MbPartPredMode( mb_type, 0 ) != Direct ) {
	MB_pred_Inter_not_direct: action ==>
	guard
		mbIsPred(mb_type)
		or mbIsBiPred(mb_type) and mb_type != BLOCK_TYPE_B_DIRECT_16x16
	do
		mbPartIdx := 0;
	end
	
	//  for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
	//    if( ( num_ref_idx_l0_active_minus1 > 0 || mb_field_decoding_flag ) && MbPartPredMode( mb_type, mbPartIdx ) != Pred_L1 )
	read_MB_pred_ref_idx_l0.loop: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < numMbPart(mb_type)
	var
		uint(size=32) res[1]
	do
		if ( (slice_num_ref_idx_l0_active_minus1 > 0)
			and Mb_Is_PredL0(mb_type, mbPartIdx)) then
			if entropy_coding_mode_flag[pps_id] = 0 then
				if slice_num_ref_idx_l0_active_minus1 = 1 then 
					vld_u_name(1,  fifo, res, "ref_idx_lx[mbPartIdx]                            ");
					ref_idx_l0[mbPartIdx] := 1 - res[0];
				else 
					vld_ue_name(  fifo, res, "ref_idx_lx[mbPartIdx]                             ");
					ref_idx_l0[mbPartIdx] := res[0];
				end
			else
				readRefIdxLX(res, 0);
				ref_idx_l0[mbPartIdx] := res[0];
			end
		else
			ref_idx_l0[mbPartIdx] := 0;
		end	
if MB_PRED then
		println("ReadRefIdxL0["+mbPartIdx+"] : "+ref_idx_l0[mbPartIdx]);
end
		mbPartIdx := mbPartIdx +1;
	end
	//end for

	read_MB_pred_ref_idx_l0.done: action ==> 
	guard
		mbPartIdx = numMbPart(mb_type)
	do
		mbPartIdx := 0;
	end

	//  for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
	//    if( ( num_ref_idx_l1_active_minus1 > 0 || mb_field_decoding_flag ) && MbPartPredMode( mb_type, mbPartIdx ) != Pred_L0 )
	read_MB_pred_ref_idx_l1.loop: action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < numMbPart(mb_type)
	var
		uint(size=32) res[1]
	do
		if ((slice_num_ref_idx_l1_active_minus1 > 0)
			and Mb_Is_PredL1(mb_type, mbPartIdx)) then
			if entropy_coding_mode_flag[pps_id] = 0 then
				if slice_num_ref_idx_l1_active_minus1 = 1 then 
					vld_u_name(1,  fifo, res, "ref_idx_lx[mbPartIdx]                            ");
					ref_idx_l1[mbPartIdx] := 1 - res[0];
				else 
					vld_ue_name(  fifo, res, "ref_idx_lx[mbPartIdx]                             ");
					ref_idx_l1[mbPartIdx] := res[0];
				end
			else
				readRefIdxLX(res, 1);
				ref_idx_l1[mbPartIdx] := res[0];
			end
		else
			ref_idx_l1[mbPartIdx] := 0;
		end	
if MB_PRED then
		println("ReadRefIdxL1["+mbPartIdx+"] : "+ref_idx_l1[mbPartIdx]);
end
		mbPartIdx := mbPartIdx +1;
	end
	//end for

	read_MB_pred_ref_idx_l1.done: action ==> 
	guard
		mbPartIdx = numMbPart(mb_type)
	do
		mbPartIdx := 0;
	end

	//  for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
	//    if( MbPartPredMode ( mb_type, mbPartIdx ) != Pred_L1 )
	read_MB_pred_mvd_l0.loop: action ==> 
		MB_PRED_REF_IDX_l0:[ref_idx_l0[mbPartIdx-1]],
		MB_PRED_MVD_l0:[mvd_l0[0], mvd_l0[1]]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < numMbPart(mb_type),
		Mb_Is_PredL0(mb_type, mbPartIdx)
	var
		int(size=32) res[1],
		int mvd_l0[2]
	do
		if entropy_coding_mode_flag[pps_id] = 0 then	
			vld_se_name(  fifo, res, "mvd_lx                                ");
			mvd_l0[0] := res[0];
			vld_se_name(  fifo, res, "mvd_lx                                ");
			mvd_l0[1] := res[0];
		else			
			readMvdLX(mvd_l0, 0);
		end
if MB_PRED then
		println("ReadMvdL0["+mbPartIdx+"] : "+mvd_l0[0]+" ; "+mvd_l0[1]);
end
		mbPartIdx := mbPartIdx +1;
	end

	//else
	read_MB_pred_mvd_l0.skip: action ==> 
	guard
		not Mb_Is_PredL0(mb_type, mbPartIdx),
		mbPartIdx < numMbPart(mb_type)
	do
		mbPartIdx := mbPartIdx+1;
	end
	//end if
	//end for

	read_MB_pred_mvd_l0.done: action ==> 
	guard
		mbPartIdx = numMbPart(mb_type)
	do
		mbPartIdx := 0;
	end

	// for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
	//   if( MbPartPredMode( mb_type, mbPartIdx ) != Pred_L0 )
	read_MB_pred_mvd_l1.loop: action ==> 
		MB_PRED_REF_IDX_l1:[ref_idx_l1[mbPartIdx-1]],
		MB_PRED_MVD_l1:[mvd_l1[0], mvd_l1[1]]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		mbPartIdx < numMbPart(mb_type),
		Mb_Is_PredL1(mb_type, mbPartIdx)
	var
		int(size=32) res[1],
		int mvd_l1[2]
	do
		if entropy_coding_mode_flag[pps_id] = 0 then	
			vld_se_name(  fifo, res, "mvd_lx                                ");
			mvd_l1[0] := res[0];
			vld_se_name(  fifo, res, "mvd_lx                                ");
			mvd_l1[1] := res[0];
		else			
			readMvdLX(mvd_l1, 1);
		end
if MB_PRED then
		println("ReadMvdL1["+mbPartIdx+"] : "+mvd_l1[0]+" ; "+mvd_l1[1]);
end
		mbPartIdx := mbPartIdx +1;
	end

	//else
	read_MB_pred_mvd_l1.skip: action ==> 
	guard
		not Mb_Is_PredL1(mb_type, mbPartIdx),
		mbPartIdx < numMbPart(mb_type)
	do
		mbPartIdx := mbPartIdx+1;
	end
	//end if
	//end for

	MB_pred_done: action ==> 
	guard
		mbPartIdx = numMbPart(mb_type)
	end

	//else (INTER pred, MbPartPredMode( mb_type, 0 ) == Direct ) )
	MB_pred_Inter_direct: action ==>
	guard
		(mb_type = BLOCK_TYPE_B_DIRECT_16x16)
	end 
	//******* End of Mb pred  ********/

	/*************************************************************
	*************************************************************
	********       Residual    	    *********
	*************************************************************
	*************************************************************/

	int(size=5) startIdx;
	int(size=5) endIdx;
	uint(size=4) block_startIdx;
	uint(size=6) block_endIdx;
	uint(size=7) maxNumCoeff;
	
	uint(size=3) i8x8;
	uint(size=3) i4x4;
	uint(size=3) NumC8x8;
	uint(size=2) iCbCr;
	uint(size=3) leveltype; // Intra16x16DCLevel 0, Intra16x16ACLevel 1, LumaLevel 2, ChromaDCLevel 3, ChromaACLevel 4 , luma64 5

	//if( startIdx = = 0 && MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
	Residual_luma_DC.run : action ==>
	guard
		Is_Intra_16x16(mb_type)
	do
		startIdx 		:= 0;
		endIdx 			:= 15;
		block_startIdx 	:= startIdx;
		block_endIdx 	:= endIdx;
		maxNumCoeff 	:= 16;
		leveltype 		:= 0;
		luma4x4BlkIdx	:= 0;
	end
	// --> residual_block( i16x16DClevel, 0, 15, 16 )

	Residual_luma_DC.return : action ==> LAST:[1]
	guard
		leveltype=0
	do
		i8x8 		:= 0;
		i4x4 		:= 0;
	end

	//else
	Residual_luma_DC.skip : action ==> //LAST:[true]
	guard
		not Is_Intra_16x16(mb_type)
	do
		startIdx 	:= 0;
		endIdx 		:= 15;
		//
		i8x8 		:= 0;
		i4x4 		:= 0;
		cbfLumaDCTab[Mb_x+1] := 0;
	end
	//end if

	// for( i8x8 = 0; i8x8 < 4; i8x8++ )
	// if( !transform_size_8x8_flag || !entropy_coding_mode_flag )
	Residual_luma_AC.loop8x8.start : action ==>
	guard
		i8x8 < 4,
		transform_size_8x8_flag=false or entropy_coding_mode_flag[pps_id] = 0 // bloc4x4 or CAVLC
	end

	// for( i4x4 = 0; i4x4 < 4; i4x4++ ) {
	// if( val_CodedBlockPatternLuma & ( 1 << i8x8 ) )
	Residual_luma_AC.loop4x4.run : action ==>
	guard
		i4x4 < 4,
		(val_CodedBlockPatternLuma & (1 << i8x8) ) != 0 // MB sub part 8x8 != 0
	do
		luma4x4BlkIdx := i4x4 + (i8x8 << 2);
		i4x4 		  := i4x4 +1;
		if i4x4 = 4 then i4x4 := 0; i8x8 := i8x8+1; end
		//if( endIdx > 0 &&  MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
		if Is_Intra_16x16(mb_type) then 
			block_startIdx 	:= if startIdx - 1 > 0 then startIdx - 1 else 0 end ;
			block_endIdx 	:= endIdx -1;
			maxNumCoeff 	:= 15;
			leveltype 		:= 1;
			// --> residual_block( i16x16AClevel[i8x8*4+ i4x4],max( 0, startIdx1 ), endIdx1, 15)
		else
			block_startIdx 	:= startIdx;
			block_endIdx 	:= endIdx;
			maxNumCoeff 	:= 16;
			leveltype 		:= 2;
			// --> residual_block( level[ i8x8 * 4 + i4x4 ], startIdx, endIdx, 16)
		end
		//end if
	end

	Residual_luma_AC.loop4x4.return: action ==> LAST: [1]
	guard
		leveltype = 1 or leveltype = 2
	end

	// else 
	Residual_luma_AC.loop4x4.skip : action ==>  LAST: [1]
	guard
		i4x4 < 4,
		(val_CodedBlockPatternLuma & (1 << i8x8) ) = 0 // MB sub part 8x8 == 0
	do
		luma4x4BlkIdx := i4x4 + (i8x8 << 2);
		/* 	if( MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
				for( i = 0; i < 15; i++ )
				i16x16AClevel[ i8x8 * 4 + i4x4 ][ i ] = 0 */
		foreach int i in 0 .. 3 do
			cbfLumaACTab[(Mb_x << 2) + locXYToTabIdx[i + (i8x8 << 2)]] := 0;
		end
		/* 	else
				for( i = 0; i < 16; i++ )
				level[ i8x8 * 4 + i4x4 ][ i ] = 0
			end if*/
		NonZeroCount[Mb_x * 4 + locXYToTabIdx[luma4x4BlkIdx]] := 0;
		i4x4 := i4x4 +1;
		if i4x4 = 4 then i4x4 := 0; i8x8 := i8x8+1; end
	end
	// end if

	/*
	if( !entropy_coding_mode_flag && transform_size_8x8_flag )
	for( i = 0; i < 16; i++ )
	level8x8[ i8x8 ][ 4 * i + i4x4 ] = level[ i8x8 * 4 + i4x4 ][ i ]
	*/
	//end for

	// else ( transform_size_8x8_flag = 1 && entropy_coding_mode_flag = 1 ) <==> CABAC && 8x8
	/* if( val_CodedBlockPatternLuma & ( 1 << i8x8 ) ) */
	Residual_luma_AC.loop8x8.I8x8_and_cabac.run : action ==>
	guard
		i8x8 < 4,
		transform_size_8x8_flag and entropy_coding_mode_flag[pps_id] = 1, // bloc8x8 and CABAC
		(val_CodedBlockPatternLuma & (1 << i8x8) ) != 0 // MB sub part 8x8 == 1
	do
		luma4x4BlkIdx   := i8x8<<2;
		block_startIdx 	:= 0;//startIdx<<2;
		block_endIdx 	:= 63;//(endIdx<<2) + 3;
		maxNumCoeff 	:= 64;
		leveltype 		:= 5;
		i8x8            := i8x8+1;
		// --> residual_block( level8x8[ i8x8 ], 4 * startIdx, 4 * endIdx + 3, 64 )
	end
	
	Residual_luma_AC.loop8x8.I8x8_and_cabac.return: action ==> LAST: [3]
	guard
		leveltype = 5
	end
	/* else */
	Residual_luma_AC.loop8x8.I8x8_and_cabac.skip : action ==> LAST: [3]
	guard
		i8x8 < 4,
		transform_size_8x8_flag and entropy_coding_mode_flag[pps_id] = 1, // bloc8x8 and CABAC
		(val_CodedBlockPatternLuma & (1 << i8x8) ) = 0 // MB sub part 8x8 == 0
	do
		i8x8 := i8x8+1;
	end

	Residual_luma_AC.end8x8 : action ==>
	guard
		i8x8 = 4
	end
	//end for

	//if( ChromaArrayType = = 1 | | ChromaArrayType = = 2 )
	Residual_Chroma.init : action ==>
	guard
		chroma_format_idc[sps_id] = 1 or chroma_format_idc[sps_id] = 2 
	do
		if chroma_format_idc[sps_id] = 1 then 
			NumC8x8 := 1;
		else 
			NumC8x8 := 2;
		end
		iCbCr 			:= 0;
		leveltype 		:= 3;
		luma4x4BlkIdx 	:= 0;
	end

	// for( iCbCr = 0; iCbCr < 2; iCbCr++ )
	//if( ( CodedBlockPatternChroma & 3 ) && startIdx = = 0 ) // chroma DC residual present
	Residual_chroma_DC.run : action ==>
	guard
		iCbCr < 2,
		(CodedBlockPatternChroma & 3) != 0
	do
		block_startIdx 	:= 0;
		block_endIdx 	:= 4 * NumC8x8 - 1;
		maxNumCoeff 	:= 4 * NumC8x8;
	end 
	//--> residual_block( ChromaDCLevel[ iCbCr ], 0, 4 * NumC8x8 - 1, 4 * NumC8x8 )

	Residual_chroma_DC.return : action ==> LAST: [1]
	guard
		leveltype = 3
	do
		iCbCr := iCbCr +1; 
	end

	// else
	Residual_chroma_DC.next : action ==> LAST: [1]
	guard
		iCbCr < 2,
		(CodedBlockPatternChroma & 3) = 0
	do
		//for( i = 0; i < 4 * NumC8x8; i++ )
		//ChromaDCLevel[ iCbCr ][ i ] = 0
		cbfChromaDCTab[Mb_x+1][iCbCr] := 0;
		iCbCr := iCbCr +1; 
	end   
	//end if

	Residual_chroma_DC.endLoop : action ==>
	guard
		iCbCr = 2
	do
		leveltype 		:= 4;
		iCbCr 			:= 0;
		i8x8 			:= 0;
		i4x4 			:= 0;
	end
	//end for  

	//for( iCbCr = 0; iCbCr < 2; iCbCr++ )
	//  for( i8x8 = 0; i8x8 < NumC8x8; i8x8++ )
	//    for( i4x4 = 0; i4x4 < 4; i4x4++ )
	//      if( ( CodedBlockPatternChroma & 2 ) && endIdx > 0 ) // chroma AC residual present
	Residual_chroma_AC.loop4x4 : action ==>
	guard
		iCbCr < 2,
		(CodedBlockPatternChroma & 2) = 2
	do
		luma4x4BlkIdx 	:= i4x4 + (i8x8 << 2);
		block_startIdx 	:= if startIdx - 1 > 0 then startIdx - 1 else 0 end ;
		block_endIdx 	:= endIdx - 1;
		maxNumCoeff 	:= 15;
	end
	// --> residual_block( ChromaACLevel[ iCbCr ][ i8x8*4+i4x4 ], max( 0, startIdx1 ), endIdx1, 15)

	Residual_chroma_AC.return : action ==> LAST:[1]
	guard
		leveltype = 4
	do
		i4x4 := i4x4 +1;
		if i4x4 = 4 then i4x4 := 0; i8x8 := i8x8 +1; end
		if i8x8 = NumC8x8 then i8x8 := 0; iCbCr := iCbCr +1; end
	end

	// else
	Residual_chroma_AC.loop4x4_skip : action ==> LAST: [1]
	guard
		iCbCr < 2,
		(CodedBlockPatternChroma & 2) != 2
	do
		luma4x4BlkIdx := i4x4 + (i8x8 << 2);
		/* for( i = 0; i < 15; i++ )
		ChromaACLevel[ iCbCr ][ i8x8*4+i4x4 ][ i ] = 0
		*/
		foreach int i in 0 .. 3 do
			cbfChromaACTab[(Mb_x << 1) + locXYToTabIdx_4[i]][iCbCr] := 0;
		end
		NonZeroCountC[Mb_x * 2 + locXYToTabIdx_4[luma4x4BlkIdx]] := [0, 0];
		i4x4 := i4x4 +1;
		if i4x4 = 4 then i4x4 := 0; i8x8 := i8x8 +1; end
		if i8x8 = NumC8x8 then i8x8:=0; iCbCr := iCbCr +1; end
	end
	//end if

	Residual_chroma_AC.skip : action ==> CBP_BLK:[val_cbp_blk]
	guard
		iCbCr = 2
	do
		iCbCr := 0;	
	end
	//end for
	//end for
	//end for

	// else if( ChromaArrayType = = 3 ) ==> Profile HP not yet implemented
	// else ( ChromaArrayType = = 0 ) ==> Profile HP not yet implemented

	//******* End of Residual  ********/

	/*************************************************************
	*************************************************************
	********       		Residual Block CAVLC   	    *********
	*************************************************************
	*************************************************************/
	int(size=6) nc;
	uint(size=4) NonZeroCount[(4 * STRIDE + 1) * 5]; 
	uint(size=4) NonZeroCountC[(2 * STRIDE + 1) * 3][2]; 
	uint(size=3) suffixLength;
	uint(size=5) inc_nb_coeff;
	uint(size=16) val_cbp_blk:=0;
	uint(size=4) zerosLeft;

	int(size=16) level[16] := [ 0 : for int i in 1 .. 16];
	uint(size=4) run[16] := [ 0 : for int i in 1 .. 16];

	residual_block_init.cavlc : action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		entropy_coding_mode_flag[pps_id] = 0
	var 
		uint(size=1) top, uint(size=1) left,//= 1 if MB not available
		uint(size=5) nA, 
		uint(size=5) nB
	do
		if leveltype = 3 then //chromaDC
			nc := -1;
		else
			top :=1; left :=1;
			if leveltype = 0 then luma4x4BlkIdx := 0; end
			if leveltype < 3 then //luma
				if (not availableB and locXYToBlkIdx[luma4x4BlkIdx]<4) then // MB 4x4 current situated on the first line of MBs 4x4, so there is no MB 4x4 above  
					nB :=0; top:=0;
				else
					nB := NonZeroCount[Mb_x * 4 + locXYToTabIdx[luma4x4BlkIdx] - STRIDE];
				end
				if (not availableA and (locXYToBlkIdx[luma4x4BlkIdx] & 3) = 0) then // MB 4x4 current situated on the first column of MBs 4x4, so there is no MB 4x4 at left  
					nA :=0; left:=0;
				else
					nA := NonZeroCount[Mb_x * 4 + locXYToTabIdx[luma4x4BlkIdx] - 1];
				end
			else //chroma
				if (not availableB and luma4x4BlkIdx<2) then // MB 4x4 current situated on the first line of MBs 4x4, so there is no MB 4x4 above  
					nB :=0; top:=0;
				else
					nB := NonZeroCountC[Mb_x * 2 + locXYToTabIdx_4[luma4x4BlkIdx] - STRIDE_4][iCbCr];
				end					
				if (not availableA and (luma4x4BlkIdx & 1) = 0) then // MB 4x4 current situated on the first column of MBs 4x4, so there is no MB 4x4 at left  
					nA :=0; left:=0;
				else
					nA := NonZeroCountC[Mb_x * 2 + locXYToTabIdx_4[luma4x4BlkIdx] - 1][iCbCr];
				end
			end
			if top = 1 and left = 1 then nc := ((nA + nB +1) >> 1); else nc := nA + nB ; end
		end
		vld_ce_coeff_token();
		level := [0 : for int i in 0 .. 15];
	end

	//if( TotalCoeff( coeff_token ) > 0 ) 
	Residual_block_read_suffixLength: action ==>
	guard
		TotalCoeff(coeff_token) >0
	do
		if leveltype = 1 or leveltype = 2 then //luma
    		val_cbp_blk:=(1 << locXYToBlkIdx[luma4x4BlkIdx]) + val_cbp_blk;
			NonZeroCount[Mb_x * 4 + locXYToTabIdx[luma4x4BlkIdx]] := TotalCoeff(coeff_token);
		else //chroma
			NonZeroCountC[Mb_x * 2 + locXYToTabIdx_4[luma4x4BlkIdx]][iCbCr] := TotalCoeff(coeff_token);
		end
		if TotalCoeff(coeff_token) > 10 and TrailingOnes(coeff_token) < 3 then suffixLength := 1; else suffixLength := 0; end
		inc_nb_coeff := 0;
	end

	// for( i = 0; i < TotalCoeff( coeff_token ); i++ )
	//if( i < TrailingOnes( coeff_token ) )
	Residual_block_read_trailing_ones_sign_flag: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		inc_nb_coeff < TotalCoeff(coeff_token)
	var
		uint level_prefix,
		uint levelSuffixSize,
		uint(size=32) res[1],
		uint level_suffix,
		uint level_prefix_temp,
		uint levelCode
	do
		if (inc_nb_coeff < TrailingOnes(coeff_token)) then
			vld_u_name(1,  fifo, res, "level[ inc_nb_coeff ]                             ");
			level[ inc_nb_coeff ] := 1 - 2 * res[0];
			inc_nb_coeff := inc_nb_coeff +1 ;
		else
			level_prefix := 0;
			level_prefix_temp:=0;
			while(level_prefix_temp = 0) do
				vld_u_name(1,  fifo, res, "level_prefix_temp                             ");
				level_prefix_temp := res[0];
				level_prefix := level_prefix +1;
			end
			level_prefix := level_prefix - 1;
	
			levelCode := ( if level_prefix < 15 then level_prefix else 15 end << suffixLength );
			if level_prefix = 14 and suffixLength = 0 then levelSuffixSize := 4;
			else if level_prefix >=15 then levelSuffixSize := level_prefix - 3;
			else levelSuffixSize := suffixLength; end end
			if levelSuffixSize > 0 then 
				vld_u_name(levelSuffixSize,  fifo, res, "level_suffix                             ");
				level_suffix := res[0];
			else
				level_suffix:=0;
			end
			//if( suffixLength > 0 | | level_prefix >= 14 )
			if suffixLength > 0 or level_prefix >= 14 then levelCode := levelCode + level_suffix; end
	
			// if( level_prefix > = 15 && suffixLength = = 0 )
			if level_prefix >= 15 and  suffixLength = 0 then levelCode := levelCode +15; end
	
			// if( level_prefix > = 16 )
			if level_prefix >= 16 then levelCode := levelCode + ( 1 << (level_prefix - 3) ) - 4096; end
	
			// if( i = = TrailingOnes( coeff_token ) &&	TrailingOnes( coeff_token ) < 3 )
			if inc_nb_coeff = TrailingOnes(coeff_token) and	TrailingOnes(coeff_token) < 3 then levelCode := levelCode + 2; end
	
			// if( levelCode % 2 = = 0 )
			if (levelCode & 1) = 0 then level[ inc_nb_coeff ] := ( (levelCode + 2) >> 1);
			else	level[ inc_nb_coeff ] := ( (-levelCode - 1) >> 1); end
	
			// if( suffixLength = = 0 )
			if suffixLength = 0 then suffixLength := 1; end
	
			//if( Abs( level[ i ] ) > ( 3 << ( suffixLength 1 ) ) &&	suffixLength < 6 )
			if  Abs(level[ inc_nb_coeff ]) > (3 << suffixLength - 1) and suffixLength < 6 then suffixLength := suffixLength +1; end
			inc_nb_coeff := inc_nb_coeff +1 ;
		end
	end

	// end if
	//end for 
	Residual_block_read_TotalCoeff_done: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		inc_nb_coeff = TotalCoeff(coeff_token)
	do
		//if( TotalCoeff( coeff_token ) < endIdx startIdx + 1 )
		if TotalCoeff(coeff_token) < block_endIdx - block_startIdx +1 then vld_ce_total_zeros(); end
		run := [0 : for int i in 0 .. 15];
	end

	Residual_block_read_total_zeros_done: action ==>
	do
		//if( TotalCoeff( coeff_token ) < endIdx startIdx + 1 )
		zerosLeft := if TotalCoeff(coeff_token) < block_endIdx - block_startIdx +1 then total_zeros else 0 end;
		inc_nb_coeff := 0;
	end

	//for( i = 0; i < TotalCoeff( coeff_token ) 1; i++ )
	Residual_block_read_run_before: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		inc_nb_coeff < TotalCoeff(coeff_token)-1,
		zerosLeft > 0
	do
		vld_ce_run_before();
	end

	Residual_block_read_run_before_done: action ==> LAST:[0], RUN:[run[inc_nb_coeff - 1]], VALUE:[level[inc_nb_coeff - 1]]
	do
		run[inc_nb_coeff] := run_before;
		zerosLeft := zerosLeft - run_before;
		inc_nb_coeff := inc_nb_coeff+1;
	end

	Residual_block_skip_read_run_before: action ==> LAST:[0], RUN:[run[inc_nb_coeff - 1]], VALUE:[level[inc_nb_coeff - 1]]
	guard
		inc_nb_coeff < TotalCoeff(coeff_token)-1,
		zerosLeft = 0
	do
		run[inc_nb_coeff] := 0;
		inc_nb_coeff := inc_nb_coeff+1;
	end

	//end for
	Residual_block_read_run_done: action ==> LAST:[0], RUN:[run[inc_nb_coeff]], VALUE:[level[inc_nb_coeff]]
	guard
		inc_nb_coeff = TotalCoeff(coeff_token)-1
	do
		run[inc_nb_coeff] := zerosLeft;
		if (Is_Intra_16x16(mb_type) and (leveltype = 1 or leveltype = 2)) or leveltype = 4 then run[inc_nb_coeff] := run[inc_nb_coeff] +1; end//the first coeffAC will be replaced by coeffDC
	end
	// --> residual_return

	//else ( TotalCoeff( coeff_token ) = 0 )
	Residual_block_skip_read_suffixLength: action ==>
	guard
		TotalCoeff(coeff_token) = 0
	do
		if leveltype = 1 or leveltype = 2 and transform_size_8x8_flag then
			val_cbp_blk:=(1 << locXYToBlkIdx[luma4x4BlkIdx]) + val_cbp_blk;
		end
		if leveltype < 3 then //luma
			NonZeroCount[Mb_x * 4 + locXYToTabIdx[luma4x4BlkIdx]] := 0;
		else //chroma
			NonZeroCountC[Mb_x * 2 + locXYToTabIdx_4[luma4x4BlkIdx]][iCbCr] := 0;
		end
	end 
	// --> residual return

	//******* End of Residual Block CAVLC ********  


	/*************************************************************
	*************************************************************
	********       		Residual Block CABAC   	    *********
	*************************************************************
	*************************************************************/
	int(size=32) coeffLevel;
	uint(size=2) sigLastTab[64];
	uint(size=2) coded_block_flag;
	uint(size=5) numCoeff;
	uint(size=5) numCoeff_i;
	uint(size=4) numDecodAbsLvlGt1;
	uint(size=4) numDecodAbsLvlEq1;
	
	procedure getCoeffLevel ()	
	var
		uint(size=32) coeff_abs_level_minus1[1],
		uint(size=32) coeff_sig_flag[1]
	begin
		getCoeffAbsLevelMinus1(codIRange, codIOffset, ctxTable, fifo, coeff_abs_level_minus1,
		   					   leveltype,  numDecodAbsLvlGt1, numDecodAbsLvlEq1);
		getCoeffSignFlag(codIRange, codIOffset, ctxTable, fifo, coeff_sig_flag);
		if coeff_sig_flag[0] = 1 then
			coeffLevel := -(coeff_abs_level_minus1[0] + 1);
		else
			coeffLevel :=   coeff_abs_level_minus1[0] + 1;
		end
		if coeff_abs_level_minus1[0] > 0 then
			numDecodAbsLvlGt1 := numDecodAbsLvlGt1 + 1;
		elsif coeff_abs_level_minus1[0] = 0 then
			numDecodAbsLvlEq1 := numDecodAbsLvlEq1 + 1;
		end
	end
	residual_block_init.cabac :  action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		entropy_coding_mode_flag[pps_id] = 1
	var
		uint(size=32) res[1] := [1],
		uint(size=32) mbLocxIdx,
		uint 		  Idx,
		uint(size= 2) x,
		uint(size= 2) y,
		uint 		  Idx_A,
		uint 		  Idx_B,
		bool		  availA,
		bool		  availB,
		uint(size= 1) cbfA,
		uint(size= 1) cbfB,
		uint(size= 6) mb_typeA,
		uint(size= 6) mb_typeB
	do
		if leveltype = 0 then
			Idx			:= Mb_x+1;
			Idx_A		:= Mb_x;
			Idx_B		:= Mb_x+1;
			x			:= 0;
			y			:= 0;
			cbfA		:= cbfLumaDCTab[Idx_A];
			cbfB		:= cbfLumaDCTab[Idx_B];
		elsif leveltype = 3 then
			Idx			:= Mb_x+1;
			Idx_A		:= Mb_x;
			Idx_B		:= Mb_x+1;
			x			:= 0;
			y			:= 0;
			cbfA		:= cbfChromaDCTab[Idx_A][iCbCr];
			cbfB		:= cbfChromaDCTab[Idx_B][iCbCr];
		elsif leveltype = 4 then
			mbLocxIdx 	:= Mb_x << 1;
			Idx			:= mbLocxIdx + locXYToTabIdx_4[luma4x4BlkIdx];
			Idx_A		:= Idx - 1;
			Idx_B		:= Idx - STRIDE_4;
			x			:= locXYToBlkIdx_4[luma4x4BlkIdx] & 1;
			y			:= locXYToBlkIdx_4[luma4x4BlkIdx] >> 1;
			cbfA		:= cbfChromaACTab[Idx_A][iCbCr];
			cbfB		:= cbfChromaACTab[Idx_B][iCbCr];
		else
			mbLocxIdx 	:= Mb_x << 2;
			Idx			:= mbLocxIdx + locXYToTabIdx[luma4x4BlkIdx];
			Idx_A		:= Idx - 1;
			Idx_B		:= Idx - STRIDE;
			x			:= locXYToBlkIdx[luma4x4BlkIdx] & 3;
			y			:= locXYToBlkIdx[luma4x4BlkIdx] >> 2;
			cbfA		:= cbfLumaACTab[Idx_A];
			cbfB		:= cbfLumaACTab[Idx_B];
		end
		availA	 := availableA or x!=0;
		availB	 := availableB or y!=0;
		mb_typeA := if x!=0 then mb_type else mbTypeTab[Mb_x]  end; 
		mb_typeB := if y!=0 then mb_type else mbTypeTab[Mb_x+1] end;
		if maxNumCoeff != 64 or chroma_format_idc[sps_id] = 3 then
			getCodedBlockFlag(codIRange, codIOffset, ctxTable, fifo, res,
							  mb_type, leveltype,
							  availA, mb_typeA, cbfA,
							  availB, mb_typeB, cbfB);
		end
		if leveltype = 0 then
			cbfLumaDCTab[Idx] := res[0];
	 	elsif leveltype = 3 then
	 		cbfChromaDCTab[Idx][iCbCr] := res[0];
	 	elsif leveltype = 4 then
	 		cbfChromaACTab[Idx][iCbCr] := res[0];
	 	elsif leveltype = 5 then
 	    	val_cbp_blk       :=(51 << ( (luma4x4BlkIdx & 8) + ((luma4x4BlkIdx&7)>>1) )) + val_cbp_blk;
	 		cbfLumaACTab[Idx         ] := 1;
	 		cbfLumaACTab[Idx+       1] := 1;
	 		cbfLumaACTab[Idx+STRIDE  ] := 1;
	 		cbfLumaACTab[Idx+STRIDE+1] := 1;
	 	else
	 	    val_cbp_blk       :=(res[0] << locXYToBlkIdx[luma4x4BlkIdx]) + val_cbp_blk;
	 		cbfLumaACTab[Idx] := res[0];
	 	end
		coded_block_flag  := res[0];
		coeffLevel 		  := 0;
		sigLastTab 		  := [0: for int i in 0 ..63];
		numDecodAbsLvlEq1 := 0;
		numDecodAbsLvlGt1 := 0;
		numCoeff   		  := block_endIdx;
		numCoeff_i 		  := block_startIdx;
	end

	residual_block_cabac.blockSkip.default :  action ==>
	guard
		coded_block_flag = 0 and (leveltype != 4 and leveltype != 1) 
	end
	residual_block_cabac.blockSkip.chroma_AC :  action ==> LAST:[0], RUN:[0], VALUE:[0]
	guard
		coded_block_flag = 0 and (leveltype = 4 or leveltype = 1) 
	end
	
	residual_block_cabac.SigLast_loop :  action ==> 
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		numCoeff_i < numCoeff
	var
		uint(size=32) res[1] := [0]
	do
		getSig(codIRange, codIOffset, ctxTable, fifo, res,
			   leveltype, numCoeff_i);
		sigLastTab[numCoeff_i] := res[0];
		if res[0] = 1 then
			getLast(codIRange, codIOffset, ctxTable, fifo, res,
					leveltype, numCoeff_i);
			if res[0] = 1 then
				sigLastTab[numCoeff_i] := 3;
				numCoeff := numCoeff_i + 1;
			end
		end
		numCoeff_i := numCoeff_i + 1;
	end
	
	residual_block_cabac.SigLast_endLoop :  action ==> LAST:[0], RUN:[0], VALUE:[coeffLevel]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		numCoeff_i = numCoeff
	do
		if sigLastTab[numCoeff-1] = 3 then	
			numCoeff := numCoeff - 1;
		end
		getCoeffLevel();
	end
	
	residual_block_cabac.Coeff_loop :  action ==> LAST:[0], RUN:[0], VALUE:[coeffLevel]
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		numCoeff != 0
	do
		numCoeff := numCoeff - 1;
		if sigLastTab[numCoeff] = 1 then	
			getCoeffLevel();
		else
			coeffLevel := 0;
		end
	end
	
	residual_block_cabac.Coeff_endLoop.default :  action ==>
	guard
		numCoeff = 0 and (leveltype != 4 and leveltype != 1)
	end
	
	residual_block_cabac.Coeff_endLoop.chroma_AC :  action ==> LAST:[0], RUN:[0], VALUE:[0]
	guard
		numCoeff = 0 and (leveltype = 4 or leveltype = 1)
	end
	//******* End of Residual Block CABAC ********  


	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		not IsStartCode(fifo)
   	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then		
  			println("start_code.search");
   		end
	end
	start_code.done: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		IsStartCode(fifo)
	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then
			println("start_code.done");
		end
	end

	byte_align_a: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
		byte_align(fifo);
	end
	
	/**************************************************************************
	 **************************************************************************
	 ********        undefined                            *********************
	 **************************************************************************
	 *************************************************************************/
  	bool actorNotFinished := true;
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("Algo_Parser doesn't manage this case yet");
		actorNotFinished := false;
	end
	
	
//********************************************************************************************************************************** 
	schedule fsm look_for_Sequence_Header :
		look_for_Sequence_Header						( look_for_Sequence_Header							) --> byte_align_a;

	    // FIXME: add minimal error resilience.
	    // byte align, then look for a starting on any byte boundary.
	    // is hex 00000100.
	    byte_align_a    ( byte_align_a    ) --> search_start_code;
	
		// search start code
		search_start_code          			( start_code.search					    ) --> search_start_code;
		search_start_code			            ( start_code.done					) --> read_Nal_unit_header;
	    

		// read Nal Unit header
		read_Nal_unit_header							( read_Nal_unit_header								) --> find_header;

		//
		find_header	  									( look_for_other_header								) --> look_for_Sequence_Header;
		find_header	  									( look_for.Sps_header	  							) --> read_Sps_id;
		find_header	  									( look_for.Pps_header	  							) --> read_Pps_seq_parameter_set_id;
		find_header	  									( look_for.Slice_header	  							) --> read_SliceH_slice_type;

		// read Sps header
		read_Sps_id	  										( read_Sps_id	    								) --> read_Sps_check_profile_idc;
		read_Sps_check_profile_idc	 						( read_Sps_chroma_format_idc	  					) --> read_Sps_chroma_format_idc_check;
		read_Sps_chroma_format_idc_check                    ( read_Sps_chroma_format_idc_check.IsEqualTo3       ) --> undefined; //not yet realized
		read_Sps_chroma_format_idc_check                    ( read_Sps_chroma_format_idc_check.IsNotEqualTo3    ) --> read_Sps_getScalingMatrix;
		// read Sps header :  Scaling_Matrix
		read_Sps_getScalingMatrix                           ( read_Sps_secScalingFlag.isEqualToTrue   			) --> read_Sps_getScalingMatrixLoop;
		read_Sps_getScalingMatrix                           ( read_Sps_secScalingFlag.isEqualToFalse  			) --> read_Sps_check_pic_order_cnt_type;
		read_Sps_getScalingMatrixLoop                       ( read_Sps_scalingMatrix.present          			) --> read_Sps_getScalingListLoop;
		read_Sps_getScalingMatrixLoop                       ( read_Sps_scalingMatrix.noPresent        			) --> read_Sps_getScalingMatrixLoopNext;
		read_Sps_getScalingListLoop                         ( read_Sps_scalingListLoop                			) --> read_Sps_getScalingListNext;
		read_Sps_getScalingListNext                         ( read_Sps_scalingListNext                			) --> read_Sps_getScalingListLoop;
		read_Sps_getScalingListNext           				( read_Sps_scalingListEnd                 			) --> read_Sps_getScalingMatrixLoopNext;
		read_Sps_getScalingMatrixLoopNext     				( read_Sps_scalingMatrix.loopNext					) --> read_Sps_getScalingMatrixLoop;
		read_Sps_getScalingMatrixLoopNext     				( read_Sps_scalingMatrix.loopEnd       				) --> read_Sps_check_pic_order_cnt_type;
		// end Scaling_Matrix
		read_Sps_check_profile_idc	 						( read_Sps_log2_max_frame_num_minus4				) --> read_Sps_check_pic_order_cnt_type;
		read_Sps_check_pic_order_cnt_type	 				( read_Sps_pic_order_cnt_type_skip01				) --> read_Sps_num_ref_frames; 
		read_Sps_check_pic_order_cnt_type	 				( read_Sps_log2_max_pic_order_cnt_lsb_minus4		) --> read_Sps_num_ref_frames;
		read_Sps_check_pic_order_cnt_type	 				( read_Sps_delta_pic_order_always_zero_flag			) --> read_Sps_offset_for_top_to_bottom_field;   
		read_Sps_offset_for_top_to_bottom_field				( read_Sps_offset_for_top_to_bottom_field	        ) --> read_Sps_offset_for_ref_frame;
		read_Sps_offset_for_ref_frame						( read_Sps_offset_for_ref_frame.loop	            ) --> read_Sps_offset_for_ref_frame;
		read_Sps_offset_for_ref_frame						( read_Sps_offset_for_ref_frame.done 	            ) --> read_Sps_num_ref_frames;
		read_Sps_num_ref_frames 							( read_Sps_num_ref_frames  	                        ) --> read_Sps_frame_mbs_only_flag;
		read_Sps_frame_mbs_only_flag 						( read_Sps_frame_mbs_only_flag	  	                ) --> read_Sps_mb_adaptive_frame_field_flag;
		read_Sps_mb_adaptive_frame_field_flag				( read_Sps_mb_adaptive_frame_field_flag  	        ) --> read_Sps_direct_8x8_interference_flag;
		read_Sps_direct_8x8_interference_flag 				( read_Sps_direct_8x8_interference_flag             ) --> read_Sps_frame_crop_left_offset;    

		read_Sps_frame_crop_left_offset						( read_Sps_frame_crop_left_offset  	                ) --> read_Sps_vui_parameters_present_flag;
		read_Sps_frame_crop_left_offset						( read_Sps_skip_frame_crop_left_offset	  	        ) --> read_Sps_vui_parameters_present_flag; 
		read_Sps_vui_parameters_present_flag				( read_Sps_vui_parameters_present_flag	  	        ) --> read_Sps_vui_parameters_present_flag_done;
		read_Sps_vui_parameters_present_flag_done			( read_Sps_done	                            		) --> look_for_Sequence_Header; //end of Sps
		read_Sps_vui_parameters_present_flag_done			( read_Sps_vui_parameters                    		) --> look_for_Sequence_Header;//undefined; //end of Sps

		// read Pps header
		read_Pps_seq_parameter_set_id 						( read_Pps_seq_parameter_set_id                     ) --> read_Pps_num_slice_groups_minus1;
		read_Pps_num_slice_groups_minus1					( read_Pps_num_slice_groups_minus1				  	) --> look_Pps_slice_group_map_type; 			  
		look_Pps_slice_group_map_type						( read_Pps_slice_group_map_type                     ) --> undefined;
		look_Pps_slice_group_map_type					    ( read_Pps_slice_group_map_type_skip 	  	        ) --> read_Pps_num_ref_idx_l0_active_minus1;
		read_Pps_num_ref_idx_l0_active_minus1				( read_Pps_num_ref_idx_l0_active_minus1	 	        ) --> read_Pps_pic_init_qp_minus26;
		read_Pps_pic_init_qp_minus26						( read_Pps_pic_init_qp_minus26	  	                ) --> read_Pps_chroma_qp_index_offset;
		read_Pps_chroma_qp_index_offset						( read_Pps_chroma_qp_index_offset 	                ) --> read_Pps_more_rbsp_data;
		read_Pps_more_rbsp_data 							( read_Pps_more_rbsp_data							) --> read_Pps_more_rbsp_data_done;
		read_Pps_more_rbsp_data_done						( read_Pps_High_Profile					  			) --> read_Pps_getScalingMatrix;
		read_Pps_more_rbsp_data_done						( read_Pps_not_High_Profile						  	) --> look_for_Sequence_Header;
		 // read Pps header :  Scaling_Matrix
		read_Pps_getScalingMatrix                           ( read_Pps_secScalingFlag.isEqualToTrue   			) --> read_Pps_getScalingMatrixLoop;
		read_Pps_getScalingMatrix                           ( read_Pps_secScalingFlag.isEqualToFalse  			) --> look_for_Sequence_Header;
		read_Pps_getScalingMatrixLoop                       ( read_Pps_scalingMatrix.present          			) --> read_Pps_getScalingListLoop;
		read_Pps_getScalingMatrixLoop                       ( read_Pps_scalingMatrix.noPresent        			) --> read_Pps_getScalingMatrixLoopNext;
		read_Pps_getScalingListLoop                         ( read_Pps_scalingListLoop                			) --> read_Pps_getScalingListNext;
		read_Pps_getScalingListNext                         ( read_Pps_scalingListNext                			) --> read_Pps_getScalingListLoop;
		read_Pps_getScalingListNext           				( read_Pps_scalingListEnd                 			) --> read_Pps_getScalingMatrixLoopNext;
		read_Pps_getScalingMatrixLoopNext     				( read_Pps_scalingMatrix.loopNext					) --> read_Pps_getScalingMatrixLoop;
		read_Pps_getScalingMatrixLoopNext     				( read_Pps_scalingMatrix.loopEnd       				) --> look_for_Sequence_Header;

		// read Slice header
		read_SliceH_slice_type								( read_SliceH_slice_type  	                        ) --> read_SliceH_picSize;
		read_SliceH_picSize									( read_SliceH_picSize						  		) --> read_SliceH_frame_num;
		read_SliceH_picSize									( read_SliceH_skip_picSize						  	) --> read_SliceH_frame_num;
		read_SliceH_frame_num								( read_SliceH_frame_num	  	                        ) --> read_SliceH_idr_pic_id;

		read_SliceH_idr_pic_id								( read_SliceH_idr_pic_id  	                        ) --> read_SliceH_delta_pic_order_cnt0;
		
		read_SliceH_delta_pic_order_cnt0					( read_SliceH_delta_pic_order_cnt0					) --> CalcPOC;

		CalcPOC												( CalcPOC	                                        ) --> read_SliceH_redundant_pic_cnt;
		read_SliceH_redundant_pic_cnt						( read_SliceH_redundant_pic_cnt                     ) --> read_SliceH_ref_pic_list_reordering;

		//ref_pic_list_reordering
		read_SliceH_ref_pic_list_reordering					( read_SliceH_ref_pic_list_reordering_flag_l0		) --> read_SliceH_reordering_of_pic_nums_idc_l0;
		read_SliceH_ref_pic_list_reordering					( read_SliceH_skip_ref_pic_list_reordering_l0		) --> read_SliceH_ref_pic_list_reordering_l1;
		
		read_SliceH_reordering_of_pic_nums_idc_l0 			( read_SliceH_ref_pic_list_reordering_flag.l0.isl0	) --> read_SliceH_reordering_of_pic_nums_idc_l0_done;
		read_SliceH_reordering_of_pic_nums_idc_l0			( read_SliceH_skip_reordering_of_pic_nums_idc.l0	) --> read_SliceH_ref_pic_list_reordering_l1;	
		read_SliceH_reordering_of_pic_nums_idc_l0_done		( read_SliceH_reordering_of_pic_nums.l0		 		) --> look_SliceH_reordering_of_pic_nums_idc_l0_done;	
		look_SliceH_reordering_of_pic_nums_idc_l0_done		( read_SliceH_reordering_of_pic_nums_idc.l0		    ) --> read_SliceH_reordering_of_pic_nums_idc_l0_done;	
		look_SliceH_reordering_of_pic_nums_idc_l0_done		( read_SliceH_reordering_of_pic_nums_idc3.l0	   	) --> read_SliceH_ref_pic_list_reordering_l1;

		read_SliceH_ref_pic_list_reordering_l1				( read_SliceH_ref_pic_list_reordering_flag_l1		) --> read_SliceH_reordering_of_pic_nums_idc_l1;
		read_SliceH_ref_pic_list_reordering_l1				( read_SliceH_skip_ref_pic_list_reordering_l1 		) --> read_SliceH_pred_weight_table;

		read_SliceH_reordering_of_pic_nums_idc_l1 		    ( read_SliceH_ref_pic_list_reordering_flag.l1.isl1	) --> read_SliceH_reordering_of_pic_nums_idc_l1_done;
		read_SliceH_reordering_of_pic_nums_idc_l1			( read_SliceH_skip_reordering_of_pic_nums_idc.l1	) --> read_SliceH_pred_weight_table;	
		read_SliceH_reordering_of_pic_nums_idc_l1_done		( read_SliceH_reordering_of_pic_nums.l1		 		) --> look_SliceH_reordering_of_pic_nums_idc_l1_done;	
		look_SliceH_reordering_of_pic_nums_idc_l1_done		( read_SliceH_reordering_of_pic_nums_idc.l1     	) --> read_SliceH_reordering_of_pic_nums_idc_l1_done;	
		look_SliceH_reordering_of_pic_nums_idc_l1_done		( read_SliceH_reordering_of_pic_nums_idc3.l1   		) --> read_SliceH_pred_weight_table;

		//pred_weight_table
		read_SliceH_pred_weight_table						( read_SliceH_pred_weight_table						) --> read_SliceH_pred_weight_table_l0;
		read_SliceH_pred_weight_table_l0                    ( read_SliceH_pred_weight_table_l0.endloop          ) --> read_SliceH_pred_weight_table_B;
		read_SliceH_pred_weight_table_l0                    ( read_SliceH_pred_weight_table_l0.loop             ) --> read_SliceH_pred_weight_table_l0_chroma;
		read_SliceH_pred_weight_table_l0_chroma             ( read_SliceH_pred_weight_table_l0_chroma_u         ) --> read_SliceH_pred_weight_table_l0_chroma_v;
		read_SliceH_pred_weight_table_l0_chroma_v           ( read_SliceH_pred_weight_table_l0_chroma_v         ) --> read_SliceH_pred_weight_table_l0;
		read_SliceH_pred_weight_table_B                     ( read_SliceH_pred_weight_table_B.skip              ) --> read_SliceH_dec_ref_pic_marking;
		read_SliceH_pred_weight_table_B                     ( read_SliceH_pred_weight_table_B.launch            ) --> read_SliceH_pred_weight_table_l1;
		read_SliceH_pred_weight_table_l1                    ( read_SliceH_pred_weight_table_l1.endloop          ) --> read_SliceH_dec_ref_pic_marking;
		read_SliceH_pred_weight_table_l1                    ( read_SliceH_pred_weight_table_l1.loop             ) --> read_SliceH_pred_weight_table_l1_chroma;
		read_SliceH_pred_weight_table_l1_chroma             ( read_SliceH_pred_weight_table_l1_chroma_u         ) --> read_SliceH_pred_weight_table_l1_chroma_v;
		read_SliceH_pred_weight_table_l1_chroma_v           ( read_SliceH_pred_weight_table_l1_chroma_v         ) --> read_SliceH_pred_weight_table_l1;
		read_SliceH_pred_weight_table						( read_SliceH_skip_pred_weight_table				) --> read_SliceH_dec_ref_pic_marking;

		//dec_ref_pic_marking
		read_SliceH_dec_ref_pic_marking						( read_SliceH_dec_ref_pic_marking	                ) --> read_SliceH_check_IdrPicFlag;
		read_SliceH_check_IdrPicFlag						( read_SliceH_no_output_of_prior_pics_flag_done		) --> read_SliceH_cabac_init_idc;
		read_SliceH_check_IdrPicFlag						( read_SliceH_adaptative_ref_pic_marking_mode_flag_done) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco								( read_SliceH_skip_memory_management_control_operation_done ) --> read_SliceH_cabac_init_idc;
		read_SliceH_check_mmco								( read_SliceH_memory_management_control_operation_done) --> read_SliceH_check_mmco_done;
		read_SliceH_check_mmco_done							( read_SliceH_mmco_0								) --> read_SliceH_cabac_init_idc;
		read_SliceH_check_mmco_done							( read_SliceH_difference_of_pic_nums_minus1_done	) --> read_SliceH_check_mmco_36;
		read_SliceH_check_mmco_done							( read_SliceH_long_term_pic_num_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_done							( read_SliceH_long_term_frame_idx_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_36							( read_SliceH_long_term_frame_idx_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_36							( read_SliceH_long_not_term_frame_idx_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_done							( read_SliceH_max_long_term_frame_idx_plus1_done	) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_done							( read_SliceH_mmco_5								) --> read_SliceH_check_mmco;
		read_SliceH_dec_ref_pic_marking						( read_SliceH_skip_dec_ref_pic_marking				) --> read_SliceH_cabac_init_idc;

		read_SliceH_cabac_init_idc							( read_SliceH_cabac_init_idc						) --> read_SliceH_disable_deblocking_filter_idc;
		read_SliceH_disable_deblocking_filter_idc			( read_SliceH_disable_deblocking_filter_idc 		) --> read_SliceH_slice_group_change_cycle;		
		read_SliceH_slice_group_change_cycle				( read_SliceH_slice_group_change_cycle				) --> read_SliceD_CABAC_alignement;

		// read Slice Data     only decoding CAVLC process is implemented
		read_SliceD_CABAC_alignement						( read_SliceD_CABAC_alignement						) --> read_SliceD_init;
		read_SliceD_init									( SliceD_init										) --> read_SliceD_mb_skip;
		read_SliceD_mb_skip									( read_SliceD_mb_skip.cavlc							) --> read_SliceD_mb_skip_run;
		read_SliceD_mb_skip									( read_SliceD_mb_skip.cabac							) --> read_SliceD_mb_skip_flag;
		read_SliceD_mb_skip									( read_SliceD_mb_skip.skip							) --> read_MB_layer_mb_type;
		read_SliceD_mb_skip_flag 							( read_SliceD_mb_skip_flag							) --> read_SliceD_mb_skip_end;
		read_SliceD_mb_skip_run								( read_SliceD_mb_skip_run.loop						) --> read_SliceD_mb_skip_run;
		read_SliceD_mb_skip_run								( read_SliceD_mb_skip_run.endLoop					) --> read_SliceD_mb_skip_end;
		read_SliceD_mb_skip_end			 		            ( read_SliceD_mb_skip_end.moredata_1   		    	) --> read_MB_layer_mb_type;
		read_SliceD_mb_skip_end			 					( read_SliceD_mb_skip_end.moredata_0				) --> SliceD_update;

		// --> macrobloc_layer()
		SliceD_update										( SliceD_update										) --> SliceD_while_moreDataFlag;
		SliceD_while_moreDataFlag							( SliceD_while_moreDataFlag							) --> read_SliceD_mb_skip;
		SliceD_while_moreDataFlag							( SliceD_end										) --> look_for_Sequence_Header;
		
		// macrobloc_layer
		read_MB_layer_mb_type								( read_MB_layer_mb_type								) --> read_MB_layer_check_I_PCM;
		read_MB_layer_check_I_PCM							( read_MB_layer_I_PCM_alignement					) --> read_MB_layer_pcm_sample_luma;
		read_MB_layer_pcm_sample_luma					    ( read_MB_layer_pcm_sample_luma.loop	            ) --> read_MB_layer_pcm_sample_luma;
		read_MB_layer_pcm_sample_luma						( read_MB_layer_pcm_sample_luma.done	            ) --> read_MB_layer_pcm_sample_chroma;
		read_MB_layer_pcm_sample_chroma						( read_MB_layer_pcm_sample_chroma.loop				) --> read_MB_layer_pcm_sample_chroma;	
		read_MB_layer_pcm_sample_chroma						( read_MB_layer_pcm_sample_chroma.done				) --> SliceD_update;
		read_MB_layer_check_I_PCM							( read_MB_layer_not_I_PCM							) --> read_MB_layer_check_pred;
		read_MB_layer_check_pred							( read_MB_layer_sub_mb_pred							) --> Sub_mb_pred; //--> sub_mb_pred
		read_MB_layer_sub_mb_pred_done				        ( read_MB_layer_sub_mb_pred_done	                ) --> read_MB_layer_coded_block_pattern;
		read_MB_layer_check_pred							( read_MB_layer_transform_size_8x8_flag				) --> MB_pred;
		// --> mb_pred()	

		read_MB_layer_coded_block_pattern					( read_MB_layer_coded_block_pattern					) --> read_MB_layer_mb_qp_delta;
		read_MB_layer_mb_qp_delta							( read_MB_layer_mb_qp_delta							) --> Residual_luma_DC;
		// --> residual ()
		read_MB_layer_mb_qp_delta							( read_MB_layer_skip_mb_qp_delta					) --> SliceD_update;

		// sub_mb_pred
		Sub_mb_pred											( read_sub_MB_pred_sub_mb_type.loop					) --> Sub_mb_pred;
		Sub_mb_pred											( read_sub_MB_pred_sub_mb_type.done					) --> read_sub_MB_pred_ref_idx_l0;
		read_sub_MB_pred_ref_idx_l0							( read_sub_MB_pred_ref_idx_l0.loop					) --> read_sub_MB_pred_ref_idx_l0;
		read_sub_MB_pred_ref_idx_l0							( read_sub_MB_pred_ref_idx_l0.done					) --> read_sub_MB_pred_ref_idx_l1;
		read_sub_MB_pred_ref_idx_l1							( read_sub_MB_pred_ref_idx_l1.loop					) --> read_sub_MB_pred_ref_idx_l1;
		read_sub_MB_pred_ref_idx_l1							( read_sub_MB_pred_ref_idx_l1.done					) --> read_sub_MB_pred_mvd_l0;
		read_sub_MB_pred_mvd_l0								( read_sub_MB_pred_mvd_l0.loop	                    ) --> read_sub_MB_pred_mvd_l0_inner;
		read_sub_MB_pred_mvd_l0								( read_sub_MB_pred_mvd_l0.skip						) --> read_sub_MB_pred_mvd_l0;
		read_sub_MB_pred_mvd_l0								( read_sub_MB_pred_mvd_l0.done						) --> read_sub_MB_pred_mvd_l1;
		read_sub_MB_pred_mvd_l0_inner						( read_sub_MB_pred_mvd_l0.inner.loop				) --> read_sub_MB_pred_mvd_l0_inner;
		read_sub_MB_pred_mvd_l0_inner						( read_sub_MB_pred_mvd_l0.inner.done				) --> read_sub_MB_pred_mvd_l0;
		read_sub_MB_pred_mvd_l1								( read_sub_MB_pred_mvd_l1.loop						) --> read_sub_MB_pred_mvd_l1_inner;
		read_sub_MB_pred_mvd_l1								( read_sub_MB_pred_mvd_l1.skip						) --> read_sub_MB_pred_mvd_l1;
		read_sub_MB_pred_mvd_l1_inner						( read_sub_MB_pred_mvd_l1.inner.loop				) --> read_sub_MB_pred_mvd_l1_inner;
		read_sub_MB_pred_mvd_l1_inner						( read_sub_MB_pred_mvd_l1.inner.done				) --> read_sub_MB_pred_mvd_l1;
		read_sub_MB_pred_mvd_l1								( sub_MB_pred_done									) --> read_MB_layer_sub_mb_pred_done; // --> macrobloc_layer()	

		// mb_pred
		MB_pred												( MB_pred_init_Intra_4x4							) --> read_MB_pred_rem_intra4x4_pred_mode;
		read_MB_pred_rem_intra4x4_pred_mode					( read_MB_pred_rem_intra4x4_pred_mode.loop			) --> read_MB_pred_rem_intra4x4_pred_mode;
		read_MB_pred_rem_intra4x4_pred_mode					( read_MB_pred_rem_intra4x4_pred_mode.done			) --> read_MB_pred_intra_chroma_pred_mode;
		MB_pred												( MB_pred_init_Intra_8x8							) --> read_MB_pred_intra_chroma_pred_mode;
		MB_pred												( MB_pred_init_Intra_16x16							) --> read_MB_pred_intra_chroma_pred_mode;
		read_MB_pred_intra_chroma_pred_mode					( read_MB_pred_intra_chroma_pred_mode.launch		) --> read_MB_layer_coded_block_pattern;
		read_MB_pred_intra_chroma_pred_mode					( read_MB_pred_intra_chroma_pred_mode.skip			) --> read_MB_layer_coded_block_pattern; // --> macrobloc_layer()
		MB_pred												( MB_pred_Inter_not_direct							) --> read_MB_pred_ref_idx_l0;
		read_MB_pred_ref_idx_l0								( read_MB_pred_ref_idx_l0.loop						) --> read_MB_pred_ref_idx_l0;
		read_MB_pred_ref_idx_l0								( read_MB_pred_ref_idx_l0.done						) --> read_MB_pred_ref_idx_l1;
		read_MB_pred_ref_idx_l1								( read_MB_pred_ref_idx_l1.loop						) --> read_MB_pred_ref_idx_l1;
		read_MB_pred_ref_idx_l1								( read_MB_pred_ref_idx_l1.done						) --> read_MB_pred_mvd_l0;
		read_MB_pred_mvd_l0									( read_MB_pred_mvd_l0.loop							) --> read_MB_pred_mvd_l0;
		read_MB_pred_mvd_l0									( read_MB_pred_mvd_l0.skip							) --> read_MB_pred_mvd_l0;
		read_MB_pred_mvd_l0									( read_MB_pred_mvd_l0.done							) --> read_MB_pred_mvd_l1;
		read_MB_pred_mvd_l1									( read_MB_pred_mvd_l1.loop							) --> read_MB_pred_mvd_l1;
		read_MB_pred_mvd_l1									( read_MB_pred_mvd_l1.skip							) --> read_MB_pred_mvd_l1;
		read_MB_pred_mvd_l1									( MB_pred_done										) --> read_MB_layer_coded_block_pattern; // --> macrobloc_layer()	
		MB_pred												( MB_pred_Inter_direct								) --> read_MB_layer_coded_block_pattern; // --> macrobloc_layer()

		// residual
		Residual_luma_DC									( Residual_luma_DC.run								) --> Residual_block; // --> residual_block()
		Residual_return										( Residual_luma_DC.return							) --> Residual_luma_AC_loop8x8;
		Residual_luma_DC									( Residual_luma_DC.skip								) --> Residual_luma_AC_loop8x8;
		Residual_luma_AC_loop8x8							( Residual_luma_AC.loop8x8.start					) --> Residual_luma_AC_loop4x4;
		Residual_luma_AC_loop8x8							( Residual_luma_AC.loop8x8.I8x8_and_cabac.run		) --> Residual_block; // --> residual_block()
		Residual_return										( Residual_luma_AC.loop8x8.I8x8_and_cabac.return	) --> Residual_luma_AC_loop8x8;
		Residual_luma_AC_loop8x8							( Residual_luma_AC.loop8x8.I8x8_and_cabac.skip		) --> Residual_luma_AC_loop8x8;
		Residual_luma_AC_loop4x4							( Residual_luma_AC.loop4x4.run						) --> Residual_block; // --> residual_block()
		Residual_return										( Residual_luma_AC.loop4x4.return					) --> Residual_luma_AC_loop8x8;
		Residual_luma_AC_loop4x4							( Residual_luma_AC.loop4x4.skip						) --> Residual_luma_AC_loop8x8;
		Residual_luma_AC_loop8x8							( Residual_luma_AC.end8x8							) --> Residual_chroma; 
		Residual_chroma										( Residual_Chroma.init								) --> Residual_chroma_DC;
		Residual_chroma_DC									( Residual_chroma_DC.run							) --> Residual_block; // --> residual_block()
		Residual_return										( Residual_chroma_DC.return							) --> Residual_chroma_DC;
		Residual_chroma_DC									( Residual_chroma_DC.next							) --> Residual_chroma_DC;
		Residual_chroma_DC									( Residual_chroma_DC.endLoop						) --> Residual_chroma_AC_loop4x4;
		Residual_chroma_AC_loop4x4							( Residual_chroma_AC.loop4x4	 					) --> Residual_block; // --> residual_block()
		Residual_return										( Residual_chroma_AC.return							) --> Residual_chroma_AC_loop4x4;
		Residual_chroma_AC_loop4x4							( Residual_chroma_AC.loop4x4_skip		 			) --> Residual_chroma_AC_loop4x4;
		Residual_chroma_AC_loop4x4							( Residual_chroma_AC.skip							) --> SliceD_update; 
		// --> macrobloc_layer / --> Slice_data

		// residual_block
		Residual_block										( residual_block_init.cavlc							) --> Residual_block_read_suffixLength;
		Residual_block										( residual_block_init.cabac							) --> residual_block_cabac_sigLast_loop;
		Residual_block_read_suffixLength					( Residual_block_read_suffixLength					) --> Residual_block_read_non_zero_coeff;
		Residual_block_read_non_zero_coeff					( Residual_block_read_trailing_ones_sign_flag		) --> Residual_block_read_non_zero_coeff;
		
		Residual_block_read_non_zero_coeff					( Residual_block_read_TotalCoeff_done				) --> Residual_block_read_total_zeros_done;
		Residual_block_read_total_zeros_done				( Residual_block_read_total_zeros_done				) --> Residual_block_read_run_before;
		Residual_block_read_run_before						( Residual_block_read_run_before					) --> Residual_block_read_run_before_done;
		Residual_block_read_run_before_done					( Residual_block_read_run_before_done				) --> Residual_block_read_run_before;
		Residual_block_read_run_before						( Residual_block_skip_read_run_before				) --> Residual_block_read_run_before;
		Residual_block_read_run_before						( Residual_block_read_run_done						) --> Residual_return;
		Residual_block_read_suffixLength					( Residual_block_skip_read_suffixLength				) --> Residual_return;

		// residual_block_cabac
		residual_block_cabac_sigLast_loop					( residual_block_cabac.blockSkip					) --> Residual_return;
		residual_block_cabac_sigLast_loop					( residual_block_cabac.SigLast_loop					) --> residual_block_cabac_sigLast_loop;
		residual_block_cabac_sigLast_loop					( residual_block_cabac.SigLast_endLoop				) --> residual_block_cabac_coeff_loop;
		residual_block_cabac_coeff_loop						( residual_block_cabac.Coeff_loop					) --> residual_block_cabac_coeff_loop;
		residual_block_cabac_coeff_loop						( residual_block_cabac.Coeff_endLoop				) --> Residual_return;
		// undefined
		undefined	  					( undefined		    				) --> undefined;

	end

	priority
		look_for > look_for_other_header;
		read_SliceH_pred_weight_table > read_SliceH_skip_pred_weight_table;
		read_SliceH_difference_of_pic_nums_minus1_done > read_SliceH_long_term_frame_idx_done > read_SliceH_memory_management_control_operation_done;
		read_SliceH_ref_pic_list_reordering_flag_l0 > read_SliceH_skip_ref_pic_list_reordering_l0;
		read_SliceH_ref_pic_list_reordering_flag_l1 > read_SliceH_skip_ref_pic_list_reordering_l1;
		read_MB_pred_mvd_l0.loop >  read_MB_pred_mvd_l0.skip > read_MB_pred_mvd_l0.done;
		read_MB_pred_mvd_l1.loop >  read_MB_pred_mvd_l1.skip > MB_pred_done;
	end

end
