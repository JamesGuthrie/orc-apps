package devel.org.sc29.wg11.mpegh.part2.main.intra;
import std.util.Math.*;

unit  IntraFunctions :
	
	int(size=7) intraPredAngle[64] = [0, 0, 32, 26, 21, 17, 13, 9, 5, 2, 0, -2,
	-5, -9, -13, -17, -21, -26, -32, -26, -21, -17, -13, -9, -5, -2, 0, 2, 5,
	9, 13, 17, 21, 26, 32];

	int(size=16) invAngle[64] =
	[  0,     0,  -256, -315,  -390,  -482, -630,  -910, -1638, -4096,
	   0, -4096, -1638, -910,  -630,  -482, -390,  -315,  -256,  -315,
	-390,  -482,  -630, -910, -1638, -4096,    0, -4096, -1638,  -910,
	-630,  -482,  -390, -315,  -256];
	
	@optimize_c(condition="OPENHEVC_ENABLE", name="pred_planar_orcc")
	procedure intraPlanarPred0(uint(size=8) src[64 * 64], 
		uint(size=8) top[129] , uint(size=8) left [129], 
		int  stride, int log2Size)
	begin
		src[0 + 0 * stride] := ((3 - 0) * left[0 + 1] + (0 + 1) * top[5] + (3 - 0) * top[0 + 1]  + (0 + 1) * left[5] + 4) >> 3;
		src[1 + 0 * stride] := ((3 - 1) * left[0 + 1] + (1 + 1) * top[5] + (3 - 0) * top[1 + 1]  + (0 + 1) * left[5] + 4) >> 3;
		src[2 + 0 * stride] := ((3 - 2) * left[0 + 1] + (2 + 1) * top[5] + (3 - 0) * top[2 + 1]  + (0 + 1) * left[5] + 4) >> 3;
		src[3 + 0 * stride] := ((3 - 3) * left[0 + 1] + (3 + 1) * top[5] + (3 - 0) * top[3 + 1]  + (0 + 1) * left[5] + 4) >> 3;
		
		src[0 + 1 * stride] := ((3 - 0) * left[1 + 1] + (0 + 1) * top[5] + (3 - 1) * top[0 + 1]  + (1 + 1) * left[5] + 4) >> 3;
		src[1 + 1 * stride] := ((3 - 1) * left[1 + 1] + (1 + 1) * top[5] + (3 - 1) * top[1 + 1]  + (1 + 1) * left[5] + 4) >> 3;
		src[2 + 1 * stride] := ((3 - 2) * left[1 + 1] + (2 + 1) * top[5] + (3 - 1) * top[2 + 1]  + (1 + 1) * left[5] + 4) >> 3;
		src[3 + 1 * stride] := ((3 - 3) * left[1 + 1] + (3 + 1) * top[5] + (3 - 1) * top[3 + 1]  + (1 + 1) * left[5] + 4) >> 3;
		
		src[0 + 2 * stride] := ((3 - 0) * left[2 + 1] + (0 + 1) * top[5] + (3 - 2) * top[0 + 1]  + (2 + 1) * left[5] + 4) >> 3;
		src[1 + 2 * stride] := ((3 - 1) * left[2 + 1] + (1 + 1) * top[5] + (3 - 2) * top[1 + 1]  + (2 + 1) * left[5] + 4) >> 3;
		src[2 + 2 * stride] := ((3 - 2) * left[2 + 1] + (2 + 1) * top[5] + (3 - 2) * top[2 + 1]  + (2 + 1) * left[5] + 4) >> 3;
		src[3 + 2 * stride] := ((3 - 3) * left[2 + 1] + (3 + 1) * top[5] + (3 - 2) * top[3 + 1]  + (2 + 1) * left[5] + 4) >> 3;
		
		src[0 + 3 * stride] := ((3 - 0) * left[3 + 1] + (0 + 1) * top[5] + (3 - 3) * top[0 + 1]  + (3 + 1) * left[5] + 4) >> 3;
		src[1 + 3 * stride] := ((3 - 1) * left[3 + 1] + (1 + 1) * top[5] + (3 - 3) * top[1 + 1]  + (3 + 1) * left[5] + 4) >> 3;
		src[2 + 3 * stride] := ((3 - 2) * left[3 + 1] + (2 + 1) * top[5] + (3 - 3) * top[2 + 1]  + (3 + 1) * left[5] + 4) >> 3;
		src[3 + 3 * stride] := ((3 - 3) * left[3 + 1] + (3 + 1) * top[5] + (3 - 3) * top[3 + 1]  + (3 + 1) * left[5] + 4) >> 3;
	end
	
	@optimize_c(condition="OPENHEVC_ENABLE", name="pred_planar_orcc")
	procedure intraPlanarPred1(uint(size=8) src[64 * 64], 
		uint(size=8) top[129] , uint(size=8) left [129], 
		int  stride, int log2Size)
	var
		int y := 0
	begin
		while (y < 8) 
		do
			src[0 + y * stride] := ((7 - 0) * left[y + 1] + (0 + 1) * top[9] + (7 - y) * top[0 + 1]  + (y + 1) * left[9] + 8) >> 4;
			src[1 + y * stride] := ((7 - 1) * left[y + 1] + (1 + 1) * top[9] + (7 - y) * top[1 + 1]  + (y + 1) * left[9] + 8) >> 4;
			src[2 + y * stride] := ((7 - 2) * left[y + 1] + (2 + 1) * top[9] + (7 - y) * top[2 + 1]  + (y + 1) * left[9] + 8) >> 4;
			src[3 + y * stride] := ((7 - 3) * left[y + 1] + (3 + 1) * top[9] + (7 - y) * top[3 + 1]  + (y + 1) * left[9] + 8) >> 4;
			src[4 + y * stride] := ((7 - 4) * left[y + 1] + (4 + 1) * top[9] + (7 - y) * top[4 + 1]  + (y + 1) * left[9] + 8) >> 4;
			src[5 + y * stride] := ((7 - 5) * left[y + 1] + (5 + 1) * top[9] + (7 - y) * top[5 + 1]  + (y + 1) * left[9] + 8) >> 4;
			src[6 + y * stride] := ((7 - 6) * left[y + 1] + (6 + 1) * top[9] + (7 - y) * top[6 + 1]  + (y + 1) * left[9] + 8) >> 4;
			src[7 + y * stride] := ((7 - 7) * left[y + 1] + (7 + 1) * top[9] + (7 - y) * top[7 + 1]  + (y + 1) * left[9] + 8) >> 4;
			
			src[0 + (y + 1) * stride] := ((7 - 0) * left[(y + 1) + 1] + (0 + 1) * top[9] + (7 - (y + 1)) * top[0 + 1]  + ((y + 1) + 1) * left[9] + 8) >> 4;
			src[1 + (y + 1) * stride] := ((7 - 1) * left[(y + 1) + 1] + (1 + 1) * top[9] + (7 - (y + 1)) * top[1 + 1]  + ((y + 1) + 1) * left[9] + 8) >> 4;
			src[2 + (y + 1) * stride] := ((7 - 2) * left[(y + 1) + 1] + (2 + 1) * top[9] + (7 - (y + 1)) * top[2 + 1]  + ((y + 1) + 1) * left[9] + 8) >> 4;
			src[3 + (y + 1) * stride] := ((7 - 3) * left[(y + 1) + 1] + (3 + 1) * top[9] + (7 - (y + 1)) * top[3 + 1]  + ((y + 1) + 1) * left[9] + 8) >> 4;
			src[4 + (y + 1) * stride] := ((7 - 4) * left[(y + 1) + 1] + (4 + 1) * top[9] + (7 - (y + 1)) * top[4 + 1]  + ((y + 1) + 1) * left[9] + 8) >> 4;
			src[5 + (y + 1) * stride] := ((7 - 5) * left[(y + 1) + 1] + (5 + 1) * top[9] + (7 - (y + 1)) * top[5 + 1]  + ((y + 1) + 1) * left[9] + 8) >> 4;
			src[6 + (y + 1) * stride] := ((7 - 6) * left[(y + 1) + 1] + (6 + 1) * top[9] + (7 - (y + 1)) * top[6 + 1]  + ((y + 1) + 1) * left[9] + 8) >> 4;
			src[7 + (y + 1) * stride] := ((7 - 7) * left[(y + 1) + 1] + (7 + 1) * top[9] + (7 - (y + 1)) * top[7 + 1]  + ((y + 1) + 1) * left[9] + 8) >> 4;
			
			src[0 + (y + 2) * stride] := ((7 - 0) * left[(y + 2) + 1] + (0 + 1) * top[9] + (7 - (y + 2)) * top[0 + 1]  + ((y + 2) + 1) * left[9] + 8) >> 4;
			src[1 + (y + 2) * stride] := ((7 - 1) * left[(y + 2) + 1] + (1 + 1) * top[9] + (7 - (y + 2)) * top[1 + 1]  + ((y + 2) + 1) * left[9] + 8) >> 4;
			src[2 + (y + 2) * stride] := ((7 - 2) * left[(y + 2) + 1] + (2 + 1) * top[9] + (7 - (y + 2)) * top[2 + 1]  + ((y + 2) + 1) * left[9] + 8) >> 4;
			src[3 + (y + 2) * stride] := ((7 - 3) * left[(y + 2) + 1] + (3 + 1) * top[9] + (7 - (y + 2)) * top[3 + 1]  + ((y + 2) + 1) * left[9] + 8) >> 4;
			src[4 + (y + 2) * stride] := ((7 - 4) * left[(y + 2) + 1] + (4 + 1) * top[9] + (7 - (y + 2)) * top[4 + 1]  + ((y + 2) + 1) * left[9] + 8) >> 4;
			src[5 + (y + 2) * stride] := ((7 - 5) * left[(y + 2) + 1] + (5 + 1) * top[9] + (7 - (y + 2)) * top[5 + 1]  + ((y + 2) + 1) * left[9] + 8) >> 4;
			src[6 + (y + 2) * stride] := ((7 - 6) * left[(y + 2) + 1] + (6 + 1) * top[9] + (7 - (y + 2)) * top[6 + 1]  + ((y + 2) + 1) * left[9] + 8) >> 4;
			src[7 + (y + 2) * stride] := ((7 - 7) * left[(y + 2) + 1] + (7 + 1) * top[9] + (7 - (y + 2)) * top[7 + 1]  + ((y + 2) + 1) * left[9] + 8) >> 4;
			
			src[0 + (y + 3) * stride] := ((7 - 0) * left[(y + 3) + 1] + (0 + 1) * top[9] + (7 - (y + 3)) * top[0 + 1]  + ((y + 3) + 1) * left[9] + 8) >> 4;
			src[1 + (y + 3) * stride] := ((7 - 1) * left[(y + 3) + 1] + (1 + 1) * top[9] + (7 - (y + 3)) * top[1 + 1]  + ((y + 3) + 1) * left[9] + 8) >> 4;
			src[2 + (y + 3) * stride] := ((7 - 2) * left[(y + 3) + 1] + (2 + 1) * top[9] + (7 - (y + 3)) * top[2 + 1]  + ((y + 3) + 1) * left[9] + 8) >> 4;
			src[3 + (y + 3) * stride] := ((7 - 3) * left[(y + 3) + 1] + (3 + 1) * top[9] + (7 - (y + 3)) * top[3 + 1]  + ((y + 3) + 1) * left[9] + 8) >> 4;
			src[4 + (y + 3) * stride] := ((7 - 4) * left[(y + 3) + 1] + (4 + 1) * top[9] + (7 - (y + 3)) * top[4 + 1]  + ((y + 3) + 1) * left[9] + 8) >> 4;
			src[5 + (y + 3) * stride] := ((7 - 5) * left[(y + 3) + 1] + (5 + 1) * top[9] + (7 - (y + 3)) * top[5 + 1]  + ((y + 3) + 1) * left[9] + 8) >> 4;
			src[6 + (y + 3) * stride] := ((7 - 6) * left[(y + 3) + 1] + (6 + 1) * top[9] + (7 - (y + 3)) * top[6 + 1]  + ((y + 3) + 1) * left[9] + 8) >> 4;
			src[7 + (y + 3) * stride] := ((7 - 7) * left[(y + 3) + 1] + (7 + 1) * top[9] + (7 - (y + 3)) * top[7 + 1]  + ((y + 3) + 1) * left[9] + 8) >> 4;
			
			y := y + 4;
		end
	end
	
	@optimize_c(condition="OPENHEVC_ENABLE", name="pred_planar_orcc")
	procedure intraPlanarPred2(uint(size=8) src[64 * 64], 
		uint(size=8) top[129] , uint(size=8) left [129], 
		int  stride, int log2Size)
	var
		int x := 0,
		int y := 0
	begin
		while (y < 16)
		do
			while (x < 16) 
			do
				src[x + y * stride] := ((15 - x) * left[y + 1] + (x + 1) * top[17]  + (15 - y) * top[x + 1]  + (y + 1) * left[17] + 16) >> 5;
				src[x + 1 + y * stride] := ((15 - (x + 1)) * left[y + 1] + (x + 1 + 1) * top[17]  + (15 - y) * top[x + 1 + 1]  + (y + 1) * left[17] + 16) >> 5;
				src[x + 2 + y * stride] := ((15 - (x + 2)) * left[y + 1] + (x + 2 + 1) * top[17]  + (15 - y) * top[x + 2 + 1]  + (y + 1) * left[17] + 16) >> 5;
				src[x + 3 + y * stride] := ((15 - (x + 3)) * left[y + 1] + (x + 3 + 1) * top[17]  + (15 - y) * top[x + 3 + 1]  + (y + 1) * left[17] + 16) >> 5;
				x := x + 4;
			end
			x := 0;
			while (x < 16) 
			do
				src[x + (y + 1) * stride] := ((15 - x) * left[(y + 1) + 1] + (x + 1) * top[17]  + (15 - (y + 1)) * top[x + 1]  + ((y + 1) + 1) * left[17] + 16) >> 5;
				src[x + 1 + (y + 1) * stride] := ((15 - (x + 1)) * left[(y + 1) + 1] + (x + 1 + 1) * top[17]  + (15 - (y + 1)) * top[x + 1 + 1]  + ((y + 1) + 1) * left[17] + 16) >> 5;
				src[x + 2 + (y + 1) * stride] := ((15 - (x + 2)) * left[(y + 1) + 1] + (x + 2 + 1) * top[17]  + (15 - (y + 1)) * top[x + 2 + 1]  + ((y + 1) + 1) * left[17] + 16) >> 5;
				src[x + 3 + (y + 1) * stride] := ((15 - (x + 3)) * left[(y + 1) + 1] + (x + 3 + 1) * top[17]  + (15 - (y + 1)) * top[x + 3 + 1]  + ((y + 1) + 1) * left[17] + 16) >> 5;
				x := x + 4;
			end
			x := 0;
			while (x < 16) 
			do
				src[x + (y + 2) * stride] := ((15 - x) * left[(y + 2) + 1] + (x + 1) * top[17]  + (15 - (y + 2)) * top[x + 1]  + ((y + 2) + 1) * left[17] + 16) >> 5;
				src[x + 1 + (y + 2) * stride] := ((15 - (x + 1)) * left[(y + 2) + 1] + (x + 1 + 1) * top[17]  + (15 - (y + 2)) * top[x + 1 + 1]  + ((y + 2) + 1) * left[17] + 16) >> 5;
				src[x + 2 + (y + 2) * stride] := ((15 - (x + 2)) * left[(y + 2) + 1] + (x + 2 + 1) * top[17]  + (15 - (y + 2)) * top[x + 2 + 1]  + ((y + 2) + 1) * left[17] + 16) >> 5;
				src[x + 3 + (y + 2) * stride] := ((15 - (x + 3)) * left[(y + 2) + 1] + (x + 3 + 1) * top[17]  + (15 - (y + 2)) * top[x + 3 + 1]  + ((y + 2) + 1) * left[17] + 16) >> 5;
				x := x + 4;
			end
			x := 0;
			while (x < 16) 
			do
				src[x + (y + 3) * stride] := ((15 - x) * left[(y + 3) + 1] + (x + 1) * top[17]  + (15 - (y + 3)) * top[x + 1]  + ((y + 3) + 1) * left[17] + 16) >> 5;
				src[x + 1 + (y + 3) * stride] := ((15 - (x + 1)) * left[(y + 3) + 1] + (x + 1 + 1) * top[17]  + (15 - (y + 3)) * top[x + 1 + 1]  + ((y + 3) + 1) * left[17] + 16) >> 5;
				src[x + 2 + (y + 3) * stride] := ((15 - (x + 2)) * left[(y + 3) + 1] + (x + 2 + 1) * top[17]  + (15 - (y + 3)) * top[x + 2 + 1]  + ((y + 3) + 1) * left[17] + 16) >> 5;
				src[x + 3 + (y + 3) * stride] := ((15 - (x + 3)) * left[(y + 3) + 1] + (x + 3 + 1) * top[17]  + (15 - (y + 3)) * top[x + 3 + 1]  + ((y + 3) + 1) * left[17] + 16) >> 5;
				x := x + 4;
			end
			x := 0;
			y := y + 4;
		end
	end
	
	@optimize_c(condition="OPENHEVC_ENABLE", name="pred_planar_orcc")
	procedure intraPlanarPred3(uint(size=8) src[64 * 64], 
		uint(size=8) top[129] , uint(size=8) left [129], 
		int  stride, int log2Size)
		var
		int x := 0,
		int y := 0
	begin
		while(y < 32)
		do
			while (x < 32)
			do
				src[x + y * stride] := ((31 - x) * left[y + 1] + (x + 1) * top[33]  + (31 - y) * top[x + 1]  + (y + 1) * left[33] + 32) >> 6;
				src[x + 1 + y * stride] := ((31 - (x + 1)) * left[y + 1] + (x + 1 + 1) * top[33]  + (31 - y) * top[x + 1 + 1]  + (y + 1) * left[33] + 32) >> 6;
				src[x + 2 + y * stride] := ((31 - (x + 2)) * left[y + 1] + (x + 2 + 1) * top[33]  + (31 - y) * top[x + 2 + 1]  + (y + 1) * left[33] + 32) >> 6;
				src[x + 3 + y * stride] := ((31 - (x + 3)) * left[y + 1] + (x + 3 + 1) * top[33]  + (31 - y) * top[x + 3 + 1]  + (y + 1) * left[33] + 32) >> 6;
				x := x + 4;
			end
			x := 0;
			while (x < 32)
			do
				src[x + (y + 1) * stride] := ((31 - x) * left[(y + 1) + 1] + (x + 1) * top[33]  + (31 - (y + 1)) * top[x + 1]  + ((y + 1) + 1) * left[33] + 32) >> 6;
				src[x + 1 + (y + 1) * stride] := ((31 - (x + 1)) * left[(y + 1) + 1] + (x + 1 + 1) * top[33]  + (31 - (y + 1)) * top[x + 1 + 1]  + ((y + 1) + 1) * left[33] + 32) >> 6;
				src[x + 2 + (y + 1) * stride] := ((31 - (x + 2)) * left[(y + 1) + 1] + (x + 2 + 1) * top[33]  + (31 - (y + 1)) * top[x + 2 + 1]  + ((y + 1) + 1) * left[33] + 32) >> 6;
				src[x + 3 + (y + 1) * stride] := ((31 - (x + 3)) * left[(y + 1) + 1] + (x + 3 + 1) * top[33]  + (31 - (y + 1)) * top[x + 3 + 1]  + ((y + 1) + 1) * left[33] + 32) >> 6;
				x := x + 4;
			end
			x := 0;
			while (x < 32)
			do
				src[x + (y + 2) * stride] := ((31 - x) * left[(y + 2) + 1] + (x + 1) * top[33]  + (31 - (y + 2)) * top[x + 1]  + ((y + 2) + 1) * left[33] + 32) >> 6;
				src[x + 1 + (y + 2) * stride] := ((31 - (x + 1)) * left[(y + 2) + 1] + (x + 1 + 1) * top[33]  + (31 - (y + 2)) * top[x + 1 + 1]  + ((y + 2) + 1) * left[33] + 32) >> 6;
				src[x + 2 + (y + 2) * stride] := ((31 - (x + 2)) * left[(y + 2) + 1] + (x + 2 + 1) * top[33]  + (31 - (y + 2)) * top[x + 2 + 1]  + ((y + 2) + 1) * left[33] + 32) >> 6;
				src[x + 3 + (y + 2) * stride] := ((31 - (x + 3)) * left[(y + 2) + 1] + (x + 3 + 1) * top[33]  + (31 - (y + 2)) * top[x + 3 + 1]  + ((y + 2) + 1) * left[33] + 32) >> 6;
				x := x + 4;
			end
			x := 0;
			while (x < 32)
			do
				src[x + (y + 3) * stride] := ((31 - x) * left[(y + 3) + 1] + (x + 1) * top[33]  + (31 - (y + 3)) * top[x + 1]  + ((y + 3) + 1) * left[33] + 32) >> 6;
				src[x + 1 + (y + 3) * stride] := ((31 - (x + 1)) * left[(y + 3) + 1] + (x + 1 + 1) * top[33]  + (31 - (y + 3)) * top[x + 1 + 1]  + ((y + 3) + 1) * left[33] + 32) >> 6;
				src[x + 2 + (y + 3) * stride] := ((31 - (x + 2)) * left[(y + 3) + 1] + (x + 2 + 1) * top[33]  + (31 - (y + 3)) * top[x + 2 + 1]  + ((y + 3) + 1) * left[33] + 32) >> 6;
				src[x + 3 + (y + 3) * stride] := ((31 - (x + 3)) * left[(y + 3) + 1] + (x + 3 + 1) * top[33]  + (31 - (y + 3)) * top[x + 3 + 1]  + ((y + 3) + 1) * left[33] + 32) >> 6;
				x := x + 4;
			end
			x := 0;
			y := y + 4;
		end
		
	end
	
	@optimize_c(condition="OPENHEVC_ENABLE", name="pred_angular_orcc")
	procedure intraAngularPred0(uint(size=8)lumaComp[4096], 
		uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], 
		int stride, int idx, uint(size=8)mode, int log2Size)
	var
		uint(size=6) OFFSET = 33,
		uint(size=6) angle := mode & 63,
		uint(size=8) refMain[128+33],
		int(size=9) iIdx,
		uint(size=5) iFact
	begin
		if(angle=26 || angle = 10) then
			if idx = 0 then
				intraAngularVertOrHor0(angle=26,lumaComp, pNeighb_above, pNeighb_left, stride);
			else
				intraAngularVertOrHor_chroma_0(angle=26,lumaComp, pNeighb_above, pNeighb_left, stride);
			end
		else
			/* Implementation of Intra_Angular(2..9,11..25,27..34) prediction
			 * mode.
			 */
			if(angle>=18) then 
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. 4
				do
					refMain[x+OFFSET] := pNeighb_above[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (4*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_left[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in 4+1 .. 2*4
					do
						refMain[x+OFFSET] := pNeighb_above[x-1+1];
					end
				end
			else  
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. 4
				do
					refMain[x+OFFSET] := pNeighb_left[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (4*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_above[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in 4+1 .. 2*4
					do
						refMain[x+OFFSET] := pNeighb_left[x-1+1];
					end
				end
			end
			if(angle>=18) then
				foreach uint y in 0 .. 4-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. 4-1
					do
						if(iFact!=0) then
							lumaComp[x + y * stride] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[x + y * stride] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			else
				foreach uint y in 0 .. 4-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. 4-1
					do
						if(iFact!=0) then
							lumaComp[y + x * stride] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[y + x * stride] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			end
		end
	end
	
	@optimize_c(condition="OPENHEVC_ENABLE", name="pred_angular_orcc")
	procedure intraAngularPred1(uint(size=8)lumaComp[4096], 
		uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], 
		int stride, int idx, uint(size=8)mode, int log2Size)
	var
		uint(size=6) OFFSET = 33,
		uint(size=6) angle := mode & 63,
		uint(size=8) refMain[128+33],
		int(size=9) iIdx,
		uint(size=5) iFact
	begin
		if(angle=26 || angle = 10) then
			if idx = 0 then
				intraAngularVertOrHor1(angle=26,lumaComp, pNeighb_above, pNeighb_left, stride);
			else
				intraAngularVertOrHor_chroma_1(angle=26,lumaComp, pNeighb_above, pNeighb_left, stride);
			end
		else
			/* Implementation of Intra_Angular(2..9,11..25,27..34) prediction
			 * mode.
			 */
			if(angle>=18) then 
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. 8
				do
					refMain[x+OFFSET] := pNeighb_above[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (8*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_left[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in 8+1 .. 2*8
					do
						refMain[x+OFFSET] := pNeighb_above[x-1+1];
					end
				end
			else  
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. 8
				do
					refMain[x+OFFSET] := pNeighb_left[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (8*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_above[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in 8+1 .. 2*8
					do
						refMain[x+OFFSET] := pNeighb_left[x-1+1];
					end
				end
			end
			if(angle>=18) then
				foreach uint y in 0 .. 8-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. 8-1
					do
						if(iFact!=0) then
							lumaComp[x + y * stride] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[x + y * stride] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			else
				foreach uint y in 0 .. 8-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. 8-1
					do
						if(iFact!=0) then
							lumaComp[y + x * stride] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[y + x * stride] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			end
		end
	end
	
	@optimize_c(condition="OPENHEVC_ENABLE", name="pred_angular_orcc")
	procedure intraAngularPred2(uint(size=8)lumaComp[4096], 
		uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], 
		int stride, int idx, uint(size=8)mode, int log2Size)
	var
		uint(size=6) OFFSET = 33,
		uint(size=6) angle := mode & 63,
		uint(size=8) refMain[128+33],
		int(size=9) iIdx,
		uint(size=5) iFact
	begin
		if(angle=26 || angle = 10) then
			if idx = 0 then
				intraAngularVertOrHor2(angle=26,lumaComp, pNeighb_above, pNeighb_left, stride);
			else
				intraAngularVertOrHor_chroma_2(angle=26,lumaComp, pNeighb_above, pNeighb_left, stride);
			end
		else
			/* Implementation of Intra_Angular(2..9,11..25,27..34) prediction
			 * mode.
			 */
			if(angle>=18) then 
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. 16
				do
					refMain[x+OFFSET] := pNeighb_above[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (16*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_left[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in 16+1 .. 2*16
					do
						refMain[x+OFFSET] := pNeighb_above[x-1+1];
					end
				end
			else  
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. 16
				do
					refMain[x+OFFSET] := pNeighb_left[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (16*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_above[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in 16+1 .. 2*16
					do
						refMain[x+OFFSET] := pNeighb_left[x-1+1];
					end
				end
			end
			if(angle>=18) then
				foreach uint y in 0 .. 16-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. 16-1
					do
						if(iFact!=0) then
							lumaComp[x + y * stride] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[x + y * stride] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			else
				foreach uint y in 0 .. 16-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. 16-1
					do
						if(iFact!=0) then
							lumaComp[y + x * stride] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[y + x * stride] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			end
		end
	end
	
	@optimize_c(condition="OPENHEVC_ENABLE", name="pred_angular_orcc")
	procedure intraAngularPred3(uint(size=8)lumaComp[4096], 
		uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], 
		int stride, int idx, uint(size=8) mode, int log2Size)
	var
		uint(size=6) OFFSET = 33,
		uint(size=6) angle := mode & 63,
		uint(size=8) refMain[128+33],
		int(size=9) iIdx,
		uint(size=5) iFact
	begin
		if(angle=26 || angle = 10) then
			if idx = 0 then
				intraAngularVertOrHor3(angle=26,lumaComp, pNeighb_above, pNeighb_left, stride);
			else
				intraAngularVertOrHor_chroma_3(angle=26,lumaComp, pNeighb_above, pNeighb_left, stride);
			end
		else
			/* Implementation of Intra_Angular(2..9,11..25,27..34) prediction
			 * mode.
			 */
			if(angle>=18) then 
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. 32
				do
					refMain[x+OFFSET] := pNeighb_above[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (32*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_left[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in 32+1 .. 2*32
					do
						refMain[x+OFFSET] := pNeighb_above[x-1+1];
					end
				end
			else  
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. 32
				do
					refMain[x+OFFSET] := pNeighb_left[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (32*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_above[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in 32+1 .. 2*32
					do
						refMain[x+OFFSET] := pNeighb_left[x-1+1];
					end
				end
			end
			if(angle>=18) then
				foreach uint y in 0 .. 32-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. 32-1
					do
						if(iFact!=0) then
							lumaComp[x + y * stride] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[x + y * stride] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			else
				foreach uint y in 0 .. 32-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. 32-1
					do
						if(iFact!=0) then
							lumaComp[y + x * stride] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[y + x * stride] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			end
		end
	end

	/* Implementation of Intra_angular(10,26) prediction mode. */
	procedure intraAngularVertOrHor0(bool isVertical, uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int stride)
	var
		uint(size=1) minVal
	begin
		minVal := if(4>16) then 0 else 1 end;
		if(isVertical) then
			if(minVal!=0) then
				foreach uint y in 0 .. 4-1
				do
					lumaComp[y * stride] := clip_i32(pNeighb_above[0+1]+
						((pNeighb_left[y+1]-pNeighb_above[0])>>1), 0, 255);
				end
			end
			foreach uint x in minVal .. 4-1
			do
				foreach uint y in 0 .. 4-1
				do
					lumaComp[x + y * stride] := pNeighb_above[x+1];
				end
			end
		else
			if(minVal!=0) then
				foreach uint x in 0 .. 4-1
				do
					lumaComp[x] := clip_i32(pNeighb_left[0+1]+
						((pNeighb_above[x+1]-pNeighb_above[0])>>1), 0, 255);
				end
			end
			foreach uint x in 0 .. 4-1
			do
				foreach uint y in minVal .. 4-1
				do
					lumaComp[x + y * stride] := pNeighb_left[y+1];
				end
			end
		end
	end
	
	/* Implementation of Intra_angular(10,26) prediction mode. */
	procedure intraAngularVertOrHor1(bool isVertical, uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int stride)
	var
		uint(size=1) minVal
	begin
		minVal := if(8>16) then 0 else 1 end;
		if(isVertical) then
			if(minVal!=0) then
				foreach uint y in 0 .. 8-1
				do
					lumaComp[y * stride] := clip_i32(pNeighb_above[0+1]+
						((pNeighb_left[y+1]-pNeighb_above[0])>>1), 0, 255);
				end
			end
			foreach uint x in minVal .. 8-1
			do
				foreach uint y in 0 .. 8-1
				do
					lumaComp[x + y * stride] := pNeighb_above[x+1];
				end
			end
		else
			if(minVal!=0) then
				foreach uint x in 0 .. 8-1
				do
					lumaComp[x] := clip_i32(pNeighb_left[0+1]+
						((pNeighb_above[x+1]-pNeighb_above[0])>>1), 0, 255);
				end
			end
			foreach uint x in 0 .. 8-1
			do
				foreach uint y in minVal .. 8-1
				do
					lumaComp[x + y * stride] := pNeighb_left[y+1];
				end
			end
		end
	end
	
	/* Implementation of Intra_angular(10,26) prediction mode. */
	procedure intraAngularVertOrHor2(bool isVertical, uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int stride)
	var
		uint(size=1) minVal
	begin
		minVal := if(16>16) then 0 else 1 end;
		if(isVertical) then
			if(minVal!=0) then
				foreach uint y in 0 .. 16-1
				do
					lumaComp[y * stride] := clip_i32(pNeighb_above[0+1]+
						((pNeighb_left[y+1]-pNeighb_above[0])>>1), 0, 255);
				end
			end
			foreach uint x in minVal .. 16-1
			do
				foreach uint y in 0 .. 16-1
				do
					lumaComp[x + y * stride] := pNeighb_above[x+1];
				end
			end
		else
			if(minVal!=0) then
				foreach uint x in 0 .. 16-1
				do
					lumaComp[x] := clip_i32(pNeighb_left[0+1]+
						((pNeighb_above[x+1]-pNeighb_above[0])>>1), 0, 255);
				end
			end
			foreach uint x in 0 .. 16-1
			do
				foreach uint y in minVal .. 16-1
				do
					lumaComp[x + y * stride] := pNeighb_left[y+1];
				end
			end
		end
	end
	
	/* Implementation of Intra_angular(10,26) prediction mode. */
	procedure intraAngularVertOrHor3(bool isVertical, uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int stride)
	var
		uint(size=1) minVal
	begin
		minVal := if(32>16) then 0 else 1 end;
		if(isVertical) then
			if(minVal!=0) then
				foreach uint y in 0 .. 32-1
				do
					lumaComp[y * stride] := clip_i32(pNeighb_above[0+1]+
						((pNeighb_left[y+1]-pNeighb_above[0])>>1), 0, 255);
				end
			end
			foreach uint x in minVal .. 32-1
			do
				foreach uint y in 0 .. 32-1
				do
					lumaComp[x + y * stride] := pNeighb_above[x+1];
				end
			end
		else
			if(minVal!=0) then
				foreach uint x in 0 .. 32-1
				do
					lumaComp[x] := clip_i32(pNeighb_left[0+1]+
						((pNeighb_above[x+1]-pNeighb_above[0])>>1), 0, 255);
				end
			end
			foreach uint x in 0 .. 32-1
			do
				foreach uint y in minVal .. 32-1
				do
					lumaComp[x + y * stride] := pNeighb_left[y+1];
				end
			end
		end
	end
	
	procedure intraAngularVertOrHor_chroma_0(bool isVertical, uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int stride)
	var
		uint(size=1) neighbIdx = if(isVertical) then 0 else 1 end
	begin
			foreach uint x in 0 .. 4-1
			do
				foreach uint y in 0 .. 4-1
				do
					if(neighbIdx=0) then
						lumaComp[x + stride * y] := pNeighb_above[x+1];
					else
						lumaComp[y + stride * x] := pNeighb_left[x+1];
					end
				end
			end
	end
	
	procedure intraAngularVertOrHor_chroma_1(bool isVertical, uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int stride)
	var
		uint(size=1) neighbIdx = if(isVertical) then 0 else 1 end
	begin
			foreach uint x in 0 .. 8-1
			do
				foreach uint y in 0 .. 8-1
				do
					if(neighbIdx=0) then
						lumaComp[x + stride * y] := pNeighb_above[x+1];
					else
						lumaComp[y + stride * x] := pNeighb_left[x+1];
					end
				end
			end
	end
	
	procedure intraAngularVertOrHor_chroma_2(bool isVertical, uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int stride)
	var
		uint(size=1) neighbIdx = if(isVertical) then 0 else 1 end
	begin
			foreach uint x in 0 .. 16-1
			do
				foreach uint y in 0 .. 16-1
				do
					if(neighbIdx=0) then
						lumaComp[x + stride * y] := pNeighb_above[x+1];
					else
						lumaComp[y + stride * x] := pNeighb_left[x+1];
					end
				end
			end
	end
	
	procedure intraAngularVertOrHor_chroma_3(bool isVertical, uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int stride)
	var
		uint(size=1) neighbIdx = if(isVertical) then 0 else 1 end
	begin
			foreach uint x in 0 .. 32-1
			do
				foreach uint y in 0 .. 32-1
				do
					if(neighbIdx=0) then
						lumaComp[x + stride * y] := pNeighb_above[x+1];
					else
						lumaComp[y + stride * x] := pNeighb_left[x+1];
					end
				end
			end
	end
	
	
//	procedure intraPlanarPred_generic(uint(size=8) src[64 * 64], uint(size=8) top[129] , uint(size=8) left [129], 
//		int  stride, int trafoSize)
//	var
//		int size_ := 1 << trafoSize
//	begin
//		foreach uint y in 0 .. size_-1
//		do
//			foreach uint x in 0 .. size_-1
//			do
//				src[x + y * stride] := ((size_ - 1 - x) * left[y + 1] + (x + 1) * top[size_ + 1] + (size_ - 1 - y) * top[x + 1]  + (y + 1) * left[size_ + 1] + size_) >> (trafoSize + 1);
//			end
//		end
//	end
	
//////////////////////////////////////////////////OldProc//////////////////////////////////////////////////////
//	procedure intraAngularPred_(uint(size=7) nS)
//	var
//		uint(size=6) OFFSET = 33,
//		uint(size=6) angle := predMode & 63,
//		uint(size=8) refMain[128+33],
//		int(size=9) iIdx,
//		uint(size=5) iFact
//	begin
//		if(angle>=18) then 
//			refMain[OFFSET] := pNeighb_above[0];
//			foreach uint x in 1 .. nS
//			do
//				refMain[x+OFFSET] := pNeighb_above[x-1+1];
//			end
//			if(intraPredAngle[angle]<0) then
//				foreach int k in (nS*intraPredAngle[angle])>>5 .. -1
//				do
//					refMain[k+OFFSET] :=
//						pNeighb_left[((k*invAngle[angle]+128)>>8)-1+1];
//				end
//			else
//				foreach uint x in nS+1 .. 2*nS
//				do
//					refMain[x+OFFSET] := pNeighb_above[x-1+1];
//				end
//			end
//		else  
//			refMain[OFFSET] := pNeighb_above[0];
//			foreach uint x in 1 .. nS
//			do
//				refMain[x+OFFSET] := pNeighb_left[x-1+1];
//			end
//			if(intraPredAngle[angle]<0) then
//				foreach int k in (nS*intraPredAngle[angle])>>5 .. -1
//				do
//					refMain[k+OFFSET] :=
//						pNeighb_above[((k*invAngle[angle]+128)>>8)-1+1];
//				end
//			else
//				foreach uint x in nS+1 .. 2*nS
//				do
//					refMain[x+OFFSET] := pNeighb_left[x-1+1];
//				end
//			end
//		end
//		if(angle>=18) then
//			foreach uint y in 0 .. nS-1
//			do
//				iIdx  := ((y+1)*intraPredAngle[angle])>>5;
//				iFact := ((y+1)*intraPredAngle[angle])&31;
//				foreach uint x in 0 .. nS-1
//				do
//					if(iFact!=0) then
//						lumaComp[x + y * 64] :=
//							((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
//							iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
//					else
//						lumaComp[x + y * 64] := refMain[x+iIdx+1 +OFFSET];
//					end
//				end
//			end
//		else
//			foreach uint y in 0 .. nS-1
//			do
//				iIdx  := ((y+1)*intraPredAngle[angle])>>5;
//				iFact := ((y+1)*intraPredAngle[angle])&31;
//				foreach uint x in 0 .. nS-1
//				do
//					if(iFact!=0) then
//						lumaComp[y + x * 64] :=
//							((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
//							iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
//					else
//						lumaComp[y + x * 64] := refMain[x+iIdx+1 +OFFSET];
//					end
//				end
//			end
//		end
//	end
//	


//////////////////////////////////////////////////NewProc//////////////////////////////////////////////////////
//if(predMode>=18) then 
//			refMain[OFFSET] := pNeighb_above[0];
//			if angle < 0 and last < -1 then
//				foreach int x in 1 .. size_
//				do
//					refMain[x+OFFSET] := pNeighb_above[x-1+1];
//				end
//				foreach int m in 0 .. last + 1 do
//					x_ := last; 
//            		refMain[x_+OFFSET] := pNeighb_left[-1 + ((x_ * invAngle[predMode - 11] + 128) >> 8)];
//            		x_ := x_ - 1;
//            	end
//			end
//			foreach uint y in 0 .. size_-1
//			do
//				iIdx  := ((y+1)*angle)>>5;
//				iFact := ((y+1)*angle)&31;
//				if(iFact!=0) then
//					foreach uint x in 0 .. size_-1
//					do
//						lumaComp[x + y * 64] := ((32-iFact)*refMain[x+iIdx+1 +OFFSET] + iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
//					end
//				else 
//					foreach uint x in 0 .. size_-1 
//					do
//						lumaComp[x + y * 64] := refMain[x+iIdx+1 +OFFSET];
//					end
//				end
//			end
//			if (predMode = 26 ) then
//				foreach uint y in 0 .. size_-1
//				do
//					lumaComp[y * 64] := clip_i32(pNeighb_above[0+1] + ((pNeighb_left[y+1]-pNeighb_left[0])>>1), 0, 255);
//				end
//			end
//		else  
//			refMain[OFFSET] := pNeighb_above[0];
//			if angle < 0 and last < -1 then
//				foreach int x in 1 .. size_
//				do
//					refMain[x+OFFSET] := pNeighb_above[x-1+1];
//				end
//				foreach int m in 0 .. last + 1 do
//					x_ := last; 
//            		refMain[x_+OFFSET] := pNeighb_above[-1 + ((x_ * invAngle[predMode - 11] + 128) >> 8)];
//            		x_ := x_ - 1;
//            	end
//			end
//			foreach uint x in 0 .. size_ - 1
//			do
//				iIdx  := ((x+1)*angle)>>5;
//				iFact := ((x+1)*angle)&31;
//				
//					if(iFact!=0) then
//						foreach uint y in 0 .. size_-1
//						do
//						lumaComp[x + y * 64] :=
//							((32-iFact)*refMain[y+iIdx+1 +OFFSET] +
//							iFact*refMain[y+iIdx+2 +OFFSET]+16) >> 5;
//						end
//					else
//						foreach uint y in 0 .. size_-1
//						do
//							lumaComp[x + y * 64] := refMain[y+iIdx+1 +OFFSET];
//						end
//					end
//				end
//			end
//			if (predMode = 10 ) then
//				foreach uint x in 0 .. size_-1
//				do
//					lumaComp[x] := clip_i32(pNeighb_left[0+1] + ((pNeighb_above[x+1]-pNeighb_above[0])>>1), 0, 255);
//				end
//			end	
//		end		
	

end