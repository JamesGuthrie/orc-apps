/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * This actor is a picture buffer containing all reference pictures. It sends
 *		samples needed for the inter prediction
 * 
 * 
 * @input IsBiPred : Indicates when the current CU is using Bi-prediction.
 * 
 * @input IsReadOrNewSlc : Indicates if samples are asked from the current RPS
 *		or if there is a new picture.
 * 
 * @input Mv : movement vectors of the current CU.
 * 
 * @input PicSize : size of the current picture.
 * 
 * @input Poc : Picture Order Count of the current slice.
 * 
 * @output PocRef : POC used for the prediction of the current CU.
 * 
 * @input PredCuSize : Size of the largest side of the current CU.
 * 
 * @input Sample : Samples from the Inloop filter. It represents the pixels
 * 		which will be displayed.
 * 
 * 
 * @output Sample : Samples needed for the inter prediction.
 * 
 * 
 * @author Damien de Saint Jorre (EPFL) <damien.desaintjorre@epfl.ch>
 */
package devel.org.sc29.wg11.mpegh.part2.main.inter;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

actor DecodingPictureBuffer ()
	uint(size=2)  IsBiPredOrLx,
	uint(size=1)  IsReadOrNewSlc,
	int (size=32) Mv,
	bool          NewMvOrLCU,
	uint(size=16) PicSize,
	uint(size=16) Poc,
	int (size=16) PocRef,
	uint(size=7)  PredCuSize,
	int (size=16) RpsPoc,
	uint(size=8)  Sample
		==>
	uint(size=8)  RefSample
		:


	/* /!\ : Check the size of the border. */
	uint(size = 16) BORDER_SIZE = 128;
	uint(size = 8) DPB_SIZE = 17;

	uint(size=8)  pictureBuffer[DPB_SIZE][3][PICT_WIDTH+2*BORDER_SIZE][PICT_HEIGHT+2*BORDER_SIZE];
	int (size=16) pocRef[DPB_SIZE];
	bool          isRef[DPB_SIZE];
	bool          isStillRef[DPB_SIZE];

	uint(size=16) picSize[2];
	uint(size=16) lcuBufferSz;
	uint(size=16) numLcuPerPict;
	uint(size=16) idxLcu;
	uint(size=16) numLcuRemain := 0;

	uint(size=7)  puSize[2];
	uint(size=7)  puSizeChr[2];

	int (size=4)  refPicIdx;
	int (size=4)  currIdx := -1;
	int (size=4)  inputPicIdx := -1;

	uint(size=16) xIdx;
	uint(size=16) yIdx;
	uint(size=7)  lineIdx := 0;
	uint(size=2)  cIdx    := 1;

	bool          isBiPred;
	int (size=32) lastMvRef[2];
	int (size=16) lastPocRef;
	int (size=32) xMvOffset;
	int (size=32) yMvOffset;
	int (size=32) xMvOffChr;
	int (size=32) yMvOffChr;
	uint(size=7)  iLoop;
	uint(size=7)  jLoop;
	uint(size=2)  compIdx;

	uint(size=1)  numPocRef;
	uint(size=3)  nbList;
	uint(size=3)  sizeOfList;


	/** Getting informations from new slice/picture. Updating these informations **/
	isNewSlice: action IsReadOrNewSlc:[isRead], PicSize:[picWidthInPix,
		picHeightInPix], Poc:[poc] ==>
	guard
		/* Fix me : We should know when there is a new picture */
		currIdx != -1 and poc = pocRef[currIdx]
	do
		nbList := 0;
		isStillRef := [false: for int i in 0 .. DPB_SIZE - 1];
	end

	isNewPict: action IsReadOrNewSlc:[isRead], PicSize:[picWidthInPix,
		picHeightInPix], Poc:[poc], NewMvOrLCU:[isMv] ==>
	guard
		not(currIdx != -1 and poc = pocRef[currIdx])
	do
		picSize[0] := picWidthInPix;
		picSize[1] := picHeightInPix;
		xIdx := 0;
		yIdx := 0;
		foreach uint i in 0 .. DPB_SIZE - 1
		do
			if(not isRef[i]) then
				currIdx := i;
			end
		end
		inputPicIdx := currIdx;
		isRef[currIdx]  := true;
		pocRef[currIdx] := poc;
		nbList          := 0;
		isStillRef := [false: for int i in 0 .. DPB_SIZE - 1];
		numLcuPerPict := ((picWidthInPix+63)/64) * ((picHeightInPix+63)/64);
		lcuBufferSz := numLcuPerPict;
		idxLcu := 0;
	end


	resetReadInPict.launch: action NewMvOrLCU:[newMv] ==>
	end

	checkNewMv.isMv: action NewMvOrLCU:[newMv] ==>
	guard
		newMv
	end

	checkNewMv.isLcu.launch: action NewMvOrLCU:[newMv] ==>
	guard
		not newMv
	do
		numLcuRemain := numLcuRemain + 1;
	end

	checkNewMv.isLcu.skip: action NewMvOrLCU:[newMv] ==>
	guard
		not newMv && numLcuRemain < lcuBufferSz - 1
	do
		numLcuRemain := numLcuRemain + 1;
	end

	/* We get the whole Cu decoded (luma and chroma components) and we save
	 * it in the Dpb (pictureBuffer).
	 */

	getCuPix.launch.firstLuma: action Sample:[samp] repeat 64 ==>
	guard
		yIdx < picSize[1]
	var
		uint(size=16) xPixIdx,
		uint(size=16) yPixIdx
	do
		xPixIdx := BORDER_SIZE + xIdx;
		yPixIdx := BORDER_SIZE + yIdx;
		foreach uint x in 0 .. 63
		do
			pictureBuffer[inputPicIdx][0][xPixIdx+x][yPixIdx] := samp[x];
		end
		lineIdx := 1;
	end

	getCuPix.launch.otherLuma: action Sample:[samp] repeat 64 ==>
	guard
		lineIdx < 64
	var
		uint(size=16) xPixIdx,
		uint(size=16) yPixIdx
	do
		xPixIdx := BORDER_SIZE + xIdx;
		yPixIdx := BORDER_SIZE + yIdx;
		foreach uint x in 0 .. 63
		do
			pictureBuffer[inputPicIdx][0][xPixIdx+x][yPixIdx+lineIdx] := samp[x];
		end
		lineIdx := lineIdx + 1;
	end

	getCuPix.launch.lumaDone: action ==>
	guard
		lineIdx = 64
	do
		lineIdx := 0;
	end

	getCuPix.launch.chroma: action Sample:[samp] repeat 32 ==>
	guard
		cIdx < 3
	var
		uint(size=16) xPixIdx,
		uint(size=16) yPixIdx
	do
		xPixIdx := (BORDER_SIZE + xIdx)>>1;
		yPixIdx := (BORDER_SIZE + yIdx)>>1;
		foreach uint x in 0 .. 31
		do
			pictureBuffer[inputPicIdx][cIdx][xPixIdx+x][yPixIdx+lineIdx] :=
				samp[x];
		end
		lineIdx := lineIdx + 1;
		if(lineIdx = 32) then
			lineIdx := 0;
			cIdx    := cIdx + 1;
		end
	end


	getCuPix.launch.chrDone: action ==>
	guard
		cIdx = 3
	do
		cIdx := 1;

		xIdx := xIdx + 64;
		if(xIdx >= picSize[0]) then
			xIdx := 0;
			yIdx := yIdx + 64;
		end
		idxLcu := idxLcu + 1;
		numLcuRemain := numLcuRemain - 1;
	end

	getCuPix.lastLineRemaining: action ==>
	guard
		numLcuRemain = lcuBufferSz && idxLcu >= numLcuPerPict - lcuBufferSz
	end

	getReadAddr.isMonoPred: action IsReadOrNewSlc:[isRead], IsBiPredOrLx:[isBiPredOrLx] ==>
	guard
		isBiPredOrLx != BI_PRED
	do
		isBiPred := false;
		numPocRef := 1;
	end

	getReadAddr.isBiPred: action IsReadOrNewSlc:[isRead], IsBiPredOrLx:[isBiPredOrLx], NewMvOrLCU:[newMv] ==>
	guard
		isBiPredOrLx = BI_PRED
	do
		isBiPred := true;
		numPocRef := 2;
	end

	/** We get all the references from the 5 lists of the Rps
	 * (StCurrentBefore, StCurrentAfter, StFollowing, LtCurrent, LtFollowing)
	 **/
	getRps.launch: action RpsPoc:[numPic]==>
	guard
		nbList < 5
	do
		sizeOfList := numPic;
	end

	getRps.done: action ==>
	guard
		nbList = 5
	do
		/* We remove from the Dpb all the pictures who are not in the Rps of
		 * the current picture
		 */
		foreach int i in 0 .. DPB_SIZE - 1
		do
			isRef[i] := isRef[i] and isStillRef[i];
		end
		isRef[currIdx] := true;
	end

	/** For each we check the index of the reference poc
	 * (in order to not remove them from the Dpb).
	 **/
	getRpsPoc.launch: action RpsPoc:[pocVal] ==>
	guard
		sizeOfList > 0
	do
		sizeOfList := sizeOfList - 1;
		foreach int i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = pocVal)then
				isStillRef[i] := true;
			end
		end
	end

	getRpsPoc.done: action ==>
	guard
		sizeOfList = 0
	do
		nbList := nbList + 1;
	end

	/* When we get the picture we add the border (in order to be able to give a
	 * reference pixels which can be outside of the picture).
	 */
	getCuPix.done: action ==>
	guard
		numLcuRemain = 0
	var
		uint xSize := picSize[0],
		uint ySize := picSize[1]
	do
		/* Fill in luma border */
		foreach uint x in BORDER_SIZE .. xSize + BORDER_SIZE - 1
		do
			foreach uint y in 0 .. BORDER_SIZE - 1
			do
				pictureBuffer[inputPicIdx][0][x][y] :=
					pictureBuffer[inputPicIdx][0][x][BORDER_SIZE];
				pictureBuffer[inputPicIdx][0][x][y+ySize+BORDER_SIZE] :=
					pictureBuffer[inputPicIdx][0][x][ySize+BORDER_SIZE-1];
			end
		end
		foreach uint y in 0 .. ySize + 2*BORDER_SIZE - 1
		do
			foreach uint x in 0 .. BORDER_SIZE - 1
			do
				pictureBuffer[inputPicIdx][0][x][y] :=
					pictureBuffer[inputPicIdx][0][BORDER_SIZE][y];
				pictureBuffer[inputPicIdx][0][x+xSize+BORDER_SIZE][y] :=
					pictureBuffer[inputPicIdx][0][xSize+BORDER_SIZE-1][y];
			end
		end

		/* Fill in chroma border */
		foreach uint comp in 1 .. 2
		do
			foreach uint x in BORDER_SIZE/2 .. xSize/2-1 + BORDER_SIZE/2
			do
				foreach uint y in 0 .. BORDER_SIZE/2 - 1
				do
					pictureBuffer[inputPicIdx][comp][x][y] :=
						pictureBuffer[inputPicIdx][comp][x][BORDER_SIZE/2];
					pictureBuffer[inputPicIdx][comp][x][y+ySize/2+BORDER_SIZE/2] :=
						pictureBuffer[inputPicIdx][comp][x][ySize/2+BORDER_SIZE/2-1];
				end
			end
			foreach uint y in 0 .. ySize/2 + BORDER_SIZE - 1
			do
				foreach uint x in 0 .. BORDER_SIZE/2 - 1
				do
					pictureBuffer[inputPicIdx][comp][x][y] :=
						pictureBuffer[inputPicIdx][comp][BORDER_SIZE/2][y];
					pictureBuffer[inputPicIdx][comp][x+xSize/2+BORDER_SIZE/2][y] :=
						pictureBuffer[inputPicIdx][comp][xSize/2+BORDER_SIZE/2-1][y];
				end
			end
		end
	end

	getReadAddr: action IsReadOrNewSlc:[isRead], IsBiPredOrLx:[isBiPredOrLx] ==>
	guard
		isRead = 1
	do
		numPocRef :=
			if(isBiPredOrLx = BI_PRED) then
				2
			else
				1
			end;
	end

	/* We get all the informations needed for sending the reference Cu. We save
	 * these samples in RefCu, it will be sent with the actions sendCu.isYxY
	 */
	getMvInfo.launch: action PocRef:[poc], PredCuSize:[predUnitSize] repeat 2,
		Mv:[mvX, mvY] ==>
	guard
		numPocRef != 0,
		not(isBiPred && numPocRef = 1 && lastPocRef = poc && lastMvRef[0] = mvX && lastMvRef[1] = mvY)
	var
		int(size=7)  sideMax,
		uint(size=7)  sideMaxChr
	do
		lastPocRef := poc;
		lastMvRef  := [mvX, mvY];
		sideMax := max(predUnitSize[0], predUnitSize[1]);
		puSize := [predUnitSize[i] + 7: for int i in 0 .. 1];
		puSizeChr := [predUnitSize[i]/2 + 3: for int i in 0 .. 1];
		sideMaxChr := sideMax >> 1;
		refPicIdx := 0;
		foreach uint i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = poc and isRef[i]) then
				refPicIdx := i;
			end
		end
		/* The mv components correspond to the absolute movement vector, that's
		 * why we don't need to add the address of the current Cu
		 */

		/* We remove 3 for each coordinate component, because for the luma
		 * prediction we need the 3 previous pixels
		 */
		xMvOffset := (mvX >> 2);
		xMvOffset := min(xMvOffset, picSize[0]+3);
		xMvOffset := max(xMvOffset, -(8 +3 -1) -(sideMax-1));
		xMvOffset := xMvOffset +BORDER_SIZE-3;
		yMvOffset := (mvY >> 2);
		yMvOffset := min(yMvOffset, picSize[1]+3);
		yMvOffset := max(yMvOffset, -(8 +3 -1) -(sideMax-1));
		yMvOffset := yMvOffset +BORDER_SIZE-3;

		/* We remove 1 for each coordinate component, because for the chroma
		 * prediction we need the previous pixel
		 */
		xMvOffChr := (mvX >> 3);
		xMvOffChr := min(xMvOffChr, picSize[0]/2+1);
		xMvOffChr := max(xMvOffChr, -(4 +1 -1) -(sideMaxChr-1));
		xMvOffChr := xMvOffChr +BORDER_SIZE/2-1;
		yMvOffChr := (mvY >> 3);
		yMvOffChr := min(yMvOffChr, picSize[1]/2+1);
		yMvOffChr := max(yMvOffChr, -(4 +1 -1) -(sideMaxChr-1));
		yMvOffChr := yMvOffChr +BORDER_SIZE/2-1;

		numPocRef := numPocRef - 1;
		iLoop := 0;
		jLoop := 0;
	end


	getMvInfo.skip: action PocRef:[poc], PredCuSize:[predUnitSize] repeat 2,
		Mv:[mvX, mvY] ==>
	guard
		isBiPred && numPocRef = 1 && lastPocRef = poc && lastMvRef[0] = mvX && lastMvRef[1] = mvY
	end

	/** We send the reference samples according to the size of the predCu. **/
	sendCu.luma.launch: action ==> RefSample:[sample]
	guard
		jLoop < puSize[1]
	var
		uint(size=8) sample
	do
		sample := pictureBuffer[refPicIdx][0][iLoop+xMvOffset][jLoop+yMvOffset];

		iLoop := iLoop + 1;
		if(iLoop = puSize[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
		end
	end

	sendCu.luma.done: action ==>
	guard
		jLoop = puSize[1]
	do
		iLoop   := 0;
		jLoop   := 0;
		compIdx := 1;
	end

	sendCu.chroma.launch: action ==> RefSample:[sample]
	guard
		compIdx < 3
	var
		uint(size=8) sample
	do
		sample := pictureBuffer[refPicIdx][compIdx][iLoop+xMvOffChr][jLoop+yMvOffChr];

		iLoop := iLoop + 1;
		if(iLoop = puSizeChr[0]) then
			iLoop := 0;
			jLoop := jLoop + 1;
			if(jLoop = puSizeChr[1]) then
				jLoop   := 0;
				compIdx := compIdx + 1;
			end
		end
	end

	sendCu.chroma.done: action ==>
	guard
		compIdx = 3
	end

	getMvInfo.done: action ==>
	guard
		numPocRef = 0
	end

	schedule fsm IsFirstNewPic:
		IsFirstNewPic (isNewPict )--> RstReadInPict;

		RstReadInPict (resetReadInPict )--> GetFirstRps;

		GetFirstRps (getRps.launch )--> GetRpsFirstPoc;
		GetFirstRps (getRps.done   )--> IsNewMvOrLCU;

		GetRpsFirstPoc (getRpsPoc.launch )--> GetRpsFirstPoc;
		GetRpsFirstPoc (getRpsPoc.done   )--> GetFirstRps;

		IsNewSlice (isNewPict  )--> GetRps;
		IsNewSlice (isNewSlice )--> GetRps2;

		IsNewMvOrLCU (checkNewMv.isMv         )--> GetReadAddr;
		IsNewMvOrLCU (checkNewMv.isLcu.skip   )--> IsNewMvOrLCU;
		IsNewMvOrLCU (checkNewMv.isLcu.launch )--> ReadLcu;

		GetReadAddr (getReadAddr )--> GetMvInfo;

		ReadLcu (getCuPix.launch.firstLuma  )--> GetCuPixLuma;
		ReadLcu (getCuPix.lastLineRemaining )--> ReadLineLcu;

		ReadLineLcu (getCuPix.launch.firstLuma )--> GetCuPixLuma2;
		ReadLineLcu (getCuPix.done             )--> IsNewSlice;

		/* Get the rps info. */
		GetRps (getRps.launch )--> GetRpsPoc;
		GetRps (getRps.done   )--> IsNewMvOrLCU;

		GetRpsPoc (getRpsPoc.launch )--> GetRpsPoc;
		GetRpsPoc (getRpsPoc.done   )--> GetRps;

		/* Get the rps info. */
		GetRps2 (getRps.launch )--> GetRpsPoc2;
		GetRps2 (getRps.done   )--> IsNewSlice;

		GetRpsPoc2 (getRpsPoc.launch )--> GetRpsPoc2;
		GetRpsPoc2 (getRpsPoc.done   )--> GetRps2;

		/* Getting the decoded picture */
		GetCuPixLuma    (getCuPix.launch.otherLuma )--> GetCuPixLuma;
		GetCuPixLuma    (getCuPix.launch.lumaDone  )--> GetCuPixChroma;
		GetCuPixChroma  (getCuPix.launch.chroma    )--> GetCuPixChroma;
		GetCuPixChroma  (getCuPix.launch.chrDone   )--> IsNewMvOrLCU;

		/* Getting the decoded picture */
		GetCuPixLuma2    (getCuPix.launch.otherLuma )--> GetCuPixLuma2;
		GetCuPixLuma2    (getCuPix.launch.lumaDone  )--> GetCuPixChroma2;
		GetCuPixChroma2  (getCuPix.launch.chroma    )--> GetCuPixChroma2;
		GetCuPixChroma2  (getCuPix.launch.chrDone   )--> ReadLineLcu;

		/* Send pixels needed for inter-prediction */
		GetMvInfo (getMvInfo.launch )--> SendCuLuma;
		GetMvInfo (getMvInfo.skip   )--> IsNewMvOrLCU;
		GetMvInfo (getMvInfo.done   )--> IsNewMvOrLCU;

		SendCuLuma (sendCu.luma.launch   )--> SendCuLuma;
		SendCuLuma (sendCu.luma.done     )--> SendCuChroma;

		SendCuChroma (sendCu.chroma.launch )--> SendCuChroma;
		SendCuChroma (sendCu.chroma.done   )--> GetMvInfo;
	end
	priority
		checkNewMv.isLcu.skip > checkNewMv.isLcu.launch;
		getCuPix.lastLineRemaining > getCuPix.launch.firstLuma;
	end
end
