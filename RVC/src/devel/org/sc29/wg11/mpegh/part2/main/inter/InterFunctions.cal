package devel.org.sc29.wg11.mpegh.part2.main.inter;

unit InterFunctions : 
	
	int shift1 = 6;
	int(size=8) ff_hevc_epel_filters[7][4] = 
  [ [-2, 58, 10, -2],
	[-4, 54, 16, -2],
	[-6, 46, 28, -4],
	[-4, 36, 36, -4],
	[-4, 28, 46, -6],
	[-2, 16, 54, -4],
	[-2, 10, 58, -2]];
	
	function QPEL_FILTER_1_H(uint(size=16) src [ 3 ] [ 64 + 7 ] [ 64 + 7 ],
		uint(size=7) x, uint(size=7) y) --> int(size=16) :
		(-src[0][x - 3][y] + 4 * src[0][x - 2][y] - 10 * src[0][x - 1][y] + 58 *
		src[0][x][y] + 17 * src[0][x + 1][y] - 5 * src[0][x + 2][y] + 1 * src[0][x +
		3][y])
	end

	function QPEL_FILTER_2_H(uint(size=16) src [ 3 ] [ 64 + 7 ] [ 64 + 7 ],
		uint(size=7) x, uint(size=7) y) --> int(size=16) :
		(-src[0][x - 3][y] + 4 * src[0][x - 2][y] - 11 * src[0][x - 1][y] + 40 *
		src[0][x][y] + 40 * src[0][x + 1][y] - 11 * src[0][x + 2][y] + 4 * src[0][x
		+ 3][y] - src[0][x + 4][y])
	end

	function QPEL_FILTER_3_H(uint(size=16) src [ 3 ] [ 64 + 7 ] [ 64 + 7 ],
		uint(size=7) x, uint(size=7) y) --> int(size=16) :
		(src[0][x - 2][y] - 5 * src[0][x - 1][y] + 17 * src[0][x][y] + 58 * src[0][x
		+ 1][y] - 10 * src[0][x + 2][y] + 4 * src[0][x + 3][y] - src[0][x + 4][y])
	end
	
	function QPEL_FILTER_1_V(int(size=16) src [ 3 ] [ 64 + 7 ] [ 64 + 7 ],
		uint(size=7) x, uint(size=7) y) --> int :
		(-src[0][x][y - 3] + 4 * src[0][x][y - 2] - 10 * src[0][x][y - 1] + 58 *
		src[0][x][y] + 17 * src[0][x][y + 1] - 5 * src[0][x][y + 2] + 1 * src[0][x][y + 3])
	end

	function QPEL_FILTER_2_V(int(size=16) src [ 3 ] [ 64 + 7 ] [ 64 + 7 ],
		uint(size=7) x, uint(size=7) y) --> int :
		(-src[0][x][y - 3] + 4 * src[0][x][y - 2] - 11 * src[0][x][y - 1] + 40 *
		src[0][x][y] + 40 * src[0][x][y + 1] - 11 * src[0][x][y + 2] + 4 * src[0][x][y + 3] - src[0][x][y + 4])
	end

	function QPEL_FILTER_3_V(int(size=16) src [ 3 ] [ 64 + 7 ] [ 64 + 7 ],
		uint(size=7) x, uint(size=7) y) --> int :
		(src[0][x][y - 2] - 5 * src[0][x][y - 1] + 17 * src[0][x][y] + 58 * src[0][x
		][y + 1] - 10 * src[0][x][y + 2] + 4 * src[0][x][y + 3] - src[0][x][y + 4])
	end
	
	function EPEL_FILTER_H(uint(size=16) src [ 3 ] [ 64 + 7 ] [ 64 + 7 ],
		uint(size=7) x, uint(size=7) y, int(size=8) filter_0,
		int(size=8) filter_1, int(size=8) filter_2, int(size=8) filter_3, int component) --> int(size=16) 
		:
		(filter_0*src[component][x - 1][y] + filter_1*src[component][x][y] + filter_2*src[component][x + 1][y] + filter_3*src[component][x + 2][y])
	end
	
	function EPEL_FILTER_V(int(size=16) src [ 3 ] [ 64 + 7 ] [ 64 + 7 ],
		int(size=16) x, int(size=16) y, int(size=8) filter_0,
		int(size=8) filter_1, int(size=8) filter_2, int(size=8) filter_3, int component) --> int 
		:
		(filter_0*src[component][x][y - 1] + filter_1*src[component][x][y] + filter_2*src[component][x][y + 1] + filter_3*src[component][x][y + 2])
	end
	
	procedure put_hevc_qpel_pixel(int(size=16) predSamples [ 3 ] [ 64 ] [ 64 ] [ 2 ], uint(size=2) listIdx,
		uint(size=16) refSamples [ 3 ] [ 64 + 7 ] [ 64 + 7 ], uint(size=7) width, uint(size=7) height )
	begin
		foreach int y in 0 .. height do
			foreach int x in 0 .. width do
				predSamples[0][x][y][listIdx] := refSamples[0][x+3][y+3] << shift1;
			end
		end
	end
	
	procedure put_hevc_qpel_h(int(size=16) predSamples [ 3 ] [ 64 ] [ 64 ] [ 2 ], uint(size=2) listIdx,
		uint(size=16) refSamples [ 3 ] [ 64 + 7 ] [ 64 + 7 ], int filterIdx, uint(size=7)
		width, uint(size=7) height)
	begin
		foreach int y in 0 .. height do
			foreach int x in 0 .. width do
				if filterIdx = 1 then
					predSamples[0][x][y][listIdx] := QPEL_FILTER_1_H(refSamples, x+3, y+3);
				elsif filterIdx = 2 then 
					predSamples[0][x][y][listIdx] := QPEL_FILTER_2_H(refSamples, x+3, y+3);
				elsif filterIdx = 3 then 
					predSamples[0][x][y][listIdx] := QPEL_FILTER_3_H(refSamples, x+3, y+3);
				end
			end
		end
	end

	procedure put_hevc_qpel_v(int(size=16) predSamples [ 3 ] [ 64 ] [ 64 ] [ 2 ], uint(size=2) listIdx,
		uint(size=16) refSamples [ 3 ] [ 64 + 7 ] [ 64 + 7 ], int filterIdx, uint(size=7)
		width, uint(size=7) height)
	begin
		foreach int y in 0 .. height do
			foreach int x in 0 .. width do
				if filterIdx = 1 then
					predSamples[0][x][y][listIdx] := QPEL_FILTER_1_V(refSamples, x+3, y+3);
				elsif filterIdx = 2 then 
					predSamples[0][x][y][listIdx] := QPEL_FILTER_2_V(refSamples, x+3, y+3);
				elsif filterIdx = 3 then 
					predSamples[0][x][y][listIdx] := QPEL_FILTER_3_V(refSamples, x+3, y+3);
				end
			end
		end
	end
	
	procedure put_hevc_qpel_hv(int(size=16) predSamples [ 3 ] [ 64 ] [ 64 ] [ 2 ], uint(size=2) listIdx,
		uint(size=16) refSamples /*intermSamples*/ [ 3 ] [ 64 + 7 ] [ 64 + 7 ], int filterIdx[2], uint(size=7)
		width, uint(size=7) height)
	var
		int(size=16) intermSamples[3][ 64 + 7] [ 64 + 7]
	begin
		foreach int y in 0 .. height+7 do
			foreach int x in 0 .. width do
				if filterIdx[0] = 1 then
					intermSamples[0][x][y] := QPEL_FILTER_1_H(refSamples, x+3, y) - 8192;
				elsif filterIdx[0] = 2 then 
					intermSamples[0][x][y] := QPEL_FILTER_2_H(refSamples, x+3, y) - 8192;
				elsif filterIdx[0] = 3 then 
					intermSamples[0][x][y] := QPEL_FILTER_3_H(refSamples, x+3, y) - 8192;
				end
			end
		end
		foreach int y in 0 .. height do
			foreach int x in 0 .. width do
				if filterIdx[1] = 1 then
					predSamples[0][x][y][listIdx] := (QPEL_FILTER_1_V(intermSamples, x, y+3) + 524288)>>6;
				elsif filterIdx[1] = 2 then 
					predSamples[0][x][y][listIdx] := (QPEL_FILTER_2_V(intermSamples, x, y+3) + 524288)>>6;
				elsif filterIdx[1] = 3 then 
					predSamples[0][x][y][listIdx] := (QPEL_FILTER_3_V(intermSamples, x, y+3) + 524288)>>6;
				end
			end
		end
	end
 

	procedure put_hevc_epel_pixel (int(size=16) predSamples [ 3 ] [ 64 ] [ 64 ] [ 2 ], uint(size=2) listIdx,
								uint(size=16) refSamples [ 3 ] [ 64 + 7 ] [ 64 + 7 ],
								uint(size=7) width, uint(size=7) height, int component)
	begin
	    foreach int y in 0 .. height do
			foreach int x in 0 .. width do
	            predSamples[component][x][y][listIdx] := refSamples[component][x+1][y+1] << shift1;
	        end
	    end
	end
	
	procedure put_hevc_epel_h (int(size=16) predSamples [ 3 ] [ 64 ] [ 64 ] [ 2 ], uint(size=2) listIdx,
								uint(size=16) refSamples [ 3 ] [ 64 + 7 ] [ 64 + 7 ],
								int filterIdx, uint(size=7) width, uint(size=7) height, int component)
	var
		int(size=8) filter_0 := ff_hevc_epel_filters[filterIdx - 1][0],
	    int(size=8) filter_1 := ff_hevc_epel_filters[filterIdx - 1][1],
	    int(size=8) filter_2 := ff_hevc_epel_filters[filterIdx - 1][2],
	    int(size=8) filter_3 := ff_hevc_epel_filters[filterIdx - 1][3]
	begin
	    foreach int y in 0 .. height do
			foreach int x in 0 .. width do
	            predSamples[component][x][y][listIdx] := EPEL_FILTER_H(refSamples, x+1, y+1, filter_0, filter_1, filter_2, filter_3, component);
	        end
	    end
	end
	
	procedure put_hevc_epel_v (int(size=16) predSamples [ 3 ] [ 64 ] [ 64 ] [ 2 ], uint(size=2) listIdx,
								uint(size=16) refSamples [ 3 ] [ 64 + 7 ] [ 64 + 7 ],
								int filterIdx, uint(size=7) width, uint(size=7) height, int component)
	var
		int(size=8) filter_0 := ff_hevc_epel_filters[filterIdx - 1][0],
	    int(size=8) filter_1 := ff_hevc_epel_filters[filterIdx - 1][1],
	    int(size=8) filter_2 := ff_hevc_epel_filters[filterIdx - 1][2],
	    int(size=8) filter_3 := ff_hevc_epel_filters[filterIdx - 1][3]
	begin
	    foreach int y in 0 .. height do
			foreach int x in 0 .. width do
	            predSamples[component][x][y][listIdx] := EPEL_FILTER_V(refSamples, x+1, y+1, filter_0, filter_1, filter_2, filter_3, component);
	        end
	    end
	end
 	
 	procedure put_hevc_epel_hv (int(size=16) predSamples [ 3 ] [ 64 ] [ 64 ] [ 2 ], uint(size=2) listIdx,
								uint(size=16) refSamples [ 3 ] [ 64 + 7 ] [ 64 + 7 ],
								int filterIdx[2], uint(size=7) width, uint(size=7) height, int component)
	var
		int(size=16) intermSamples[3][ 64 + 7] [ 64 + 7],
		int(size=8) filter_0 := ff_hevc_epel_filters[filterIdx[0] - 1][0],
	    int(size=8) filter_1 := ff_hevc_epel_filters[filterIdx[0] - 1][1],
	    int(size=8) filter_2 := ff_hevc_epel_filters[filterIdx[0] - 1][2],
	    int(size=8) filter_3 := ff_hevc_epel_filters[filterIdx[0] - 1][3]
	begin
		foreach int y in 0 .. height+3 do
				foreach int x in 0 .. width do
		            intermSamples[component][x][y] := EPEL_FILTER_H(refSamples, x+1, y, filter_0, filter_1, filter_2, filter_3, component) - 8192;
		        end
		end
	    filter_0 := ff_hevc_epel_filters[filterIdx[1] - 1][0];
	    filter_1 := ff_hevc_epel_filters[filterIdx[1] - 1][1];
	    filter_2 := ff_hevc_epel_filters[filterIdx[1] - 1][2];
	    filter_3 := ff_hevc_epel_filters[filterIdx[1] - 1][3];
	    foreach int y in 0 .. height do
			foreach int x in 0 .. width do
	            predSamples[component][x][y][listIdx] := (EPEL_FILTER_V(intermSamples, x, y+1, filter_0, filter_1, filter_2, filter_3, component) + 524288) >> 6;
	        end
	    end
	end
	
	procedure put_unweighted_pred (int (size=16) src[3][64][64][2], int width, int height, uint(size=1) rdList, int component)
	begin
	    foreach int y in 0 .. height do
	        foreach int x in 0 .. width do
	            src[component][x][y][0] := (src[component][x][y][rdList] + (1 <<(shift1-1)))>>shift1;
	        end
	    end
	end
/* 
static void FUNC(put_weighted_pred_avg)(uint8_t *_dst, ptrdiff_t _dststride,
                                        int16_t *src1, int16_t *src2,
                                        ptrdiff_t srcstride,
                                        int width, int height)
{
    int x, y;
    pixel *dst = (pixel*)_dst;
    ptrdiff_t dststride = _dststride / sizeof(pixel);

    int shift = 14 + 1 - BIT_DEPTH;
#if BIT_DEPTH < 14
    int offset = 1 << (shift - 1);
#else
    int offset = 0;
#endif

    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            dst[x] = av_clip_pixel((src1[x] + src2[x] + offset) >> shift);
        }
        dst  += dststride;
        src1 += srcstride;
        src2 += srcstride;
    }
}

static void FUNC(weighted_pred)(uint8_t denom, int16_t wlxFlag, int16_t olxFlag,
                                uint8_t *_dst, ptrdiff_t _dststride,
                                int16_t *src, ptrdiff_t srcstride,
                                int width, int height)
{
    int shift;
    int log2Wd;
    int wx;
    int ox;
    int x , y;
    int offset;
    pixel *dst = (pixel*)_dst;
    ptrdiff_t dststride = _dststride / sizeof(pixel);

    shift  = 14 - BIT_DEPTH;
    log2Wd = denom + shift;
    offset = 1 << (log2Wd - 1);
    wx = wlxFlag;
    ox = olxFlag * (1 << (BIT_DEPTH - 8));

    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            if (log2Wd >= 1) {
                dst[x] = av_clip_pixel(((src[x] * wx + offset) >> log2Wd) + ox);
            } else {
                dst[x] = av_clip_pixel(src[x] * wx + ox);
            }
        }
        dst  += dststride;
        src  += srcstride;
    }
}

static void FUNC(weighted_pred_avg)(uint8_t denom, int16_t wl0Flag, int16_t wl1Flag,
                                    int16_t ol0Flag, int16_t ol1Flag,
                                    uint8_t *_dst, ptrdiff_t _dststride,
                                    int16_t *src1, int16_t *src2, ptrdiff_t srcstride,
                                    int width, int height)
{
    int shift;
    int log2Wd;
    int w0;
    int w1;
    int o0;
    int o1;
    int x , y;
    pixel *dst = (pixel*)_dst;
    ptrdiff_t dststride = _dststride / sizeof(pixel);

    shift  = 14 - BIT_DEPTH;
    log2Wd = denom + shift;
    w0 = wl0Flag;
    w1 = wl1Flag;
    o0 = (ol0Flag) * (1 << (BIT_DEPTH - 8));
    o1 = (ol1Flag) * (1 << (BIT_DEPTH - 8));

    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            dst[x] = av_clip_pixel((src1[x] * w0 + src2[x] * w1 +
                                    ((o0 + o1 + 1) << log2Wd)) >> (log2Wd + 1));
        }
        dst  += dststride;
        src1 += srcstride;
        src2 += srcstride;
    }
}
*/
end
