/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
package devel.org.sc29.wg11.mpegh.part2.main.Filters;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;
import devel.org.sc29.wg11.mpegh.part2.inter.NaluType.*;

import  testBench.common.SourceUnit.*;

//There should be much less division.
//There should be a function for the code which test if two pixels are in the same slice thanks to the variable filtAcrSlc.
actor SaoFilter(bool DEBUG)
	uint(size=2)  IsPicSlcLcu,
	uint(size=8)  LcuSizeMax,
	uint(size=2)  LFAcrossSlcTile,
	uint(size=16) PicSize,
	uint(size=8)  SampleIn,
	int (size=9)  SaoSe,
	uint(size=16) TilesCoord
		==>
	uint(size=8)  FiltSample
		:
		
	bool DEBUG_Trace = false;
		
	uint(size=4)  BIT_DEPTH = 8;


	int(size=3) constHPos0[4][2] = [[-1,1],  [ 0,0], [-1,1],  [ 1,-1]];
	int(size=3) constVPos0[4][2] = [[ 0,0],  [-1,1], [-1,1],  [-1, 1]];
	int(size=3) edgeIdxConv[5] = [1, 2, 0, 3, 4];

	int(size=2) signResult[3][128][128];

	bool          slcSaoCompEn[3];

	uint(size=8) OrigPict[3][PICT_WIDTH_POW_2][PICT_HEIGHT_POW_2];
	uint(size=8) FiltPict[3][PICT_WIDTH_POW_2][PICT_HEIGHT_POW_2];

	
	uint(size=2)  cIdx;
	uint(size=2)  saoTypeIdx[PICT_WIDTH_POW_2/64][PICT_HEIGHT_POW_2/64][3];
	int (size=9)  saoOffset[PICT_WIDTH_POW_2/64][PICT_HEIGHT_POW_2/64][3][5];
	uint(size=2)  saoEoClass[PICT_WIDTH_POW_2/64][PICT_HEIGHT_POW_2/64][3];
	uint(size=5)  saoLeftClass[PICT_WIDTH_POW_2/64][PICT_HEIGHT_POW_2/64][3];
	uint(size=3)  bandTable[32];
	uint(size=8)  lcuSizeMax;
	uint(size=6)  picSizeInCu[2];
	uint(size=6)  picSizeInMb[2];
	uint(size=16) picSize[3][2];
	uint(size=8)  xCu := 0;
	uint(size=8)  yCu := 0;
	uint(size=6)  xCuFilt := 0;
	uint(size=6)  yCuFilt := 0;
	uint(size=16) numTokenPerLcu[2];
	uint(size=16) tokenGot;

	int(size=16) iLoop;

	uint(size=16) numTiles;
	uint(size=16) lcuTileIdx;
	uint(size=16) tilesBeg[MAX_NUM_TILES][2];
	uint(size=16) tilesEnd[MAX_NUM_TILES][2];
	bool         filtAcrSlc[PICT_WIDTH_POW_2/64][PICT_HEIGHT_POW_2/64];
	bool         filtAcrTile[PICT_WIDTH_POW_2/64][PICT_HEIGHT_POW_2/64];
	bool         filtAcrAllSlc;
	bool         filtAcrAllTiles;
	bool         filtAcrCurrSlc;
	bool         filtAcrCurrTile;
	uint(size=8) numSlc[PICT_WIDTH_POW_2/64][PICT_HEIGHT_POW_2/64];
	uint(size=8) numTile[PICT_WIDTH_POW_2/64][PICT_HEIGHT_POW_2/64];
	uint(size=8) numCurrSlc;

	procedure nextLcuAddress()
	begin
		xCu := xCu + 1;
		if(xCu = tilesEnd[lcuTileIdx][0]) then
			xCu := tilesBeg[lcuTileIdx][0];
			yCu := yCu + 1;
			if(yCu = tilesEnd[lcuTileIdx][1]) then
				lcuTileIdx := lcuTileIdx + 1;
				xCu := tilesBeg[lcuTileIdx][0];
				yCu := tilesBeg[lcuTileIdx][1];
			end
		end
	end

	procedure nextMbAddr()
	begin
		xCu := xCu + 1;
		if(xCu = picSizeInMb[0]) then
			xCu := 0;
			yCu := yCu + 1;
		end
	end

	function lcuFiltIsPictureBorder() --> bool
	:
		xCuFilt = 0 || yCuFilt = 0||
		xCuFilt+1 >= picSizeInCu[0] ||
		yCuFilt+1 >= picSizeInCu[1]
	end

	procedure copyCu(uint(size=16) addrBeg[2], uint(size=16) addrEnd[2], uint(size=2) cIdx)
	begin
		foreach uint x in addrBeg[0] .. addrEnd[0]
		do
			foreach uint y in addrBeg[1] .. addrEnd[1]
			do
				FiltPict[cIdx][x][y] := OrigPict[cIdx][x][y];
			end
		end
	end

	procedure saoFilterEdgeLuma_Horiz(uint(size=16) rx, uint(size=16) ry,
		uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		uint(size=16) xMax,
		uint(size=16) yMax,
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) xPix1,
		uint(size=16) xPix2,
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		int (size=16) idxMin
	begin
		xMax := min(lcuSizeMax - 1, picSize[0] - rx - 1);
		yMax := min(lcuSizeMax - 1, picSize[1] - ry - 1);

		idxMin := if(rx = 0) then 0 else -1 end;

		foreach int(size=16) y in 0 .. yMax
		do
			yIdx := ry + y;
			foreach int(size=16) x in idxMin .. xMax
			do
				xIdx := rx + x;
				xPix2 := xIdx + 1;
				signResult[0][(x+1)&127][y] :=
					Sign3(OrigPict[0][xPix2 & MASK_WIDTH_POW_2][yIdx] -
						OrigPict[0][xIdx][yIdx]);
			end
		end
		idxMin := 0;
		if(lcuIsPictBorder) then
			if(rx = 0) then
				idxMin := 1;
				foreach uint(size=16) y in ry .. ry + yMax
				do
					FiltPict[0][0][y] :=
						OrigPict[0][0][y];
				end
			end
			if(rx + xMax = picSize[0] - 1) then
				xMax := xMax - 1;
				foreach uint(size=16) y in ry .. ry + yMax
				do
					FiltPict[0][picSize[0] - 1 ][y] :=
						OrigPict[0][picSize[0] - 1][y];
				end
			end
		end

		foreach uint(size=3) x in idxMin .. xMax
		do
			xIdx := rx + x;
			xPix1 := xIdx - 1;
			xPix2 := xIdx + 1;
			foreach uint(size=3) y in 0 .. yMax
			do
				yIdx := ry + y;

				edgeIdx := 2 + signResult[0][x][y]
					- signResult[0][x+1][y];
				edgeIdx := edgeIdxConv[edgeIdx];
				FiltPict[0][xIdx][yIdx] :=
					clip_i32(OrigPict[0][xIdx][yIdx] +
						saoOffset[xCuFilt][yCuFilt][0][edgeIdx], 0, 255);
			end
		end
		if(not filtAcrAllSlc || not filtAcrAllTiles) then
			foreach uint(size=3) y in 0 .. yMax
			do
				yIdx := ry + y;
				foreach uint(size=3) x in idxMin .. xMax
				do
					xIdx := rx + x;
					xPix1 := xIdx - 1;
					xPix2 := xIdx + 1;
	
					pixIsInPict := true;
					if(not filtAcrSlc[xIdx/lcuSizeMax][yIdx/lcuSizeMax] &&
						numSlc[xPix1/lcuSizeMax][yIdx/lcuSizeMax] !=
						numSlc[xPix2/lcuSizeMax][yIdx/lcuSizeMax]) then
						pixIsInPict := false;
					else if(not filtAcrTile[xIdx/lcuSizeMax][yIdx/lcuSizeMax] &&
						numTile[xPix1/lcuSizeMax][yIdx/lcuSizeMax] !=
						numTile[xPix2/lcuSizeMax][yIdx/lcuSizeMax]) then
						
						pixIsInPict := false;
					end end

					if( not pixIsInPict) then
						FiltPict[0][xIdx][yIdx] :=
							OrigPict[0][xIdx][yIdx];
					end
				end
			end
		end
	end

	procedure saoFilterEdgeLuma_Vert(uint(size=16) rx, uint(size=16) ry,
		uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		int (size=16) idxMin,
		uint(size=16) xMax,
		uint(size=16) yMax,
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) yPix1,
		uint(size=16) yPix2,
		uint(size=3) edgeIdx,
		bool pixIsInPict
	begin
		xMax := min(lcuSizeMax - 1, picSize[0] - rx - 1);
		yMax := min(lcuSizeMax - 1, picSize[1] - ry - 1);
		idxMin := if(ry = 0) then 0 else -1 end;

		foreach int(size=16) x in 0 .. xMax
		do
			xIdx := rx + x;
			foreach int(size=16) y in idxMin .. yMax
			do
				yIdx := ry + y;
				yPix2 := yIdx + 1;

				signResult[0][x][(y+1)&127] :=
					Sign3(OrigPict[0][xIdx][yPix2 & MASK_HEIGHT_POW_2] -
						OrigPict[0][xIdx][yIdx]);
			end
		end
		idxMin := 0;
		if(lcuIsPictBorder) then
			if(ry = 0) then
				idxMin := 1;
				foreach uint(size=16) x in rx .. rx + xMax
				do
					FiltPict[0][x][0] :=
						OrigPict[0][x][0];
				end
			end
			if(ry + yMax = picSize[1] - 1) then
				yMax := yMax - 1;
				foreach uint(size=16) x in rx .. rx + xMax
				do
					FiltPict[0][x][picSize[1] - 1] :=
						OrigPict[0][x][picSize[1] - 1];
				end
			end
		end

		foreach uint(size=3) y in idxMin .. yMax
		do
			yIdx := ry + y;
			yPix2 := yIdx + 1;
			foreach uint(size=3) x in 0 .. xMax
			do
				xIdx := rx + x;

				edgeIdx := 2 + signResult[0][x][y]
					- signResult[0][x][y+1];
				edgeIdx := edgeIdxConv[edgeIdx];
				FiltPict[0][xIdx][yIdx] :=
					clip_i32(OrigPict[0][xIdx][yIdx] +
						saoOffset[xCuFilt][yCuFilt][0][edgeIdx], 0, 255);
			end
		end

		if(not filtAcrAllSlc || not filtAcrAllTiles) then
			foreach uint(size=3) x in 0 .. xMax
			do
				xIdx := rx + x;
				foreach uint(size=3) y in idxMin .. yMax
				do
					yIdx := ry + y;
	
					yPix1 := yIdx - 1;
					yPix2 := yIdx + 1;
	
					pixIsInPict := true;
					if(not filtAcrSlc[xIdx/lcuSizeMax][yIdx/lcuSizeMax] &&
						numSlc[xIdx/lcuSizeMax][yPix1/lcuSizeMax] !=
						numSlc[xIdx/lcuSizeMax][yPix2/lcuSizeMax]) then
						pixIsInPict := false;
					else if(not filtAcrTile[xIdx/lcuSizeMax][yIdx/lcuSizeMax] &&
						numTile[xIdx/lcuSizeMax][yPix1/lcuSizeMax] !=
						numTile[xIdx/lcuSizeMax][yPix2/lcuSizeMax]) then
						pixIsInPict := false;
					end end
	
					if(not pixIsInPict) then
						FiltPict[0][xIdx][yIdx] :=
							OrigPict[0][xIdx][yIdx];
					end
				end
			end
		end
	end

	procedure saoFilterEdgeLuma_Diag(uint(size=16) rx, uint(size=16) ry,
		uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		int (size=16) idxMin[2],
		int (size=16) idxMax[2],
		int (size=16) xMax,
		int (size=16) xIdx,
		int (size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		uint(size=3)  edgeIdx,
		int(size=2)  xOff[2],
		int(size=2)  yOff[2]
	begin
		idxMax[0] := min(lcuSizeMax - 1, picSize[0] - rx - 1);
		idxMax[1] := min(lcuSizeMax - 1, picSize[1] - ry - 1);
		foreach uint k in 0 .. 1
		do
			xOff[k] := constHPos0[saoEoClass[xCuFilt][yCuFilt][0]][k];
			yOff[k] := constVPos0[saoEoClass[xCuFilt][yCuFilt][0]][k];
		end

		idxMin[0] := if(rx = 0 || xOff[0] != -1) then 0 else -1 end;
		xMax      := if(xOff[0]  = -1) then idxMax[0] else idxMax[0] + 1 end;
		idxMin[1] := if(ry = 0) then 0 else -1 end;

		pixIdx[1][1] := ry + yOff[1] + idxMin[1];
		foreach int(size=16) y in idxMin[1] .. idxMax[1]
		do
			yIdx := ry + y;
			pixIdx[1][0] := rx + xOff[1] + idxMin[0];
			foreach int(size=16) x in idxMin[0] .. xMax
			do
				xIdx := rx + x;
				signResult[0][(x+xOff[1])&127][(y+yOff[1])&127] :=
					Sign3(OrigPict[0][pixIdx[1][0] & MASK_WIDTH_POW_2][pixIdx[1][1]] -
						OrigPict[0][xIdx][yIdx]);
				pixIdx[1][0] := pixIdx[1][0] + 1;
			end
			pixIdx[1][1] := pixIdx[1][1] + 1;
		end

		idxMin[0] := 0;
		idxMin[1] := 0;
		if(lcuIsPictBorder) then
			fillInBorderPix(rx, ry, idxMin, idxMax, picSize);
		end
		foreach int(size=16) y in idxMin[1] .. idxMax[1]
		do
			yIdx := ry + y;
			foreach int(size=16) x in idxMin[0] .. idxMax[0]
			do
				xIdx := rx + x;
				foreach uint k in 0 .. 1
				do
					pixIdx[k][0] := xIdx + xOff[k];
					pixIdx[k][1] := yIdx + yOff[k];
				end
				edgeIdx := 2 + signResult[0][x][y]
					- signResult[0][(x+xOff[1])&127][(y+yOff[1])&127];
				edgeIdx := edgeIdxConv[edgeIdx];

				FiltPict[0][xIdx][yIdx] :=
					clip_i32(OrigPict[0][xIdx][yIdx] +
					saoOffset[xCuFilt][yCuFilt][0][edgeIdx], 0, 255);
			end
		end
		if(not filtAcrAllSlc || not filtAcrAllTiles) then
			resetTilesOrSliceEdgeLuma(rx, ry, idxMin, idxMax, xOff, yOff);
		end
	end

	procedure resetTilesOrSliceEdgeLuma(uint(size=16) rx, uint(size=16) ry, uint(size=16) idxMin[2], uint(size=16) idxMax[2],
		int(size=2)  xOff[2], int(size=2)  yOff[2])
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool          pixIsInPict
	begin
		foreach uint(size=16) y in idxMin[1] .. idxMax[1]
		do
			yIdx := ry + y;
			foreach uint(size=16) x in idxMin[0] .. idxMax[0]
			do
				xIdx := rx + x;
				pixIsInPict := true;
				foreach uint k in 0 .. 1
				do
					pixIdx[k][0] := xIdx + xOff[k];
					pixIdx[k][1] := yIdx + yOff[k];
					if(not filtAcrSlc[xIdx/lcuSizeMax][yIdx/lcuSizeMax] &&
						numSlc[xIdx/lcuSizeMax][yIdx/lcuSizeMax] !=
						numSlc[pixIdx[k][0]/lcuSizeMax][pixIdx[k][1]/lcuSizeMax]) then
						pixIsInPict := false;
					else if(not filtAcrTile[xIdx/lcuSizeMax][yIdx/lcuSizeMax] &&
						numTile[xIdx/lcuSizeMax][yIdx/lcuSizeMax] !=
						numTile[pixIdx[k][0]/lcuSizeMax][pixIdx[k][1]/lcuSizeMax]) then
						pixIsInPict := false;
					end end
				end
				if(not pixIsInPict) then
					FiltPict[0][xIdx][yIdx] :=
						OrigPict[0][xIdx][yIdx];
				end
			end
		end
	end

	procedure fillInBorderPix(uint(size=16) rx, uint(size=16) ry, uint(size=16) idxMin[2],
		uint(size=16) idxMax[2], uint(size=16) picSize[2])
	begin
		if(rx = 0) then
			idxMin[0] := 1;
			foreach uint(size=16) y in ry .. ry + idxMax[1]
			do
				FiltPict[0][0][y] :=
					OrigPict[0][0][y];
			end
		end
		if(rx + idxMax[0] = picSize[0] - 1) then
			idxMax[0] := idxMax[0] - 1;
			foreach uint(size=16) y in ry .. ry + idxMax[1]
			do
				FiltPict[0][picSize[0] - 1][y] :=
					OrigPict[0][picSize[0] - 1][y];
			end
		end
		if(ry = 0) then
			idxMin[1] := 1;
			foreach uint(size=16) x in rx .. rx + idxMax[0]
			do
				FiltPict[0][x][0] :=
					OrigPict[0][x][0];
			end
		end
		if(ry + idxMax[1] = picSize[1] - 1) then
			idxMax[1] := idxMax[1] - 1;
			foreach uint(size=16) x in rx .. rx + idxMax[0]
			do
				FiltPict[0][x][picSize[1] - 1] :=
					OrigPict[0][x][picSize[1] - 1];
			end
		end
	end

	procedure fillInBorderPixChr(uint(size=16) rx, uint(size=16) ry, uint(size=2) cIdx,
		uint(size=16) idxMin[2], uint(size=16) idxMax[2], uint(size=16) picSize[2])
	begin
		if(rx = 0) then
			idxMin[0] := 1;
			foreach uint(size=16) y in ry .. ry + idxMax[1]
			do
				FiltPict[cIdx][0][y] :=
					OrigPict[cIdx][0][y];
			end
		end
		if(rx + idxMax[0] = picSize[0] - 1) then
			idxMax[0] := idxMax[0] - 1;
			foreach uint(size=16) y in ry .. ry + idxMax[1]
			do
				FiltPict[cIdx][picSize[0] - 1][y] :=
					OrigPict[cIdx][picSize[0] - 1][y];
			end
		end
		if(ry = 0) then
			idxMin[1] := 1;
			foreach uint(size=16) x in rx .. rx + idxMax[0]
			do
				FiltPict[cIdx][x][0] :=
					OrigPict[cIdx][x][0];
			end
		end
		if(ry + idxMax[1] = picSize[1] - 1) then
			idxMax[1] := idxMax[1] - 1;
			foreach uint(size=16) x in rx .. rx + idxMax[0]
			do
				FiltPict[cIdx][x][picSize[1] - 1] :=
					OrigPict[cIdx][x][picSize[1] - 1];
			end
		end
	end

	procedure codingTreeBlockModifLuma(uint(size=16) rx, uint(size=16) ry,
		uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		int (size=16) idxMax[2],
		uint(size=3)  bandShift = BIT_DEPTH-5,
		uint(size=3)  bandIdx
	begin
		if(saoTypeIdx[xCuFilt][yCuFilt][0] = 2 and saoEoClass[xCuFilt][yCuFilt][0] = 0) then
			saoFilterEdgeLuma_Horiz(rx,ry,picSize, lcuIsPictBorder);
		else if(saoTypeIdx[xCuFilt][yCuFilt][0] = 2 and saoEoClass[xCuFilt][yCuFilt][0] = 1) then
			saoFilterEdgeLuma_Vert(rx,ry,picSize, lcuIsPictBorder);
		else if(saoTypeIdx[xCuFilt][yCuFilt][0] = 2) then
			saoFilterEdgeLuma_Diag(rx,ry,picSize, lcuIsPictBorder);
		else
			idxMax[0] := min(lcuSizeMax - 1, picSize[0] - rx - 1);
			idxMax[1] := min(lcuSizeMax - 1, picSize[1] - ry - 1);
			foreach int(size=16) y in ry .. ry + idxMax[1]
			do
				foreach int(size=16) x in rx .. rx + idxMax[0]
				do
					bandIdx := bandTable[OrigPict[0][x][y]>>bandShift];
					FiltPict[0][x][y] :=
						clip_i32(OrigPict[0][x][y] +
						saoOffset[xCuFilt][yCuFilt][0][bandIdx], 0, 255);
				end
			end
		end end end
	end



	procedure resetTilesOrSliceEdgeChroma(uint(size=16) rx, uint(size=16) ry,
		uint(size=2) cIdx, uint(size=16) idxMin[2], uint(size=16) idxMax[2],
		int(size=2)  xOff[2], int(size=2)  yOff[2])
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool          pixIsInPict
	begin
		foreach uint(size=16) y in idxMin[1] .. idxMax[1]
		do
			yIdx := ry + y;
			foreach uint(size=16) x in idxMin[0] .. idxMax[0]
			do
				xIdx := rx + x;
				pixIsInPict := true;
				foreach uint k in 0 .. 1
				do
					pixIdx[k][0] := xIdx + xOff[k];
					pixIdx[k][1] := yIdx + yOff[k];
					if(not filtAcrSlc[xIdx / (lcuSizeMax >> 1)][yIdx / (lcuSizeMax >> 1)] &&
						numSlc[xIdx / (lcuSizeMax >> 1)][yIdx / (lcuSizeMax >> 1)] !=
						numSlc[pixIdx[k][0] / (lcuSizeMax >> 1)][pixIdx[k][1] / (lcuSizeMax >> 1)]) then
						pixIsInPict := false;
					else if(not filtAcrTile[xIdx / (lcuSizeMax >> 1)][yIdx / (lcuSizeMax >> 1)] &&
						numTile[xIdx / (lcuSizeMax >> 1)][yIdx / (lcuSizeMax >> 1)] !=
						numTile[pixIdx[k][0] / (lcuSizeMax >> 1)][pixIdx[k][1] / (lcuSizeMax >> 1)]) then
						pixIsInPict := false;
					end end
				end
				if(not pixIsInPict) then
					FiltPict[cIdx][xIdx][yIdx] :=
						OrigPict[cIdx][xIdx][yIdx];
				end
			end
		end
	end

	procedure saoFilterEdgeChroma_Horiz(uint(size=16) rx, uint(size=16) ry,
		uint(size=2) cIdx, uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		uint(size=16) xMax,
		uint(size=16) yMax,
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) xPix1,
		uint(size=16) xPix2,
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		int (size=16) idxMin
	begin
		xMax := min((lcuSizeMax - 1) >> 1, picSize[0] - rx - 1);
		yMax := min((lcuSizeMax - 1) >> 1, picSize[1] - ry - 1);

		idxMin := if(rx = 0) then 0 else -1 end;
		foreach int(size=16) y in 0 .. yMax
		do
			yIdx := ry + y;
			foreach int(size=16) x in idxMin .. xMax
			do
				xIdx := rx + x;
				xPix2 := xIdx + 1;
				signResult[cIdx][(x+1)&127][y] :=
					Sign3(OrigPict[cIdx][xPix2 & MASK_WIDTH_POW_2][yIdx] -
						OrigPict[cIdx][xIdx][yIdx]);
			end
		end
		idxMin := 0;
		if(lcuIsPictBorder) then
			if(rx = 0) then
				idxMin := 1;
				foreach uint(size=16) y in ry .. ry + yMax
				do
					FiltPict[cIdx][0][y] :=
						OrigPict[cIdx][0][y];
				end
			end
			if(rx + xMax = picSize[0] - 1) then
				xMax := xMax - 1;
				foreach uint(size=16) y in ry .. ry + yMax
				do
					FiltPict[cIdx][picSize[0] - 1][y] :=
						OrigPict[cIdx][picSize[0] - 1][y];
				end
			end
		end

		foreach uint(size=3) x in idxMin .. xMax
		do
			xIdx := rx + x;
			xPix1 := xIdx - 1;
			xPix2 := xIdx + 1;
			foreach uint(size=3) y in 0 .. yMax
			do
				yIdx := ry + y;

				edgeIdx := 2 + signResult[cIdx][x][y]
					- signResult[cIdx][x+1][y];
				edgeIdx := edgeIdxConv[edgeIdx];
				FiltPict[cIdx][xIdx][yIdx] :=
					clip_i32(OrigPict[cIdx][xIdx][yIdx] +
						saoOffset[xCuFilt][yCuFilt][cIdx][edgeIdx], 0, 255);
			end
		end

		if(not filtAcrAllSlc || not filtAcrAllTiles) then
			foreach uint(size=3) y in 0 .. yMax
			do
				yIdx := ry + y;
				foreach uint(size=3) x in idxMin .. xMax
				do
					xIdx := rx + x;
					xPix1 := xIdx - 1;
					xPix2 := xIdx + 1;
	
					pixIsInPict := true;
					if(not filtAcrSlc[xIdx / (lcuSizeMax >> 1)][yIdx / (lcuSizeMax >> 1)] &&
						numSlc[xPix1 / (lcuSizeMax >> 1)][yIdx / (lcuSizeMax >> 1)] !=
						numSlc[xPix2 / (lcuSizeMax >> 1)][yIdx / (lcuSizeMax >> 1)]) then
						pixIsInPict := false;
					else if(not filtAcrTile[xIdx / (lcuSizeMax >> 1)][yIdx / (lcuSizeMax >> 1)] &&
						numTile[xPix1 / (lcuSizeMax >> 1)][yIdx / (lcuSizeMax >> 1)] !=
						numTile[xPix2 / (lcuSizeMax >> 1)][yIdx / (lcuSizeMax >> 1)]) then
						pixIsInPict := false;
					end end

					if( not pixIsInPict) then
						FiltPict[cIdx][xIdx][yIdx] :=
							OrigPict[cIdx][xIdx][yIdx];
					end
				end
			end
		end
	end

	procedure saoFilterEdgeChroma_Vert(uint(size=16) rx, uint(size=16) ry,
		uint(size=2) cIdx, uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) xMax,
		uint(size=16) yMax,
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		int (size=16) idxMin,
		uint(size=16) yPix1,
		uint(size=16) yPix2
	begin
		xMax := min((lcuSizeMax - 1) >> 1, picSize[0] - rx - 1);
		yMax := min((lcuSizeMax - 1) >> 1, picSize[1] - ry - 1);
		idxMin := if(ry = 0) then 0 else -1 end;

		foreach int(size=16) x in 0 .. xMax
		do
			xIdx := rx + x;
			foreach int(size=16) y in idxMin .. yMax
			do
				yIdx := ry + y;
				yPix2 := yIdx + 1;
				signResult[cIdx][x][(y+1)&127] :=
					Sign3(OrigPict[cIdx][xIdx][yPix2 & MASK_HEIGHT_POW_2] -
						OrigPict[cIdx][xIdx][yIdx]);
			end
		end

		idxMin := 0;
		if(lcuIsPictBorder) then
			if(ry = 0) then
				idxMin := 1;
				foreach uint(size=16) x in rx .. rx + xMax
				do
					FiltPict[cIdx][x][0] :=
						OrigPict[cIdx][x][0];
				end
			end
			if(ry + yMax = picSize[1] - 1) then
				yMax := yMax - 1;
				foreach uint(size=16) x in rx .. rx + xMax
				do
					FiltPict[cIdx][x][picSize[1] - 1] :=
						OrigPict[cIdx][x][picSize[1] - 1];
				end
			end
		end

		foreach uint(size=3) y in idxMin .. yMax
		do
			yIdx := ry + y;
			yPix2 := yIdx + 1;
			foreach uint(size=3) x in 0 .. xMax
			do
				xIdx := rx + x;

				edgeIdx := 2 + signResult[cIdx][x][y]
					- signResult[cIdx][x][y+1];
				edgeIdx := edgeIdxConv[edgeIdx];
				FiltPict[cIdx][xIdx][yIdx] :=
					clip_i32(OrigPict[cIdx][xIdx][yIdx] +
						saoOffset[xCuFilt][yCuFilt][cIdx][edgeIdx], 0, 255);
			end
		end

		if(not filtAcrAllSlc || not filtAcrAllTiles) then
			foreach uint(size=3) x in 0 .. xMax
			do
				xIdx := rx + x;
				foreach uint(size=3) y in idxMin .. yMax
				do
					yIdx := ry + y;

					yPix1 := yIdx - 1;
					yPix2 := yIdx + 1;

					pixIsInPict := true;
					if(not filtAcrSlc[xIdx / (lcuSizeMax >> 1)][yIdx / (lcuSizeMax >> 1)] &&
						numSlc[xIdx / (lcuSizeMax >> 1)][yPix1 / (lcuSizeMax >> 1)] !=
						numSlc[xIdx / (lcuSizeMax >> 1)][yPix2 / (lcuSizeMax >> 1)]) then
						pixIsInPict := false;
					else if(not filtAcrTile[xIdx / (lcuSizeMax >> 1)][yIdx / (lcuSizeMax >> 1)] &&
						numTile[xIdx / (lcuSizeMax >> 1)][yPix1 / (lcuSizeMax >> 1)] !=
						numTile[xIdx / (lcuSizeMax >> 1)][yPix2 / (lcuSizeMax >> 1)]) then
						pixIsInPict := false;
					end end

					if(not pixIsInPict) then
						FiltPict[cIdx][xIdx][yIdx] :=
							OrigPict[cIdx][xIdx][yIdx];
					end
				end
			end
		end
	end

	procedure saoFilterEdgeChroma_Diag(uint(size=16) rx, uint(size=16) ry, uint(size=2) cIdx,
		uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		int (size=16) idxMin[2],
		int (size=16) idxMax[2],
		int (size=16) xMax,
		int (size=16) xIdx,
		int (size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		uint(size=3)  edgeIdx,
		int(size=2)  xOff[2],
		int(size=2)  yOff[2]
	begin
		foreach uint k in 0 .. 1
		do
			xOff[k] := constHPos0[saoEoClass[xCuFilt][yCuFilt][cIdx]][k];
			yOff[k] := constVPos0[saoEoClass[xCuFilt][yCuFilt][cIdx]][k];
		end
		idxMax[0] := min((lcuSizeMax - 1) >> 1, picSize[0] - rx - 1);
		idxMax[1] := min((lcuSizeMax - 1) >> 1, picSize[1] - ry - 1);

		idxMin[0] := if(rx = 0 || xOff[0] != -1) then 0 else -1 end;
		xMax      := if(xOff[0]  = -1) then idxMax[0] else idxMax[0] + 1 end;
		idxMin[1] := if(ry = 0) then 0 else -1 end;

		pixIdx[1][1] := ry + yOff[1] + idxMin[1];
		foreach int(size=16) y in idxMin[1] .. idxMax[1]
		do
			yIdx := ry + y;
			pixIdx[1][0] := rx + xOff[1] + idxMin[0];
			foreach int(size=16) x in idxMin[0] .. xMax
			do
				xIdx := rx + x;
				signResult[cIdx][(x+xOff[1])&127][(y+yOff[1])&127] :=
					Sign3(OrigPict[cIdx][pixIdx[1][0] & MASK_WIDTH_POW_2][pixIdx[1][1]] -
						OrigPict[cIdx][xIdx][yIdx]);
				pixIdx[1][0] := pixIdx[1][0] + 1;
			end
			pixIdx[1][1] := pixIdx[1][1] + 1;
		end
		idxMin[0] := 0;
		idxMin[1] := 0;
		if(lcuIsPictBorder) then
			fillInBorderPixChr(rx, ry, cIdx, idxMin, idxMax, picSize);
		end

		foreach int(size=16) y in idxMin[1] .. idxMax[1]
		do
			yIdx := ry + y;
			foreach int(size=16) x in idxMin[0] .. idxMax[0]
			do
				xIdx := rx + x;
				foreach uint k in 0 .. 1
				do
					pixIdx[k][0] := xIdx + xOff[k];
					pixIdx[k][1] := yIdx + yOff[k];
				end
				edgeIdx := 2 + signResult[cIdx][x][y]
					- signResult[cIdx][(x+xOff[1])&127][(y+yOff[1])&127];
				edgeIdx := edgeIdxConv[edgeIdx];

				FiltPict[cIdx][xIdx][yIdx] :=
					clip_i32(OrigPict[cIdx][xIdx][yIdx] +
					saoOffset[xCuFilt][yCuFilt][cIdx][edgeIdx], 0, 255);
			end
		end
		if(not filtAcrAllSlc || not filtAcrAllTiles) then
			resetTilesOrSliceEdgeChroma(rx, ry, cIdx, idxMin, idxMax, xOff, yOff);
		end
	end

	procedure codingTreeBlockModifChroma(uint(size=16) rx, uint(size=16) ry,
		uint(size=2) cIdx, uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		uint(size=16) xMax,
		uint(size=16) yMax,
		uint(size=3) bandShift = BIT_DEPTH-5,
		uint(size=3) bandIdx
	begin
		if(saoTypeIdx[xCuFilt][yCuFilt][cIdx] = 2) then
			if(saoEoClass[xCuFilt][yCuFilt][cIdx] = 0) then
				saoFilterEdgeChroma_Horiz(rx, ry, cIdx, picSize, lcuIsPictBorder);
			else if(saoEoClass[xCuFilt][yCuFilt][cIdx] = 1) then
				saoFilterEdgeChroma_Vert(rx, ry, cIdx, picSize, lcuIsPictBorder);
			else
				saoFilterEdgeChroma_Diag(rx, ry, cIdx, picSize, lcuIsPictBorder);
			end end
		else
			xMax := min((lcuSizeMax - 1) >> 1, picSize[0] - rx - 1);
			yMax := min((lcuSizeMax - 1) >> 1, picSize[1] - ry - 1);
			foreach uint(size=16) y in ry .. ry + yMax
			do
				foreach uint(size=16) x in rx .. rx + xMax
				do
					bandIdx := bandTable[OrigPict[cIdx][x][y]>>bandShift];
					FiltPict[cIdx][x][y] :=
						clip_i32(OrigPict[cIdx][x][y] +
						saoOffset[xCuFilt][yCuFilt][cIdx][bandIdx], 0, 255);
				end
			end
		end
	end

	procedure filtPrevLcu()
	begin
		if(xCu > 0 && yCu > 0) then
			xCuFilt := xCu - 1;
			yCuFilt := yCu - 1;
			sampAdapOffFilt();
		end
		if(xCu = picSizeInCu[0] -1 && yCu > 0) then
			xCuFilt := xCu;
			yCuFilt := yCu - 1;
			sampAdapOffFilt();
		end
		if(xCu > 0 && yCu = picSizeInCu[1] -1) then
			xCuFilt := xCu - 1;
			yCuFilt := yCu;
			sampAdapOffFilt();
		end
	end

	procedure sampAdapOffFilt()
	var
		uint(size=16) picSizeLoc[2],
		bool lcuIsPictBorder
	begin
		lcuIsPictBorder := lcuFiltIsPictureBorder();
		foreach uint cIdx in 0 .. 2
		do
			picSizeLoc := [picSize[cIdx][0], picSize[cIdx][1]];
			if(saoTypeIdx[xCuFilt][yCuFilt][cIdx] = 1) then
				foreach uint i in 0 .. 31
				do
					bandTable[i] := 0;
				end
				foreach uint k in 0 .. 3
				do
					bandTable[(k+saoLeftClass[xCuFilt][yCuFilt][cIdx]) & 31] := k+1;
				end
			end
			if(saoTypeIdx[xCuFilt][yCuFilt][cIdx]!=0) then
				if(cIdx=0) then
					codingTreeBlockModifLuma((xCuFilt*lcuSizeMax),
						(yCuFilt*lcuSizeMax), picSizeLoc, lcuIsPictBorder);
				else
					codingTreeBlockModifChroma((xCuFilt * (lcuSizeMax >> 1)),
						(yCuFilt * (lcuSizeMax >> 1)), cIdx, picSizeLoc, lcuIsPictBorder);
				end
			end
		end
	end
uint numPict;
	isNewPict: action IsPicSlcLcu:[isNewPicSlcLcu],
		LcuSizeMax:[lcuSz], LFAcrossSlcTile:[lfAcrossSlcTile],
		PicSize:[picWidthInPix, picHeightInPix], SaoSe:[saoSe] ==>
	guard
		isNewPicSlcLcu = NEW_PIC
	do
//		println("Pict num : " + numPict + ". Pic size : {" + picWidthInPix + " ; " + picHeightInPix + "}");
		numPict := numPict + 1;
		lcuSizeMax := lcuSz;
		picSizeInCu := [(picWidthInPix+(lcuSizeMax - 1))/lcuSizeMax, (picHeightInPix+(lcuSizeMax - 1))/lcuSizeMax];
		picSizeInMb := [(picWidthInPix+15)/16, (picHeightInPix+15)/16];
		picSize[0]  := [picWidthInPix   , picHeightInPix];
		picSize[1]  := [picSize[0][0] >> 1, picSize[0][1] >> 1];
		picSize[2]  := [picSize[1][0], picSize[1][1]];
		slcSaoCompEn[0] := (saoSe & 1) !=0;
		slcSaoCompEn[1] := (saoSe & 2) !=0;
		slcSaoCompEn[2] := slcSaoCompEn[1];
		filtAcrCurrSlc  := (lfAcrossSlcTile & 1) != 0;
		filtAcrCurrTile := (lfAcrossSlcTile & 2) != 0;
		filtAcrAllSlc := filtAcrCurrSlc;
		filtAcrAllTiles := filtAcrCurrTile;
		numCurrSlc := 0;
		lcuTileIdx := 0;
		numTokenPerLcu[0] := lcuSz * lcuSz;
		numTokenPerLcu[1] := numTokenPerLcu[0] >> 2;
	end

	//There should be slice SAO enable for each independent slice.
	isNewSlice: action IsPicSlcLcu:[isNewPicSlcLcu],
		LcuSizeMax:[lcuSz], LFAcrossSlcTile:[lfAcrossSlcTile],
		PicSize:[picWidthInPix, picHeightInPix]/*, SaoSe:[saoSe]*/ ==>
	guard
		isNewPicSlcLcu = NEW_SLC
	do
		/*slcSaoCompEn[0] := (saoSe & 1) !=0;
		slcSaoCompEn[1] := (saoSe & 2) !=0;
		slcSaoCompEn[2] := slcSaoCompEn[1];*/
		filtAcrCurrSlc  := (lfAcrossSlcTile & 1) != 0;
		filtAcrCurrTile := (lfAcrossSlcTile & 2) != 0;
		filtAcrAllSlc := filtAcrAllSlc && filtAcrCurrSlc;
		filtAcrAllTiles := filtAcrAllTiles && filtAcrCurrTile;
		numCurrSlc := numCurrSlc + 1;
		lcuSizeMax := lcuSz;
	end

	getNumTiles: action TilesCoord:[valNumTiles] ==>
	do
		numTiles := valNumTiles;
		iLoop := 0;
	end

	getTilesCoord.launch: action TilesCoord:[tilesCoord] repeat 4 ==>
	guard
		iLoop < numTiles
	do
		tilesBeg[iLoop] := [tilesCoord[0]/lcuSizeMax, tilesCoord[1]/lcuSizeMax];
		tilesEnd[iLoop] := [(tilesCoord[2]+(lcuSizeMax - 1))/lcuSizeMax, (tilesCoord[3]+(lcuSizeMax - 1))/lcuSizeMax];
		iLoop := iLoop + 1;
	end

	getTilesCoord.done: action ==>
	guard
		iLoop = numTiles
	end

	getCuPix.launch.init: action IsPicSlcLcu:[isNewLcu] ==>
	guard
		lcuTileIdx < numTiles
	do
		tokenGot := 0;
		numSlc[xCu][yCu]  := numCurrSlc;
		numTile[xCu][yCu] := lcuTileIdx;
		filtAcrSlc[xCu][yCu]  := filtAcrCurrSlc;
		filtAcrTile[xCu][yCu] := filtAcrCurrTile;
	end

	getCuPix.launch.luma: action SampleIn:[samp] repeat 16 ==>
	guard
		tokenGot < numTokenPerLcu[0]
	var
		uint(size=16) xPic,
		uint(size=16) yPic
	do
		xPic := (xCu * lcuSizeMax) + (tokenGot & (lcuSizeMax - 1));
		yPic := (yCu * lcuSizeMax) + tokenGot / lcuSizeMax;
		foreach uint x in 0 .. 15
		do
			OrigPict[0][x+xPic][yPic] := samp[x]; 
		end

		xPic := xCu<<6;
		yPic := yCu<<6;
		numSlc[xCu][yCu]     := numCurrSlc;
		filtAcrSlc[xCu][yCu] := filtAcrCurrSlc;

		tokenGot := tokenGot + 16;
	end

	getCuPix.launch.lumaDone: action ==>
	guard
		tokenGot = numTokenPerLcu[0]
	do
		tokenGot := 0;
		cIdx := 1;
	end

	getCuPix.launch.chroma: action SampleIn:[samp] repeat 8 ==>
	guard
		cIdx < 3
	var
		uint(size=16) xPic,
		uint(size=16) yPic
	do
		xPic := (xCu * (lcuSizeMax >> 1)) + (tokenGot & ((lcuSizeMax - 1) >> 1));
		yPic := (yCu * (lcuSizeMax >> 1)) + tokenGot / (lcuSizeMax >> 1);

		foreach uint x in 0 .. 7
		do
			OrigPict[cIdx][x+xPic][yPic] := samp[x]; 
		end

		tokenGot := tokenGot + 8;
		if(tokenGot = numTokenPerLcu[1]) then
			tokenGot := 0;
			cIdx := cIdx + 1;
		end
	end

	getCuPix.launch.chromaDone: action ==>
	guard
		cIdx = 3
	do
		cIdx := 0;
	end

	getCuPix.done: action ==>
	guard
		lcuTileIdx = numTiles
	do
		xCuFilt := picSizeInCu[0] -1;
		yCuFilt := picSizeInCu[1] -1;
		sampAdapOffFilt();

		xCu := 0;
		yCu := 0;
	end

	getSaoMerge.noMerge: action SaoSe:[mergeInfo] ==>
	guard
		(slcSaoCompEn[0] || slcSaoCompEn[1]) and mergeInfo = SAO_NO_MERGE
	do
		if (DEBUG_Trace) then
			println("=== getSaoMerge.noMerge ===");
			println("SaoSe       = " + mergeInfo);
		end
	end

	getSaoMerge.merge: action SaoSe:[mergeInfo] ==>
	guard
		(slcSaoCompEn[0] || slcSaoCompEn[1]) and mergeInfo != SAO_NO_MERGE
	var
		uint(size=16) addrBeg[2],
		uint(size=16) addrEnd[2],
		uint(size=16) xMerge =
			if(mergeInfo = SAO_MERGE_LEFT) then xCu-1 else xCu end,
		uint(size=16) yMerge =
			if(mergeInfo = SAO_MERGE_UP)  then yCu-1 else yCu end
	do
		if (DEBUG_Trace) then
			println("=== getSaoMerge.Merge ===");
			println("SaoSe       = " + mergeInfo);
		end

		foreach uint cIdx in 0 .. 2
		do
			saoTypeIdx[xCu][yCu][cIdx] := saoTypeIdx[xMerge][yMerge][cIdx];
			if(saoTypeIdx[xCu][yCu][cIdx] = 0) then
				addrBeg :=
					if(cIdx=0) then
						[xCu * lcuSizeMax, yCu * lcuSizeMax]
					else
						[xCu * (lcuSizeMax >> 1), yCu * (lcuSizeMax >> 1)]
					end;
				addrEnd :=
					if(cIdx=0) then
						[(xCu * lcuSizeMax)+(lcuSizeMax - 1), (yCu * lcuSizeMax)+(lcuSizeMax - 1)]
					else
						[(xCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1), (yCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1)]
					end;
		
				copyCu(addrBeg, addrEnd, cIdx);
			else
				foreach uint i in 1 .. 4
				do
					saoOffset[xCu][yCu][cIdx][i] := saoOffset[xMerge][yMerge][cIdx][i];
				end
				saoEoClass[xCu][yCu][cIdx] := saoEoClass[xMerge][yMerge][cIdx];
				saoLeftClass[xCu][yCu][cIdx] := saoLeftClass[xMerge][yMerge][cIdx];
			end
		end
		filtPrevLcu();
		nextLcuAddress();
	end

	getSaoMerge.skip: action ==>
	guard
		not slcSaoCompEn[0] && not slcSaoCompEn[1]
	var
		uint(size=16) addrBeg[2],
		uint(size=16) addrEnd[2]
	do
		saoTypeIdx[xCu][yCu] := [0, 0, 0];
		addrBeg := [xCu * lcuSizeMax, yCu * lcuSizeMax];
		addrEnd := [(xCu * lcuSizeMax)+(lcuSizeMax - 1),
			(yCu * lcuSizeMax)+(lcuSizeMax - 1)];
		copyCu(addrBeg, addrEnd, 0);

		addrBeg := [xCu * (lcuSizeMax >> 1), yCu * (lcuSizeMax >> 1)];
		addrEnd := [(xCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1),
		        (yCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1)];
		copyCu(addrBeg, addrEnd, 1);

		addrBeg := [xCu * (lcuSizeMax >> 1), yCu * (lcuSizeMax >> 1)];
		addrEnd := [(xCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1),
		        (yCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1)];
		copyCu(addrBeg, addrEnd, 2);
		filtPrevLcu();
		nextLcuAddress();
	end

	getSaoTypeIdx.is0: action SaoSe:[typeIdx] ==>
	guard
		/* Replace by (cIdx<3 && slcSaoCompEn[cIdx] && typeIdx = 0) when orcc's simulator
		 * support short-circuit evaluation.
		 */
		if cIdx <3 && typeIdx = 0 then slcSaoCompEn[cIdx] else false end
	var
		uint(size=16) addrBeg[2],
		uint(size=16) addrEnd[2]
	do
		if (DEBUG_Trace) then
			println("=== getSaoTypeIdx.is0 ===");
			println("SaoSe       = " + typeIdx);
		end

		addrBeg :=
			if(cIdx=0) then
				[xCu * lcuSizeMax, yCu * lcuSizeMax]
			else
				[xCu * (lcuSizeMax >> 1), yCu * (lcuSizeMax >> 1)]
			end;
		addrEnd :=
			if(cIdx=0) then
				[(xCu * lcuSizeMax)+(lcuSizeMax - 1), (yCu * lcuSizeMax)+(lcuSizeMax - 1)]
			else
				[(xCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1),
					(yCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1)]
			end;

		copyCu(addrBeg, addrEnd, cIdx);
		saoTypeIdx[xCu][yCu][cIdx] := 0;
		cIdx := cIdx + 1;
	end

	getSaoTypeIdx.isNot0: action SaoSe:[saoSe] repeat 6 ==>
	guard
		/* Replace by (cIdx<3 && slcSaoCompEn[cIdx] && saoSe[0] != 0) when orcc's simulator
		 * support short-circuit evaluation.
		 */
		if cIdx <3 then slcSaoCompEn[cIdx] && saoSe[0] != 0 else false end
	do
		if (DEBUG_Trace) then
			println("=== getSaoTypeIdx.isNot0 ===");
			print("SaoSe       = [");
			foreach uint i in 0 .. 5 do
				print(saoSe[i] + ", ");
			end
			println("]");
		end
		
		saoTypeIdx[xCu][yCu][cIdx] := saoSe[0];
		foreach uint i in 1 .. 4
		do
			saoOffset[xCu][yCu][cIdx][i] := saoSe[i];
		end
		if(saoTypeIdx[xCu][yCu][cIdx]=2) then
			saoEoClass[xCu][yCu][cIdx] := saoSe[5];
		else
			saoLeftClass[xCu][yCu][cIdx] := saoSe[5];
		end

		cIdx := cIdx + 1;
	end

	getSaoTypeIdx.skip: action ==>
	guard
		/* Replace by (cIdx<3 && not slcSaoCompEn[cIdx]) when orcc's simulator
		 * support short-circuit evaluation.
		 */
		if cIdx <3 then not slcSaoCompEn[cIdx] else false end
	var
		uint(size=16) addrBeg[2],
		uint(size=16) addrEnd[2]
	do
		addrBeg :=
			if(cIdx=0) then
				[xCu * lcuSizeMax, yCu * lcuSizeMax]
			else
				[xCu * (lcuSizeMax >> 1), yCu * (lcuSizeMax >> 1)]
			end;
		addrEnd :=
			if(cIdx=0) then
				[(xCu * lcuSizeMax)+(lcuSizeMax - 1), (yCu * lcuSizeMax)+(lcuSizeMax - 1)]
			else
				[(xCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1), (yCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1)]
			end;

		saoTypeIdx[xCu][yCu][cIdx] := 0;
		copyCu(addrBeg, addrEnd, cIdx);
		cIdx := cIdx + 1;
	end

	getSaoTypeIdxDone: action ==>
	guard
		cIdx = 3
	do
		cIdx := 0;
		filtPrevLcu();
		nextLcuAddress();
	end
	

	sendSamples.launch: action ==> FiltSample:[filtSamp] repeat 16*16 + 2 * 8*8 
	guard
		yCu < picSizeInMb[1]
	var
		uint tokenOffset,
		uint(size=8) filtSamp[16*16+2*8*8],
		uint(size=16) blkAddrX, uint(size=16) blkAddrY,
		uint(size=16) xMax, uint(size=16) yMax
	do
		blkAddrX := xCu*16;
		blkAddrY := yCu*16;
		xMax := min(15, picSize[0][0] - blkAddrX - 1);
		yMax := min(15, picSize[0][1] - blkAddrY - 1);
		foreach uint y in 0 .. yMax
		do
			foreach uint x in 0 .. xMax
			do
				filtSamp[x+y*16] := FiltPict[0][blkAddrX+x][blkAddrY+y];
			end
		end
		if(DEBUG) then
			foreach uint y in 0 .. 15
			do
				foreach uint x in xMax + 1 .. 15
				do
					filtSamp[x+y*16] := 0;
				end
			end
			foreach uint x in 0 .. 15
			do
				foreach uint y in yMax + 1 .. 15
				do
					filtSamp[x+y*16] := 0;
				end
			end
		end

		blkAddrX := blkAddrX>>1;
		blkAddrY := blkAddrY>>1;
		tokenOffset:= 16*16;
		xMax := min(7, picSize[0][0]/2 - blkAddrX - 1);
		yMax := min(7, picSize[0][1]/2 - blkAddrY - 1);
		foreach uint comp in 1 .. 2
		do
			foreach uint y in 0 .. yMax
			do
				foreach uint x in 0 .. xMax
				do
					filtSamp[x+y*8 + tokenOffset] := FiltPict[comp][blkAddrX+x][blkAddrY+y];
				end
			end
			tokenOffset:= tokenOffset + 8*8;
		end

		if(DEBUG) then
			tokenOffset:= 16*16;
			foreach uint comp in 1 .. 2
			do
				foreach uint y in yMax + 1 .. 7
				do
					foreach uint x in 0 .. 7
					do
						filtSamp[x+y*8 + tokenOffset] := 0;
					end
				end
				foreach uint x in xMax + 1 .. 7
				do
					foreach uint y in 0 .. 7
					do
						filtSamp[x+y*8 + tokenOffset] := 0;
					end
				end
				tokenOffset:= tokenOffset + 8*8;
			end
		end

		nextMbAddr();
	end

	sendSamples.done: action ==>
	guard
		yCu = picSizeInMb[1]
	do
		xCuFilt := 0;
		yCuFilt := 0;
		xCu := 0;
		yCu := 0;
	end

	schedule fsm IsNewPict:
		IsNewPict (isNewPict )--> GetNumTiles;

		GetCuPix (isNewSlice           )--> GetNumTiles;
		GetCuPix (getCuPix.launch.init )--> GetCuPixLuma;
		GetCuPix (getCuPix.done        )--> SendSamples;

		GetCuPixLuma (getCuPix.launch.luma     )--> GetCuPixLuma;
		GetCuPixLuma (getCuPix.launch.lumaDone )--> GetCuPixChr;

		GetCuPixChr (getCuPix.launch.chroma     )--> GetCuPixChr;
		GetCuPixChr (getCuPix.launch.chromaDone )--> GetSaoMerge;

		GetNumTiles   (getNumTiles          )--> GetTilesCoord;
		GetTilesCoord (getTilesCoord.launch )--> GetTilesCoord;
		GetTilesCoord (getTilesCoord.done   )--> GetCuPix;

		GetSaoMerge (getSaoMerge.skip    )--> GetCuPix;
		GetSaoMerge (getSaoMerge.merge   )--> GetCuPix;
		GetSaoMerge (getSaoMerge.noMerge )--> GetSaoTypeIdx;

		GetSaoTypeIdx(getSaoTypeIdx     )--> GetSaoTypeIdx;
		GetSaoTypeIdx(getSaoTypeIdxDone )--> GetCuPix;

		SendSamples (sendSamples.launch )--> SendSamples;
		SendSamples (sendSamples.done   )--> IsNewPict;
	end
end
