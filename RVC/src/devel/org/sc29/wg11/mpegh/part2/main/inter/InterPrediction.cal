/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * Decoding process for inter prediction samples
 * 
 * 
 * @input CuMode : mode (Intra, Inter or Skip mode) of all CU sent.
 * 
 * @input CuSize : size of all CU sent.
 * 
 * @input IsBiPredOrLx : Indicates when the current CU is using Bi-prediction.
 * 
 * @input Mv : motion vectors of the current CU.
 * 
 * @input PartMode : Giving the partitioning mode of the current CU.
 * 
 * @input Poc : Picture Order Count of the current slice.
 * 
 * @input RefList : Reference Lists (L0 and L1) of the current slice.
 * 
 * @input Sample : Samples from the DPB, used for the inter prediction.
 * 
 * @input SliceType : slice type (I, P or B) of the current slice.
 * 
 * @input WeightedPredSe : syntax elements for the weighted prediction decoded
 * 	by the parser.
 * 
 * 
 * @output PredSample : Interpolated samples according to the movement
 *		components given.
 * 
 * @author Damien de Saint Jorre (EPFL) <damien.desaintjorre@epfl.ch>
 */

package devel.org.sc29.wg11.mpegh.part2.main.inter;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

actor InterPrediction(uint(size=2) DECODE_COMP, uint(size=2) PROCESS_MODE_HALF_PIX = 0,
		uint(size=8) LOG2_NUM_SUB_BLK[2], uint(size=8) IDX_SUB_BLOCK[2])

	uint(size=16) CUInfo,
	uint(size=2)  IsBiPredOrLx,
	int (size=32) Mv,
	uint(size=4)  PartMode,
	int (size=16) Poc,
	uint(size=3)  RefIdx,
	int (size=16) RefList,
	uint(size=8)  Sample,
	uint(size=2)  SliceType,
	int (size=16) WeightedPredSe // is size correct ?
		==>
	uint(size=8) PredSample
		:

	uint(size=8) SZ_REF_LIST = 16;

	uint(size=2) HALF_PIX_1ST_PART = 1;
	uint(size=2) HALF_PIX_2ND_PART = 2;

	bool IS_2ND_PART_PRED;

	int shift1 = 6;
	/* Fix me !! */
	uint(size=4) bitDepth = 8;
	uint(size=10) maxPixVal = (1<<bitDepth)-1;

	uint(size=2) LUMA_COMP   = 1;
	uint(size=2) CHROMA_COMP = 2;
	uint(size=2) ALL_COMP    = 3;


	int(size=16)  currPoc;
	uint(size=2)  listIdx;

	uint(size=7)  iLoop;
	uint(size=7)  jLoop;
	
	uint(size=13)  numPixToGet;
	uint(size=13)  pixIdx;

	uint(size=2)  compIdx;
	int (size=16) refListX[2][SZ_REF_LIST];
	uint(size=2)  wpIdc;
	uint(size=4)  numRefIdxLxAct[2];
	bool          isBSlice;
	uint(size=4)  refIdxLxAct;
	uint(size=3)  log2WeightDenom[3];
	int           weight[SZ_REF_LIST][2][3];
	int           offset[SZ_REF_LIST][2][3];

	uint(size=3)  numPartDecoded;
	uint(size=3)  numPart;
	uint(size=7)  puSize[2];
	uint(size=7)  puSizeChr[2];
	uint(size=7)  fullPuSize[2];
	uint(size=7)  fullPuSizeChr[2];
	uint(size=5)  cuMode;
	uint(size=7)  subPuIdxMin[2][2];
	uint(size=7)  subPuIdxMax[2][2];
	uint(size=7)  subPuSize[2][2];

	int           logWD[3];
	int           weightCu[3][2];
	int           offsetCu[3][2];
	uint(size=2)  isBiPredOrLx;
	int (size=4)  refIdxLx[2];
	int (size=32) mvLx[2][2];
	uint(size=2)  numList;
	int           logWDTab[SZ_REF_LIST+1][SZ_REF_LIST+1][3];
	int           weightCuTab[SZ_REF_LIST+1][SZ_REF_LIST+1][3][2];
	int           offsetCuTab[SZ_REF_LIST+1][SZ_REF_LIST+1][3][2];

	int (size=16) predSampLuma[2][64+7][64+7];
	int (size=16) predSampChr[2][2][32+3][32+3];

	uint(size=2) intermOff;

	/* Coefficients used for the 8-tap filter (luma component) and 4-tap filter
	 * (chroma component).
	 */
	int(size=8) interPredCoeff[3][8][8] = 
	[
		[//LumaCoeff
		[ 0, 0,   0,  0,  0,   0, 0,  0],
		[-1, 4, -10, 58, 17,  -5, 1,  0],
		[-1, 4, -11, 40, 40, -11, 4, -1],
		[ 0, 1,  -5, 17, 58, -10, 4, -1]],
		[//ChromaCoeff
		[ 0,  0,  0,  0],
		[-2, 58, 10, -2],
		[-4, 54, 16, -2],
		[-6, 46, 28, -4],
		[-4, 36, 36, -4],
		[-4, 28, 46, -6],
		[-2, 16, 54, -4],
		[-2, 10, 58, -2]],
		[//ChromaCoeff
		[ 0,  0,  0,  0],
		[-2, 58, 10, -2],
		[-4, 54, 16, -2],
		[-6, 46, 28, -4],
		[-4, 36, 36, -4],
		[-4, 28, 46, -6],
		[-2, 16, 54, -4],
		[-2, 10, 58, -2]]
	];

	/* 8-tap filter. */
	procedure predictionFilteringLuma(bool isHoriz, int rdCoord[2], int wrCoord[2],
		int(size=8) coeffIdx, int finalOffset, int finalShift)
	var
		int pixVal := finalOffset,
		int xRd = rdCoord[0],
		int yRd = rdCoord[1]
	begin
		/* We get the  8 pixels needed for the filter and
		 * we multiply these values with some coefficients. These coefficients
		 * depend on the movement vector (if it's equal to a 8th, 4th or half
		 * of pixel).
		 */
		if(isHoriz) then
			pixVal := pixVal +
				if(coeffIdx = 1) then
					-    predSampLuma[listIdx][xRd  ][yRd] +  4*predSampLuma[listIdx][xRd+1][yRd]
					- 10*predSampLuma[listIdx][xRd+2][yRd] + 58*predSampLuma[listIdx][xRd+3][yRd]
					+ 17*predSampLuma[listIdx][xRd+4][yRd] -  5*predSampLuma[listIdx][xRd+5][yRd]
					+    predSampLuma[listIdx][xRd+6][yRd]
				else if(coeffIdx = 2) then
					-    predSampLuma[listIdx][xRd][yRd]   +  4*predSampLuma[listIdx][xRd+1][yRd]
					- 11*predSampLuma[listIdx][xRd+2][yRd] + 40*predSampLuma[listIdx][xRd+3][yRd]
					+ 40*predSampLuma[listIdx][xRd+4][yRd] - 11*predSampLuma[listIdx][xRd+5][yRd]
					+  4*predSampLuma[listIdx][xRd+6][yRd] -    predSampLuma[listIdx][xRd+7][yRd]
				else
					      predSampLuma[listIdx][xRd+1][yRd] - 5*predSampLuma[listIdx][xRd+2][yRd]
					 + 17*predSampLuma[listIdx][xRd+3][yRd] + 58*predSampLuma[listIdx][xRd+4][yRd]
					 - 10*predSampLuma[listIdx][xRd+5][yRd] + 4*predSampLuma[listIdx][xRd+6][yRd]
					 -    predSampLuma[listIdx][xRd+7][yRd]
				end end;
			/*foreach int idx in 0 .. 7
			do
				pixVal := pixVal +  interPredCoeff[0][coeffIdx][idx] *
					predSampLuma[listIdx][xRd+idx][yRd];
			end*/
		else
			pixVal := pixVal +
				if(coeffIdx = 1) then
					-    predSampLuma[listIdx][xRd][yRd]   +  4*predSampLuma[listIdx][xRd][yRd+1]
					- 10*predSampLuma[listIdx][xRd][yRd+2] + 58*predSampLuma[listIdx][xRd][yRd+3]
					+ 17*predSampLuma[listIdx][xRd][yRd+4] -  5*predSampLuma[listIdx][xRd][yRd+5]
					+    predSampLuma[listIdx][xRd][yRd+6]
				else if(coeffIdx = 2) then
					-    predSampLuma[listIdx][xRd][yRd]   +  4*predSampLuma[listIdx][xRd][yRd+1]
					- 11*predSampLuma[listIdx][xRd][yRd+2] + 40*predSampLuma[listIdx][xRd][yRd+3]
					+ 40*predSampLuma[listIdx][xRd][yRd+4] - 11*predSampLuma[listIdx][xRd][yRd+5]
					+  4*predSampLuma[listIdx][xRd][yRd+6] -    predSampLuma[listIdx][xRd][yRd+7]
				else
					      predSampLuma[listIdx][xRd][yRd+1] -  5*predSampLuma[listIdx][xRd][yRd+2]
					 + 17*predSampLuma[listIdx][xRd][yRd+3] + 58*predSampLuma[listIdx][xRd][yRd+4]
					 - 10*predSampLuma[listIdx][xRd][yRd+5] +  4*predSampLuma[listIdx][xRd][yRd+6]
					 -    predSampLuma[listIdx][xRd][yRd+7]
				end end;
			/*foreach int idx in 0 .. 7
			do
				pixVal := pixVal +  interPredCoeff[0][coeffIdx][idx] *
					predSampLuma[listIdx][xRd][yRd+idx];
			end*/
		end
		predSampLuma[listIdx][wrCoord[0]][wrCoord[1]] :=
			pixVal >> finalShift;
	end

	/* 4-tap filter. */
	procedure predictionFilteringChr(bool isHoriz, int rdCoord[2], int wrCoord[2],
		int(size=8) coeffIdx, int finalOffset, int finalShift, uint(size=2) cIdx)
	var
		int pixVal := finalOffset,
		int xRd = rdCoord[0],
		int yRd = rdCoord[1]
	begin
		/* We get the 4 pixels needed for the filter and
		 * we multiply these values with some coefficients. These coefficients
		 * depend on the movement vector (if it's equal to a 4th or half
		 * of pixel).
		 */
		if(isHoriz) then
			pixVal := pixVal	+ 
				if(coeffIdx = 1) then
					-  2*predSampChr[listIdx][cIdx-1][xRd]  [yRd] + 58*predSampChr[listIdx][cIdx-1][xRd+1][yRd]
					+ 10*predSampChr[listIdx][cIdx-1][xRd+2][yRd] -  2*predSampChr[listIdx][cIdx-1][xRd+3][yRd]
				else if(coeffIdx = 2) then
					-  4*predSampChr[listIdx][cIdx-1][xRd]  [yRd] + 54*predSampChr[listIdx][cIdx-1][xRd+1][yRd]
					+ 16*predSampChr[listIdx][cIdx-1][xRd+2][yRd] -  2*predSampChr[listIdx][cIdx-1][xRd+3][yRd]
				else if(coeffIdx = 3) then
					-  6*predSampChr[listIdx][cIdx-1][xRd]  [yRd] + 46*predSampChr[listIdx][cIdx-1][xRd+1][yRd]
					+ 28*predSampChr[listIdx][cIdx-1][xRd+2][yRd] -  4*predSampChr[listIdx][cIdx-1][xRd+3][yRd]
				else if(coeffIdx = 4) then
					-  4*predSampChr[listIdx][cIdx-1][xRd]  [yRd] + 36*predSampChr[listIdx][cIdx-1][xRd+1][yRd]
					+ 36*predSampChr[listIdx][cIdx-1][xRd+2][yRd] -  4*predSampChr[listIdx][cIdx-1][xRd+3][yRd]
				else if(coeffIdx = 5) then
					-  4*predSampChr[listIdx][cIdx-1][xRd]  [yRd] + 28*predSampChr[listIdx][cIdx-1][xRd+1][yRd]
					+ 46*predSampChr[listIdx][cIdx-1][xRd+2][yRd] -  6*predSampChr[listIdx][cIdx-1][xRd+3][yRd]
				else if(coeffIdx = 6) then
					-  2*predSampChr[listIdx][cIdx-1][xRd]  [yRd] + 16*predSampChr[listIdx][cIdx-1][xRd+1][yRd]
					+ 54*predSampChr[listIdx][cIdx-1][xRd+2][yRd] -  4*predSampChr[listIdx][cIdx-1][xRd+3][yRd]
				else
					-  2*predSampChr[listIdx][cIdx-1][xRd]  [yRd] + 10*predSampChr[listIdx][cIdx-1][xRd+1][yRd]
					+ 58*predSampChr[listIdx][cIdx-1][xRd+2][yRd] -  2*predSampChr[listIdx][cIdx-1][xRd+3][yRd]
				end end end end end end;
			/*foreach int idx in 0 .. 3
			do
				pixVal := pixVal +  interPredCoeff[1][coeffIdx][idx] *
					predSampChr[listIdx][cIdx-1][xRd+idx][yRd];
			end*/
		else
			pixVal := pixVal	+ 
				if(coeffIdx = 1) then
					-  2*predSampChr[listIdx][cIdx-1][xRd][yRd]   + 58*predSampChr[listIdx][cIdx-1][xRd][yRd+1]
					+ 10*predSampChr[listIdx][cIdx-1][xRd][yRd+2] -  2*predSampChr[listIdx][cIdx-1][xRd][yRd+3]
				else if(coeffIdx = 2) then
					-  4*predSampChr[listIdx][cIdx-1][xRd][yRd]   + 54*predSampChr[listIdx][cIdx-1][xRd][yRd+1]
					+ 16*predSampChr[listIdx][cIdx-1][xRd][yRd+2] -  2*predSampChr[listIdx][cIdx-1][xRd][yRd+3]
				else if(coeffIdx = 3) then
					-  6*predSampChr[listIdx][cIdx-1][xRd][yRd]   + 46*predSampChr[listIdx][cIdx-1][xRd][yRd+1]
					+ 28*predSampChr[listIdx][cIdx-1][xRd][yRd+2] -  4*predSampChr[listIdx][cIdx-1][xRd][yRd+3]
				else if(coeffIdx = 4) then
					-  4*predSampChr[listIdx][cIdx-1][xRd][yRd]   + 36*predSampChr[listIdx][cIdx-1][xRd][yRd+1]
					+ 36*predSampChr[listIdx][cIdx-1][xRd][yRd+2] -  4*predSampChr[listIdx][cIdx-1][xRd][yRd+3]
				else if(coeffIdx = 5) then
					-  4*predSampChr[listIdx][cIdx-1][xRd][yRd]   + 28*predSampChr[listIdx][cIdx-1][xRd][yRd+1]
					+ 46*predSampChr[listIdx][cIdx-1][xRd][yRd+2] -  6*predSampChr[listIdx][cIdx-1][xRd][yRd+3]
				else if(coeffIdx = 6) then
					-  2*predSampChr[listIdx][cIdx-1][xRd][yRd]   + 16*predSampChr[listIdx][cIdx-1][xRd][yRd+1]
					+ 54*predSampChr[listIdx][cIdx-1][xRd][yRd+2] -  4*predSampChr[listIdx][cIdx-1][xRd][yRd+3]
				else
					-  2*predSampChr[listIdx][cIdx-1][xRd][yRd]   + 10*predSampChr[listIdx][cIdx-1][xRd][yRd+1]
					+ 58*predSampChr[listIdx][cIdx-1][xRd][yRd+2] -  2*predSampChr[listIdx][cIdx-1][xRd][yRd+3]
				end end end end end end;
			/*foreach int idx in 0 .. 3
			do
				pixVal := pixVal +  interPredCoeff[1][coeffIdx][idx] *
					predSampChr[listIdx][cIdx-1][xRd][yRd+idx];
			end*/
		end
		predSampChr[listIdx][cIdx-1][wrCoord[0]][wrCoord[1]] :=
			pixVal >> finalShift;
	end

	procedure horizInterp(uint(size=7) fullPuIdxMax[2], int(size=8) puIdxMax[2], int mvQuartPix[2],
		uint(size=2) cIdx)
	var
		int(size=32) coord[2],
		int pixVal
	begin
		/* We get the 4 or 8 pixels needed for the filter and
		 * we multiply these values with some coefficients. These coefficients
		 * depend on the movement vector (if it's equal to a 8th, 4th or half
		 * of pixel).
		 */
		if(cIdx = 0) then
			if(mvQuartPix[1] = 0) then
				foreach int x in 0 .. puIdxMax[0]-1
				do
					foreach int y in 0 .. puIdxMax[1]-1
					do
						/* Horizontal interpolation */
						coord := [x, y+3];
						@inline
						predictionFilteringLuma(true, coord, [x, y], mvQuartPix[0], 0, 0);
					end
				end
			else if(mvQuartPix[0] = 1) then
				foreach int y in 0 .. fullPuIdxMax[1]-1
				do
					foreach int x in 0 .. puIdxMax[0]-1
					do
						pixVal := -8192 +
								-    predSampLuma[listIdx][x  ][y] +  4*predSampLuma[listIdx][x+1][y]
								- 10*predSampLuma[listIdx][x+2][y] + 58*predSampLuma[listIdx][x+3][y]
								+ 17*predSampLuma[listIdx][x+4][y] -  5*predSampLuma[listIdx][x+5][y]
								+    predSampLuma[listIdx][x+6][y];
						predSampLuma[listIdx][x][y] := pixVal;
					end
				end
			else if(mvQuartPix[0] = 2) then
				foreach int y in 0 .. fullPuIdxMax[1]-1
				do
					foreach int x in 0 .. puIdxMax[0]-1
					do
						pixVal := -8192 +
								-    predSampLuma[listIdx][x  ][y] +  4*predSampLuma[listIdx][x+1][y]
								- 11*predSampLuma[listIdx][x+2][y] + 40*predSampLuma[listIdx][x+3][y]
								+ 40*predSampLuma[listIdx][x+4][y] - 11*predSampLuma[listIdx][x+5][y]
								+  4*predSampLuma[listIdx][x+6][y] -    predSampLuma[listIdx][x+7][y];
						predSampLuma[listIdx][x][y] := pixVal;
					end
				end
			else
				foreach int y in 0 .. fullPuIdxMax[1]-1
				do
					foreach int x in 0 .. puIdxMax[0]-1
					do
						pixVal := -8192 +
								      predSampLuma[listIdx][x+1][y] -  5*predSampLuma[listIdx][x+2][y]
								 + 17*predSampLuma[listIdx][x+3][y] + 58*predSampLuma[listIdx][x+4][y]
								 - 10*predSampLuma[listIdx][x+5][y] +  4*predSampLuma[listIdx][x+6][y]
								 -    predSampLuma[listIdx][x+7][y];
						predSampLuma[listIdx][x][y] := pixVal;
					end
				end
			end end end
		else
			if(mvQuartPix[1] = 0) then
				foreach int x in 0 .. puIdxMax[0]-1
				do
					foreach int y in 0 .. puIdxMax[1]-1
					do
						coord := [x, y+1];
						@inline
						predictionFilteringChr(true, coord, [x, y], mvQuartPix[0], 0, 0, cIdx);
					end
				end
			else if(mvQuartPix[0] = 1) then
				foreach int y in 0 .. fullPuIdxMax[1]-1
				do
					foreach int x in 0 .. puIdxMax[0]-1
					do
						pixVal := -8192	+ 
								-  2*predSampChr[listIdx][cIdx-1][x]  [y] + 58*predSampChr[listIdx][cIdx-1][x+1][y]
								+ 10*predSampChr[listIdx][cIdx-1][x+2][y] -  2*predSampChr[listIdx][cIdx-1][x+3][y];
						predSampChr[listIdx][cIdx-1][x][y] := pixVal;
					end
				end
			else if(mvQuartPix[0] = 2) then
				foreach int y in 0 .. fullPuIdxMax[1]-1
				do
					foreach int x in 0 .. puIdxMax[0]-1
					do
						pixVal := -8192;
						pixVal := pixVal	+ 
								-  4*predSampChr[listIdx][cIdx-1][x]  [y] + 54*predSampChr[listIdx][cIdx-1][x+1][y]
								+ 16*predSampChr[listIdx][cIdx-1][x+2][y] -  2*predSampChr[listIdx][cIdx-1][x+3][y];
						predSampChr[listIdx][cIdx-1][x][y] := pixVal;
					end
				end
			else if(mvQuartPix[0] = 3) then
				foreach int y in 0 .. fullPuIdxMax[1]-1
				do
					foreach int x in 0 .. puIdxMax[0]-1
					do
						pixVal := -8192	+ 
								-  6*predSampChr[listIdx][cIdx-1][x]  [y] + 46*predSampChr[listIdx][cIdx-1][x+1][y]
								+ 28*predSampChr[listIdx][cIdx-1][x+2][y] -  4*predSampChr[listIdx][cIdx-1][x+3][y];
						predSampChr[listIdx][cIdx-1][x][y] := pixVal;
					end
				end
			else if(mvQuartPix[0] = 4) then
				foreach int y in 0 .. fullPuIdxMax[1]-1
				do
					foreach int x in 0 .. puIdxMax[0]-1
					do
						pixVal := -8192	+ 
								-  4*predSampChr[listIdx][cIdx-1][x]  [y] + 36*predSampChr[listIdx][cIdx-1][x+1][y]
								+ 36*predSampChr[listIdx][cIdx-1][x+2][y] -  4*predSampChr[listIdx][cIdx-1][x+3][y];
						predSampChr[listIdx][cIdx-1][x][y] := pixVal;
					end
				end
			else if(mvQuartPix[0] = 5) then
				foreach int y in 0 .. fullPuIdxMax[1]-1
				do
					foreach int x in 0 .. puIdxMax[0]-1
					do
						pixVal := -8192	+ 
								-  4*predSampChr[listIdx][cIdx-1][x]  [y] + 28*predSampChr[listIdx][cIdx-1][x+1][y]
								+ 46*predSampChr[listIdx][cIdx-1][x+2][y] -  6*predSampChr[listIdx][cIdx-1][x+3][y];
						predSampChr[listIdx][cIdx-1][x][y] := pixVal;
					end
				end
			else if(mvQuartPix[0] = 6) then
				foreach int y in 0 .. fullPuIdxMax[1]-1
				do
					foreach int x in 0 .. puIdxMax[0]-1
					do
						pixVal := -8192	+ 
								-  2*predSampChr[listIdx][cIdx-1][x]  [y] + 16*predSampChr[listIdx][cIdx-1][x+1][y]
								+ 54*predSampChr[listIdx][cIdx-1][x+2][y] -  4*predSampChr[listIdx][cIdx-1][x+3][y];
						predSampChr[listIdx][cIdx-1][x][y] := pixVal;
					end
				end
			else
				foreach int y in 0 .. fullPuIdxMax[1]-1
				do
					foreach int x in 0 .. puIdxMax[0]-1
					do
						pixVal := -8192	+ 
								-  2*predSampChr[listIdx][cIdx-1][x]  [y] + 10*predSampChr[listIdx][cIdx-1][x+1][y]
								+ 58*predSampChr[listIdx][cIdx-1][x+2][y] -  2*predSampChr[listIdx][cIdx-1][x+3][y];
						predSampChr[listIdx][cIdx-1][x][y] := pixVal;
					end
				end
			end end end end end end end
		end
	end

	procedure vertInterpLuma(int mvQuartPix[2], int(size=8) puIdxMax[2])
	var
		int(size=32) coord[2],
		int(size=32) pixValue
	begin
		if(mvQuartPix[0] != 0) then
			foreach int x in 0 .. puIdxMax[0]-1
			do
				foreach int y in 0 .. puIdxMax[1]-1
				do
					pixValue := 524288;
					/* Then we do the vertical interpolation with the result from the
					 * previous part.
					 */
					pixValue := pixValue +
						if(mvQuartPix[1] = 1) then
							-    predSampLuma[listIdx][x][y  ] +  4*predSampLuma[listIdx][x][y+1]
							- 10*predSampLuma[listIdx][x][y+2] + 58*predSampLuma[listIdx][x][y+3]
							+ 17*predSampLuma[listIdx][x][y+4] -  5*predSampLuma[listIdx][x][y+5]
							+    predSampLuma[listIdx][x][y+6]
						else if(mvQuartPix[1] = 2) then
							-    predSampLuma[listIdx][x][y]   +  4*predSampLuma[listIdx][x][y+1]
							- 11*predSampLuma[listIdx][x][y+2] + 40*predSampLuma[listIdx][x][y+3]
							+ 40*predSampLuma[listIdx][x][y+4] - 11*predSampLuma[listIdx][x][y+5]
							+  4*predSampLuma[listIdx][x][y+6] -    predSampLuma[listIdx][x][y+7]
						else
							     predSampLuma[listIdx][x][y+1] -  5*predSampLuma[listIdx][x][y+2]
							+ 17*predSampLuma[listIdx][x][y+3] + 58*predSampLuma[listIdx][x][y+4]
							- 10*predSampLuma[listIdx][x][y+5] +  4*predSampLuma[listIdx][x][y+6]
							-    predSampLuma[listIdx][x][y+7]
						end end;
					/*foreach int idx in 0 .. 7
					do
						pixValue := pixValue +  interPredCoeff[0][mvQuartPix[1]][idx]
							* predSampLuma[listIdx][x][y+idx];
					end*/
					predSampLuma[listIdx][x][y] := pixValue >> 6;
				end
			end
		else
			foreach int x in 0 .. puIdxMax[0]-1
			do
				foreach int y in 0 .. puIdxMax[1]-1
				do
					/* Vertical interpolation */
					if((PROCESS_MODE_HALF_PIX & HALF_PIX_1ST_PART) != 0) then
						coord := [x+3, y];
					else
						coord := [x, y];
					end
					@inline
					predictionFilteringLuma(false, coord, [x, y], mvQuartPix[1], 0, 0);
				end
			end
		end
	end

	procedure vertInterpChr(int mvQuartPix[2], int(size=8) puIdxMax[2],
		uint(size=2) cIdx)
	var
		int(size=32) coord[2],
		int(size=32) pixValue
	begin
		if(mvQuartPix[0]=0) then /* Vertical interpolation */
			foreach int x in 0 .. puIdxMax[0]-1
			do
				foreach int y in 0 .. puIdxMax[1]-1
				do
					if((PROCESS_MODE_HALF_PIX & HALF_PIX_1ST_PART) != 0) then
						coord := [x+1, y];
					else
						coord := [x, y];
					end
					@inline
					predictionFilteringChr(false, coord, [x, y], mvQuartPix[1], 0, 0, cIdx);
				end
			end
		else
			foreach int x in 0 .. puIdxMax[0]-1
			do
				foreach int y in 0 .. puIdxMax[1]-1
				do

					pixValue := 524288;
					/* Then we do the vertical interpolation with the result from the
					 * previous part.
					 */
					foreach int idx in 0 .. 3
					do
						pixValue := pixValue +  interPredCoeff[cIdx][mvQuartPix[1]]
							[idx] * predSampChr[listIdx][cIdx-1][x][y+idx];
					end
					predSampChr[listIdx][cIdx-1][x][y] := pixValue >> 6;
				end
			end
		end
	end

	procedure vertInterp(int mvQuartPix[2], int(size=8) puIdxMax[2], uint(size=2) cIdx)
	begin
		if(cIdx = 0) then	
			vertInterpLuma(mvQuartPix, puIdxMax);
		else
			vertInterpChr(mvQuartPix, puIdxMax, cIdx);
		end
	end
	/* Computing the weighted prediction of the current pixel */
	/* CLEAN ME */
	procedure weightedPred(uint(size=2) cIdx, uint(size=7) puIdxMax[2], uint(size=2)  numList,
		uint(size=2) isBiPredOrLx, uint(size=2)  wpIdc, int weightCu[3][2], int offsetCu[3][2],
		int logWD[3])
	var
		uint(size=1) rdList = if(isBiPredOrLx = PRED_L1) then 1 else 0 end,
		int wX,
		int oX,
		int locLogWD,
		int w0,
		int w1,
		int o0,
		int o1
	begin
		if(cIdx = 0) then
			/* If we have a mono-prediction */
			if(numList = 1) then
				if(wpIdc = 0) then
					foreach int y in 0 .. puIdxMax[1]-1
					do
						foreach int x in 0 .. puIdxMax[0]-1
						do
							/* When we don't have a weighted prediction, we do the
							 * average.
							 */
							predSampLuma[0][x][y] := (predSampLuma[rdList][x][y] + (1 <<(shift1-1)))>>shift1;
							/* We apply a threashold according to bitDepth
							 * (which is equal to 8, 10 or 12 bits).
							 */
							predSampLuma[0][x][y] := clip_i32(predSampLuma[0][x][y], 0 , maxPixVal);
						end
					end
				else
					foreach int y in 0 .. puIdxMax[1]-1
					do
						foreach int x in 0 .. puIdxMax[0]-1
						do
							/* If we had a bi-prediction both pictures used and movement
							 * vectors where identical
							 */
							if(isBiPredOrLx != BI_PRED) then
								/* We use the bi-prediction way */
								wX := weightCu[cIdx][rdList];
								oX := offsetCu[cIdx][rdList];
								locLogWD := logWD[cIdx];
								predSampLuma[0][x][y] :=
									if(locLogWD >= 1) then
										((predSampLuma[rdList][x][y]*wX + (1<<(locLogWD-1))) >> locLogWD)+oX
									else
										predSampLuma[rdList][x][y]*wX +oX
									end;
							else
								/* Weighted prediction for mono-prediction. */
								wX := weightCu[cIdx][0] + weightCu[cIdx][1];
								oX := offsetCu[cIdx][0] + offsetCu[cIdx][1] +1;
								locLogWD := logWD[cIdx] +1;
								predSampLuma[0][x][y] := ((predSampLuma[0][x][y]*wX + (oX<<(locLogWD-1))) >>locLogWD);
							end
							/* We apply a threashold according to bitDepth
							 * (which is equal to 8, 10 or 12 bits).
							 */
							predSampLuma[0][x][y] := clip_i32(predSampLuma[0][x][y], 0 , maxPixVal);
						end
					end
				end
			/* If we have a bi-prediction */
			else
				if(wpIdc = 0) then
					foreach int y in 0 .. puIdxMax[1]-1
					do
						foreach int x in 0 .. puIdxMax[0]-1
						do
							/* When we don't have a weighted prediction, we do the average
							 * of both pixels.
							 */
							predSampLuma[0][x][y] := (predSampLuma[0][x][y] + predSampLuma[1][x][y] + 64)
								>> 7;
							/* We apply a threshold according to bitDepth
							 * (which is equal to 8, 10 or 12 bits).
							 */
							predSampLuma[0][x][y] := clip_i32(predSampLuma[0][x][y], 0 ,
								maxPixVal);
						end
					end
				else /* When we have weighted prediction for bi-prediction */
					foreach int y in 0 .. puIdxMax[1]-1
					do
						foreach int x in 0 .. puIdxMax[0]-1
						do
							/* Then we realize the weighted prediction with the pixel
							 * values and the coefficients.
							 */
							w0 := weightCu[cIdx][0];
							w1 := weightCu[cIdx][1];
							o0 := offsetCu[cIdx][0];
							o1 := offsetCu[cIdx][1];
							locLogWD := logWD[cIdx];
							predSampLuma[0][x][y] := (predSampLuma[0][x][y]*w0 + predSampLuma[1][x][y]*w1 +
								((o0+o1+1)<<locLogWD))>>(locLogWD+1);
							/* We apply a threashold according to bitDepth
							 * (which is equal to 8, 10 or 12 bits).
							 */
							predSampLuma[0][x][y] := clip_i32(predSampLuma[0][x][y], 0 ,
								maxPixVal);
						end
					end
				end
			end
		else
			foreach int y in 0 .. puIdxMax[1]-1
			do
				foreach int x in 0 .. puIdxMax[0]-1
				do
					if(numList = 1) then
						if(wpIdc = 0) then
							predSampChr[0][cIdx-1][x][y] := (predSampChr[rdList][cIdx-1][x][y] + (1 <<(shift1-1)))>>shift1;
						else
							if(isBiPredOrLx != BI_PRED) then
								wX := weightCu[cIdx][rdList];
								oX := offsetCu[cIdx][rdList];
								locLogWD := logWD[cIdx];
								predSampChr[0][cIdx-1][x][y] :=
									if(locLogWD >= 1) then
										((predSampChr[rdList][cIdx-1][x][y]*wX + (1<<(locLogWD-1))) >> locLogWD)+oX
									else
										predSampChr[rdList][cIdx-1][x][y]*wX +oX
									end;
							else
								wX := weightCu[cIdx][0] + weightCu[cIdx][1];
								oX := offsetCu[cIdx][0] + offsetCu[cIdx][1] +1;
								locLogWD := logWD[cIdx] +1;
								predSampChr[0][cIdx-1][x][y] := ((predSampChr[0][cIdx-1][x][y]*wX + (oX<<(locLogWD-1))) >>locLogWD);
							end
						end
						predSampChr[0][cIdx-1][x][y] := clip_i32(predSampChr[0][cIdx-1][x][y], 0 , maxPixVal);
					else
						if(wpIdc = 0) then
							predSampChr[0][cIdx-1][x][y] := (predSampChr[0][cIdx-1][x][y] + predSampChr[1][cIdx-1][x][y] + 64)
								>> 7;
							predSampChr[0][cIdx-1][x][y] := clip_i32(predSampChr[0][cIdx-1][x][y], 0 ,
								maxPixVal);
						else
							w0 := weightCu[cIdx][0];
							w1 := weightCu[cIdx][1];
							o0 := offsetCu[cIdx][0];
							o1 := offsetCu[cIdx][1];
							locLogWD := logWD[cIdx];
							predSampChr[0][cIdx-1][x][y] := (predSampChr[0][cIdx-1][x][y]*w0 + predSampChr[1][cIdx-1][x][y]*w1 +
								((o0+o1+1)<<locLogWD))>>(locLogWD+1);
							predSampChr[0][cIdx-1][x][y] := clip_i32(predSampChr[0][cIdx-1][x][y], 0 ,
								maxPixVal);
						end
					end
				end
			end
		end
	end

	/* Computing the weighted prediction coefficients (logWd, w0, w1, o0, o1),
	 * according to the picture(s) used for the prediction.
	 */
	procedure computeWeights(int refIdxL0, int refIdxL1)
	var
		int(size=16) pocL0,
		int(size=16) pocL1,
		int          tb,
		int          td,
		int          tx,
		int          weightScalFact,
		int          w0,
		int          w1,
		uint(size=3) idxL0 = refIdxL0+1,
		uint(size=3) idxL1 = refIdxL1+1,
		uint(size=2) COMP_MIN = if((DECODE_COMP & LUMA_COMP) = 0) then 1 else 0 end,
		uint(size=2) COMP_MAX = if((DECODE_COMP & CHROMA_COMP) != 0) then 2 else 0 end
	begin
		/*Implicit weighted prediction : we compute the weights thanks the the
		 * poc value of the reference pictures
		 */
		if(wpIdc = 2) then
			if(refIdxL0 >=0 && refIdxL1 >= 0) then
				if(refIdxL0>=0) then
					pocL0 := refListX[0][refIdxL0];
				end
				if(refIdxL1>=0) then
					pocL1 := refListX[1][refIdxL1];
				end
				tb := clip_i32(currPoc- pocL0, -128, 127);
				td := clip_i32(pocL1-pocL0, -128, 127);
				if(td != 0) then
					tx := (16384 + (abs(td)>>1))/td;
					weightScalFact := clip_i32((tb*tx +32)>>6, -1024, 1023);
				end
				if(pocL0 = pocL1 || (weightScalFact>>2)<-64 ||
					(weightScalFact>>2)>128) then
					w0 := 32;
					w1 := 32;
				else
					w0 := 64 - (weightScalFact>>2);
					w1 := weightScalFact>>2;
				end
				foreach int component in COMP_MIN .. COMP_MAX
				do
					logWDTab[idxL0][idxL1][component] := 5+shift1;
					offsetCuTab[idxL0][idxL1][component][0] := 0;
					offsetCuTab[idxL0][idxL1][component][1] := 0;
					weightCuTab[idxL0][idxL1][component][0] := w0;
					weightCuTab[idxL0][idxL1][component][1] := w1;
				end
			else
				foreach int component in COMP_MIN .. COMP_MAX
				do
					logWDTab[idxL0][idxL1][component] := shift1;
					offsetCuTab[idxL0][idxL1][component][0] := 0;
					offsetCuTab[idxL0][idxL1][component][1] := 0;
					weightCuTab[idxL0][idxL1][component][0] := 1;
					weightCuTab[idxL0][idxL1][component][1] := 1;
				end
			end
		/*Explicit weighted prediction : we get the coefficients thanks to the
		 * predWeight table (decoded at the beginning of each slice).
		 */
		else if (wpIdc = 1) then
			foreach int component in COMP_MIN .. COMP_MAX
			do
				logWDTab[idxL0][idxL1][component] := log2WeightDenom[component] + shift1;
				if(refIdxL0 >=0) then
					weightCuTab[idxL0][idxL1][component][0] := weight[refIdxL0][0][component];
					offsetCuTab[idxL0][idxL1][component][0] := offset[refIdxL0][0][component];
				end
				if(refIdxL1 >=0) then
					weightCuTab[idxL0][idxL1][component][1] := weight[refIdxL1][1][component];
					offsetCuTab[idxL0][idxL1][component][1] := offset[refIdxL1][1][component];
				end
			end
		end end
	end

	initialize ==>
	do
		IS_2ND_PART_PRED := (PROCESS_MODE_HALF_PIX & HALF_PIX_2ND_PART) != 0;
		if(PROCESS_MODE_HALF_PIX = 3 && (LOG2_NUM_SUB_BLK[0] != 0 || LOG2_NUM_SUB_BLK[1] != 0)) then
			print(" Warning in InterPrediction : Using SubBlk with no pre-computing for Half/Quarter Pix.");
			println(" There will be more interpolation than needed.");
		end
	end

	/* We have a new slice, we will update differents value then get the new
	 * refList and weights
	 */
	isNewSlice.notDep: action PartMode:[partMode], Poc:[poc], SliceType:[sliceType],
		WeightedPredSe:[weightPredIdc] ==>
	guard
		partMode = PART_MODE_SLICE_INDEP ||
		partMode = PART_MODE_PICT
	do
		isBSlice := sliceType = B_SLICE;
		currPoc  := poc;
		wpIdc    := weightPredIdc;
		listIdx  := 0;
	end

	isNewSlice.dep: action PartMode:[partMode] ==>
	guard
		partMode = PART_MODE_SLICE_DEP
	end

	/* We have a New Cu in the Slice */
	getPartMode: action PartMode:[partMode] ==>
	guard
		partMode != PART_MODE_SLICE_DEP && partMode != PART_MODE_SLICE_INDEP &&
		partMode != PART_MODE_PICT
	do
		numPart := partModeToNumPart[partMode];
		numPartDecoded := 0;
	end

	/** Getting the size of each reference list  **/
	getSizeRefList.launch: action RefList:[sizeList] ==>
	guard
		listIdx < 2
	do
		numRefIdxLxAct[listIdx] := sizeList;
		iLoop := 0;
	end

	getSizeRefList.done: action ==>
	guard
		listIdx = 2
	end

	/** Getting the poc contained in each reference list **/
	getRefList.launch: action RefList:[refPoc] ==>
	guard
		iLoop < numRefIdxLxAct[listIdx]
	do
		refListX[listIdx][iLoop] := refPoc;
		iLoop := iLoop + 1;
	end

	getRefList.done: action ==>
	guard
		iLoop = numRefIdxLxAct[listIdx]
	do
		listIdx := listIdx + 1;
	end

	/* Getting the syntax elements for the weighted prediction when we have
	 * weighted prediction in explicit mode
	 */
	getWeightDenom.launch: action WeightedPredSe:[weightDenom] repeat 2 ==>
	guard
		wpIdc = 1
	do
		listIdx := 0;
		log2WeightDenom[0] := weightDenom[0];
		log2WeightDenom[1] := weightDenom[0] + weightDenom[1];
		log2WeightDenom[2] := weightDenom[0] + weightDenom[1];
	end

	getWeightDenom.skip: action ==>
	guard
		wpIdc != 1
	do
		if(wpIdc = 2) then
			foreach int idxL0 in -1 .. numRefIdxLxAct[0]-1
			do
				foreach int idxL1 in -1 .. numRefIdxLxAct[1]-1
				do
					computeWeights(idxL0, idxL1);
				end
			end
		end
	end

	getWeightLX.launch: action ==>
	guard
		listIdx = 0 || listIdx = 1 && isBSlice
	do
		iLoop := 0;
		if(listIdx = 0) then
			refIdxLxAct := numRefIdxLxAct[0];
		else
			refIdxLxAct := numRefIdxLxAct[1];
		end
	end

	getWeightLX.skip: action ==>
	guard
		listIdx != 2
	do
		listIdx := listIdx + 1;
	end

	getWeightLX.done: action ==>
	guard
		listIdx = 2
	do
		foreach int idxL0 in -1 .. numRefIdxLxAct[0]-1
		do
			foreach int idxL1 in -1 .. numRefIdxLxAct[1]-1
			do
				computeWeights(idxL0, idxL1);
			end
		end
	end

	getLumaWeightLX.launch: action WeightedPredSe:[lumWeightFlag] ==>
	guard
		iLoop < refIdxLxAct
	do
		weight[iLoop][listIdx][0] := lumWeightFlag;
		iLoop := iLoop + 1;
	end

	getLumaWeightLX.done: action ==>
	guard
		iLoop = refIdxLxAct
	do
		iLoop := 0;
	end

	getChromaWeightLX.launch: action WeightedPredSe:[chrWeightFlag] ==>
	guard
		iLoop < refIdxLxAct
	do
		weight[iLoop][listIdx][1] := chrWeightFlag;
		iLoop := iLoop + 1;
	end

	getChromaWeightLX.done: action ==>
	guard
		iLoop = refIdxLxAct
	do
		iLoop := 0;
	end

	getDeltaLumaWeight.launch: action WeightedPredSe:[wpSyntElem] repeat 2 ==>
	guard
		iLoop < refIdxLxAct && weight[iLoop][listIdx][0] != 0
	do
		weight[iLoop][listIdx][0] := (1<<log2WeightDenom[0]) + wpSyntElem[0];
		offset[iLoop][listIdx][0] := wpSyntElem[1];
	end

	getDeltaLumaWeight.skip: action ==>
	guard
		iLoop < refIdxLxAct && weight[iLoop][listIdx][0] = 0
	do
		weight[iLoop][listIdx][0] := (1<<log2WeightDenom[0]);
		offset[iLoop][listIdx][0] := 0;
	end

	getDeltaLumaWeight.done: action ==>
	guard
		iLoop = refIdxLxAct
	do
		iLoop := 0;
		listIdx := listIdx + 1;
	end

	getDeltaChromaWeight.launch: action WeightedPredSe:[wpSyntElem] repeat 4 ==>
	guard
		weight[iLoop][listIdx][1] != 0
	var
		int offPred
	do
		weight[iLoop][listIdx][1] := (1<<log2WeightDenom[1]) + wpSyntElem[0];
		offPred := 128 - (128*weight[iLoop][listIdx][1] >> log2WeightDenom[1]);
		offset[iLoop][listIdx][1] := clip_i32(offPred+wpSyntElem[1], -128, 127);

		weight[iLoop][listIdx][2] := (1<<log2WeightDenom[2]) + wpSyntElem[2];
		offPred := 128 - (128*weight[iLoop][listIdx][2] >> log2WeightDenom[2]);
		offset[iLoop][listIdx][2] := clip_i32(offPred+wpSyntElem[3], -128, 127);

		iLoop := iLoop + 1;
	end

	getDeltaChromaWeight.skip: action ==>
	guard
		weight[iLoop][listIdx][1] = 0
	do
		weight[iLoop][listIdx][1] := (1<<log2WeightDenom[1]);
		offset[iLoop][listIdx][1] := 0;
		weight[iLoop][listIdx][2] := (1<<log2WeightDenom[2]);
		offset[iLoop][listIdx][2] := 0;
		iLoop := iLoop + 1;
	end

	/* Get the size of each part of the current Cu. */
	getCuInfo.launch: action CUInfo:[cuInfo] repeat 5 ==>
	guard
		numPartDecoded < numPart
	do
		cuMode := cuInfo[0];
		puSize     := [cuInfo[i] : for int i in 3 .. 4];
		puSizeChr  := [cuInfo[i]>>1 : for int i in 3 .. 4];
		fullPuSize := [cuInfo[i] + 7 : for int i in 3 .. 4];
		fullPuSizeChr := [(cuInfo[i]>>1) + 3 : for int i in 3 .. 4];
		if((PROCESS_MODE_HALF_PIX & HALF_PIX_1ST_PART) != 0) then
			numPixToGet := fullPuSize[0] * fullPuSize[1];
		else
			numPixToGet := puSize[0] * fullPuSize[1];
		end
		pixIdx := 0;
		numPartDecoded := numPartDecoded + 1;
	end

	getCuInfo.done: action ==>
	guard
		numPartDecoded = numPart
	end

	/* We launch the InterPrediction code only if we have an
	 * inter prediction :)
	 */
	getCuMode.isNotInter: action ==>
	guard
		not(cuMode = INTER || cuMode = SKIP)
	end

	getCuMode.isInter: action IsBiPredOrLx:[isBiPredOrPredLX] ==>
	guard
		cuMode = INTER || cuMode = SKIP
	var
		uint(size=7) intermSize[2][2] = [[puSize[0], fullPuSize[1]],
			[puSizeChr[0], fullPuSizeChr[1]]],
		uint(size=5) nbBlkInPu,
		uint(size=5) numBlk,
		uint(size=5) blkRemain
	do
		isBiPredOrLx := isBiPredOrPredLX;

		if((LOG2_NUM_SUB_BLK[0] != 0 || LOG2_NUM_SUB_BLK[1] != 0)) then
			if(IS_2ND_PART_PRED) then
				foreach uint i in 0 .. 1
				do
					nbBlkInPu := puSize[i] >> 2;
					numBlk    := nbBlkInPu >> LOG2_NUM_SUB_BLK[i];
					blkRemain := nbBlkInPu - (numBlk << LOG2_NUM_SUB_BLK[i]);
					subPuIdxMin[0][i] := IDX_SUB_BLOCK[i] * numBlk;
					if(IDX_SUB_BLOCK[i] >= (1 << LOG2_NUM_SUB_BLK[i]) - blkRemain) then
						subPuIdxMin[0][i] := subPuIdxMin[0][i] + IDX_SUB_BLOCK[i]
							- (1 << LOG2_NUM_SUB_BLK[i]) + blkRemain;
						numBlk := numBlk + 1;
					end
					subPuIdxMax[0][i] := subPuIdxMin[0][i] + numBlk;
	
					subPuSize[0][i]   := numBlk << 2;
					subPuSize[1][i]   := numBlk << 1;
					subPuIdxMin[1][i] := subPuIdxMin[0][i] << 1;
					subPuIdxMax[1][i] := subPuIdxMax[0][i] << 1;
					subPuIdxMin[0][i] := subPuIdxMin[0][i] << 2;
					subPuIdxMax[0][i] := subPuIdxMax[0][i] << 2;
				end
			else
				foreach uint i in 0 .. 1
				do
					nbBlkInPu := intermSize[0][i];
					numBlk    := nbBlkInPu>> LOG2_NUM_SUB_BLK[i];
					blkRemain := nbBlkInPu - (numBlk << LOG2_NUM_SUB_BLK[i]);
					subPuIdxMin[0][i] := IDX_SUB_BLOCK[i] * numBlk;
					if(IDX_SUB_BLOCK[i] >= (1 << LOG2_NUM_SUB_BLK[i]) - blkRemain) then
						subPuIdxMin[0][i] := subPuIdxMin[0][i] + IDX_SUB_BLOCK[i]
							- (1 << LOG2_NUM_SUB_BLK[i]) + blkRemain;
						numBlk := numBlk + 1;
					end
					subPuIdxMax[0][i] := subPuIdxMin[0][i] + numBlk;
					subPuSize[0][i]   := numBlk;
				end
				foreach uint i in 0 .. 1
				do
					nbBlkInPu := intermSize[1][i];
					numBlk    := nbBlkInPu>> LOG2_NUM_SUB_BLK[i];
					blkRemain := nbBlkInPu - (numBlk << LOG2_NUM_SUB_BLK[i]);
					subPuIdxMin[1][i] := IDX_SUB_BLOCK[i] * numBlk;
					if(IDX_SUB_BLOCK[i] >= (1 << LOG2_NUM_SUB_BLK[i]) - blkRemain) then
						subPuIdxMin[1][i] := subPuIdxMin[1][i] + IDX_SUB_BLOCK[i]
							- (1 << LOG2_NUM_SUB_BLK[i]) + blkRemain;
						numBlk := numBlk + 1;
					end
					subPuIdxMax[1][i] := subPuIdxMin[1][i] + numBlk;
					subPuSize[1][i]   := numBlk;
				end
			end
		end
	end

	/* Getting the prediction components for mono or bi-prediction */
	getRefIdx.monoPred: action RefIdx:[refIndexLx], Mv:[mv] repeat 2 ==>
	guard
		isBiPredOrLx != BI_PRED
	var
		uint idxL0,
		uint idxL1,
		uint(size=2) COMP_MIN = if((DECODE_COMP & LUMA_COMP) = 0) then 1 else 0 end,
		uint(size=2) COMP_MAX = if((DECODE_COMP & CHROMA_COMP) != 0) then 2 else 0 end
	do
		if(isBiPredOrLx = PRED_L0) then
			mvLx[0] := [mv[i]:for int i in 0 .. 1];
			mvLx[1] := [0,0];
			refIdxLx := [refIndexLx, -1];
			listIdx := 0;
		else
			mvLx[1] := [mv[i]:for int i in 0 .. 1];
			mvLx[0] := [0,0];
			refIdxLx := [-1, refIndexLx];
			listIdx := 1;
		end
		idxL0 := refIdxLx[0]+1;
		idxL1 := refIdxLx[1]+1;
		foreach int component in COMP_MIN .. COMP_MAX
		do
			logWD[component] := logWDTab[idxL0][idxL1][component];
			foreach int list in 0 .. 1
			do
				weightCu[component][list] := weightCuTab[idxL0][idxL1][component][list];
				offsetCu[component][list] := offsetCuTab[idxL0][idxL1][component][list];
			end
		end
		numList := 1;
		iLoop   := 0;
		jLoop   := 0;
	end

	getRefIdx.biPred: action RefIdx:[refIndexLx] repeat 2, Mv:[mv] repeat 4 ==>
	guard
		isBiPredOrLx = BI_PRED
	var
		uint idxL0,
		uint idxL1,
		uint(size=2) COMP_MIN = if((DECODE_COMP & LUMA_COMP) = 0) then 1 else 0 end,
		uint(size=2) COMP_MAX = if((DECODE_COMP & CHROMA_COMP) != 0) then 2 else 0 end
	do
		mvLx := [[mv[2*i+j]:for uint j in 0 ..1]: for int i in 0 .. 1];
		refIdxLx := [refIndexLx[i]: for uint i in 0 .. 1];
		idxL0 := refIdxLx[0]+1;
		idxL1 := refIdxLx[1]+1;
		foreach int component in COMP_MIN .. COMP_MAX
		do
			logWD[component] := logWDTab[idxL0][idxL1][component];
			foreach int list in 0 .. 1
			do
				weightCu[component][list] := weightCuTab[idxL0][idxL1][component][list];
				offsetCu[component][list] := offsetCuTab[idxL0][idxL1][component][list];
			end
		end
		listIdx := 0;
		iLoop   := 0;
		jLoop   := 0;
		numList :=
			/* If we have the same picture with the same movement vectors we 
			 * don't need to do the same interpolation twice :)
			 */
			if(refListX[0][refIdxLx[0]] = refListX[1][refIdxLx[1]] &&
				mvLx[0][0] = mvLx[1][0] && mvLx[0][1] = mvLx[1][1]) then
				1
			else
				2
			end;
	end

	/* Getting the samples from the DPB and realizing the interpolation. */

	getSamples.luma.launch: action Sample:[sample] ==>
	guard
		pixIdx  < numPixToGet,
		(LOG2_NUM_SUB_BLK[0] = 0 && LOG2_NUM_SUB_BLK[1] = 0) ||
		IS_2ND_PART_PRED ||
		(iLoop >= subPuIdxMin[0][0] && jLoop >= subPuIdxMin[0][1] &&
		 iLoop <  subPuIdxMax[0][0]+7 && jLoop < subPuIdxMax[0][1]+3)
	do
		if(LOG2_NUM_SUB_BLK[0] = 0 && LOG2_NUM_SUB_BLK[1] = 0) then
			predSampLuma[listIdx][iLoop][jLoop] := sample;
		else if(not IS_2ND_PART_PRED) then
				predSampLuma[listIdx][iLoop - subPuIdxMin[0][0]][jLoop - subPuIdxMin[0][1]] := sample;
		else if(iLoop >= subPuIdxMin[0][0] && jLoop >= subPuIdxMin[0][1] &&
			    iLoop <  subPuIdxMax[0][0]+7 && jLoop <  subPuIdxMax[0][1]+7) then
				predSampLuma[listIdx][iLoop - subPuIdxMin[0][0]][jLoop - subPuIdxMin[0][1]] := sample;
		end end end

		pixIdx := pixIdx + 1;
		iLoop := iLoop + 1;
		if((PROCESS_MODE_HALF_PIX & HALF_PIX_1ST_PART) != 0) then
			if(iLoop = fullPuSize[0]) then
				iLoop := 0;
				jLoop := jLoop + 1;
			end
		else
			if(iLoop = puSize[0]) then
				iLoop := 0;
				jLoop := jLoop + 1;
			end
		end
	end

	getSamples.luma.skip: action ==>
	guard
		pixIdx  < numPixToGet,
		not((LOG2_NUM_SUB_BLK[0] = 0 && LOG2_NUM_SUB_BLK[1] = 0) ||
		IS_2ND_PART_PRED ||
		(iLoop >= subPuIdxMin[0][0] && jLoop >= subPuIdxMin[0][1] &&
		 iLoop <  subPuIdxMax[0][0]+7 && jLoop < subPuIdxMax[0][1]+3))
	do
		pixIdx := pixIdx + 1;
		iLoop := iLoop + 1;
		if((PROCESS_MODE_HALF_PIX & HALF_PIX_1ST_PART) != 0) then
			if(iLoop = fullPuSize[0]) then
				iLoop := 0;
				jLoop := jLoop + 1;
			end
		else
			if(iLoop = puSize[0]) then
				iLoop := 0;
				jLoop := jLoop + 1;
			end
		end
	end

	getSamples.luma.done: action ==>
	guard
		pixIdx = numPixToGet
	do
		pixIdx := 0;
		compIdx := 1;
		iLoop   := 0;
		jLoop   := 0;
	end

	getSamples.chroma.launch: action Sample:[sample] ==>
	guard
		compIdx < 3,
		(LOG2_NUM_SUB_BLK[0] = 0 && LOG2_NUM_SUB_BLK[1] = 0) ||
		IS_2ND_PART_PRED ||
		(iLoop >= subPuIdxMin[1][0] && jLoop >= subPuIdxMin[1][1] &&
		 iLoop < subPuIdxMax[1][0]+3 && jLoop < subPuIdxMax[1][1]+1)
	do
		if((LOG2_NUM_SUB_BLK[0] = 0 && LOG2_NUM_SUB_BLK[1] = 0)) then
			predSampChr[listIdx][compIdx-1][iLoop][jLoop] := sample;
		else if(not IS_2ND_PART_PRED) then
			predSampChr[listIdx][compIdx-1][iLoop - subPuIdxMin[1][0]][jLoop - subPuIdxMin[1][1]] := sample;
		else if(iLoop >= subPuIdxMin[1][0] && jLoop >= subPuIdxMin[1][1] &&
			    iLoop < subPuIdxMax[1][0]+3 && jLoop < subPuIdxMax[1][1]+3) then
			predSampChr[listIdx][compIdx-1][iLoop - subPuIdxMin[1][0]][jLoop - subPuIdxMin[1][1]] := sample;
		end end end

		iLoop := iLoop + 1;
		if((PROCESS_MODE_HALF_PIX & HALF_PIX_1ST_PART) != 0) then
			if(iLoop = fullPuSizeChr[0]) then
 				iLoop := 0;
				jLoop := jLoop + 1;
				if(jLoop = fullPuSizeChr[1]) then
					iLoop := 0;
					jLoop := 0;
					compIdx := compIdx + 1;
				end
			end
		else
			if(iLoop = puSizeChr[0]) then
				iLoop := 0;
				jLoop := jLoop + 1;
				if(jLoop = fullPuSizeChr[1]) then
					iLoop := 0;
					jLoop := 0;
					compIdx := compIdx + 1;
				end
			end
		end
	end

	getSamples.chroma.skip: action ==>
	guard
		compIdx < 3,
		not((LOG2_NUM_SUB_BLK[0] = 0 && LOG2_NUM_SUB_BLK[1] = 0) ||
		IS_2ND_PART_PRED ||
		(iLoop >= subPuIdxMin[1][0] && jLoop >= subPuIdxMin[1][1] &&
		 iLoop < subPuIdxMax[1][0]+3 && jLoop < subPuIdxMax[1][1]+1))
	do
		iLoop := iLoop + 1;
		if((PROCESS_MODE_HALF_PIX & HALF_PIX_1ST_PART) != 0) then
			if(iLoop = fullPuSizeChr[0]) then
 				iLoop := 0;
				jLoop := jLoop + 1;
				if(jLoop = fullPuSizeChr[1]) then
					iLoop := 0;
					jLoop := 0;
					compIdx := compIdx + 1;
				end
			end
		else
			if(iLoop = puSizeChr[0]) then
				iLoop := 0;
				jLoop := jLoop + 1;
				if(jLoop = fullPuSizeChr[1]) then
					iLoop := 0;
					jLoop := 0;
					compIdx := compIdx + 1;
				end
			end
		end
	end

	getSamples.chroma.done: action ==>
	guard
		compIdx = 3
	end

	interpolateSamples: action ==>
	var
		uint maskMv[3] = [3, 7, 7],
		int mvQuartPix[2],
		uint(size=2) COMP_MIN = if((DECODE_COMP & LUMA_COMP) = 0) then 1 else 0 end,
		uint(size=2) COMP_MAX = if((DECODE_COMP & CHROMA_COMP) != 0) then 2 else 0 end,
		int (size=8) puIdxMax[2],
		uint(size=7) idxMax1stPart[2]
	do

		if(LOG2_NUM_SUB_BLK[0] = 0 && LOG2_NUM_SUB_BLK[1] = 0) then
			puIdxMax := [puSize[i]: for int i in 0 .. 1];
			idxMax1stPart := [puSize[0], fullPuSize[1]];
		else
			puIdxMax := [subPuSize[0][0], subPuSize[0][1]];
			if(not IS_2ND_PART_PRED && subPuIdxMin[0][1] + subPuSize[0][1] > puSize[1]) then
				puIdxMax[1] := puSize[1] - subPuIdxMin[0][1];
			end
			idxMax1stPart := [subPuSize[0][0], subPuSize[0][1]];
		end

		foreach int component in COMP_MIN .. COMP_MAX /* Y, Cb, Cr */
		do
			if(component = 1) then
				if(LOG2_NUM_SUB_BLK[0] = 0 && LOG2_NUM_SUB_BLK[1] = 0) then
					puIdxMax := [puSizeChr[i]: for int i in 0 .. 1];
					idxMax1stPart := [puSizeChr[0], fullPuSizeChr[1]];
				else
					puIdxMax := [subPuSize[1][0], subPuSize[1][1]];
					if(not IS_2ND_PART_PRED && subPuIdxMin[1][1] + subPuSize[1][1] > puSizeChr[1]) then
						puIdxMax[1] := puSizeChr[1] - subPuIdxMin[1][1];
					end
					idxMax1stPart := [subPuSize[1][0], subPuSize[1][1]];
				end
			end
			/* We just need to do the fractionnal part of the movement
			 * interpolation.
			 */
			mvQuartPix := [mvLx[listIdx][i] & maskMv[component]:
				for int i in 0 .. 1];


			if(((PROCESS_MODE_HALF_PIX & HALF_PIX_1ST_PART) != 0) &&
				mvQuartPix[0] = 0 && mvQuartPix[1] = 0) then
				if(component = 0) then
					foreach int x in 0 .. puIdxMax[0]-1
					do
						foreach int y in 0 .. puIdxMax[1]-1
						do
							/* When we mvQuartPix is equal to [0,0], we multiply by 1^shift1,
							 * because after this procedure we will have the weighted prediction.
							 */
							predSampLuma[listIdx][x][y] := predSampLuma[listIdx][x+3]
								[y+3]<<shift1;
						end
					end
				else
					foreach int x in 0 .. puIdxMax[0]-1
					do
						foreach int y in 0 .. puIdxMax[1]-1
						do
							/* When we mvQuartPix is equal to [0,0], we multiply by 1^shift1,
							 * because after this procedure we will have the weighted prediction.
							 */
							predSampChr[listIdx][component-1][x][y] := predSampChr[listIdx][component-1][x+1]
								[y+1]<<shift1;
						end
					end
				end
			end

			if(((PROCESS_MODE_HALF_PIX & HALF_PIX_1ST_PART) != 0) &&
				mvQuartPix[0]!=0) then
				horizInterp(idxMax1stPart, puIdxMax, mvQuartPix, component);
			end

			if((PROCESS_MODE_HALF_PIX & HALF_PIX_2ND_PART) != 0 && mvQuartPix[1] != 0) then
				vertInterp(mvQuartPix, puIdxMax, component);
			end
		end

		listIdx := listIdx + 1;
		iLoop := 0;
		jLoop := 0;
	end

	getSamples.done: action ==>
	// This guard should be simplified.
	guard
		listIdx = numList && isBiPredOrLx = BI_PRED || listIdx = 2 || listIdx = 1 && isBiPredOrLx = PRED_L0
	var
		uint(size=7) puIdxMax[2],
		uint(size=2) COMP_MIN = if((DECODE_COMP & LUMA_COMP) = 0) then 1 else 0 end,
		uint(size=2) COMP_MAX = if((DECODE_COMP & CHROMA_COMP) != 0) then 2 else 0 end
	do
		puIdxMax := 
			if(not IS_2ND_PART_PRED || (LOG2_NUM_SUB_BLK[0] = 0 && LOG2_NUM_SUB_BLK[1] = 0)) then
				[puSize[i]: for int i in 0 .. 1]
			else
				[subPuSize[0][0], subPuSize[0][1]]
			end;
		if((PROCESS_MODE_HALF_PIX & HALF_PIX_2ND_PART) != 0) then
			foreach int component in COMP_MIN .. COMP_MAX /* Y, Cb, Cr */
			do
				if(component=1) then
					puIdxMax := [puIdxMax[i]>>1 : for int i in 0 .. 1];
				end
				weightedPred(component, puIdxMax, numList, isBiPredOrLx,
					wpIdc, weightCu,offsetCu, logWD);
			end
		end
		iLoop := 0;
		jLoop := 0;
	end

	sendPu.skip: action ==>
	guard
		IS_2ND_PART_PRED && (LOG2_NUM_SUB_BLK[0] != 0 || LOG2_NUM_SUB_BLK[1] != 0),
		jLoop < puSize[1],
		iLoop < subPuIdxMin[0][0] || iLoop >= subPuIdxMax[0][0] ||
		jLoop < subPuIdxMin[0][1] || jLoop >= subPuIdxMax[0][1]
	do
		while(jLoop < puSize[1] &&
			(iLoop < subPuIdxMin[0][0] || iLoop >= subPuIdxMax[0][0] ||
			 jLoop < subPuIdxMin[0][1] || jLoop >= subPuIdxMax[0][1]))
		do
			iLoop := iLoop + 4;
			if(iLoop = puSize[0]) then
				iLoop := 0;
				jLoop := jLoop + 4;
			end
		end
	end

	sendPu.launch.allComp: action ==> PredSample:[pix] repeat 16+2*4
	guard
		(PROCESS_MODE_HALF_PIX & HALF_PIX_2ND_PART) != 0,
		DECODE_COMP = ALL_COMP && jLoop < puSize[1]
	var
		uint(size=8) pix[16+2*4],
		uint(size=5) off
	do
		foreach uint y in 0 .. 3
		do
			foreach uint x in 0 .. 3
			do
				pix[y*4+x] := predSampLuma[0][iLoop+x-subPuIdxMin[0][0]][jLoop+y-subPuIdxMin[0][1]];
			end
		end
		off := 16;
		foreach uint component in 1 .. 2
		do
			foreach uint y in 0 .. 1
			do
				foreach uint x in 0 .. 1
				do
					pix[y*2+x+off] := predSampChr[0][component-1][iLoop/2+x-subPuIdxMin[1][0]][jLoop/2+y-subPuIdxMin[1][1]];
				end
			end
			off := off + 4;
		end
		iLoop := iLoop + 4;
		if(iLoop = puSize[0]) then
			iLoop := 0;
			jLoop := jLoop + 4;
		end
	end

	sendPu.launch.lumaComp: action ==> PredSample:[pix] repeat 16
	guard
		(PROCESS_MODE_HALF_PIX & HALF_PIX_2ND_PART) != 0,
		DECODE_COMP = LUMA_COMP && jLoop < puSize[1]
	var
		uint(size=8) pix[16]
	do
		foreach uint y in 0 .. 3
		do
			foreach uint x in 0 .. 3
			do
				pix[y*4+x] := predSampLuma[0][iLoop+x-subPuIdxMin[0][0]][jLoop+y-subPuIdxMin[0][1]];
			end
		end
		iLoop := iLoop + 4;
		if(iLoop = puSize[0]) then
			iLoop := 0;
			jLoop := jLoop + 4;
		end
	end

	sendPu.launch.chromaComp: action ==> PredSample:[pix] repeat 2*4
	guard
		(PROCESS_MODE_HALF_PIX & HALF_PIX_2ND_PART) != 0,
		DECODE_COMP = CHROMA_COMP && jLoop < puSize[1]
	var
		uint(size=8) pix[2*4],
		uint(size=5) off := 0
	do
		foreach uint component in 1 .. 2
		do
			foreach uint y in 0 .. 1
			do
				foreach uint x in 0 .. 1
				do
					pix[y*2+x+off] := predSampChr[0][component-1][iLoop/2+x-subPuIdxMin[1][0]][jLoop/2+y-subPuIdxMin[1][1]];
				end
			end
			off := off + 4;
		end
		iLoop := iLoop + 4;
		if(iLoop = puSize[0]) then
			iLoop := 0;
			jLoop := jLoop + 4;
		end
	end

	sendPu.done: action ==>
	guard
		(PROCESS_MODE_HALF_PIX & HALF_PIX_2ND_PART) = 0 ||
		jLoop = puSize[1]
	do
		iLoop := 0;
		jLoop := 0;
	end

	checkSendIntermPu.isTrue: action ==>
	guard
		(PROCESS_MODE_HALF_PIX & HALF_PIX_2ND_PART) = 0
	var
		int mvQuartPix[2]
	do
		mvQuartPix := [mvLx[listIdx-1][i] & 3:
			for int i in 0 .. 1];
		intermOff := if(mvQuartPix[0] = 0 and mvQuartPix[1] != 0) then 3 else 0 end;
	end

	checkSendIntermPu.isFalse: action ==>
	guard
		(PROCESS_MODE_HALF_PIX & HALF_PIX_2ND_PART) != 0
	end


	sendIntermPu.launch.lumaComp: action ==> PredSample:[sampVal]
	guard
		(PROCESS_MODE_HALF_PIX & HALF_PIX_2ND_PART) = 0,
		jLoop < fullPuSize[1]
	var
		int(size=16) sampVal
	do
		sampVal := predSampLuma[listIdx-1][iLoop + intermOff][jLoop];
		iLoop := iLoop + 1;

		if((LOG2_NUM_SUB_BLK[0] = 0 && LOG2_NUM_SUB_BLK[1] = 0)) then
			if(iLoop = puSize[0]) then
				iLoop := 0;
				jLoop := jLoop + 1;
			end
		else
			if(iLoop = subPuSize[0][0]) then
				iLoop := 0;
				jLoop := jLoop + 1;
				if(jLoop = subPuSize[0][1]) then
					jLoop := fullPuSize[1];
				end
			end
		end
	end

	sendIntermPu.launch.lumaDone: action ==>
	guard
		jLoop = fullPuSize[1]
	var
		int mvQuartPix[2]
	do
		mvQuartPix := [mvLx[listIdx-1][i] & 7:
			for int i in 0 .. 1];
		intermOff := if(mvQuartPix[0] = 0 and mvQuartPix[1] != 0) then 1 else 0 end;

		iLoop   := 0;
		jLoop   := 0;
		compIdx := 1;
	end

	sendIntermPu.launch.chromaComp.forward: action ==> PredSample:[sampVal]
	guard
		(PROCESS_MODE_HALF_PIX & HALF_PIX_2ND_PART) = 0,
		compIdx < 3
	var
		int(size=16) sampVal
	do
		sampVal := predSampChr[listIdx-1][compIdx-1][iLoop + intermOff][jLoop];
		iLoop := iLoop + 1;
		if((LOG2_NUM_SUB_BLK[0] = 0 && LOG2_NUM_SUB_BLK[1] = 0)) then
			if(iLoop = puSizeChr[0]) then
				iLoop := 0;
				jLoop := jLoop + 1;
				if(jLoop = fullPuSizeChr[1]) then
					iLoop := 0;
					jLoop := 0;
					compIdx := compIdx + 1;
				end
			end
		else
			if(iLoop = subPuSize[1][0]) then
				iLoop := 0;
				jLoop := jLoop + 1;
				if(jLoop = subPuSize[1][1]) then
					iLoop := 0;
					jLoop := 0;
					compIdx := compIdx + 1;
				end
			end
		end
	end

	sendIntermPu.done: action ==>
	guard
		compIdx = 3
	end

	schedule fsm GetPartMode:
		GetPartMode (isNewSlice.dep    )--> GetPartMode;
		GetPartMode (isNewSlice.notDep )--> GetSizeRefList;
		GetPartMode (getPartMode )--> GetCuInfo;

		GetSizeRefList (getSizeRefList.launch )--> GetRefList;
		GetSizeRefList (getSizeRefList.done   )--> GetWeightDenom;

		GetRefList (getRefList.launch )--> GetRefList;
		GetRefList (getRefList.done   )--> GetSizeRefList;

		GetWeightDenom (getWeightDenom.launch )--> GetWeightLX;
		GetWeightDenom (getWeightDenom.skip   )--> GetPartMode;

		GetWeightLX (getWeightLX.launch )--> GetLumaWeightLX;
		GetWeightLX (getWeightLX.skip   )--> GetWeightLX;
		GetWeightLX (getWeightLX.done   )--> GetPartMode;

		GetLumaWeightLX (getLumaWeightLX.launch )--> GetLumaWeightLX;
		GetLumaWeightLX (getLumaWeightLX.done   )--> GetChromaWeightLX;

		GetChromaWeightLX (getChromaWeightLX.launch )--> GetChromaWeightLX;
		GetChromaWeightLX (getChromaWeightLX.done   )--> GetDeltaLumWtLX;

		GetDeltaLumWtLX (getDeltaLumaWeight.launch )--> GetDeltaChrWtLX;
		GetDeltaLumWtLX (getDeltaLumaWeight.skip   )--> GetDeltaChrWtLX;
		GetDeltaLumWtLX (getDeltaLumaWeight.done   )--> GetWeightLX;

		GetDeltaChrWtLX (getDeltaChromaWeight   )--> GetDeltaLumWtLX;

		GetCuInfo (getCuInfo.launch )--> GetCuMode;
		GetCuInfo (getCuInfo.done   )--> GetPartMode;

		GetCuMode (getCuMode.isNotInter )--> GetCuInfo;
		GetCuMode (getCuMode.isInter )--> GetRefIdx;

		GetRefIdx (getRefIdx )--> GetSamples;

		GetSamples (getSamples.luma )--> GetLumaSamples;
		GetSamples (getSamples.done )--> SendPu;

		GetLumaSamples (getSamples.luma.launch )--> GetLumaSamples;
		GetLumaSamples (getSamples.luma.skip   )--> GetLumaSamples;
		GetLumaSamples (getSamples.luma.done   )--> GetChromaSamples;

		GetChromaSamples (getSamples.chroma.launch )--> GetChromaSamples;
		GetChromaSamples (getSamples.chroma.skip )--> GetChromaSamples;
		GetChromaSamples (getSamples.chroma.done   )--> InterpolateSamples;

		InterpolateSamples (interpolateSamples )--> CheckSendIntermPu;

		SendPu (sendPu.skip   )--> SendPu;
		SendPu (sendPu.launch )--> SendPu;
		SendPu (sendPu.done   )--> GetCuInfo;

		CheckSendIntermPu (checkSendIntermPu.isTrue )--> SendIntermPuLuma;
		CheckSendIntermPu (checkSendIntermPu.isFalse )--> GetSamples;

		SendIntermPuLuma (sendIntermPu.launch.lumaComp )--> SendIntermPuLuma;
		SendIntermPuLuma (sendIntermPu.launch.lumaDone )--> SendIntermPuChr;

		SendIntermPuChr (sendIntermPu.launch.chromaComp )--> SendIntermPuChr;
		SendIntermPuChr (sendIntermPu.done              )--> GetSamples;
	end
	priority
		getWeightLX.launch > getWeightLX.skip >getWeightLX.done;
		sendPu.skip > sendPu.launch > sendPu.done;
		getSamples.done > getSamples.luma;
	end
end