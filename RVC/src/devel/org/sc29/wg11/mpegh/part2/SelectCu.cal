/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
 
/**
 * Decoding process for intra blocks.
 * 
 * 
 * @input CUInfo : Informations related to the current CU
 *        (size, address and mode : INTRA,INTER,...).
 * 
 * @input InterSample : Pixel's value from the Inter-prediction CU.
 * 
 * @input IntraSample : Pixel's value from the Intra-prediction CU.
 * 
 * @input PartMode : Giving the partitioning mode of the current CU.
 * 
 * @input ResidualSample : Residual values for the current CU.
 * 
 * 
 * @output Sample : Pixel's value before inLoop filter.
 * 
 * 
 * @author Damien de Saint Jorre (EPFL) <damien.desaintjorre@epfl.ch>
 */
 
package devel.org.sc29.wg11.mpegh.part2;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;
import devel.org.sc29.wg11.mpegh.part2.inter.NaluType.*;

actor SelectCu()
	uint(size=16) CUInfo,
	uint(size=8)  InterSample,
	uint(size=8)  IntraSample,
	uint(size=4)  PartMode,
	bool          SplitTransform,
	int (size=9)  ResidualSample
		==>
	uint(size=8) IntraNeighb,
	uint(size=8) Sample
		:

	uint(size=8)  SCU_SIZE = 16+2*4;
	uint(size=4)  numPart;
	uint(size=3)  numPartDecoded;

	uint(size=8)  predSamp[64 * 64 + 2 * 32 * 32];
	uint(size=8)  neighbSamp[3][128];

	uint(size=5)  cuMode;
	uint(size=4)  partMode;

	uint(size=7)  cuSize[4][2];
	uint(size=5)  cuOff[4][2] := [[0,0],[0,0],[0,0],[0,0]];
	uint(size=7)  cuWidth;
	uint(size=7)  numPixNeighb[3];
	uint(size=8)  idxPixNeighb;
	uint(size=2)  cIdx;

	uint(size=9)  nbBlk;
	uint(size=9)  idxBlk;

	uint(size=7)  xIdx;
	uint(size=7)  yIdx;


	uint(size=16) lastLcuAddr := 0;
	uint(size=16) curLcuAddr := 0;

	isNewSlice: action PartMode:[partModeVal] ==>
	guard
		partModeVal = PART_MODE_SLICE_DEP || partModeVal = PART_MODE_SLICE_INDEP ||
		partModeVal = PART_MODE_PICT
	end

	getPartMode: action PartMode:[partModeVal] ==>
	guard
		partModeVal != PART_MODE_SLICE_DEP && partModeVal != PART_MODE_SLICE_INDEP &&
		partModeVal != PART_MODE_PICT
	do
		partMode := partModeVal;
		numPart := partModeToNumPart[partModeVal];
		numPartDecoded := 0;
	end

	/* Getting informations of the next CU. */
	getCuInfo.launch: action CUInfo:[cuInfo] repeat 5 ==>
	guard
		numPartDecoded < numPart && numPart != 2
	do
		cuMode  := cuInfo[0] & ~NO_IN_SAMP;
		cuWidth := cuInfo[3];
		nbBlk   := cuWidth*cuWidth/16;
		idxBlk  := 0;
		curLcuAddr := cuInfo[1]&~63;
		cuSize  := [[cuInfo[i]/4:for int i in 3 .. 4]:for int j in 0 .. 3];
		cuOff[0] := [0:for int i in 0 .. 1];
		trafoTreeDepth  := 0;
		trafoTreeIdx[0] := 3;
	end

	/* Getting informations of the next CU when there are two part.
	 * Get twice informations in order to have all the informations concerning
	 * this CU.
	 */
	getCuInfo.launch.numPart2: action CUInfo:[cuInfo] repeat 10 ==>
	guard
		numPartDecoded < numPart && numPart = 2
	do
		cuMode := cuInfo[0] & ~NO_IN_SAMP;
		cuSize  := [[cuInfo[i+5*j]/4:for uint i in 3 .. 4]:
			for uint j in 0 .. 1];
		cuWidth := max(cuInfo[3], cuInfo[4]);
		neighbBlkSz  := cuWidth;
		nbBlk   := cuWidth*cuWidth/16;
		idxBlk  := 0;
		curLcuAddr := cuInfo[1]&~63;
		if(partMode=PART_2NxN || partMode=PART_2NxnU ||
			partMode=PART_2NxnD) then
			cuOff[1][0] := 0;
			cuOff[1][1] := cuInfo[4]/4;
		else
			cuOff[1][0] := cuInfo[3]/4;
			cuOff[1][1] := 0;
		end
		trafoTreeDepth  := 0;
		trafoTreeIdx[0] := 3;
		numPartDecoded := 0;
	end

	isNewLcu: action ==>
	guard
		lastLcuAddr != curLcuAddr
	do
		lastLcuAddr := curLcuAddr;
		yIdx := 0;
	end

	isNewPu: action ==>
	guard
		lastLcuAddr = curLcuAddr
	end

	getCuInfo.done: action ==>
	guard
		numPartDecoded = numPart
	end

	/** Checking type of prediction.  **/
	getCuMode.isIntra: action ==>
	guard
		cuMode = INTRA
	do
		numPartDecoded := numPartDecoded + 1;
	end

	getCuMode.isInter: action ==>
	guard
		cuMode = INTER || cuMode = SKIP
	do
		xIdx := 0;
		yIdx := 0;
		neighbBlkSz := cuWidth;
		numPixNeighb[0] := (cuWidth * 2) - 1;
		numPixNeighb[1] := numPixNeighb[0] >> 1;
		numPixNeighb[2] := numPixNeighb[0] >> 1;
		idxPixNeighb := 0;
		cIdx := 0;
	end

	getCuMode.isOther: action ==>
	guard
		cuMode = OTHER || cuMode = IN_SAMP
	do
		numPartDecoded := numPartDecoded + 1;
	end

	/* Getting samples from intraPrediction */
	getCuSample.isIntra: action IntraSample:[intraSample] repeat SCU_SIZE,
		ResidualSample:[resSample] repeat SCU_SIZE
		==> Sample:[sample] repeat SCU_SIZE
	guard
		idxBlk < nbBlk
	var
		uint(size=16) blkAddr[2],
		bool bottomBlk,
		uint(size=5) sampOff,
		uint(size=8) sample[SCU_SIZE]
	do
		foreach uint sampIdx in 0 .. SCU_SIZE-1
		do
			sample[sampIdx] :=
				clip_i32(intraSample[sampIdx]+resSample[sampIdx], 0, 255);
		end

		zScanToAbsCoord(idxBlk, blkAddr);

		bottomBlk := blkAddr[1]+4 >= neighbBlkSz;
		if(blkAddr[0]+4 >= neighbBlkSz) then
			foreach uint y in 0 .. 3
			do
				neighbSamp[0][numPixNeighb[0]-1 -blkAddr[1]-y] := sample[4*y+3];
			end
			sampOff := 16;
			blkAddr[1] := blkAddr[1] >> 1;
			foreach int comp in 1 .. 2
			do
				foreach uint y in 0 .. 1
				do
					neighbSamp[comp][numPixNeighb[comp]-1 -blkAddr[1]-y] :=
						sample[2*y+1+sampOff];
				end
				sampOff := 20;
			end
		end
		if(bottomBlk) then
			foreach uint x in 0 .. 3
			do
				neighbSamp[0][blkAddr[0]+x] := sample[4*3+x];
			end
			sampOff := 16;
			blkAddr[0] := blkAddr[0] >> 1;
			foreach int comp in 1 .. 2
			do
				foreach uint x in 0 .. 1
				do
					neighbSamp[comp][blkAddr[0]+x] := sample[2*1+x+sampOff];
				end
				sampOff := 20;
			end
		end

		idxBlk := idxBlk + 1;
	end

	/* Getting prediction samples from interPrediction */
	getCuSample.isInter: action InterSample:[interSample] repeat SCU_SIZE ==>
	guard
		idxBlk < nbBlk
	var
		uint(size=16) blkAddr[2],
		/* Offset is not null when numPart = 2 and partIdx = 1. */
		uint xOff = cuOff[numPartDecoded][0],
		uint yOff = cuOff[numPartDecoded][1],
		uint blkIdx
	do
		blkAddr := [xIdx+xOff, yIdx+yOff];
		blkIdx := absCoordInBlkToZScan(blkAddr);
		foreach int i in 0 .. SCU_SIZE-1
		do
			predSamp[24*blkIdx + i] := interSample[i];
		end

		/* Computing the location of the next block (it's sent in ZScan order instead of RasterScan. */
		xIdx := xIdx + 1;
		if(xIdx = cuSize[numPartDecoded][0]) then
			xIdx := 0;
			yIdx := yIdx + 1;
			if(yIdx = cuSize[numPartDecoded][1]) then
				yIdx := 0;
				numPartDecoded := numPartDecoded + 1;
			end
		end

		idxBlk := idxBlk + 1;
	end

	/* Getting the residual part for interPrediction then computing the
	 * result.
	 */
	getCuSample.isInterRes: action ResidualSample:[resSample] repeat SCU_SIZE
		==> Sample:[sample] repeat SCU_SIZE
	guard
		idxBlk < nbBlk
	var
		uint(size=16) blkAddr[2],
		bool bottomBlk,
		uint(size=5)  sampOff,
		uint(size=8)  sample[SCU_SIZE]
	do
		foreach int i in 0 .. SCU_SIZE-1
		do
			sample[i] := clip_i32(predSamp[24*idxBlk + i] +
						resSample[i], 0, 255);
		end


		zScanToAbsCoord(idxBlk, blkAddr);

		bottomBlk := blkAddr[1]+4 >= neighbBlkSz;
		if(blkAddr[0]+4 >= 0) then
			foreach uint y in 0 .. 3
			do
				neighbSamp[0][numPixNeighb[0]-1 -blkAddr[1]-y] := sample[4*y+3];
			end
			sampOff := 16;
			blkAddr[1] := blkAddr[1] >> 1;
			foreach int comp in 1 .. 2
			do
				foreach uint y in 0 .. 1
				do
					neighbSamp[comp][numPixNeighb[comp]-1 -blkAddr[1]-y] :=
						sample[2*y+1+sampOff];
				end
				sampOff := 20;
			end
		end
		if(bottomBlk) then
			foreach uint x in 0 .. 3
			do
				neighbSamp[0][blkAddr[0]+x] := sample[4*3+x];
			end
			sampOff := 16;
			blkAddr[0] := blkAddr[0] >> 1;
			foreach int comp in 1 .. 2
			do
				foreach uint x in 0 .. 1
				do
					neighbSamp[comp][blkAddr[0]+x] := sample[2*1+x+sampOff];
				end
				sampOff := 20;
			end
		end

		idxBlk := idxBlk + 1;
	end

	getCuSample.done: action ==>
	guard
		idxBlk = nbBlk
	do
		idxBlk := 0;
	end

	int (size=4) trafoTreeDepth;
	uint(size=3) trafoTreeIdx[6];
	uint(size=7) neighbBlkSz;

	/* Check if the intra prediction CU has to be split in 4 "subCU" */
	getSplitTrafo.isTrue: action SplitTransform:[splitTrafo] ==>
	guard
		splitTrafo && trafoTreeDepth>-1
	do
		trafoTreeDepth := trafoTreeDepth + 1;
		trafoTreeIdx[trafoTreeDepth] := 0;
	end

	/* Check if the intra prediction will not be split again, then realize the
	 * prediction for this part of CU
	 */
	getSplitTrafo.isFalse: action SplitTransform:[splitTrafo] ==>
	guard
		not splitTrafo && trafoTreeDepth>-1
	var
		uint(size=7)  treeNS
	do
		treeNS := cuWidth;
		foreach uint idx in 1 .. trafoTreeDepth
		do
			treeNS := treeNS >> 1;
		end
		

		nbBlk := treeNS*treeNS/16;
		neighbBlkSz  := treeNS;
		idxBlk := 0;


		/* going to the next "branch of the tree" */
		trafoTreeIdx[trafoTreeDepth] := trafoTreeIdx[trafoTreeDepth] + 1;
		/* Replace by (trafoTreeDepth > -1 && trafoTreeIdx[trafoTreeDepth] = 4) when orcc's simulator
		 * support short-circuit evaluation.
		 */
		while(if trafoTreeDepth>= 0 then (trafoTreeIdx[trafoTreeDepth] = 4) else false end)
		do
			trafoTreeDepth := trafoTreeDepth - 1;
			if(trafoTreeDepth>-1) then
				trafoTreeIdx[trafoTreeDepth] :=
					trafoTreeIdx[trafoTreeDepth] + 1;
			end
		end

		numPixNeighb[0] := treeNS * 2 - 1;
		numPixNeighb[1] := numPixNeighb[0] >> 1;
		numPixNeighb[2] := numPixNeighb[0] >> 1;
		idxPixNeighb := 0;
		cIdx := 0;
	end

	getSplitTrafo.isInter: action SplitTransform:[splitTrafo] ==>
	guard
		trafoTreeDepth>-1
	do
		if(splitTrafo) then
			trafoTreeDepth := trafoTreeDepth + 1;
			trafoTreeIdx[trafoTreeDepth] := 0;
		else
			trafoTreeIdx[trafoTreeDepth] := trafoTreeIdx[trafoTreeDepth] + 1;
			while(if trafoTreeDepth>= 0 then (trafoTreeIdx[trafoTreeDepth] = 4) else false end)
			do
				trafoTreeDepth := trafoTreeDepth - 1;
				if(trafoTreeDepth>-1) then
					trafoTreeIdx[trafoTreeDepth] :=
						trafoTreeIdx[trafoTreeDepth] + 1;
				end
			end
		end
	end

	getSplitTrafo.done: action ==>
	guard
		trafoTreeDepth = -1
	end

	sendIntraNeighb.launch: action ==> IntraNeighb:[neighbSamp[idxComp][idxSamp]]
	guard
		cIdx < 3
	var
		uint(size=8) idxSamp = idxPixNeighb,
		uint(size=2) idxComp = cIdx
	do
		idxPixNeighb := idxPixNeighb + 1;
		if(idxPixNeighb = numPixNeighb[cIdx]) then
			idxPixNeighb := 0;
			cIdx := cIdx + 1;
		end
	end

	sendIntraNeighb.done: action ==>
	guard
		cIdx = 3
	end

	schedule fsm GetPartMode:
		GetPartMode (isNewSlice       )--> GetPartMode;
		GetPartMode (getPartMode      )--> GetCuInfo;

		GetCuInfo   (getCuInfo.launch )--> CheckNewLcu;
		GetCuInfo   (getCuInfo.done   )--> GetPartMode;

		CheckNewLcu (isNewLcu )--> GetCuMode;
		CheckNewLcu (isNewPu  )--> GetCuMode;

		GetCuMode (getCuMode.isIntra )--> GetSplitTrafoIntra;
		GetCuMode (getCuMode.isInter )--> GetSplitTrafoInter;
		GetCuMode (getCuMode.isOther )--> GetCuInfo;


		GetSplitTrafoIntra (getSplitTrafo.isTrue  )--> GetSplitTrafoIntra;
		GetSplitTrafoIntra (getSplitTrafo.isFalse )--> GetCuSampleIntra;
		GetSplitTrafoIntra (getSplitTrafo.done    )--> GetCuInfo;

		GetCuSampleIntra (getCuSample.isIntra )--> GetCuSampleIntra;
		GetCuSampleIntra (getCuSample.done    )--> SendIntraNeighb;

		SendIntraNeighb (sendIntraNeighb.launch )--> SendIntraNeighb;
		SendIntraNeighb (sendIntraNeighb.done   )--> GetSplitTrafoIntra;


		GetSplitTrafoInter (getSplitTrafo.isInter  )--> GetSplitTrafoInter;
		GetSplitTrafoInter (getSplitTrafo.done    )--> GetCuSampleInter;

		GetCuSampleInter (getCuSample.isInter )--> GetCuSampleInter;
		GetCuSampleInter (getCuSample.done    )--> GetCuResInter;

		GetCuResInter (getCuSample.isInterRes )--> GetCuResInter;
		GetCuResInter (getCuSample.done       )--> SendInterNeighb;

		SendInterNeighb (sendIntraNeighb.launch )--> SendInterNeighb;
		SendInterNeighb (sendIntraNeighb.done   )--> GetCuInfo;
	end
end