package devel.org.sc29.wg11.mpegh.part2.common;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

actor tilesMerger () 	uint (size= 8) IN1, 
						uint (size= 8) IN2, 
						uint (size= 8) IN3, 
						uint (size= 8) IN4,
						uint(size=16) TilesCoord
  						==> 
  						uint (size= 8) OUT:

uint counter0 := 0;
uint counter1 := 0;
uint counter2 := 0;
uint counter3 := 0;
uint countOut := 0;
int(size=16) iLoop;
uint(size=16) numTiles;

uint (size=8) tab0[384*256*3/2];
uint (size=8) tab1[448*256*3/2];
uint (size=8) tab2[384*224*3/2];
uint (size=8) tab3[448*224*3/2];

uint tileSize[MAX_NUM_TILES];

	read.tile0: action IN1:[data]  ==> 
	guard
		counter0 < tileSize[0]*3/2
	do
		tab0[counter0] := data;
		counter0 := counter0 + 1;
	end
	
	read.tile1: action IN2:[data] ==> 
	guard
		counter1 < tileSize[1]*3/2
	do
		tab1[counter1] := data;
		counter1 := counter1 + 1;
	end
	
	read.tile2: action IN3:[data] ==> 
	guard
		counter2 < tileSize[2]*3/2
	do
		tab2[counter2] := data;
		counter2 := counter2 + 1;
	end
	
	read.tile3: action IN4:[data]  ==>  
	guard
		counter3 < tileSize[3]*3/2
	do
		tab3[counter3] := data;
		counter3 := counter3 + 1;
	end
	
	endTiles: action ==>
	guard
		counter0 = tileSize[0]*3/2,
		counter1 = tileSize[1]*3/2,
		counter2 = tileSize[2]*3/2,
		counter3 = tileSize[3]*3/2
	end
	
	getNumTiles: action TilesCoord:[valNumTiles] ==>
	do
		numTiles := valNumTiles;
		iLoop := 0;
	end

	getTilesCoord.launch: action TilesCoord:[tilesCoord] repeat 4 ==>
	var
		uint tileWidth,
		uint tileHeight
	do
		tileWidth  := tilesCoord[2] - tilesCoord[0];
		tileHeight := tilesCoord[3] - tilesCoord[1];
		tileSize[iLoop] := tileWidth * tileHeight;
		iLoop := iLoop + 1;
	end

	getTilesCoord.done: action ==>
	guard
		iLoop = numTiles
	do
		iLoop := 0;
	end
	
	
	sendTile0: action ==> OUT:[out]
	var
		uint (size=8) out
	do
		out := tab0[countOut];
		countOut := countOut + 1;
	end
	
	sentTile0: action ==>
	guard
		countOut = tileSize[0]*3/2
	do
		countOut := 0;
	end
	
	sendTile1: action ==> OUT:[out]
	var
		uint (size=8) out
	do
		out := tab1[countOut];
		countOut := countOut + 1;
	end
	
	sentTile1: action ==>
	guard
		countOut = tileSize[1]*3/2
	do
		countOut := 0;
	end
	
	
	sendTile2: action ==> OUT:[out]
	var
		uint (size=8) out
	do
		out := tab2[countOut];
		countOut := countOut + 1;
	end
	
	sentTile2: action ==>
	guard
		countOut = tileSize[2]*3/2
	do
		countOut := 0;
	end
	
	sendTile3: action ==> OUT:[out]
	var
		uint (size=8) out
	do
		out := tab3[countOut];
		countOut := countOut + 1;
	end
	
	sentTile3: action ==>
	guard
		countOut = tileSize[3]*3/2
	do
		countOut := 0;
		counter0 := 0;
		counter1 := 0;
		counter2 := 0;
		counter3 := 0;
		
	end
	
	
	schedule fsm GetNumTiles:
		GetNumTiles   	(getNumTiles          )	--> GetTilesCoord;
		GetTilesCoord 	(getTilesCoord.launch )	--> GetTilesCoord;
		GetTilesCoord 	(getTilesCoord.done   )	--> readTiles;
		readTiles		(read)					--> readTiles;
		readTiles		(endTiles)				--> t0;
		t0				(sendTile0)				--> t0;
		t0				(sentTile0)				--> t1;
		t1				(sendTile1)				--> t1;
		t1				(sentTile1)				--> t2;
		t2				(sendTile2)				--> t2;
		t2				(sentTile2) 			--> t3;
		t3				(sendTile3)				--> t3;
		t3				(sentTile3)				--> GetNumTiles;
	end
	
	priority
		getTilesCoord.done > getTilesCoord.launch;
		sentTile0 > sendTile0;
		sentTile1 > sendTile1;
		sentTile2 > sendTile2;
		sentTile3 > sendTile3;
		endTiles  > read;
	end
end