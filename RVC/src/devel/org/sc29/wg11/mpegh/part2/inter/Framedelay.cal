/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
package devel.org.sc29.wg11.mpegh.part2.inter;

import std.util.Math.*;
import common.CommonConstantHEVC.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

actor Framedelay()
	uint(size=16) PictSize,
	uint(size=8)  Block_in
		==>
	uint(size=8)  Block_out
		:


	uint(size=6)  picSizeInCu[2];
	uint(size=16) picSize[2];
	uint(size=6)  xIdx;
	uint(size=6)  yIdx;
	uint(size=6)  lastXIdx;
	uint(size=6)  lastYIdx;
	uint(size=6)  xIdxSamp;
	uint(size=6)  yIdxSamp;
	uint(size=16) xAddrVert;
	uint(size=16) yAddrVert;
	uint(size=16) pixAddr[2];
	uint(size=9)  blkIdx := 0;

	uint(size=8)  pictureBuffer[3][PICT_WIDTH][PICT_HEIGHT];
	uint(size=1)  currHorIdx;


	procedure saveRasterScanCu(uint(size=8) sample[64*64 + 2*32*32])
	var
		uint(size=16) pixAddr[2],
		uint tokenOffset
	begin
		foreach uint blkIdx in 0 .. 255
		do
			rasterScanToAbsCoord(blkIdx, pixAddr);
			pixAddr[0] := pixAddr[0] + xAddrVert;
			pixAddr[1] := pixAddr[1] + yAddrVert;
			tokenOffset := blkIdx*(16+2*4);
			foreach uint y in 0 .. 3
			do
				foreach uint x in 0 .. 3
				do
					pictureBuffer[0][pixAddr[0]+x][pixAddr[1]+y] :=
						sample[tokenOffset + 4*y+x];
				end
			end
			tokenOffset := tokenOffset + 16;
			pixAddr[0]  := pixAddr[0]>>1;
			pixAddr[1]  := pixAddr[1]>>1;
			foreach uint comp in 1 .. 2
			do
				foreach uint y in 0 .. 1
				do
					foreach uint x in 0 .. 1
					do
						pictureBuffer[comp][pixAddr[0]+x][pixAddr[1]+y] :=
							sample[tokenOffset + 2*y+x];
					end
				end
				tokenOffset := tokenOffset + 4;
			end
		end
	end



	isNewPict: action PictSize:[picWidthInPix, picHeightInPix] ==>
	do
		picSize[0] := picWidthInPix;
		picSize[1] := picHeightInPix;
		picSizeInCu[0] := (picWidthInPix+63)/64;
		picSizeInCu[1] := (picHeightInPix+63)/64;
		lastXIdx := 0;
		lastYIdx := 0;
		xIdx := 0;
		yIdx := 0;
		xIdxSamp := 0;
		yIdxSamp := 0;
	end

	getCuPix.launch.pict: action Block_in:[samp] repeat 64*64 + 32*32*2==>
	guard
		yIdx < picSizeInCu[1]-1 && xIdx < picSizeInCu[0]-1
	do
		xAddrVert := xIdx*64;
		yAddrVert := yIdx*64;
		saveRasterScanCu(samp);


		currHorIdx := currHorIdx + 1;
		lastXIdx := xIdx;
		lastYIdx := yIdx;
		xIdx := xIdx + 1;
		if(xIdx = picSizeInCu[0]) then
			xIdx := 0;
			yIdx := yIdx + 1;
		end
	end

	getCuPix.launch.lastColOrRow.vert: action  ==>
	guard
		(xIdx = picSizeInCu[0]-1 || yIdx = picSizeInCu[1]-1)
	do
		xAddrVert := xIdx*64;
		yAddrVert := yIdx*64;

		blkIdx := 0;
		rasterScanToAbsCoord(0, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end


	getBlk.launch: action  Block_in:[samp] repeat 4*4 + 2*2*2 ==>
	guard
		blkIdx < 256 && pixAddr[0] < picSize[0] && pixAddr[1] < picSize[1]
	do
		foreach uint y in 0 .. 3
		do
			foreach uint x in 0 .. 3
			do
				pictureBuffer[0][pixAddr[0]+x][pixAddr[1]+y] :=
					samp[4*y+x];
			end
		end


		pixAddr[0]  := pixAddr[0]>>1;
		pixAddr[1]  := pixAddr[1]>>1;
		foreach uint comp in 1 .. 2
		do
			foreach uint y in 0 .. 1
			do
				foreach uint x in 0 .. 1
				do
					pictureBuffer[comp][pixAddr[0]+x][pixAddr[1]+y] :=
						samp[2*y+x + 16+4*(comp-1)];
				end
			end
		end

		blkIdx := blkIdx + 1;
		rasterScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

	getBlk.skip.vertEdge: action ==>
	guard
		blkIdx < 256,
		pixAddr[0] >= picSize[0] || pixAddr[1] >= picSize[1]
	do
		blkIdx := blkIdx + 1;
		rasterScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end


	getBlk.done: action ==>
	guard
		blkIdx = 256
	do
		currHorIdx := currHorIdx + 1;
		lastXIdx := xIdx;
		lastYIdx := yIdx;
		xIdx := xIdx + 1;
		if(xIdx = picSizeInCu[0]) then
			xIdx := 0;
			yIdx := yIdx + 1;
		end
	end

	getCuPix.done: action ==>
	guard
		yIdx = picSizeInCu[1]
	do
		lastXIdx := 0;
		lastYIdx := 0;
		xIdx := 0;
		yIdx := 0;
	end

	sendSamples.launch: action ==> Block_out:[samples] repeat 64*64 + 2* 32*32
	guard
		yIdxSamp < picSizeInCu[1],
		xIdxSamp != lastXIdx || yIdxSamp != lastYIdx
	var
		uint tokenOffset,
		uint(size=8) samples[64*64+2*32*32],
		uint(size=16) blkAddrX, uint(size=16) blkAddrY
	do
		blkAddrX := xIdxSamp*64;
		blkAddrY := yIdxSamp*64;
		foreach uint y in 0 .. 63
		do
			foreach uint x in 0 .. 63
			do
					samples[x+y*64] := pictureBuffer[0][blkAddrX+x][blkAddrY+y];
			end
		end

		blkAddrX := blkAddrX>>1;
		blkAddrY := blkAddrY>>1;
		tokenOffset:= 64*64;
		foreach uint comp in 1 .. 2
		do
			foreach uint y in 0 .. 31
			do
				foreach uint x in 0 .. 31
				do
						samples[x+y*32 + tokenOffset] := pictureBuffer[comp][blkAddrX+x][blkAddrY+y];
				end
			end
			tokenOffset:= tokenOffset + 32*32;
		end

		xIdxSamp := xIdxSamp + 1;
		if(xIdxSamp = picSizeInCu[0]) then
			xIdxSamp := 0;
			yIdxSamp := yIdxSamp + 1;
		end
	end

	sendSamples.skip: action ==> 
	guard
		 xIdxSamp = lastXIdx
	end

	sendSamples.done: action ==>
	guard
		yIdxSamp = picSizeInCu[1]
	end

	schedule fsm IsNewPict:
		IsNewPict (isNewPict )--> GetCuPix;

		GetCuPix  (getCuPix.launch.pict              )--> SendSamplesVert;
		GetCuPix  (getCuPix.launch.lastColOrRow.vert )--> GetBlk;
		GetCuPix  (getCuPix.done                     )--> SendSamples;

		GetBlk (getBlk.launch )--> GetBlk;
		GetBlk (getBlk.skip   )--> GetBlk;
		GetBlk (getBlk.done   )--> SendSamplesVert;


		SendSamplesVert (sendSamples.launch )--> GetCuPix;
		SendSamplesVert (sendSamples.skip   )--> GetCuPix;

		SendSamples (sendSamples.launch )--> SendSamples;
		SendSamples (sendSamples.done   )--> IsNewPict;
	end
end