/*
 * Author: Jinglin
 * Date: 16/01/13 
 * actor of aggregating disparity in horizontal and vertical directions with adaptive weight 
 */
package stereo;

import std.util.Math.*;
 
actor aggregation1()
	float Cost_in, uint(size=8) L_rgb,  uint(size=8) R_rgb
	==> 
	float Cost_out:

	//const
	int max_rd = 60;
	int max_iter_time = 7;
	float gamaP = 36.0;
	float R_gama = 0.05882;
	int height = 375;
	int width = 450;
	
	//variable
	int offset[max_iter_time];float N_distance[max_iter_time];
	float r0;
	float g0;
	float b0;
	float r;
	float g;
	float b;
	float wm;
	float wp;
	float w0;
	float cm;
	float cp;
	float c0;
	int dj := 0;
	
	//sqrt function
	float mid;
	float last; 
	float low;
	float up; 
	float val:=0.0;

	/******************************************************************************
	* Abs function
	*****************************************************************************/
	function abs(float x)
				-->
			float
		:
			if(x > 0.0)then
				x
			else
				-x
			end
		end
	/******************************************
	 * Sqrt funtion procedure
	 ******************************************/
	procedure sqrt (float x)
	begin
		float last:=0;
		last := val;
		val :=(val + x/val) / 2;
		while abs(val-last) > 2.718282 do
			last := val;
			val :=(val + x/val) / 2;
		end
	end 
	
	procedure aggregation_V(int offset, float Ndistance, float R_gamaC, uint(size=8) imageL_rgb [height*width*3+15], float src[height*width*max_rd], float dst[height*width*max_rd])
	begin
		foreach int j in 0 .. height-1
		do
			foreach int i in 0 .. width-1
			do
				dj:=0;
				r0 := imageL_rgb[j*width + 3*i + 15];
				g0 := imageL_rgb[j*width + 3*i + 1 + 15];
				b0 := imageL_rgb[j*width + 3*i + 2 + 15];
				
				r := imageL_rgb[max((j-offset),0) *width + 3*i + 15];
				g := imageL_rgb[max((j-offset),0) *width + 3*i + 1 + 15];
				b := imageL_rgb[max((j-offset),0) *width + 3*i + 2 + 15];
				
				//sqrt functions procedures 
				//val := sqrt(val);
				val := ((r0-r)*(r0-r) + (g0-g)*(g0-g) + (b0-b)*(b0-b));
				wm :=  val * R_gamaC;
				
				r := imageL_rgb[min((j+offset),height-1)*width + 3*i + 15];
				g := imageL_rgb[min((j+offset),height-1)*width + 3*i + 1 + 15];
				b := imageL_rgb[min((j+offset),height-1)*width + 3*i + 2 + 15];
				
				//sqrt functions procedures 
				//sqrt(((r0-r)*(r0-r) + (g0-g)*(g0-g) + (b0-b)*(b0-b)));
				val := ((r0-r)*(r0-r) + (g0-g)*(g0-g) + (b0-b)*(b0-b));
				wp := val * R_gamaC;
				
				// no math functions for exp
				//wm = exp(Ndistance-wm);
				//wp = exp(Ndistance-wp);
				
				// normalization
				w0 := 1/(wm+wp+1);
				wm := wm*w0;
				wp := wp*w0;
				
				foreach int rd in 0 .. max_rd-1
				do
					c0 := src[dj*width + i];
					cm := src[(dj+max(0,j-offset))*width + i];
					cp := src[(dj+min(height-1,j+offset))*width + i];
					
					dst[(dj+j)*width + i] := wm*cm + w0*c0 + wp*cp;
					dj := dj + height;
				end
				
			end
		end
	end
	
	procedure aggregation_H(int offset, float Ndistance, float R_gamaC, uint(size=8) imageL_rgb [height*width*3+15], float src[height*width*max_rd], float dst[height*width*max_rd])
	begin
		foreach int j in 0 .. height-1
		do 
			foreach int i in 0 .. width-1
			do
				dj:=0;
				r0 := imageL_rgb[j*width + 3*i + 15];
				g0 := imageL_rgb[j*width + 3*i + 1 + 15];
				b0 := imageL_rgb[j*width + 3*i + 2 + 15];
				
				r := imageL_rgb[j*width + 3*(max(0,i-offset)) + 15];
				g := imageL_rgb[j*width + 3*(max(0,i-offset)) + 1 + 15];
				b := imageL_rgb[j*width + 3*(max(0,i-offset)) + 2 + 15];
				
				//sqrt functions procedures 
				//sqrt(((r0-r)*(r0-r) + (g0-g)*(g0-g) + (b0-b)*(b0-b)));
				val := ((r0-r)*(r0-r) + (g0-g)*(g0-g) + (b0-b)*(b0-b));
				wm :=  val * R_gamaC;
				
				r := imageL_rgb[j*width + 3*(min(width,i+offset)) + 15];
				g := imageL_rgb[j*width + 3*(min(width,i+offset)) + 1 + 15];
				b := imageL_rgb[j*width + 3*(min(width,i+offset)) + 2 + 15];
				
				//sqrt functions procedures 
				//sqrt(((r0-r)*(r0-r) + (g0-g)*(g0-g) + (b0-b)*(b0-b)));
				val := ((r0-r)*(r0-r) + (g0-g)*(g0-g) + (b0-b)*(b0-b));
				wp :=  val * R_gamaC;
			
				// no math functions for exp
				//wm = exp(Ndistance-wm);
				//wp = exp(Ndistance-wp);
				
				// normalization
				w0 := 1/(wm+wp+1);
				wm := wm*w0;
				wp := wp*w0;
				
				foreach int rd in 0 .. max_rd-1
				do
					c0 := src[dj*width + i];
					cm := src[dj*width + max(0,i-offset)];
					cp := src[dj*width + min(width-1,i+offset)];
					
					dst[(dj+j)*width + i] := wm*cm + w0*c0 + wp*cp;
					dj := dj + height;
				end
			end
		end
								
	end
	
	CostAggregation:action  L_rgb:[left] repeat (width*height*3 + 15) , R_rgb:[right] repeat (width*height*3 + 15), Cost_in:[err] repeat height*width*max_rd ==> Cost_out:[err] repeat height*width*max_rd
	var
		List (type :float, size = height*width*max_rd) err_out
	do
	 	foreach int i in 0 .. 6
	 	do 
	 		aggregation_V((i*i) mod 33, offset[i]/gamaP, R_gama, left, err, err_out);
	 		aggregation_H((i*i) mod 33, offset[i]/gamaP, R_gama, left, err_out, err);
	 	end 
	end
	
end