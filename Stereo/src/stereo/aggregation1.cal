/*
 * Author: Jinglin
 * Date: 16/01/13 
 * actor of aggregating disparity in horizontal and vertical directions with adaptive weight 
 */
package stereo;

import std.util.Math.*;
 
actor aggregation1()
	uint (size = 32) Cost_in, uint(size=8) L_rgb,  uint(size=8) R_rgb
	==> 
	uint (size = 32) Cost_out:

	//const
	int max_rd = 60;
	uint R_gama = 1/20;
	int height = 375;
	int width = 450;
	
	//variable
	uint r0;
	uint g0;
	uint b0;
	uint r;
	uint g;
	uint b;
	uint wm;
	uint wp;
	uint w0;
	uint cm;
	uint cp;
	uint c0;
	int dj := 0;
	uint val := 0;

	/******************************************
	 * Sqrt funtion procedure
	 ******************************************/
	
	procedure aggregation_V(int offset, uint R_gamaC, uint(size=8) imageL_rgb [height*width*3+15], uint src[height*width*max_rd], uint dst[height*width*max_rd])
	begin
		foreach int j in 0 .. height-1
		do
			foreach int i in 0 .. width-1
			do
				dj:=0;
				r0 := imageL_rgb[j*width + 3*i + 15];
				g0 := imageL_rgb[j*width + 3*i + 1 + 15];
				b0 := imageL_rgb[j*width + 3*i + 2 + 15];
				
				r := imageL_rgb[max((j-offset),0) *width + 3*i + 15];
				g := imageL_rgb[max((j-offset),0) *width + 3*i + 1 + 15];
				b := imageL_rgb[max((j-offset),0) *width + 3*i + 2 + 15];
				
				//sqrt functions procedures 
				//val := sqrt(val);
				val := ((r0-r)*(r0-r) + (g0-g)*(g0-g) + (b0-b)*(b0-b));
				wm :=  val * R_gamaC;
				
				r := imageL_rgb[min((j+offset),height-1)*width + 3*i + 15];
				g := imageL_rgb[min((j+offset),height-1)*width + 3*i + 1 + 15];
				b := imageL_rgb[min((j+offset),height-1)*width + 3*i + 2 + 15];
				
				//sqrt functions procedures 
				//sqrt(((r0-r)*(r0-r) + (g0-g)*(g0-g) + (b0-b)*(b0-b)));
				val := ((r0-r)*(r0-r) + (g0-g)*(g0-g) + (b0-b)*(b0-b));
				wp := val * R_gamaC;				
				
				// normalization
				w0 := 1/(wm+wp+1);
				wm := wm*w0;
				wp := wp*w0;
				
				foreach int rd in 0 .. max_rd-1
				do
					c0 := src[dj*width + i];
					cm := src[(dj+max(0,j-offset))*width + i];
					cp := src[(dj+min(height-1,j+offset))*width + i];
					
					dst[(dj+j)*width + i] := wm*cm + w0*c0 + wp*cp;
					dj := dj + height;
				end
				
			end
		end
	end
	
	procedure aggregation_H(int offset, uint R_gamaC, uint(size=8) imageL_rgb [height*width*3+15], uint src[height*width*max_rd], uint dst[height*width*max_rd])
	begin
		foreach int j in 0 .. height-1
		do 
			foreach int i in 0 .. width-1
			do
				dj:=0;
				r0 := imageL_rgb[j*width + 3*i + 15];
				g0 := imageL_rgb[j*width + 3*i + 1 + 15];
				b0 := imageL_rgb[j*width + 3*i + 2 + 15];
				
				r := imageL_rgb[j*width + 3*(max(0,i-offset)) + 15];
				g := imageL_rgb[j*width + 3*(max(0,i-offset)) + 1 + 15];
				b := imageL_rgb[j*width + 3*(max(0,i-offset)) + 2 + 15];
				
				val := ((r0-r)*(r0-r) + (g0-g)*(g0-g) + (b0-b)*(b0-b));
				wm :=  val * R_gamaC;
				
				r := imageL_rgb[j*width + 3*(min(width,i+offset)) + 15];
				g := imageL_rgb[j*width + 3*(min(width,i+offset)) + 1 + 15];
				b := imageL_rgb[j*width + 3*(min(width,i+offset)) + 2 + 15];
				
				val := ((r0-r)*(r0-r) + (g0-g)*(g0-g) + (b0-b)*(b0-b));
				wp :=  val * R_gamaC;

				// normalization
				w0 := 1/(wm+wp+1);
				wm := wm*w0;
				wp := wp*w0;
				
				foreach int rd in 0 .. max_rd-1
				do
					c0 := src[dj*width + i];
					cm := src[dj*width + max(0,i-offset)];
					cp := src[dj*width + min(width-1,i+offset)];
					
					dst[(dj+j)*width + i] := wm*cm + w0*c0 + wp*cp;
					dj := dj + height;
				end
			end
		end								
	end
	
	CostAggregation:action  L_rgb:[left] repeat (width*height*3 + 15) , R_rgb:[right] repeat (width*height*3 + 15), Cost_in:[err] repeat height*width*max_rd ==> Cost_out:[err_out] repeat height*width*max_rd
	var
		List (type: uint, size = height*width*max_rd) err_out
	do
	 	foreach int i in 0 .. 6
	 	do 
	 		aggregation_V((i*i) mod 33,  R_gama, left, err, err_out);
	 		aggregation_H((i*i) mod 33,  R_gama, left, err_out, err);
	 	end 
	end
	
end