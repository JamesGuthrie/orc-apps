

/***********************************************************************

This software module was originally developed by Herv√© Yviquel IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
//Modified by Damien de Saint Jorre IETR/INSA of Rennes (France)
//Modified by Jerome Gorin IETR/INSA of Rennes (France)
package org.ietr.stdio;

actor Source () ==> uint(size=8) O :

native procedure source_init ( ) end
native procedure source_readNBytes (uint(size=8) outTable [ NB_TOKEN_TO_SENT ] , uint(size=12) nbTokenToRead ) end
native function source_sizeOfFile ( ) --> int(size=32) end 
native procedure source_rewind ( ) end
native function source_getNbLoop () --> uint end
native procedure source_exit (int exitCode) end

uint(size=32) NB_TOKEN_TO_SENT = 4096;

uint(size=8) bytesRead [ NB_TOKEN_TO_SENT ];

uint(size=32) iterationLoop := 0;
int (size=32) fileLoop;
uint(size=32) nbByteLeft;
uint(size=12) nbByteToSend := 0;
uint(size=12) nbByteSent := 0;
uint(size=32) nbIteration;

initialize ==>
do
	source_init();
	fileLoop := source_getNbLoop();
end

getFileSize: action ==>
guard
	source_sizeOfFile() > 0
var
	uint(size=32) nbBytes
do
	nbBytes := source_sizeOfFile();
	nbIteration := nbBytes / NB_TOKEN_TO_SENT;
	nbByteLeft := nbBytes mod NB_TOKEN_TO_SENT;
end

readNBytes: action ==>
guard
	iterationLoop < nbIteration
do
	source_readNBytes(bytesRead, NB_TOKEN_TO_SENT);
	nbByteToSend := NB_TOKEN_TO_SENT;
	nbByteSent := 0;
	iterationLoop := iterationLoop + 1;
end

readEndOfFile: action ==>
guard
	nbByteLeft > 0
do
	source_readNBytes(bytesRead, nbByteLeft);
	nbByteToSend := nbByteLeft;
	nbByteSent := 0;
end

readFileDone: action ==>
do
	iterationLoop := 0;
	fileLoop := fileLoop - 1;
	if(fileLoop <= 0)then
		source_exit(0);
	end
	source_rewind();
end

sendData.launch: action ==> O:[ Out ]
guard
	nbByteToSend > nbByteSent
var
	uint(size=8) Out
do
	Out := bytesRead[nbByteSent];
	nbByteSent := nbByteSent + 1;
end

sendData.done: action ==>
guard
	nbByteToSend = nbByteSent
end

schedule fsm ReadInit :
	ReadInit ( getFileSize ) --> ReadFile;

	ReadFile ( readNBytes    ) --> SendData;
	ReadFile ( readEndOfFile ) --> SendLastData;
	ReadFile ( readFileDone  ) --> ReadFile;

	SendData ( sendData.launch ) --> SendData;
	SendData ( sendData.done   ) --> ReadFile;

	SendLastData ( sendData.launch ) --> SendLastData;
	SendLastData ( sendData.done   ) --> ReadFileDone;

	ReadFileDone ( readFileDone ) --> ReadInit;
end

priority
	readNBytes > readEndOfFile > readFileDone;
	sendData.launch > sendData.done;
end

end