/**
 * This FU is part of a RVC-CAL implementation of SKID3 user authentication protocol.
 * This FU (as part of the server's implementation) receives the client's authentication request and client's HMAC (H2), 
 * prepares data for HMAC operations (H1 and H2') and sends the needed data to its helper FU (Server_Sender).
 * 
 * FU ID: Server_Receiver
 * One FU parameter: 
 * 	 This FU gets its own UID as an FU parameter.
 *   1) int serverID: the UID of the server.
 * Three input port:
 * 	 1) uint(size=8) IP1_PRG: the nounce from pseudo random generator (PRG).
 *   2) int(size=8) IP2_Hash_Size: the hash size (in bytes) of the Hash operation (e.g. SHA-1, SHA-2 etc.) used in the HMAC.
 *   3) uint(size=8) IP3_Channel: the communication channel to receive client's data (the UID, the nounce rC and the HMAC H2). 
 * Four output port:
 * 	 1) int(size=64) OP1_Message_Size: the size (in bytes) of the message to be HMACed.
 *   2) uint(size=8) OP2_Message: the message to be HMACed.
 *   3) int(size=64) OP3_Hash_Size: the hash size (in bytes) of the Hash operation (e.g. SHA-1, SHA-2 etc.) used in the HMAC.    
 *   4) uint(size=8) OP4_Link: the link to exchange data between this FU and the Server_Sender FU.
 *   Note: OP1_Message_Size and OP3_Hash_Size ports have to be 64-bit in size to match the corresponding input ports in the HMAC.
 *
 * Developer: Junaid Jameel Ahmad @ Uni-Konstanz 2012
 * Last modified: 13.04.2012
 */

package Protocols.Authentication.SKID3;

actor Server_Receiver(int(size=8) serverID) uint(size=8) IP1_PRG, int(size=8) IP2_Hash_Size, uint(size=8) IP3_Channel 
	==> 
	int(size=64) OP1_Message_Size, uint(size=8) OP2_Message,  int(size=64) OP3_Hash_Size,  uint(size=8) OP4_Link:

	int(size=8) clientID := 0;
	uint(size=8) rS := 0; // My nounce
	uint(size=8) rC := 0; // Client's nounce.
	
	int(size=8) hashSize := 0; // Number of bytes.	
	int counter := 0;
	

	receiveConfigurations:
	action IP1_PRG:[r], IP2_Hash_Size:[hSize] ==>
	do
		rS := r;
		hashSize := hSize;
		counter := 0;		
	end
	
	// Process clients's ID and nounce (rC)
	processClientsIDAndNounce:
	action IP3_Channel:[id, r] ==> 
	guard counter = 0
	do
		clientID := id;
		rC := r;
		counter := counter + 1;
	end

	// Prepare data to generate the HMAC on client's nounce (i.e., H1), which will be sent to the client for authentication.
	sendHMACData1:
	action ==> OP1_Message_Size:[3], OP2_Message:[rS, rC, serverID], OP3_Hash_Size:[hashSize] end

	// Process (receive and forward) the client's HMAC (H2) on my nounce.
	processClientHMAC:
	action IP3_Channel:[h] ==> OP4_Link:[h]
	guard counter >= 1 and counter <= hashSize
	do
		counter := counter + 1;	
	end

	// Prepare data to generate my copy of the client's HMAC (i.e., H2'). Server_Sender actor will verify if H2' equals H2.
	sendHMACData2:
	action ==> OP1_Message_Size:[3], OP2_Message:[rC, rS, clientID], OP3_Hash_Size:[hashSize]
	guard counter > hashSize end

	schedule fsm start:
		start(receiveConfigurations) --> listenChannel;
		
		listenChannel(processClientsIDAndNounce) --> sendHMACData1;
		sendHMACData1(sendHMACData1) --> listenChannel;
		
		listenChannel(processClientHMAC) --> listenChannel;
		listenChannel(sendHMACData2) --> sendHMACData2;
		
	 	sendHMACData2(sendHMACData2) --> start;
	end
	
	priority
		processClientsIDAndNounce > processClientHMAC > sendHMACData2;
	end

end
