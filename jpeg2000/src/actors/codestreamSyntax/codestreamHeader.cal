package actors.codestreamSyntax;
import utils.markerPackage.*;
import utils.commonPackage.*;
import utils.codestreamPackage.*;
/******************************************************************************
 * Actor decription
 *****************************************************************************/
actor codestreamHeader () uint(size= 8) codestream
						  ==>
						  uint(size= 9) codestreamOut,
						  uint(size= 8) SIZ,
						  uint(size= 8) COC,
						  uint(size= 8) SOT,
						  uint(size= 8) deqTileInfo,
						  uint(size= 8) traTileInfo
:
/******************************************************************************
 * Globale variables
 *****************************************************************************/
	uint(size=16) buffer_v := 0;
	uint(size=16) length_v;
	uint(size=16) cpt_v;
	uint(size=32) cpt2_v;
	uint(size= 8) HeaderIdx;
	bool          cocExists[2][NB_COMPONENT_MAX];
	bool          qccExists[2][NB_COMPONENT_MAX];
/******************************************************************************
 * readByte
 *****************************************************************************/
	readByte : action codestream:[ codestream_p ] ==>
	do
		buffer_v := ((buffer_v & 0x00FF) << 8 ) + codestream_p;
	end
/******************************************************************************
 * SIZ variables
 *****************************************************************************/
	uint(size=16) Rsiz;
	uint(size=32) Xsiz;
	uint(size=32) Ysiz;
	uint(size=32) XOsiz;
	uint(size=32) YOsiz;
	uint(size=32) XTsiz;
	uint(size=32) YTsiz;
	uint(size=32) XTOsiz;
	uint(size=32) YTOsiz;
	uint(size=16) Csiz;
	uint(size= 8) Ssiz[SIZ_MAX];
	uint(size= 8) XRsiz[SIZ_MAX];
	uint(size= 8) YRsiz[SIZ_MAX];
/******************************************************************************
 * SIZ action
 *****************************************************************************/
	ifIsStartSIZ : action ==>
	guard
		buffer_v = SIZ
	end
	StartSIZ : action codestream:[ codestream_p ] repeat 38 
					  ==>
					  SIZ:[codestream_p] repeat 38,
					  deqTileInfo:[Csiz]
	do
		length_v     := (codestream_p[ 0] <<  8) +  codestream_p[ 1] - 38;
		Rsiz         := (codestream_p[ 2] <<  8) +  codestream_p[ 3];
		Xsiz         := (codestream_p[ 4] << 24) + (codestream_p[ 5] << 16) +
					    (codestream_p[ 6] <<  8) +  codestream_p[ 7];
		Ysiz         := (codestream_p[ 8] << 24) + (codestream_p[ 9] << 16) +
					    (codestream_p[10] <<  8) +  codestream_p[11];
		XOsiz        := (codestream_p[12] << 24) + (codestream_p[13] << 16) +
					    (codestream_p[14] <<  8) +  codestream_p[15];
		YOsiz        := (codestream_p[16] << 24) + (codestream_p[17] << 16) +
					    (codestream_p[18] <<  8) +  codestream_p[19];
		XTsiz        := (codestream_p[20] << 24) + (codestream_p[21] << 16) +
					    (codestream_p[22] <<  8) +  codestream_p[23];
		YTsiz        := (codestream_p[24] << 24) + (codestream_p[25] << 16) +
					    (codestream_p[26] <<  8) +  codestream_p[27];
		XTOsiz       := (codestream_p[28] << 24) + (codestream_p[29] << 16) +
					    (codestream_p[30] <<  8) +  codestream_p[31];
		YTOsiz       := (codestream_p[32] << 24) + (codestream_p[33] << 16) +
					    (codestream_p[34] <<  8) +  codestream_p[35];
		Csiz         := (codestream_p[36] <<  8) +  codestream_p[37];
		buffer_v     := 0;
		cpt_v        := 0;
		HeaderIdx    := 0;
		cocExists[0] := [false: for int c in 0 .. NB_COMPONENT_MAX - 1];
		qccExists[0] := [false: for int c in 0 .. NB_COMPONENT_MAX - 1];
		Psot         := 0;
	end
	readByteSIZ : action codestream:[ codestream_p ] repeat 3 ==> SIZ:[codestream_p]  repeat 3
	guard
		length_v > 0
	do
		Ssiz[cpt_v]  := codestream_p[0];
		XRsiz[cpt_v] := codestream_p[1];
		YRsiz[cpt_v] := codestream_p[2];
		length_v     := length_v - 3;
		cpt_v        := cpt_v + 1;
	end
	ifIsEndSIZ : action ==>
	guard
		length_v = 0
	do
		if DEBUG_HEADER = true then
		    println("====================");
    		println("==== SOC Header ====");
    		println("====================");
			println("==== SIZ ====");
    		print(" R    = "+Rsiz+" : ");
    		if Rsiz = 0 then
    			println("Capabilities specified in this Recommendation | International Standard only");
    		else
    			if Rsiz = 1 then
    				println("Codestream restricted as described for Profile 0 from Table A-45");
    			else
    				println("Codestream restricted as described for Profile 1 from Table A-45");
    			end
    		end
    		println(" X    = "+Xsiz);
    		println(" Y    = "+Ysiz);
    		println(" XO   = "+XOsiz);
    		println(" YO   = "+YOsiz);
    		println(" XT   = "+XTsiz);
    		println(" YT   = "+YTsiz);
    		println(" XTO  = "+XTOsiz);
		    println(" YTO  = "+YTOsiz);
    		println(" C    = "+Csiz);
    		foreach uint(size=8) i in 0 .. cpt_v-1 do
      			print(" S"+i+"   = "+Ssiz[i]+" : sample bit depth = "+((Ssiz[i]&0x7f)+1)+". ");
      			if (Ssiz[i] & 0x80) = 0 then
					println("unsigned values");
      			else
					println("signed values");
      			end
      			println(" XR"+i+"  = "+XRsiz[i]);
      			println(" YR"+i+"  = "+YRsiz[i]);
    		end
    	end
	end
/******************************************************************************
 * COD COC variables
 *****************************************************************************/
	uint(size= 8) Scoc[2][NB_COMPONENT_MAX];
	uint(size=32) SGcoc[2][NB_COMPONENT_MAX];
	uint(size= 8) SPcoc[2][NB_COMPONENT_MAX][COD_MAX];
	uint(size=16) Ccoc;
/******************************************************************************
 * COD COC action
 *****************************************************************************/
	ifIsStartCOC : action ==>
	guard
		buffer_v = COD || buffer_v = COC
	end
	StartCOC.COD : action codestream:[ codestream_p ] repeat 7 ==>
	guard
		buffer_v = COD
	do
		length_v := (codestream_p[0] <<  8) +  codestream_p[1] - 7;
		Ccoc     := 0xFFFF;
    	foreach uint(size=8) c in 0 .. NB_COMPONENT_MAX-1 do
    		cocExists[HeaderIdx][c] := true;
			Scoc[HeaderIdx][c]      :=  codestream_p[2];
			SGcoc[HeaderIdx][c]     := (codestream_p[3] << 24) + (codestream_p[4] << 16) +
								       (codestream_p[5] <<  8) +  codestream_p[6];
		end
		cpt_v := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	StartCOC.COC4 : action codestream:[ codestream_p ] repeat 4 ==>
	guard
		buffer_v = COC && Csiz < 257
	do
		length_v                   := (codestream_p[0] << 8) + codestream_p[1] - 4;
		Ccoc                       :=  codestream_p[2];
	    cocExists[HeaderIdx][Ccoc] := true;
		Scoc[HeaderIdx][Ccoc]      := (Scoc[HeaderIdx][Ccoc] & 0xFE) | codestream_p[3];
		cpt_v                      := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	StartCOC.COC5 : action codestream:[ codestream_p ] repeat 5 ==>
	guard
		buffer_v = COC && Csiz >= 257
	do
		length_v                   := (codestream_p[0] << 8) + codestream_p[1] - 5;
		Ccoc                       := (codestream_p[2] << 8) + codestream_p[3];
	    cocExists[HeaderIdx][Ccoc] := true;
		Scoc[HeaderIdx][Ccoc]      := (Scoc[HeaderIdx][Ccoc] & 0xFE) | codestream_p[4];
		cpt_v                      := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	readByteCOC : action codestream:[ codestream_p ] ==>
	guard
		length_v > 0
	do
		if Ccoc != 0xFFFF then
			SPcoc[HeaderIdx][Ccoc][cpt_v] := codestream_p;
		else
    		foreach uint(size=8) c in 0 .. NB_COMPONENT_MAX-1 do
				SPcoc[HeaderIdx][c][cpt_v] := codestream_p;
			end
		end
		length_v := length_v - 1;
		cpt_v    := cpt_v + 1;
	end
	ifIsEndCOC : action ==>
	guard
		length_v = 0
	var
		uint(size=16) c := Ccoc
	do
		if DEBUG_HEADER = true then
			if Ccoc = 0xFFFF then
				c := 0;
			end
    		if buffer_v = COD then
    			println("==== COD ====");
				else
				println("==== COC ====");
			    println(" C    = "+c);
			end
			print(" S    = "+Scoc[HeaderIdx][c]+" :");
    		foreach uint(size=8) i in 0 .. 2 do
    			cpt2_v := ((1<<i) << 4) + (Scoc[HeaderIdx][c] &(1<<i));
      			if cpt2_v = 0x10 then print(" PPx = PPy = 15,"); end
		    	if cpt2_v = 0x11 then print(" Entropy coder with precinct values defined below,"); end
    	 		if cpt2_v = 0x20 then print(" No SOP,"); end
     			if cpt2_v = 0x22 then print(" SOP,"); end
     	 		if cpt2_v = 0x40 then println(" No EPH"); end
     	 		if cpt2_v = 0x44 then println(" EPH"); end
    		end
    		if buffer_v = COD then
    			println(" SG   = "+SGcoc[HeaderIdx][c]);
    			cpt2_v := (SGcoc[HeaderIdx][c] >> 24) & 0xff;
    			if cpt2_v = 0 then println("       Layer-resolution level-component-position progression"); end
    			if cpt2_v = 1 then println("       Resolution level-layer-component-position progression"); end
    			if cpt2_v = 2 then println("       Resolution level-position-component-layer progression"); end
    			if cpt2_v = 3 then println("       Position-component-resolution level-layer progression"); end
    			if cpt2_v = 4 then println("       Component-position-resolution level-layer progression"); end
	    		println("");
    			println("       Number of layers : "+((SGcoc[HeaderIdx][c] >> 8) & 0xffff));
	    		println("");
    			if (SGcoc[HeaderIdx][c] & 0xff) = 0 then
			   		println("       No multiple component transformation specified.");
    			else
		    		println("       Component transformation used on components 0, 1, 2 for coding efficiency (see Annex G.2).");
      				println("       Irreversible component transformation used with the 9-7 irreversible filter.");
      				println("       Reversible component transformation used with the 5-3 reversible filter.");
    			end
    			println("");
			end
    		foreach uint(size=8) i in 0 .. cpt_v - 1 do
	      		print(" SP"+i+"  = "+SPcoc[HeaderIdx][c][i]+" : ");
    	  		if i = 0 then println("Number of decomposition levels, NL = "+SPcoc[HeaderIdx][c][i]+", Zero implies no transformation"); end
      			if i = 1 then println("Code-block width exponent offset value,  xcb = "+(SPcoc[HeaderIdx][c][i]+2)); end
      			if i = 2 then println("Code-block height exponent offset value, ycb = "+(SPcoc[HeaderIdx][c][i]+2)); end
      			if i = 3 then 
	  				println("Style of the code-block coding passes");
					foreach uint(size=8) j in 0 .. 5 do
    					cpt2_v := ((1<<j) << 8) + (SPcoc[HeaderIdx][c][i] &(1<<j));
      					if cpt2_v = 0x0100 then println("            No selective arithmetic coding bypass"); end
	  					if cpt2_v = 0x0101 then println("            Selective arithmetic coding bypass"); end
	  					if cpt2_v = 0x0200 then println("            No reset of context probabilities on coding pass boundaries"); end
	  					if cpt2_v = 0x0202 then println("            Reset context probabilities on coding pass boundaries"); end
	  					if cpt2_v = 0x0400 then println("            No termination on each coding pass"); end
	  					if cpt2_v = 0x0404 then println("            Termination on each coding pass"); end
	  					if cpt2_v = 0x0800 then println("            No vertically causal context"); end
	  					if cpt2_v = 0x0808 then println("            Vertically causal context"); end
	  					if cpt2_v = 0x1000 then println("            No predictable termination"); end
		  				if cpt2_v = 0x1010 then println("            Predictable termination"); end
	  					if cpt2_v = 0x2000 then println("            No segmentation symbols are used"); end
	  					if cpt2_v = 0x2020 then println("            Segmentation symbols are used"); end
					end
				end
				if i = 4 then
		  			print("Wavelet transformation used");
					if SPcoc[HeaderIdx][c][i] = 0 then
						println(" 9-7 irreversible filter");
					else
						println(" 5-3 reversible filter");
					end
				end
      			if i > 4 then
					println("Precinct size "+(i-5)+" : resolution level("+(i-5)+") : PPx = "+(SPcoc[HeaderIdx][c][i]&0xf)+" : PPy = "+(SPcoc[HeaderIdx][c][i]>>4));
      			end
    		end
    	end
		buffer_v        := 0;
	end
/******************************************************************************
 * QCD QCC variables
 *****************************************************************************/
	uint(size= 8) Sqcc[2][NB_COMPONENT_MAX];
	uint(size=16) SPqcc[2][NB_COMPONENT_MAX][QCD_MAX];
	uint(size=16) Cqcc;
	uint(size=16) Cqcc2;
/******************************************************************************
 * QCD QCC action
 *****************************************************************************/
	ifIsStartQCC : action ==>
	guard
		buffer_v = QCD || buffer_v = QCC
	end
	StartQCC.QCD : action codestream:[ codestream_p ] repeat 3 ==>
	guard
		buffer_v = QCD
	do
		length_v        := (codestream_p[0] << 8) + codestream_p[1] - 3;
		Cqcc            := 0;
		Cqcc2           := 0xFFFF;
    	foreach uint(size=8) c in 0 .. NB_COMPONENT_MAX-1 do
    		qccExists[HeaderIdx][c] := true;
			Sqcc[HeaderIdx][c]      :=  codestream_p[2];
		end
		cpt_v           := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	StartQCC.QCC4 : action codestream:[ codestream_p ] repeat 4 ==>
	guard
		buffer_v = QCC and Csiz < 257
	do
		length_v                   := (codestream_p[0] << 8) + codestream_p[1] - 4;
		Cqcc                       :=  codestream_p[2];
		Cqcc2                      :=  Cqcc;
    	qccExists[HeaderIdx][Cqcc] := true;
		Sqcc[HeaderIdx][Cqcc]      :=  codestream_p[3];
		cpt_v                      := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	StartQCC.QCC5 : action codestream:[ codestream_p ] repeat 5 ==>
	guard
		buffer_v = QCC and Csiz < 257
	do
		length_v                   := (codestream_p[0] << 8) + codestream_p[1] - 5;
		Cqcc                       := (codestream_p[2] << 8) + codestream_p[3];
		Cqcc2                      :=  Cqcc;
		qccExists[HeaderIdx][Cqcc] := true;
		Sqcc[HeaderIdx][Cqcc]      :=  codestream_p[4];
		cpt_v                      := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	readByteQCC.read8 : action codestream:[ codestream_p ] ==>
	guard
		length_v > 0 and (Sqcc[HeaderIdx][Cqcc] & 0x1f) = 0
	do
		if Cqcc2 != 0xFFFF then
			SPqcc[HeaderIdx][Cqcc][cpt_v] := codestream_p;
		else
    		foreach uint(size=8) c in 0 .. NB_COMPONENT_MAX-1 do
				SPqcc[HeaderIdx][c][cpt_v] := codestream_p;
			end
		end
		length_v := length_v - 1;
		cpt_v    := cpt_v + 1;
	end
	readByteQCC.read16 : action codestream:[ codestream_p ] repeat 2 ==>
	guard
		length_v > 0 and (Sqcc[HeaderIdx][Cqcc] & 0x1f) != 0
	do
		if Cqcc2 != 0xFFFF then
			SPqcc[HeaderIdx][Cqcc][cpt_v] := (codestream_p[0] <<  8) +  codestream_p[1];
		else
    		foreach uint(size=8) c in 0 .. NB_COMPONENT_MAX-1 do
				SPqcc[HeaderIdx][c][cpt_v] := (codestream_p[0] <<  8) +  codestream_p[1];
			end
		end
		length_v := length_v - 2;
		cpt_v    := cpt_v + 1;
	end
	ifIsEndQCC : action ==>
	guard
		length_v = 0
	do
		if DEBUG_HEADER = true then
			if buffer_v = QCD then
			    println("==== QCD ====");
			else
				println("==== QCC ====");
				println(" C    = "+Cqcc);
			end
    		print(" S    = "+Sqcc[HeaderIdx][Cqcc]+" : ");
    		if (Sqcc[HeaderIdx][Cqcc] & 0x1f) = 0 then print("No quantization"); end
    		if (Sqcc[HeaderIdx][Cqcc] & 0x1f) = 1 then print("Scalar derived"); end
    		if (Sqcc[HeaderIdx][Cqcc] & 0x1f) = 2 then print("Scalar expounded"); end
    		println(" : Number of guard bits = "+((Sqcc[HeaderIdx][Cqcc]>>5)&0x7));
    		foreach uint(size=8) i in 0 .. cpt_v - 1 do
      			print(" SP"+i+"  = "+SPqcc[HeaderIdx][Cqcc][i]+" : ");
      			if (Sqcc[HeaderIdx][Cqcc] & 0x1f) = 0 then
					println("Exponent, Eb = "+((SPqcc[HeaderIdx][Cqcc][i]>>3)&0x01F));
      			else 
					println("Mantissa, Ub = "+(SPqcc[HeaderIdx][Cqcc][i]& 0x7FF)+" : Exponent, Eb = "+((SPqcc[HeaderIdx][Cqcc][i]>>11)&0x01F));
      			end
    		end
		end
		buffer_v := 0;
	end
/******************************************************************************
 * RGN variables
 *****************************************************************************/
 	uint(size=16) Crgn[2];
	uint(size= 8) Srgn[2];
	uint(size= 8) SPrgn[2];
/******************************************************************************
 * RGN action
 *****************************************************************************/
	ifIsStartRGN : action ==>
	guard
		buffer_v = RGN
	end
	StartRGN.RGN5 : action codestream:[ codestream_p ] repeat 5 ==>
	guard
		Csiz < 257
	do
		Crgn[HeaderIdx]      := codestream_p[2];
		Srgn[HeaderIdx]      := codestream_p[3];
		SPrgn[HeaderIdx]     := codestream_p[4];
		buffer_v             := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
		if DEBUG_HEADER = true then
		    println("==== RGN ====");
    		println(" C    = "+Crgn[HeaderIdx]);
    		print(" S    = "+Srgn[HeaderIdx]+" : ");
    		if Srgn[HeaderIdx] = 0 then
				println("Implicit ROI (maximum shift)");
    		else 
      			println("All other values reserved");
    		end
    		println(" SP   = "+SPrgn[HeaderIdx]+" : Binary shifting of ROI coefficients above the background");
    	end
	end
	StartRGN.RGN6 : action codestream:[ codestream_p ] repeat 6 ==>
	guard
		Csiz >= 257
	do
		Crgn[HeaderIdx]      := (codestream_p[2] << 8) + codestream_p[3];
		Srgn[HeaderIdx]      :=  codestream_p[4];
		SPrgn[HeaderIdx]     :=  codestream_p[5];
		buffer_v             := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
		if DEBUG_HEADER = true then
			println("==== RGN ====");
    		println(" C    = " + Crgn[HeaderIdx]);
    		print(" S    = " + Srgn[HeaderIdx] +" : ");
    		if Srgn[HeaderIdx] = 0 then
				println("Implicit ROI (maximum shift)");
    		else 
      			println("All other values reserved");
    		end
    		println(" SP   = "+SPrgn[HeaderIdx]+" : Binary shifting of ROI coefficients above the background");
    	end
	end
/******************************************************************************
 * POC variables
 *****************************************************************************/
 	uint(size= 8) RSpoc[2][POC_MAX];
	uint(size=16) CSpoc[2][POC_MAX];
	uint(size=16) LYEpoc[2][POC_MAX];
	uint(size= 8) REpoc[2][POC_MAX];
	uint(size=16) CEpoc[2][POC_MAX];
	uint(size= 8) Ppoc[2][POC_MAX];
/******************************************************************************
 * POC action
 *****************************************************************************/
	ifIsStartPOC : action ==>
	guard
		buffer_v = POC
	end
	StartPOC : action codestream:[ codestream_p ] repeat 2 ==>
	do
		length_v := (codestream_p[0] << 8) + codestream_p[1] - 2;
		buffer_v := 0;
		cpt_v    := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	readBytePOC.read7 : action codestream:[ codestream_p ] repeat 7 ==>
	guard
		length_v > 0 and Csiz < 257
	do
		length_v                 := length_v - 7;
		RSpoc[HeaderIdx][cpt_v]  :=  codestream_p[0];
		CSpoc[HeaderIdx][cpt_v]  :=  codestream_p[1];
		LYEpoc[HeaderIdx][cpt_v] := (codestream_p[2] <<  8) + codestream_p[3];
		REpoc[HeaderIdx][cpt_v]  :=  codestream_p[4];
		CEpoc[HeaderIdx][cpt_v]  :=  codestream_p[5];
		Ppoc[HeaderIdx][cpt_v]   :=  codestream_p[6];
		cpt_v                    := cpt_v + 1;
	end
	readBytePOC.read9 : action codestream:[ codestream_p ] repeat 9 ==>
	guard
		length_v > 0 and Csiz >= 257
	do
		length_v                 := length_v - 9;
		RSpoc[HeaderIdx][cpt_v]  :=  codestream_p[0];
		CSpoc[HeaderIdx][cpt_v]  := (codestream_p[1] <<  8) + codestream_p[2];
		LYEpoc[HeaderIdx][cpt_v] := (codestream_p[3] <<  8) + codestream_p[4];
		REpoc[HeaderIdx][cpt_v]  :=  codestream_p[5];
		CEpoc[HeaderIdx][cpt_v]  := (codestream_p[6] <<  8) + codestream_p[7];
		Ppoc[HeaderIdx][cpt_v]   :=  codestream_p[8];
		cpt_v                    := cpt_v + 1;
	end
	ifIsEndPOC : action ==>
	guard
		length_v = 0
	do
		if DEBUG_HEADER = true then
			println("==== POC ====");
    		foreach uint(size=8) i in 0 .. cpt_v - 1 do
				println(" RS"+i+"    = "+RSpoc[HeaderIdx][i]);
      			println(" CS"+i+"    = "+CSpoc[HeaderIdx][i]);
      			println(" LYE"+i+"   = "+LYEpoc[HeaderIdx][i]);
      			println(" RE"+i+"    = "+REpoc[HeaderIdx][i]);
      			println(" CE"+i+"    = "+CEpoc[HeaderIdx][i]);
      			print(" P"+i+"     = "+Ppoc[HeaderIdx][i]+" : ");
      			if Ppoc[HeaderIdx][i] = 0 then println("Layer-resolution level-component-position progression"); end
      			if Ppoc[HeaderIdx][i] = 1 then println("Resolution level-layer-component-position progression"); end
      			if Ppoc[HeaderIdx][i] = 2 then println("Resolution level-position-component-layer progression"); end
      			if Ppoc[HeaderIdx][i] = 3 then println("Position-component-resolution level-layer progression"); end
      			if Ppoc[HeaderIdx][i] = 4 then println("Component-position-resolution level-layer progression"); end
      		end
    	end
	end
/******************************************************************************
 * PPM variables
 *****************************************************************************/
	uint(size= 8) Zppm;
	uint(size=32) Nppm[PPM_Z_MAX];
	uint(size= 8) Ippm[PPM_Z_MAX][PPM_N_MAX];
/******************************************************************************
 * PPM action
 *****************************************************************************/
	ifIsStartPPM : action ==>
	guard
		buffer_v = PPM
	end
	StartPPM : action codestream:[ codestream_p ] repeat 3 ==>
	do
		length_v := (codestream_p[0] << 8) + codestream_p[1] - 3;
		Zppm     :=  codestream_p[2];
		cpt_v    := 0;
		cpt2_v   := 0;
		buffer_v := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	readBytePPM.Z : action codestream:[ codestream_p ] repeat 4 ==>
	guard
		cpt_v < Zppm and cpt2_v = Nppm[cpt_v]
	do
		length_v    := length_v - 4;
		Nppm[cpt_v] := (codestream_p[0] << 24) + (codestream_p[1] << 16) +
					   (codestream_p[2] <<  8) +  codestream_p[3];
		if (cpt_v != 0) || (cpt_v = 0 && cpt2_v = Nppm[cpt_v])  then
			cpt_v   := cpt_v + 1;
		end
		cpt2_v      := 0;
	end
	readBytePPM.N : action codestream:[ codestream_p ] ==>
	guard
		cpt2_v < Nppm[cpt_v]
	do
		length_v            := length_v - 1;
		Ippm[cpt_v][cpt2_v] := codestream_p;
		cpt2_v              := cpt2_v + 1;
	end
	ifIsEndPPM : action ==>
	guard
		length_v = 0
	do
		if DEBUG_HEADER = true then
			println("==== PPM ====");
    		println(" Z    = "+Zppm);
    		foreach uint(size=8) z in 0 .. Zppm - 1 do
      			println(" N"+z+"     = "+Nppm[z]);
      			foreach uint(size=8) n in 0 .. Nppm[z] - 1 do
					println(" I"+z+""+n+"    = "+Ippm[z][n]+" : a revoir !!!");
				end
			end
		end
	end
/******************************************************************************
 * TLM variables
 *****************************************************************************/
	uint(size= 8) Ztlm;
	uint(size= 8) Stlm;
	uint(size=16) Ttlm[TLM_MAX];
	uint(size=32) Ptlm[TLM_MAX];
/******************************************************************************
 * TLM action
 *****************************************************************************/
	ifIsStartTLM : action ==>
	guard
		buffer_v = TLM
	end
	StartTLM : action codestream:[ codestream_p ] repeat 4 ==>
	do
		length_v := (codestream_p[0] << 8) + codestream_p[1] - 4;
		Ztlm     :=  codestream_p[2];
		Stlm     :=  codestream_p[3];
		buffer_v := 0;
		cpt_v    := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	readByteTLM.ST0_SP0 : action codestream:[ codestream_p ] repeat 2 ==>
	guard
		length_v > 0 and ((Stlm>>4)&0x3) = 0 and ((Stlm>>6)&0x3) = 0
	do
		length_v    := length_v - 2;
		Ptlm[cpt_v] := (codestream_p[0] << 8) + codestream_p[1];
		cpt_v       := cpt_v + 1;
	end
	readByteTLM.ST1_SP0 : action codestream:[ codestream_p ] repeat 3 ==>
	guard
		length_v > 0 and ((Stlm>>4)&0x3) = 1 and ((Stlm>>6)&0x3) = 0
	do
		length_v    := length_v - 3;
		Ttlm[cpt_v] :=  codestream_p[0];
		Ptlm[cpt_v] := (codestream_p[1] << 8) + codestream_p[2];
		cpt_v       := cpt_v + 1;
	end
	readByteTLM.ST2_SP0 : action codestream:[ codestream_p ] repeat 4 ==>
	guard
		length_v > 0 and ((Stlm>>4)&0x3) = 2 and ((Stlm>>6)&0x3) = 0
	do
		length_v    := length_v - 4;
		Ttlm[cpt_v] := (codestream_p[0] << 8) + codestream_p[1];
		Ptlm[cpt_v] := (codestream_p[2] << 8) + codestream_p[3];
		cpt_v       := cpt_v + 1;
	end
	readByteTLM.ST0_SP1 : action codestream:[ codestream_p ] repeat 4 ==>
	guard
		length_v > 0 and ((Stlm>>4)&0x3) = 0 and ((Stlm>>6)&0x3) = 1
	do
		length_v    := length_v - 4;
		Ptlm[cpt_v] := (codestream_p[0] << 24) + (codestream_p[1] << 16) +
					   (codestream_p[2] <<  8) +  codestream_p[3];
		cpt_v       := cpt_v + 1;
	end
	readByteTLM.ST1_SP1 : action codestream:[ codestream_p ] repeat 5 ==>
	guard
		length_v > 0 and ((Stlm>>4)&0x3) = 1 and ((Stlm>>6)&0x3) = 1
	do
		length_v    := length_v - 5;
		Ttlm[cpt_v] :=  codestream_p[0];
		Ptlm[cpt_v] := (codestream_p[1] << 24) + (codestream_p[2] << 16) +
					   (codestream_p[3] <<  8) +  codestream_p[4];
		cpt_v       := cpt_v + 1;
	end
	readByteTLM.ST2_SP1 : action codestream:[ codestream_p ] repeat 6 ==>
	guard
		length_v > 0 and ((Stlm>>4)&0x3) = 2 and ((Stlm>>6)&0x3) = 1
	do
		length_v    := length_v - 6;
		Ttlm[cpt_v] := (codestream_p[0] <<  8) +  codestream_p[1];
		Ptlm[cpt_v] := (codestream_p[2] << 24) + (codestream_p[3] << 16) +
					   (codestream_p[4] <<  8) +  codestream_p[5];
		cpt_v       := cpt_v + 1;
	end
	ifIsEndTLM : action ==>
	guard
		length_v = 0
	do
		if DEBUG_HEADER = true then
    		println("==== TLM ====");
    		println(" Z    = "+Ztlm);
    		print(" S    = "+Stlm+" : ");
    		if ((Stlm>>4)&0x8) = 0 then println("ST = 0; Ttlm parameter is 0 bits, SP = 0; Ptlm parameter 16 bits"); end
    		if ((Stlm>>4)&0x8) = 1 then println("ST = 1; Ttlm parameter 8 bits,    SP = 0; Ptlm parameter 16 bits"); end
    		if ((Stlm>>4)&0x8) = 2 then println("ST = 2; Ttlm parameter 16 bits,   SP = 0; Ptlm parameter 16 bits"); end
    		if ((Stlm>>4)&0x8) = 4 then println("ST = 0; Ttlm parameter is 0 bits, SP = 1; Ptlm parameter 32 bits"); end
    		if ((Stlm>>4)&0x8) = 5 then println("ST = 1; Ttlm parameter 8 bits,    SP = 1; Ptlm parameter 32 bits"); end	
    		if ((Stlm>>4)&0x8) = 6 then println("ST = 2; Ttlm parameter 16 bits,   SP = 1; Ptlm parameter 32 bits"); end
       		foreach uint(size=8) i in 0 .. cpt_v - 1 do
    			if ((Stlm>>4)&0x3) != 0 then
					println(" T"+i+"     = "+Ttlm[i]);
      			else
					println(" P"+i+"     = "+Ptlm[i]);
      			end
    		end
		end
	end
/******************************************************************************
 * PLM variables
 *****************************************************************************/
	uint(size= 8) Zplm;
	uint(size= 8) Nplm[PLM_Z_MAX];
	uint(size= 8) Iplm[PLM_Z_MAX][PLM_N_MAX];
/******************************************************************************
 * PLM action
 *****************************************************************************/
	ifIsStartPLM : action ==>
	guard
		buffer_v = PLM
	end
	StartPLM : action codestream:[ codestream_p ] repeat 3 ==>
	do
		length_v := (codestream_p[0] << 8) + codestream_p[1] - 3;
		Zplm     :=  codestream_p[2];
		cpt_v    := 0;
		cpt2_v   := 0;
		Nplm[0]  := 0;
		buffer_v := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	readBytePLM.Z : action codestream:[ codestream_p ] ==>
	guard
		cpt_v < Zplm and cpt2_v = Nplm[cpt_v]
	do
		length_v    := length_v - 1;
		Nplm[cpt_v] := codestream_p;
		if (cpt_v != 0) || (cpt_v = 0 && cpt2_v = Nplm[cpt_v])  then
			cpt_v   := cpt_v + 1;
		end
		cpt2_v      := 0;
	end
	readBytePLM.N : action codestream:[ codestream_p ] ==>
	guard
		cpt2_v < Nplm[cpt_v]
	do
		length_v            := length_v - 1;
		Iplm[cpt_v][cpt2_v] := codestream_p;
		cpt2_v              := cpt2_v + 1;
	end
	ifIsEndPLM : action ==>
	guard
		length_v = 0
	do
		if DEBUG_HEADER = true then
			println("==== PLM ====");
    		println(" Z    = "+Zplm);
    		foreach uint(size=8) z in 0 .. Zplm - 1 do
      			println(" N"+z+"     = "+Nplm[z]);
      			foreach uint(size=8) n in 0 .. Nplm[z] - 1 do
					println(" I"+z+""+n+"    = "+Iplm[z][n]+" : a revoir !!!");
				end
			end
    	end
	end
/******************************************************************************
 * CRG variables
 *****************************************************************************/
	uint(size=16) Xcrg[CRG_MAX];
	uint(size=16) Ycrg[CRG_MAX];
/******************************************************************************
 * CRG action
 *****************************************************************************/
	ifIsStartCRG : action ==>
	guard
		buffer_v = CRG
	end
	StartCRG : action codestream:[ codestream_p ] repeat 2 ==>
	do
		length_v := (codestream_p[0] << 8) + codestream_p[1] - 2;
		buffer_v := 0;
		cpt_v    := 0; 
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	readByteCRG : action codestream:[ codestream_p ] repeat 4 ==>
	guard
		length_v > 0
	do
		length_v    := length_v - 4;
		Xcrg[cpt_v] := (codestream_p[0] << 8) + codestream_p[1];
		Ycrg[cpt_v] := (codestream_p[2] << 8) + codestream_p[3];
		cpt_v       := cpt_v + 1;
	end
	ifIsEndCRG : action ==>
	guard
		length_v = 0
	do
		if DEBUG_HEADER = true then
			println("==== CRG ====");
			foreach uint(size=8) i in 0 .. cpt_v - 1 do
      			println(" X"+i+"     = "+Xcrg[i]);
      			println(" Y"+i+"     = "+Ycrg[i]);
    		end
		end
	end
/******************************************************************************
 * COM variables
 *****************************************************************************/
	uint(size=16) Rcom[2];
	uint(size= 8) Ccom[2][COM_MAX];
/******************************************************************************
 * COM action
 *****************************************************************************/
	ifIsStartCOM : action ==>
	guard
		buffer_v = COM
	end
	StartCOM : action codestream:[ codestream_p ] repeat 4 ==>
	do
		length_v        := (codestream_p[0] << 8) + codestream_p[1] - 4;
		Rcom[HeaderIdx] := (codestream_p[2] << 8) + codestream_p[3];
		buffer_v        := 0;
		cpt_v           := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	readByteCOM : action codestream:[ codestream_p ] ==>
	guard
		length_v > 0
	do
		length_v               := length_v - 1;
		Ccom[HeaderIdx][cpt_v] := codestream_p;
		cpt_v                  := cpt_v + 1;
	end
	ifIsEndCOM : action ==>
	guard
		length_v = 0
	do
		if DEBUG_HEADER = true then
			println("==== COM ====");
    		print(" R    = "+Rcom[HeaderIdx]+" : ");
    		if Rcom[HeaderIdx] = 0 then
      			println("General use (binary values)");
    		else
      			println("General use (IS 8859-15:1999 (Latin) values)");
    		end
			foreach uint(size=8) i in 0 .. cpt_v - 1 do
				println(" C"+i+"   = "+Ccom[HeaderIdx][i]);
    		end
		end
	end
/******************************************************************************
 * SOT variables
 *****************************************************************************/
	uint(size=16) Isot;
	uint(size=32) Psot;
	uint(size= 8) TPsot;
	uint(size= 8) TNsot;
/******************************************************************************
 * SOT action
 *****************************************************************************/
	ifIsStartSOT : action ==> 
	guard
		buffer_v = SOT
	end
	StartSOT : action codestream:[ codestream_p ] repeat 10 ==> SOT:[codestream_p] repeat 10
	do
		Isot         := (codestream_p[2] <<  8) +  codestream_p[3];
		Psot         := (codestream_p[4] << 24) + (codestream_p[5] << 16) +
					    (codestream_p[6] <<  8) +  codestream_p[7];
		TPsot        :=  codestream_p[8];
		TNsot        :=  codestream_p[9];
		buffer_v     := 0;
		HeaderIdx    := 1;
		cocExists[1] := [false: for int c in 0 .. NB_COMPONENT_MAX - 1];
		qccExists[1] := [false: for int c in 0 .. NB_COMPONENT_MAX - 1];
		
		foreach uint(size=8) c in 0 .. NB_COMPONENT_MAX-1 do
			SGcoc[1][c] := SGcoc[0][c];
		end
		if DEBUG_HEADER = true then
		    println("====================");
    		println("==== SOT Header ====");
    		println("====================");
			println("==== SOT ====");
    		println(" I    = "+Isot+" : Tile index");
    		println(" P    = "+Psot);
    		println(" TP   = "+TPsot);
    		println(" TN   = "+TNsot+" : Number of tile-parts of this tile in the codestream");
    	end
		Psot         := Psot - TileHeaderSize;
	end
/******************************************************************************
 * PPT variables
 *****************************************************************************/
	uint(size= 8) Zppt;
	uint(size= 8) Ippt[PPT_MAX];
/******************************************************************************
 * PPT action
 *****************************************************************************/
	ifIsStartPPT : action ==>
	guard
		buffer_v = PPT
	end
	StartPPT : action codestream:[ codestream_p ] repeat 3 ==>
	do
		length_v := (codestream_p[0] << 8) + codestream_p[1] - 3;
		Zppt     :=  codestream_p[2];
		buffer_v := 0;
		cpt_v    := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	readBytePPT : action codestream:[ codestream_p ] ==>
	guard
		length_v > 0
	do
		length_v    := length_v - 1;
		Ippt[cpt_v] := codestream_p;
		cpt_v       := cpt_v + 1;
	end
	ifIsEndPPT : action ==>
	guard
		length_v = 0
	do
		if DEBUG_HEADER = true then
			println("==== PPT ====");
    		println(" Z    = "+Zppt);
   			foreach uint(size=8) i in 0 .. cpt_v - 1 do
				println(" I"+i+"     = "+Ippt[i]);
    		end
    	end
	end
/******************************************************************************
 * PLT variables
 *****************************************************************************/
	uint(size= 8) Zplt;
	uint(size= 8) Iplt[PLT_MAX];
/******************************************************************************
 * PLT action
 *****************************************************************************/
	ifIsStartPLT : action ==>
	guard
		buffer_v = PLT
	end
	StartPLT : action codestream:[ codestream_p ] repeat 3 ==>
	do
		length_v := (codestream_p[0] << 8) + codestream_p[1] - 3;
		Zplt     :=  codestream_p[2];
		buffer_v := 0;
		cpt_v    := 0;
		if Psot != 0 then Psot := Psot - ((codestream_p[0] <<  8) +  codestream_p[1]) - 2; end
	end
	readBytePLT : action codestream:[ codestream_p ] ==>
	guard
		length_v > 0
	do
		length_v    := length_v - 1;
		Iplt[cpt_v] := codestream_p;
		cpt_v       := cpt_v + 1;
	end
	ifIsEndPLT : action ==>
	guard
		length_v = 0
	do
		if DEBUG_HEADER = true then
			println("==== PLT ====");
    		println(" Z    = "+Zplt);
   			foreach uint(size=8) i in 0 .. cpt_v - 1 do
				println(" I"+i+"     = "+Iplt[i]);
    		end
    	end
	end
/******************************************************************************
 * SOD action
 *****************************************************************************/
	ifIsStartSOD : action ==> 
	guard
		buffer_v = SOD
	do
		buffer_v := 0;
		Ccoc     := 0;
		if Psot != 0 then Psot := Psot - 2; end
		if DEBUG_HEADER = true then
			println("==== SOD ====");
			println("====================");
			println("==== SOT    End ====");
			println("====================");
		end
	end
/******************************************************************************
 * EOC action
 *****************************************************************************/
	ifIsStartEOC : action ==> 
	guard
		buffer_v = EOC
	do
		buffer_v := 0;
		println("==== End of input stream ====");
	end
/******************************************************************************
 ******************************************************************************
 ******************************************************************************
 *****************************************************************************/
	writeCOC : action ==> COC:[C_0, C_1, S, SG_0, SG_1, SG_2, SG_3,
							   SP[0], SP[1], SP[2], SP[3], SP[4]
							  ]
	guard
		Ccoc != Csiz
	var
		uint(size= 8) C_0,
		uint(size= 8) C_1,
		uint(size= 8) S,
		uint(size= 8) SG_0,
		uint(size= 8) SG_1,
		uint(size= 8) SG_2,
		uint(size= 8) SG_3,
		uint(size= 8) SP[5],
		uint(size= 8) idx := 0
	do
		if cocExists[1][Ccoc] then
			idx := 1;
		end
		C_1   :=  Ccoc       & 0xff;
		C_0   := (Ccoc>>8)   & 0xff;
		S     :=  Scoc[idx][Ccoc];
		SG_3  :=  SGcoc[idx][Ccoc]      & 0xff;
		SG_2  := (SGcoc[idx][Ccoc]>> 8) & 0xff;
		SG_1  := (SGcoc[idx][Ccoc]>>16) & 0xff;
		SG_0  := (SGcoc[idx][Ccoc]>>24) & 0xff;
		SP[0] := SPcoc[idx][Ccoc][0];
		SP[1] := SPcoc[idx][Ccoc][1];
		SP[2] := SPcoc[idx][Ccoc][2];
		SP[3] := SPcoc[idx][Ccoc][3];
		SP[4] := SPcoc[idx][Ccoc][4];
		if (S & 0x1) != 0 then
			cpt_v := SP[0]+1;
		else
			cpt_v := 0;
		end
		cpt2_v := 5;
	end
	writeCOCEnd : action ==>
	guard
		Ccoc = Csiz
	do
		Ccoc := 0;
		Cqcc := 0;
	end
	writeCOCloop : action ==> COC:[SP]
	guard
		cpt_v != 0
	var
		uint(size= 8) SP,
		uint(size= 8) idx  := 0
	do
		if cocExists[1][Ccoc] then
			idx := 1;
		end
		SP     := SPcoc[idx][Ccoc][cpt2_v];
		cpt_v  := cpt_v  - 1;
		cpt2_v := cpt2_v + 1;
	end
	writeCOCloopEnd : action ==>
	guard
		cpt_v = 0
	do
		Ccoc := Ccoc + 1;
	end
/******************************************************************************
 ******************************************************************************
 ******************************************************************************
 *****************************************************************************/
	writeDeqTileInfo : action ==> deqTileInfo:[G, NL, Ssiz[Cqcc], Revers],
								  traTileInfo:[NL, Revers]
	guard
		Cqcc != Csiz
	var
		uint(size= 8) G,
		uint(size= 8) NL,
		uint(size= 8) Revers,
		uint(size= 8) idx := 0
	do
		if qccExists[1][Cqcc] then
			idx := 1;
		end
		G       :=  Sqcc[idx][Cqcc];
		if cocExists[1][Cqcc] then
			idx := 1;
		else
			idx := 0;
		end
		NL      := SPcoc[idx][Cqcc][0];
		Revers  := SPcoc[idx][Cqcc][4];

		cpt_v   := 3*NL;
		cpt2_v  := 0;
	end
	writeDeqTileInfoEnd : action ==> codestreamOut:[ 0x100 ]
	guard
		Cqcc = Csiz
	do
		Cqcc   := 0;
	end
	writeDeqTileInfoLoop : action ==> deqTileInfo:[SP_0, SP_1]
	guard
		cpt2_v <= cpt_v
	var
		uint(size= 8) SP_0,
		uint(size= 8) SP_1,
		uint(size= 8) idx  := 0
	do
		if cocExists[1][Cqcc] then
			idx := 1;
		end
		SP_1   :=  SPqcc[idx][Cqcc][cpt2_v] & 0xff;
		SP_0   := (SPqcc[idx][Cqcc][cpt2_v]>>8) & 0xff;
		cpt2_v :=  cpt2_v + 1;
	end
	writeDeqTileInfoLoopEnd : action ==>
	guard
		cpt2_v > cpt_v
	do
		Cqcc := Cqcc + 1;
	end
/******************************************************************************
 ******************************************************************************
 ******************************************************************************
 *****************************************************************************/
 
/******************************************************************************
 * bypassByte
 *****************************************************************************/
	bypassByte : action codestream:[ codestream_p ] ==> codestreamOut:[ codestream_p ]
	guard
		Psot != 0
	do
		Psot   := Psot - 1;
	end
	ifIsEndBypass : action codestream:[ codestream_p ] repeat 2 ==>
	guard
		Psot = 0
	do
		buffer_v := (codestream_p[0] << 8 ) + codestream_p[1];
	end
/******************************************************************************
 * Idle action
 *****************************************************************************/
	Idle : action codestream:[ codestream_p ] ==> 
	end
/******************************************************************************
 * Scheduler
 *****************************************************************************/	
	schedule fsm waitStartNext_st:
		// wait Next Marker state
		waitStartNext_st    (ifIsStartSIZ   ) --> startSIZ_st;
		waitStartNext_st    (ifIsStartCOC   ) --> startCOC_st;
		waitStartNext_st    (ifIsStartQCC   ) --> startQCC_st;
		waitStartNext_st    (ifIsStartRGN   ) --> startRGN_st;
		waitStartNext_st    (ifIsStartPOC   ) --> startPOC_st;
		waitStartNext_st    (ifIsStartPPM   ) --> startPPM_st;
		waitStartNext_st    (ifIsStartTLM   ) --> startTLM_st;
		waitStartNext_st    (ifIsStartPLM   ) --> startPLM_st;
		waitStartNext_st    (ifIsStartCRG   ) --> startCRG_st;
		waitStartNext_st    (ifIsStartCOM   ) --> startCOM_st;
		waitStartNext_st    (ifIsStartSOT   ) --> startSOT_st;
		waitStartNext_st    (ifIsStartPPT   ) --> startPPT_st;
		waitStartNext_st    (ifIsStartPLT   ) --> startPLT_st;
		waitStartNext_st    (ifIsStartSOD   ) --> writeCOC_st;
		waitStartNext_st    (ifIsStartEOC   ) --> end_stream_st;
		waitStartNext_st    (readByte       ) --> waitStartNext_st;
		// SIZ state
		startSIZ_st         (StartSIZ       ) --> waitEndSIZ_st;
		waitEndSIZ_st       (ifIsEndSIZ     ) --> waitStartNext_st;
		waitEndSIZ_st       (readByteSIZ    ) --> waitEndSIZ_st;
		// COD COC state
		startCOC_st         (StartCOC       ) --> waitEndCOC_st;
		waitEndCOC_st       (ifIsEndCOC     ) --> waitStartNext_st;
		waitEndCOC_st       (readByteCOC    ) --> waitEndCOC_st;
		// QCD QCC state
		startQCC_st         (StartQCC       ) --> waitEndQCC_st;
		waitEndQCC_st       (ifIsEndQCC     ) --> waitStartNext_st;
		waitEndQCC_st       (readByteQCC    ) --> waitEndQCC_st;
		// RGN state
		startRGN_st         (StartRGN       ) --> waitStartNext_st;
		// POC state
		startPOC_st         (StartPOC       ) --> waitEndPOC_st;
		waitEndPOC_st       (ifIsEndPOC     ) --> waitStartNext_st;
		waitEndPOC_st       (readBytePOC    ) --> waitEndPOC_st;
		// PPM state
		startPPM_st         (StartPPM       ) --> waitEndPPM_st;
		waitEndPPM_st       (ifIsEndPPM     ) --> waitStartNext_st;
		waitEndPPM_st       (readBytePPM    ) --> waitEndPPM_st;
		// TLM state
		startTLM_st         (StartTLM       ) --> waitEndTLM_st;
		waitEndTLM_st       (ifIsEndTLM     ) --> waitStartNext_st;
		waitEndTLM_st       (readByteTLM    ) --> waitEndTLM_st;
		// PLM state
		startPLM_st         (StartPLM       ) --> waitEndPLM_st;
		waitEndPLM_st       (ifIsEndPLM     ) --> waitStartNext_st;
		waitEndPLM_st       (readBytePLM    ) --> waitEndPLM_st;
		// CRG state
		startCRG_st         (StartCRG       ) --> waitEndCRG_st;
		waitEndCRG_st       (ifIsEndCRG     ) --> waitStartNext_st;
		waitEndCRG_st       (readByteCRG    ) --> waitEndCRG_st;
		// COM state
		startCOM_st         (StartCOM       ) --> waitEndCOM_st;
		waitEndCOM_st       (ifIsEndCOM     ) --> waitStartNext_st;
		waitEndCOM_st       (readByteCOM    ) --> waitEndCOM_st;
		// SOT state
		startSOT_st         (StartSOT       ) --> waitStartNext_st;
		// PPT
		startPPT_st         (StartPPT       ) --> waitEndPPT_st;
		waitEndPPT_st       (ifIsEndPPT     ) --> waitStartNext_st;
		waitEndPPT_st       (readBytePPT    ) --> waitEndPPT_st;
		// PLT
		startPLT_st         (StartPLT       ) --> waitEndPLT_st;
		waitEndPLT_st       (ifIsEndPLT     ) --> waitStartNext_st;
		waitEndPLT_st       (readBytePLT    ) --> waitEndPLT_st;
		// writeCOC
		writeCOC_st         (writeCOC       ) --> writeCOCloop_st;
		writeCOC_st         (writeCOCEnd    ) --> writeDeqTileInfo_st;
		writeCOCloop_st     (writeCOCloop   ) --> writeCOCloop_st;
		writeCOCloop_st     (writeCOCloopEnd) --> writeCOC_st;
		// writeQCD
		writeDeqTileInfo_st     (writeDeqTileInfo       ) --> writeDeqTileInfoLoop_st;
		writeDeqTileInfo_st     (writeDeqTileInfoEnd    ) --> bypassByte_st;
		writeDeqTileInfoLoop_st (writeDeqTileInfoLoop   ) --> writeDeqTileInfoLoop_st;
		writeDeqTileInfoLoop_st (writeDeqTileInfoLoopEnd) --> writeDeqTileInfo_st;
		// bypassByte
		bypassByte_st       (bypassByte     ) --> bypassByte_st;
		bypassByte_st       (ifIsEndBypass  ) --> waitStartNext_st;
		// end stream
		end_stream_st       (Idle           ) --> end_stream_st;
	end
/******************************************************************************
 * Priority
 *****************************************************************************/	
	priority
		ifIsStartSIZ   > readByte;
		ifIsStartCOC   > readByte;
		ifIsStartQCC   > readByte;
		ifIsStartRGN   > readByte;
		ifIsStartPOC   > readByte;
		ifIsStartPPM   > readByte;
		ifIsStartTLM   > readByte;
		ifIsStartPLM   > readByte;
		ifIsStartCRG   > readByte;
		ifIsStartCOM   > readByte;
		ifIsStartSOT   > readByte;
		ifIsStartPPT   > readByte;
		ifIsStartPLT   > readByte;
		ifIsStartSOD   > readByte;
		ifIsStartEOC   > readByte;
	end
end