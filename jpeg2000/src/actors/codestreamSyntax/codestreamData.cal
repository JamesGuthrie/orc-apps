package actors.codestreamSyntax;
import utils.markerPackage.*;
import utils.commonPackage.*;
import utils.codestreamPackage.*;
/******************************************************************************
 * Actor decription
 *****************************************************************************/
actor codestreamData () uint(size= 9) dataIn,
						uint(size= 8) SIZ,
						uint(size= 8) COC,
						uint(size= 8) SOT,
						bool          CBlkInfoReady
						==>
						uint(size= 8) cbInfo,
						uint(size= 8) cbInfoSegSize,
						uint(size= 8) traPictureInfo,
						uint(size=10) CD
: 
/******************************************************************************
 * GetHeaderValue
 *****************************************************************************/
	uint(size=32) siz_x_v;
	uint(size=32) siz_y_v;
	uint(size=32) siz_xo_v;
	uint(size=32) siz_yo_v;
	uint(size=32) siz_xt_v;
	uint(size=32) siz_yt_v;
	uint(size=32) siz_xto_v;
	uint(size=32) siz_yto_v;
	uint(size= 8) siz_c_v;
	uint(size= 8) siz_xr_v[SIZ_MAX];
	uint(size= 8) siz_yr_v[SIZ_MAX];
	uint(size=16) coc_c_v;
	uint(size= 8) coc_s_v[NB_COMPONENT_MAX];
	uint(size=32) coc_sg_v[NB_COMPONENT_MAX];
	uint(size= 8) coc_sp_v[NB_COMPONENT_MAX][COD_MAX];
	uint(size=16) sot_i_v;
	uint(size= 8) cpt_v;
/******************************************************************************
 * SOC_SIZ action
 *****************************************************************************/
	GetSIZ : action SIZ:[ siz_p ] repeat 38 ==>
	do
		siz_x_v   := (siz_p[ 4] << 24) + (siz_p[ 5] << 16) + (siz_p[ 6] <<  8) +  siz_p[ 7];
		siz_y_v   := (siz_p[ 8] << 24) + (siz_p[ 9] << 16) + (siz_p[10] <<  8) +  siz_p[11];
		siz_xo_v  := (siz_p[12] << 24) + (siz_p[13] << 16) + (siz_p[14] <<  8) +  siz_p[15];
		siz_yo_v  := (siz_p[16] << 24) + (siz_p[17] << 16) + (siz_p[18] <<  8) +  siz_p[19];
		siz_xt_v  := (siz_p[20] << 24) + (siz_p[21] << 16) + (siz_p[22] <<  8) +  siz_p[23];
		siz_yt_v  := (siz_p[24] << 24) + (siz_p[25] << 16) + (siz_p[26] <<  8) +  siz_p[27];
		siz_xto_v := (siz_p[28] << 24) + (siz_p[29] << 16) + (siz_p[30] <<  8) +  siz_p[31];
		siz_yto_v := (siz_p[32] << 24) + (siz_p[33] << 16) + (siz_p[34] <<  8) +  siz_p[35];
		siz_c_v   := (siz_p[36] <<  8) +  siz_p[37];
		cpt_v     := 0;
	end
	GetSIZloop : action SIZ:[ siz_p ] repeat 3 ==>
	guard
		cpt_v != siz_c_v
	do
		siz_xr_v[cpt_v] := siz_p[1];
		siz_yr_v[cpt_v] := siz_p[2];
		cpt_v           := cpt_v + 1;
	end
	EndGetSIZloop : action ==>
	guard
		cpt_v = siz_c_v
	end
/******************************************************************************
 * COC action
 *****************************************************************************/
	GetCOC : action COC:[ coc_p ] repeat 12 ==> 
	guard
		coc_c_v != siz_c_v	
	do
		coc_s_v[coc_c_v]     :=  coc_p[2];
		coc_sg_v[coc_c_v]    := (coc_p[3] << 24) + (coc_p[4] << 16) + (coc_p[5] <<  8) +  coc_p[6];
		coc_sp_v[coc_c_v][0] :=  coc_p[7];
		coc_sp_v[coc_c_v][1] :=  coc_p[8];
		coc_sp_v[coc_c_v][2] :=  coc_p[9];
		coc_sp_v[coc_c_v][3] :=  coc_p[10];
		coc_sp_v[coc_c_v][4] :=  coc_p[11];
		cpt_v       :=  0;
	end
	GetCOCEnd : action ==> 
	guard
		coc_c_v = siz_c_v	
	end
	GetCOCloop : action COC:[ coc_p ] ==>
	guard
		(coc_s_v[coc_c_v] & 0x1) != 0 && cpt_v <= coc_sp_v[coc_c_v][0] 
	do
		coc_sp_v[coc_c_v][5+cpt_v] := coc_p;
		cpt_v                      := cpt_v + 1;
	end
	EndGetCOCloop : action ==>
	guard
		(coc_s_v[coc_c_v] & 0x1) = 0 || cpt_v > coc_sp_v[coc_c_v][0]
	do
		coc_c_v := coc_c_v + 1; 
	end
/******************************************************************************
 * SOT action
 *****************************************************************************/
  	GetSOT : action SOT:[sot_p] repeat 10, CBlkInfoReady:[ready] ==>
  	guard 
  		ready = true
  	do
		sot_i_v := (sot_p[2] <<  8) +  sot_p[3];		
		coc_c_v := 0;
  	end
/******************************************************************************
 * procedure SOT_INIT
 *****************************************************************************/
	procedure SOT_INIT ()
	begin
		sot_i_v := 0;
	end
/******************************************************************************
 * CodeBlock Globale variables
 *****************************************************************************/
 	bool          cblk_exists[CB_C_MAX][CB_R_MAX][CB_S_MAX][CB_W_MAX][CB_H_MAX];
 	uint(size= 8) cblk_lblock[CB_C_MAX][CB_R_MAX][CB_S_MAX][CB_W_MAX][CB_H_MAX];
 	uint(size= 8) cblk_nbCodingPasses[CB_S_MAX][CB_W_MAX][CB_H_MAX];
    uint(size= 8) cblk_zeroBitPlane[CB_S_MAX][CB_W_MAX][CB_H_MAX];
    uint(size=16) cblk_size[CB_S_MAX][CB_W_MAX][CB_H_MAX];
    uint(size= 8) cblk_w[CB_S_MAX][CB_W_MAX][CB_H_MAX];
    uint(size= 8) cblk_h[CB_S_MAX][CB_W_MAX][CB_H_MAX];

/******************************************************************************
 * TagTree Globale variables
 *****************************************************************************/
	uint(size= 8) tt_w[TT_C_MAX][TT_R_MAX][TT_P_MAX][TT_S_MAX];
	uint(size= 8) tt_lvls[TT_C_MAX][TT_R_MAX][TT_P_MAX][TT_S_MAX];
	uint(size= 8) tt_InclV[TT_C_MAX][TT_R_MAX][TT_P_MAX][TT_S_MAX][TT_LEVEL_MAX][TT_INDEX_MAX];
    uint(size= 8) tt_InclS[TT_C_MAX][TT_R_MAX][TT_P_MAX][TT_S_MAX][TT_LEVEL_MAX][TT_INDEX_MAX];
    uint(size= 8) tt_BdV[TT_C_MAX][TT_R_MAX][TT_P_MAX][TT_S_MAX][TT_LEVEL_MAX][TT_INDEX_MAX];
    uint(size= 8) tt_BdS[TT_C_MAX][TT_R_MAX][TT_P_MAX][TT_S_MAX][TT_LEVEL_MAX][TT_INDEX_MAX];
/******************************************************************************
 * TagTree local variables
 *****************************************************************************/
	uint(size=8) ttl_k;
  	uint(size=8) ttl_tmin;
  	uint(size=8) ttl_idx;
  	uint(size=8) ttl_ts;
  	uint(size=8) ttl_tv;
  	uint(size=8) ttl_t;
/******************************************************************************
 * CodestreamTools global variables
 *****************************************************************************/
 	uint(size= 8) cst_idxX;
 	uint(size= 8) cst_idxY;
 	uint(size=16) cst_TX0;
 	uint(size=16) cst_TX1;
	uint(size=16) cst_TY0;
 	uint(size=16) cst_TY1;
 	uint(size=16) cst_TCX0;
 	uint(size=16) cst_TCX1;
	uint(size=16) cst_TCY0;
 	uint(size=16) cst_TCY1;
 	uint(size=16) cst_TRX0;
 	uint(size=16) cst_TRX1;
	uint(size=16) cst_TRY0;
 	uint(size=16) cst_TRY1;
 	uint(size= 8) cst_PPX;
 	uint(size= 8) cst_PPY;
/******************************************************************************
 * CodestreamTop local variables
 *****************************************************************************/
    uint(size=16) csl_subbandX;
    uint(size=16) csl_subbandY;
    uint(size= 8) csl_precinctX; 
    uint(size= 8) csl_precinctY;
    uint(size=16) csl_zoneSizeX;
    uint(size=16) csl_zoneSizeY; 
    uint(size= 8) csl_cbSizeX;
    uint(size= 8) csl_cbSizeY;
 	uint(size= 8) csl_mins;
    uint(size= 8) csl_maxs;
  	uint(size= 8) csl_wcb;
    uint(size= 8) csl_hcb;
    uint(size= 8) csl_l;
    uint(size= 8) csl_r;
    uint(size= 8) csl_c;
    uint(size=16) csl_pX_loop;
    uint(size=16) csl_pY_loop;
    uint(size=16) csl_pX_loop_end;
    uint(size=16) csl_pY_loop_end;
    uint(size= 8) csl_lend;
    uint(size= 8) csl_rend;
    uint(size= 8) csl_cend;
    uint(size= 8) csl_s;
 	uint(size= 8) csl_w;
    uint(size= 8) csl_h;
    uint(size= 8) csl_w2;
    uint(size= 8) csl_h2;
    uint(size= 8) csl_p;
    uint(size= 8) csl_pX;
    uint(size= 8) csl_pmaxX;
    uint(size= 8) csl_pY;
    uint(size= 8) csl_pmaxY;
    uint(size= 8) csl_tmp;
    uint(size= 8) csl_tmp2;
/******************************************************************************
 ******************************************************************************
 ******************************************************************************
 * getBits decription
 ******************************************************************************
 ******************************************************************************
 *****************************************************************************/

/******************************************************************************
 * getBits Globale variables
 *****************************************************************************/
 	uint(size=16) getBitsRes;
 	uint(size= 8) getNbBits;
 	uint(size=16) word;
 	uint(size= 8) cptBit;
/******************************************************************************
 * procedure getBits
 *****************************************************************************/
  	procedure  getBits (uint(size=8) nb)
  	begin
	    cptBit     := cptBit    - nb;
	    getNbBits  := getNbBits - nb;
	    getBitsRes := (getBitsRes << nb) + ((word >> cptBit) & ((1<<nb)-1));
  	end
/******************************************************************************
 * procedure getBits
 *****************************************************************************/
  	procedure  getBits2 (uint(size=8) byte)
  	begin
		getBits(cptBit);
  		if((word & 0xff) = 0xff) then
			cptBit := 7;
		else
			cptBit := 8;
		end
    	word       := ((word << 8) + byte) & 0xffff;
    	if cptBit >= getNbBits then
    		getBits(getNbBits);
    	end
    	//
    	cptBit     := cptBit;
    	getBitsRes := getBitsRes;
    end
/******************************************************************************
 * GetBits
 *****************************************************************************/
	GetBits : action ==>
 	guard
 		cptBit >= getNbBits
 	do
 		getBits(getNbBits);
 	end
	GetBits2 : action dataIn:[byte] ==>
 	guard
 		cptBit < getNbBits
 	do
		getBits2(byte);
 	end
/******************************************************************************
 ******************************************************************************
 ******************************************************************************
 * CodeBlock decription
 ******************************************************************************
 ******************************************************************************
 *****************************************************************************/

/******************************************************************************
 * procedure CodeBlockNew
 *****************************************************************************/
  	procedure CodeBlockNew ()
	begin
		foreach uint(size=8) s in 0 .. CB_S_MAX - 1 do
			foreach uint(size=8) w in 0 .. CB_W_MAX - 1 do
				foreach uint(size=8) h in 0 .. CB_H_MAX - 1 do
					cblk_nbCodingPasses[s][w][h] := 0;
					cblk_size[s][w][h]           := 0;
					cblk_w[s][w][h]              := 0;
					cblk_h[s][w][h]              := 0;
					foreach uint(size=8) c in 0 .. CB_C_MAX - 1 do
						foreach uint(size=8) r in 0 .. CB_R_MAX - 1 do
							cblk_exists[c][r][s][w][h] := false;
							cblk_lblock[c][r][s][w][h] := 3;
						end
					end
				end
			end
		end		
 	end
 	procedure CodeBlockInit ()
	begin
		foreach uint(size=8) s in 0 .. CB_S_MAX - 1 do
			foreach uint(size=8) w in 0 .. CB_W_MAX - 1 do
				foreach uint(size=8) h in 0 .. CB_H_MAX - 1 do
					cblk_zeroBitPlane[s][w][h]   := 0;
					cblk_size[s][w][h]           := 0;
				end
			end
		end		
 	end
/******************************************************************************
 * procedure CodeBlockSetLBlock
 *****************************************************************************/
  	procedure CodeBlockSetLBlock (uint(size=8)value)
  	var
  		uint(size=16) lblock = cblk_lblock[csl_c][csl_r][csl_s][csl_w2][csl_h2]
  	begin
		cblk_lblock[csl_c][csl_r][csl_s][csl_w2][csl_h2] := lblock + value;	
 	end

/******************************************************************************
 ******************************************************************************
 ******************************************************************************
 * TagTree decription
 ******************************************************************************
 ******************************************************************************
 *****************************************************************************/

/******************************************************************************
 * procedure TagTreeNew
 *****************************************************************************/
  	procedure TagTreeNew ()
	begin
		foreach uint(size=8) c in 0 .. TT_C_MAX - 1 do
			foreach uint(size=8) r in 0 .. TT_R_MAX - 1 do
				foreach uint(size=8) p in 0 .. TT_P_MAX - 1 do
					foreach uint(size=8) s in 0 .. TT_S_MAX - 1 do
						tt_lvls[c][r][p][s] := 0xff;
					end
				end
			end
		end		
 	end
/******************************************************************************
 * function TagTreeIfExists
 *****************************************************************************/
  	function TagTreeIfExists () --> bool :
		tt_lvls[csl_c][csl_r][csl_p][csl_s] != 0xff	
 	end
/******************************************************************************
 * procedure TagTreeAdd
 *****************************************************************************/
  	procedure TagTreeAdd ()
	var
		uint(size=8) tmp_h    := csl_wcb+1,
		uint(size=8) tmp_w    := csl_hcb+1,
		uint(size=8) ttv_lvls := 0
	begin
		if DEBUG_ARRAY = true then	
			if csl_c >= TT_C_MAX then
				println ("codestreamData TagTreeAdd error TT_C_MAX : "+csl_c+" >= "+TT_C_MAX+" !!!");
			end
			if csl_r >= TT_R_MAX then
				println ("codestreamData TagTreeAdd error TT_R_MAX : "+csl_r+" >= "+TT_R_MAX+" !!!");
			end
			if csl_p >= TT_P_MAX then
				println ("codestreamData TagTreeAdd error TT_C_MAX : "+csl_p+" >= "+TT_P_MAX+" !!!");
			end
			if csl_s >= TT_S_MAX then
				println ("codestreamData TagTreeAdd error TT_S_MAX : "+csl_s+" >= "+TT_S_MAX+" !!!");
			end
		end
	
		tt_w[csl_c][csl_r][csl_p][csl_s] := tmp_w;
		if (tmp_w!=0 && tmp_h!=0) then
			ttv_lvls := 1;
			while (tmp_h!=1 || tmp_w !=1) do
				tmp_h    := (tmp_h+1) >> 1;
				tmp_w    := (tmp_w+1) >> 1;
				ttv_lvls := ttv_lvls + 1;
			end
		end
		tt_lvls[csl_c][csl_r][csl_p][csl_s] := ttv_lvls;
		
		foreach uint(size=8) i in 0 .. TT_LEVEL_MAX - 1 do
			foreach uint(size=8) j in 0 .. TT_INDEX_MAX - 1 do
				tt_InclV[csl_c][csl_r][csl_p][csl_s][i][j] := (1<<7)-1;
				tt_InclS[csl_c][csl_r][csl_p][csl_s][i][j] := 0;
				tt_BdV[csl_c][csl_r][csl_p][csl_s][i][j]   := (1<<7)-1;
				tt_BdS[csl_c][csl_r][csl_p][csl_s][i][j]   := 0;
			end
		end		
 	end
/******************************************************************************
 * procedure tagTreeUpdateStart
 *****************************************************************************/
  	procedure  tagTreeUpdateStart (uint(size= 8) ttV[TT_C_MAX][TT_R_MAX][TT_P_MAX][TT_S_MAX][TT_LEVEL_MAX][TT_INDEX_MAX],
  							 	   uint(size= 8) ttS[TT_C_MAX][TT_R_MAX][TT_P_MAX][TT_S_MAX][TT_LEVEL_MAX][TT_INDEX_MAX])
  	var
  		uint(size=8) ttv_w = tt_w[csl_c][csl_r][csl_p][csl_s]
  	begin
      	ttl_idx := (csl_w>>ttl_k)*((ttv_w+(1<<ttl_k)-1)>>ttl_k)+(csl_h>>ttl_k);
		if DEBUG_ARRAY = true then	
			if ttl_k >= TT_LEVEL_MAX then
				println ("codestreamData tagTreeUpdateStart error TT_LEVEL_MAX : "+ttl_k+" >= "+TT_LEVEL_MAX+" !!!");
			end
			if ttl_idx >= TT_INDEX_MAX then
				println ("codestreamData tagTreeUpdateStart error TT_INDEX_MAX : "+ttl_idx+" >= "+TT_INDEX_MAX+" !!!");
			end
		end
      	ttl_ts  := ttS[csl_c][csl_r][csl_p][csl_s][ttl_k][ttl_idx];
      	ttl_tv  := ttV[csl_c][csl_r][csl_p][csl_s][ttl_k][ttl_idx];
      	if (ttl_ts < ttl_tmin) then
			ttl_ts := ttl_tmin;
      	end
  	end
/******************************************************************************
 * procedure tagTreeUpdateEnd
 *****************************************************************************/
  	procedure  tagTreeUpdateEnd (uint(size= 8) ttV[TT_C_MAX][TT_R_MAX][TT_P_MAX][TT_S_MAX][TT_LEVEL_MAX][TT_INDEX_MAX],
  							   	 uint(size= 8) ttS[TT_C_MAX][TT_R_MAX][TT_P_MAX][TT_S_MAX][TT_LEVEL_MAX][TT_INDEX_MAX])
  	begin
	    if (ttl_t>ttl_ts && ttl_tv<ttl_ts) then
    		ttl_ts := ttl_t;
    	end
	  	ttS[csl_c][csl_r][csl_p][csl_s][ttl_k][ttl_idx] := ttl_ts;
   		ttV[csl_c][csl_r][csl_p][csl_s][ttl_k][ttl_idx] := ttl_tv;
	    if (ttl_k>0) then
			if (ttl_ts<ttl_tv) then
		  		ttl_tmin := ttl_ts;
			else
		  		ttl_tmin := ttl_tv;
			end
			ttl_k := ttl_k - 1;
		end
  	end
/******************************************************************************
 * TagTreeUpdateIncl
 *****************************************************************************/
  	TagTreeUpdateIncl : action ==>
  	do
	  	ttl_k    := tt_lvls[csl_c][csl_r][csl_p][csl_s] - 1;
	  	ttl_tmin := tt_InclS[csl_c][csl_r][csl_p][csl_s][ttl_k][0];
	  	ttl_t    := csl_l + 1;
	  	tagTreeUpdateStart(tt_InclV, tt_InclS);
	end
/******************************************************************************
 * TagTreeUpdateBD
 *****************************************************************************/
  	TagTreeUpdateBD : action ==>
  	do
 		ttl_k    := tt_lvls[csl_c][csl_r][csl_p][csl_s] - 1;
	  	ttl_tmin := tt_BdS[csl_c][csl_r][csl_p][csl_s][ttl_k][0];
	  	ttl_t    := csl_tmp;
	    tagTreeUpdateStart(tt_BdV, tt_BdS);
  	end
/******************************************************************************
 * TagTreeUpdateLoop
 *****************************************************************************/
 	TagTreeUpdateLoop.default : action ==>
 	guard
 		ttl_t>ttl_ts && ttl_tv>=ttl_ts && cptBit >= 1
 	do
 		getNbBits  := 1;
 		getBitsRes := 0;
 		getBits(1);
 		if (getBitsRes = 1) then
			ttl_tv := ttl_ts;
		end
      	ttl_ts := ttl_ts + 1;
 	end
 	TagTreeUpdateLoop.readByte : action dataIn:[byte] ==>
 	guard
 		ttl_t>ttl_ts && ttl_tv>=ttl_ts && cptBit < 1
 	do
 		getNbBits  := 1;
 		getBitsRes := 0;
 		getBits2(byte);
 		if (getBitsRes = 1) then
			ttl_tv := ttl_ts;
		end
      	ttl_ts := ttl_ts + 1;
 	end
 	TagTreeUpdateLoopEnd : action ==>
 	guard
 		ttl_t<=ttl_ts || ttl_tv<ttl_ts
 	end
/******************************************************************************
 * TagTreeUpdateEndIncl
 *****************************************************************************/
  	TagTreeUpdateNoEndIncl : action ==>
  	guard
  		ttl_k > 0
  	do
	  	tagTreeUpdateEnd(tt_InclV, tt_InclS);
	  	tagTreeUpdateStart(tt_InclV, tt_InclS);
  	end
  	TagTreeUpdateEndIncl : action ==>
  	guard
  		ttl_k = 0
  	do
	  	tagTreeUpdateEnd(tt_InclV, tt_InclS);
  	end
/******************************************************************************
 * TagTreeUpdateEndBD
 *****************************************************************************/
  	TagTreeUpdateNoEndBD : action ==>
  	guard
  		ttl_k > 0
  	do
	    tagTreeUpdateEnd(tt_BdV, tt_BdS);
	    tagTreeUpdateStart(tt_BdV, tt_BdS);
  	end
  	TagTreeUpdateEndBD : action ==>
  	guard
  		ttl_k = 0
  	do
	    tagTreeUpdateEnd(tt_BdV, tt_BdS);
  	end
  	
/******************************************************************************
 ******************************************************************************
 ******************************************************************************
 * CodestreamTools decription
 ******************************************************************************
 ******************************************************************************
 *****************************************************************************/

/******************************************************************************
 * procedure getTX0_TX1
 *****************************************************************************/
  	procedure getTX0_TX1 () 
  	var
  		uint(size=32) numXtiles = (siz_x_v - siz_xto_v + (siz_xt_v-1)) / siz_xt_v,
  		uint(size=32) p         = sot_i_v mod numXtiles
  	begin
  		cst_idxX := p;
  		cst_TX0  := siz_xto_v + p * siz_xt_v;
  		cst_TX1  := cst_TX0 + siz_xt_v;
  		if cst_TX0 < siz_xo_v then
  			cst_TX0 := siz_xo_v;
  		end
  		if cst_TX1 > siz_x_v then
  			cst_TX1 := siz_x_v;
  		end
	end
/******************************************************************************
 * procedure getTY0_TY1
 *****************************************************************************/
  	procedure getTY0_TY1 () 
  	var
  		uint(size=32) numXtiles = (siz_x_v - siz_xto_v + (siz_xt_v-1)) / siz_xt_v,
  		uint(size=32) q         = sot_i_v / numXtiles
  	begin
  		cst_idxY := q;
  		cst_TY0  := siz_yto_v + q * siz_yt_v;
  		cst_TY1  := cst_TY0 + siz_yt_v;
  		if cst_TY0 < siz_yo_v then
  			cst_TY0 := siz_yo_v;
  		end
  		if cst_TY1 > siz_y_v then
  			cst_TY1 := siz_y_v;
  		end
	end
/******************************************************************************
 * procedure getTRX0_TRX1
 *****************************************************************************/
  	procedure getTRX0_TRX1 () 
  	var
  		uint(size= 8) sp0  = coc_sp_v[csl_c][0] - csl_r,
  		uint(size=32) xr   = siz_xr_v[csl_c],
  		uint(size=32) tcx0 = (cst_TX0 + (xr-1)) / xr,
  		uint(size=32) tcx1 = (cst_TX1 + (xr-1)) / xr
  	begin
  		cst_TCX0 := tcx0;
  		cst_TCX1 := tcx1;
  		cst_TRX0 := (tcx0>>sp0);
  		if (tcx0 & ((1<<sp0)-1)) != 0 then
  			cst_TRX0 := cst_TRX0 + 1;
  		end
  		cst_TRX1 := (tcx1>>sp0);
  		if (tcx1 & ((1<<sp0)-1)) != 0 then
  			cst_TRX1 := cst_TRX1 + 1;
  		end
	end
/******************************************************************************
 * procedure getTRY0_TRY1
 *****************************************************************************/
  	procedure getTRY0_TRY1 () 
  	var
  		uint(size= 8) sp0  = coc_sp_v[csl_c][0] - csl_r,
  		uint(size=32) yr   = siz_yr_v[csl_c],
  		uint(size=32) tcy0 = (cst_TY0 + (yr-1)) / yr,
  		uint(size=32) tcy1 = (cst_TY1 + (yr-1)) / yr
  	begin
  		cst_TCY0 := tcy0;
  		cst_TCY1 := tcy1;
  		cst_TRY0 := (tcy0>>sp0);
  		if (tcy0 & ((1<<sp0)-1)) != 0 then
  			cst_TRY0 := cst_TRY0 + 1;
  		end
  		cst_TRY1 := (tcy1>>sp0);
  		if (tcy1 & ((1<<sp0)-1)) != 0 then
  			cst_TRY1 := cst_TRY1 + 1;
  		end
	end
/******************************************************************************
 * procedure getPPX_PPY
 *****************************************************************************/
  	procedure getPPX_PPY (uint(size= 8) r)
  	var
  		uint(size= 8) s  = coc_s_v[csl_c]&0x1,
  		uint(size= 8) pp = coc_sp_v[csl_c][SP_PP_OFFSET+r]
  	begin
  		if (s != 0) then
  			cst_PPX :=  pp & 0x0f;
  			cst_PPY := (pp >> 4) & 0x0f;
  		else
  			cst_PPX := 15;
  			cst_PPY := 15;
  		end
	end
/******************************************************************************
 * function getNumPrecinctsWide
 *****************************************************************************/
  	function getNumPrecinctsWide () --> uint(size=8)
  	var
  		uint(size=16) tmp = cst_TRX1 & ((1<<cst_PPX)-1),
  		uint(size= 8) ret = (cst_TRX1 >> cst_PPX) - (cst_TRX0 >> cst_PPX)
  	:
  		if cst_TRX1 = cst_TRX0 then
  			0
  		else
  			if tmp = 0 then
  				ret
  			else
  				ret+1
  			end
  		end
	end
/******************************************************************************
 * function getNumPrecinctsHigh
 *****************************************************************************/
  	function getNumPrecinctsHigh () --> uint(size=8)
  	var
  		uint(size=16) tmp = cst_TRY1 & ((1<<cst_PPY)-1),
  		uint(size= 8) ret = (cst_TRY1 >> cst_PPY) - (cst_TRY0 >> cst_PPY)
  	:
  		if cst_TRY1 = cst_TRY0 then
  			0
  		else
  			if tmp = 0 then
  				ret
  			else
  				ret+1
  			end
  		end
	end
/******************************************************************************
 * procedure getSubbandSize
 *****************************************************************************/
  	procedure  getSubbandSize ()
  	var
  		uint(size= 8) sp0       = coc_sp_v[csl_c][0] - csl_r,
  		uint(size=16) tmp       = (1<<sp0) - 1,
  		uint(size=16) subbandX := (cst_TCX1 - cst_TCX0 + tmp) >> sp0,
  		uint(size=16) subbandY := (cst_TCY1 - cst_TCY0 + tmp) >> sp0,
  		uint(size= 8) ceilX    := 0,
  		uint(size= 8) ceilY    := 0
  	begin
  		if csl_r != 0 then
  			ceilX     := subbandX & 1;
  			subbandX  := (subbandX + 1) >> 1;
  			ceilY     := subbandY & 1;
  			subbandY  := (subbandY + 1) >> 1;
  		end
  		if csl_s = 1 || csl_s = 3 then
  			csl_subbandX := subbandX - ceilX;
  		else
  		  	csl_subbandX := subbandX;
  		end
  		if csl_s = 2 || csl_s = 3 then
  			csl_subbandY := subbandY - ceilY;
   		else
  		  	csl_subbandY := subbandY;
   		end
	end
/******************************************************************************
 * procedure getCodeBlockSizeDefault
 *****************************************************************************/
  	procedure getCodeBlockSizeDefault ()
  	var
  		uint(size= 8) sp1       = coc_sp_v[csl_c][1] + 2,
  		uint(size= 8) sp2       = coc_sp_v[csl_c][2] + 2
  	begin
	  	csl_cbSizeX := sp1;
	  	csl_cbSizeY := sp2;
	end
/******************************************************************************
 * procedure getPrecinctSize
 *****************************************************************************/
  	procedure getPrecinctSize ()
  	var
  		uint(size= 8) nbPrecinctX = csl_subbandX >> cst_PPX,
  		uint(size= 8) nbPrecinctY = csl_subbandY >> cst_PPY,
  		uint(size= 8) tmpX       := csl_pmaxX - nbPrecinctX - 1,
  		uint(size= 8) tmpY       := csl_pmaxY - nbPrecinctY - 1
  	begin
  		csl_precinctX := cst_PPX;
  		csl_precinctY := cst_PPY;
	  	if cst_PPX != 15 || cst_PPY != 15 then
	  		if tmpX <= 1 then
	  			tmpX := tmpX + 1;
	  		end
  			csl_precinctX := cst_PPX - LOG2[tmpX];
  			if tmpY <= 1 then
	  			tmpY := tmpY + 1;
	  		end
  			csl_precinctY := cst_PPY - LOG2[tmpY];
	  	end
	end
/******************************************************************************
 * procedure getZoneSize
 *****************************************************************************/
  	procedure  getZoneSize ()
  	begin
  		csl_zoneSizeX := csl_subbandX - (csl_pX<<csl_precinctX);
  		csl_zoneSizeY := csl_subbandY - (csl_pY<<csl_precinctY);
  		if ((1<<csl_precinctX) < csl_zoneSizeX) && (csl_pmaxX != 0) then
  			csl_zoneSizeX := (1<<csl_precinctX);
  		end
  		if ((1<<csl_precinctY) < csl_zoneSizeY) && (csl_pmaxY != 0) then
  			csl_zoneSizeY := (1<<csl_precinctY);
  		end
	end
/******************************************************************************
 * procedure getCodeBlockSize
 *****************************************************************************/
  	procedure  getCodeBlockSize ()
  	var
  		uint(size=16) cbSizeX   := csl_cbSizeX,
  		uint(size=16) cbSizeY   := csl_cbSizeY,
  		uint(size=16) zoneSizeX  = csl_zoneSizeX - (csl_h<<cbSizeX),
  		uint(size=16) zoneSizeY  = csl_zoneSizeY - (csl_w<<cbSizeY)
  	begin
  		cbSizeX := 1<<cbSizeX;
    	cbSizeY := 1<<cbSizeY;
    	if zoneSizeX < cbSizeX then
    		cbSizeX := zoneSizeX;
    	end
    	if zoneSizeY < cbSizeY then
    		cbSizeY := zoneSizeY;
    	end
    	cblk_w[csl_s][csl_w2][csl_h2] := cbSizeX;
  		cblk_h[csl_s][csl_w2][csl_h2] := cbSizeY;
	end
/******************************************************************************
 * procedure getNbCodeBlock
 *****************************************************************************/
  	procedure  getNbCodeBlock ()
  	begin
  		/* csl_hcb */
  		csl_hcb := 0;
  		if (1<<csl_cbSizeX) < csl_zoneSizeX then 
  			csl_hcb := (csl_zoneSizeX - 1) >> csl_cbSizeX;
  		end
   		/* csl_wcb */
  		csl_wcb := 0;
  		if (1<<csl_cbSizeY) < csl_zoneSizeY then 
  			csl_wcb := (csl_zoneSizeY - 1) >> csl_cbSizeY;
  		end
	end
/******************************************************************************
 * procedure genCblkIdx
 *****************************************************************************/
  	procedure  genCblkIdx ()
   	var
  		uint(size= 8) nbCbX     := 0,
  		uint(size= 8) nbCbY     := 0,
  		uint(size=16) zoneSizeX := (1<<csl_precinctX),
  		uint(size=16) zoneSizeY := (1<<csl_precinctY)
  	begin
  		if zoneSizeX > csl_subbandX then
  			zoneSizeX := csl_subbandX; 
  		end
  		if zoneSizeY > csl_subbandY then
  			zoneSizeY := csl_subbandY; 
  		end
  		if (1<<csl_cbSizeX) < zoneSizeX then
  			nbCbX := (zoneSizeX-1) >> csl_cbSizeX;
  		end
  		if (1<<csl_cbSizeY) < zoneSizeY then
  			nbCbY := (zoneSizeY-1) >> csl_cbSizeY;
  		end
  		csl_h2  := csl_h + (csl_pX << nbCbX);
  		csl_w2  := csl_w + (csl_pY << nbCbY);
 	end
/******************************************************************************
 * fonction ifPrecValidX
 *****************************************************************************/
	function ifPrecValidX(uint(size= 8) nl) --> bool
	var
		uint(size=32) tmp = siz_xr_v[csl_c] << (cst_PPX + nl)
	:
		if (csl_pX_loop mod tmp) = 0 then
			true
		else
			if csl_pX_loop != cst_TX0 then
				false
			else
				if (cst_TRX0 & ((1<<cst_PPX)-1)) = 0 then
					false
				else
					true
				end
			end
		end
	end
/******************************************************************************
 * fonction ifPrecValidY
 *****************************************************************************/
	function ifPrecValidY(uint(size= 8) nl) --> bool
	var
		uint(size=32) tmp = siz_yr_v[csl_c] << (cst_PPY + nl)
	:
		if (csl_pY_loop mod tmp) = 0 then
			true
		else
			if csl_pY_loop != cst_TY0 then
				false
			else
				if (cst_TRY0 & ((1<<cst_PPY)-1)) = 0 then
					false
				else
					true
				end
			end
		end
	end
/******************************************************************************
 * fonction ifPrecValid
 *****************************************************************************/
	function ifPrecValid() --> bool
	var
		uint(size= 8) sp0 = coc_sp_v[csl_c][0],
		uint(size= 8) nl  = sp0 - csl_r
	:
		if ((coc_sg_v[csl_c] >> 24) != 4) || ((coc_s_v[csl_c]&0x1) = 0) then
			true
		else
			ifPrecValidX(nl) && ifPrecValidY(nl)
		end
	end
/******************************************************************************
 * procedure getNumPrec
 *****************************************************************************/
  	procedure  getNumPrec ()
  	var
		uint(size= 8) nl  = coc_sp_v[csl_c][0] - csl_r,
		uint(size=32) xr  = siz_xr_v[csl_c],
		uint(size=32) yr  = siz_yr_v[csl_c]
  	begin
  		if (coc_s_v[csl_c] & 0x1) != 0 then
  			csl_pX    := ((csl_pX_loop / xr) >> (nl + cst_PPX)) - (cst_TRX0 >> cst_PPX);
  			csl_pY    := ((csl_pY_loop / yr) >> (nl + cst_PPY)) - (cst_TRY0 >> cst_PPY);
  			csl_pmaxX := getNumPrecinctsWide();
  			csl_pmaxY := getNumPrecinctsHigh();
  		else
  			csl_pX    := 0;
  			csl_pY    := 0;
  			csl_pmaxX := 0;
  			csl_pmaxY := 0;
  		end
	end
/******************************************************************************
 ******************************************************************************
 ******************************************************************************
 * Codestream decription
 ******************************************************************************
 ******************************************************************************
 *****************************************************************************/
 
/******************************************************************************
 * procedure loopIncr_cprl
 *****************************************************************************/
  	procedure loopIncr_cprl ()
 	begin
 		if (csl_l = csl_lend-1) then
 			if (csl_r = csl_rend-1) then
 				if (csl_pX_loop = csl_pX_loop_end-1) then
 					if (csl_pY_loop = csl_pY_loop_end-1) then
 						csl_c := csl_c + 1;
 						csl_pY_loop := 0;//cst_TY0;
 					else
 						csl_pY_loop := csl_pY_loop + 1;
 					end
	 				csl_pX_loop := 0;//cst_TX0;
 				else
 					csl_pX_loop := csl_pX_loop + 1;
 				end
 				csl_r := 0;
 			else
 				csl_r := csl_r + 1;
 			end
 			csl_l := 0;
 		else
 			csl_l := csl_l + 1;
 		end
 		if csl_c != csl_cend then
			getPPX_PPY(csl_r);
			getTRX0_TRX1();
			getTRY0_TRY1();
		end
 	end
/******************************************************************************
 * procedure loopIncr_lrcp
 *****************************************************************************/
   	procedure loopIncr_lrcp ()
 	begin
 		if (csl_pX_loop = csl_pX_loop_end-1) then
 			if (csl_pY_loop = csl_pY_loop_end-1) then
 				if (csl_c = csl_cend-1) then
 					if (csl_r = csl_rend-1) then
 						csl_l := csl_l + 1;
 						csl_r := 0;
 					else
 						csl_r := csl_r + 1;
 					end
 					csl_c := 0;
 				else
 					csl_c := csl_c + 1;
 				end
 				getPPX_PPY(csl_r);
 				getTRX0_TRX1();
		 		getTRY0_TRY1();
 				csl_pY_loop_end := getNumPrecinctsHigh();
 				csl_pX_loop_end := getNumPrecinctsWide();
 				csl_pY_loop := 0;
  			else
 				csl_pY_loop := csl_pY_loop + 1;  			
 			end
 			csl_pX_loop := 0;
 		else
 			csl_pX_loop := csl_pX_loop + 1;
 		end
 	end
/******************************************************************************
 * procedure loopIncr_rlcp
 *****************************************************************************/
   	procedure loopIncr_rlcp ()
 	begin 	
 		if (csl_pX_loop = csl_pX_loop_end-1) then
 			if (csl_pY_loop = csl_pY_loop_end-1) then
 				if (csl_c = csl_cend-1) then
 					if (csl_l = csl_lend-1) then
 						csl_r := csl_r + 1;
 						csl_l := 0;
 					else
 						csl_l := csl_l + 1;
 					end
 					csl_c := 0;
 				else
 					csl_c := csl_c + 1;
 				end
 				getPPX_PPY(csl_r);
 				getTRX0_TRX1();
		 		getTRY0_TRY1();
 				csl_pY_loop_end := getNumPrecinctsHigh();
 				csl_pX_loop_end := getNumPrecinctsWide();
 				csl_pY_loop := 0;
  			else
 				csl_pY_loop := csl_pY_loop + 1;  			
 			end
 			csl_pX_loop := 0;
 		else
 			csl_pX_loop := csl_pX_loop + 1;
 		end 	
 	end
/******************************************************************************
 * procedure loopIncr_main
 *****************************************************************************/
   	procedure loopIncr_main ()
 	begin
 		if (coc_sg_v[csl_c] >> 24) = 4 then
 			loopIncr_cprl();
 		else
 			if (coc_sg_v[csl_c] >> 24) = 1 then
 				loopIncr_rlcp();
 			else
 				loopIncr_lrcp();
 			end
 		end
 	end
/******************************************************************************
 * WaitInit_main
 *****************************************************************************/
  	WaitInit_main : action dataIn:[data] ==>
  	guard
  		data != 0x100
  	end
 /******************************************************************************
 * LoopInit_main
 *****************************************************************************/
  	LoopInit_main : action dataIn:[data]
  						   ==>
  						   traPictureInfo:[
  						   	siz_c_v ,
  						   	(sizeTileX >> 8) & 0xff, sizeTileX & 0xff,
  						   	(sizeTileY >> 8) & 0xff, sizeTileY & 0xff
  						   ]
  	
  	guard
  		data = 0x100
  	var
		uint(size=16) sizeTileX,
		uint(size=16) sizeTileY
  	do
 		word      := 0;
 		cptBit    := 0;
 		csl_c     := 0;
 		csl_r     := 0;
 		csl_l     := 0;
  		csl_cend  := siz_c_v;
  		csl_rend  := coc_sp_v[csl_c][0] + 1;
  		csl_lend  := (coc_sg_v[csl_c] >> 8) & 0xffff;  		
		getTY0_TY1();
		getTX0_TX1();
		TagTreeNew();
  		CodeBlockNew();
  		getPPX_PPY(csl_r);
 		getTRX0_TRX1();
 		getTRY0_TRY1();
		sizeTileX   := cst_TCX1 - cst_TCX0;
		sizeTileY   := cst_TCY1 - cst_TCY0;
		if DEBUG_TRACE = true then
			if (coc_sg_v[csl_c] >> 24) = 4 then
				println("===== readCompPosResLy "+sot_i_v);
			end
			if (coc_sg_v[csl_c] >> 24) = 1 then
				println("===== readResLyCompPos");
			end
			if (coc_sg_v[csl_c] >> 24) = 0 then
				 println("===== readLyResCompPos");
			end
 		end
 		if (coc_s_v[csl_c]&0x1) != 0 then
  			if (coc_sg_v[csl_c] >> 24) = 4 then
				csl_pY_loop     := cst_TCY0;
				csl_pX_loop     := cst_TCX0;
	  			csl_pY_loop_end := cst_TCY1;
  				csl_pX_loop_end := cst_TCX1;
  			else
 				csl_pY_loop     := 0;
				csl_pX_loop     := 0;
 				csl_pY_loop_end := getNumPrecinctsHigh();
 				csl_pX_loop_end := getNumPrecinctsWide();
  			end
  		else
  			csl_pY_loop_end := 1;
  			csl_pX_loop_end := 1;
  		end
	end
/******************************************************************************
 * LoopStart_main
 *****************************************************************************/
 	LoopStart_main.default : action ==>
 	guard
 		(coc_s_v[csl_c] & Scod_SOP_en) = 0 && csl_c != csl_cend && csl_l != csl_lend && csl_r != csl_rend && ifPrecValid()
 	do
		if (coc_sg_v[csl_c] >> 24) = 4 then
			getNumPrec();
		else
			csl_pX    := csl_pX_loop;
  			csl_pY    := csl_pY_loop;
  			csl_pmaxX := csl_pX_loop_end;
  			csl_pmaxY := csl_pY_loop_end;
		end
 	end
 	LoopStart_main.SOP : action dataIn:[data] repeat 6 ==>
 	guard
 		(coc_s_v[csl_c] & Scod_SOP_en) != 0 && csl_c != csl_cend && csl_l != csl_lend && csl_r != csl_rend && ifPrecValid()
 	do
 		if DEBUG_HEADER = true then
    		println("==== SOP ====");
    		println(" N    = "+((data[4]<<8)+data[5]));
 		end
		if (coc_sg_v[csl_c] >> 24) = 4 then
			getNumPrec();
		else
			csl_pX    := csl_pX_loop;
  			csl_pY    := csl_pY_loop;
  			csl_pmaxX := csl_pX_loop_end;
  			csl_pmaxY := csl_pY_loop_end;
		end
 	end
/******************************************************************************
 * LoopIncr_main
 *****************************************************************************/
 	LoopIncr_main : action ==>
 	guard
 		csl_c != csl_cend && csl_l != csl_lend && csl_r != csl_rend
 	do
  		loopIncr_main();		
 	end
/******************************************************************************
 * LoopEnd_main
 *****************************************************************************/
 	LoopEnd_main : action ==> CD:[0x200]
 	guard
 		csl_c = csl_cend || csl_l = csl_lend || csl_r = csl_rend
 	do
 		SOT_INIT();
 	end
/******************************************************************************
 * procedure loopIncr_swh
 *****************************************************************************/
  	procedure loopIncr_swh ()
 	begin
 		if (csl_h = csl_hcb) then
 			if (csl_w = csl_wcb) then
 				csl_s := csl_s + 1;
 				csl_w := 0;
 	 			csl_h := 0;			
 				if csl_s != csl_maxs then
 				 	getSubbandSize();
	 				getCodeBlockSizeDefault();
 				 	getPrecinctSize();
 				    getZoneSize();
	 				getNbCodeBlock();
	 			end
 			else
 				csl_w := csl_w + 1;
 			end
 			csl_h := 0;
 		else
 			csl_h := csl_h + 1;
 		end
 		if csl_s != csl_maxs then
 			getSubbandSize();
	 		getCodeBlockSizeDefault();
 			getPrecinctSize();
 			getZoneSize();
 			genCblkIdx();
 			getCodeBlockSize();
 		end
 	end
/******************************************************************************
 * procedure loopInit_swh
 *****************************************************************************/
  	procedure  loopInit_swh ()
  	begin
  		if (csl_r = 0) then
 			csl_mins := 0;
 			csl_maxs := 1;
 			getPPX_PPY(csl_r);
 		else
 			csl_mins := 1;
 			csl_maxs := 4;
 			getPPX_PPY(csl_r-1);
 		end
 		csl_p := csl_pY * csl_pmaxX + csl_pX;
 		csl_s := csl_mins;
 		csl_w := 0;
 		csl_h := 0;
 		getSubbandSize();
	 	getCodeBlockSizeDefault();
 		getPrecinctSize();
 		getZoneSize();
 		getNbCodeBlock();
 		genCblkIdx();
 		getCodeBlockSize();
	end
/******************************************************************************
 * LoopInit_swh1
 *****************************************************************************/
 	LoopInit_swh1.default : action ==>
 	guard
 		cptBit >= 1
 	do
 		CodeBlockInit();
 		loopInit_swh();
 		getNbBits  := 1;
 		getBitsRes := 0;
 		getBits(1);
 	end  
 	LoopInit_swh1.readByte : action dataIn:[byte] ==>
 	guard
 		cptBit < 1
 	do
 		CodeBlockInit();
 		loopInit_swh();
 		getNbBits  := 1;
 		getBitsRes := 0;
		getBits2(byte);
 	end
 	LoopInit_swh2 : action ==>
 	do
 		loopInit_swh();
 	end
/******************************************************************************
 * IsZeroLength
 *****************************************************************************/
 	IsZeroLength : action ==>
 	guard
 		getBitsRes = 0
 	do
 		cptBit := 0;
 		if DEBUG_TRACE = true then
 			println("# CodeBlock c = "+csl_c+" r = "+csl_r+" : skip");
 		end
 		loopIncr_main();
 	end
	IsNotZeroLength : action ==>
 	guard
 		getBitsRes = 1
 	do
 		if TagTreeIfExists() = false then
 			TagTreeAdd();
 		end
 	end
/******************************************************************************
 * LoopStart_swh
 *****************************************************************************/
	LoopStart_swh1 : action ==>
 	guard
 		csl_s != csl_maxs
 	do
 		if (csl_w = 0) && (csl_h = 0) then
 			if TagTreeIfExists() = false then
	 			TagTreeAdd();
 			end
 		end
 	end
 	LoopStart_swh2 : action ==>
	guard
 		csl_s != csl_maxs
	end
 	LoopEnd_swh2.default : action ==>
 	do
 	 	word        := 0;
 		cptBit      := 0;
 		loopIncr_main();
 	end
/******************************************************************************
 * Goto_swh2
 *****************************************************************************/
 	Goto_swh2.default : action ==>
 	 guard
 		(coc_s_v[csl_c] & Scod_EPH_en) = 0
 	end
 	Goto_swh2.EPH : action dataIn:[data] repeat 2 ==>
 	 guard
 		(coc_s_v[csl_c] & Scod_EPH_en) != 0
 	do
 		if DEBUG_HEADER = true then
    		println("==== EPH ====");
 		end
  	end
/******************************************************************************
 * checkCBsizeNoNull
 *****************************************************************************/
 	checkCBsizeNoNull : action ==>
 	guard
 		cblk_w[csl_s][csl_w2][csl_h2] != 0 && cblk_h[csl_s][csl_w2][csl_h2] != 0
 	end
 	checkCBsizeNull : action ==>
 	guard
 		cblk_w[csl_s][csl_w2][csl_h2] = 0 || cblk_h[csl_s][csl_w2][csl_h2] = 0
 	do
 		loopIncr_swh();	
 	end
/******************************************************************************
 * CodeBlockExists
 *****************************************************************************/
 	CodeBlockExists.default : action ==>
 	guard
 		cptBit >= 1	&& cblk_exists[csl_c][csl_r][csl_s][csl_w2][csl_h2] = true
 	do
		getNbBits  := 1;
 		getBitsRes := 0;
		getBits(1); 	
 	end
 	CodeBlockExists.readByte : action  dataIn:[byte] ==>
 	guard
 		cptBit < 1	&& cblk_exists[csl_c][csl_r][csl_s][csl_w2][csl_h2] = true
 	do
		getNbBits  := 1;
 		getBitsRes := 0;
		getBits2(byte); 	
 	end
	CodeBlockNotExists : action ==>
 	guard
 		cblk_exists[csl_c][csl_r][csl_s][csl_w2][csl_h2] = false
  	end
 	CodeBlockExistsGONext : action ==>
 	guard
 		getBitsRes = 0
 	var
 		uint(size=8) w,
 		uint(size=8) h
 	do
 		if DEBUG_TRACE = true then
 			w := cblk_w[csl_s][csl_w2][csl_h2];
 			h := cblk_h[csl_s][csl_w2][csl_h2];
 			println("# CodeBlock("+w+", "+h+") c = "+csl_c+" r = "+csl_r+" p = "+csl_p+" s = "+csl_s+" w = "+csl_w+" h = "+csl_h+" : skip");
 		end
 		loopIncr_swh();	
 	end
 	CodeBlockExistsContinu : action ==>
 	guard
 		getBitsRes = 1
 	do
 		csl_tmp    := 1;
 		csl_tmp2   := 0;
 		getBitsRes := 0;
 	end
/******************************************************************************
 * ZeroBitPlane
 *****************************************************************************/
 	ZeroBitPlane : action ==>
 	guard
  		ttl_tv <= csl_l+1
  	do
  		csl_tmp := 1;
 	end
 	ZeroBitPlaneGONext : action ==>
 	guard
  		ttl_tv > csl_l+1
  	var
 		uint(size=8) w,
 		uint(size=8) h
 	do
 		if DEBUG_TRACE = true then
 			w := cblk_w[csl_s][csl_w2][csl_h2];
 			h := cblk_h[csl_s][csl_w2][csl_h2];
			println("# CodeBlock("+w+", "+h+") c = "+csl_c+" r = "+csl_r+" p = "+csl_p+" s = "+csl_s+" w = "+csl_w+" h = "+csl_h+" : skip");
		end	
		loopIncr_swh();  	
 	end
 	ZeroBitPlaneLoop : action ==>
 	guard
 		ttl_tv >= csl_tmp+1
  	do
  		csl_tmp := csl_tmp+1;
 	end
 	ZeroBitPlaneEnd : action ==>
 	guard
 		ttl_tv < csl_tmp+1
  	do
  		cblk_zeroBitPlane[csl_s][csl_w2][csl_h2] := ttl_tv;
  		csl_tmp    := 1;
 		csl_tmp2   := 0;
 		getBitsRes := 0;
 	end
/******************************************************************************
 * GetNumCodingPasse
 *****************************************************************************/
 	GetNumCodingPasse : action ==>
 	guard
 		csl_tmp2 <= 7 && getBitsRes = ((1<<csl_tmp2)-1)
 	do
 		csl_tmp   := csl_tmp + getBitsRes;
 		if (csl_tmp = 1) then
 			csl_tmp2 := csl_tmp;
 		else
 			csl_tmp2 := csl_tmp-1;
 		end
 		getNbBits  := csl_tmp2;
 		getBitsRes := 0; 		
 	end
/******************************************************************************
 * GetLblock
 *****************************************************************************/
 	GetLblock.default : action ==>
 	guard
 	 	cptBit >= 1	
 	do
		cblk_nbCodingPasses[csl_s][csl_w2][csl_h2] := csl_tmp + getBitsRes;
		getNbBits  := 1;
 		getBitsRes := 0;
 		getBits(1);
 		csl_tmp    := getBitsRes;
 	end
 	GetLblock.readByte : action dataIn:[byte] ==>
 	guard
 	 	cptBit < 1	
 	do
		cblk_nbCodingPasses[csl_s][csl_w2][csl_h2] := csl_tmp + getBitsRes;
		getNbBits  := 1;
 		getBitsRes := 0;
 		getBits2(byte);
 		csl_tmp    := getBitsRes;
 	end
/******************************************************************************
 * GetNbOneBits
 *****************************************************************************/
 	GetNbOneBits.default : action ==>
 	guard
 	 	cptBit >= 1 && getBitsRes = 1	
 	do
		getNbBits  := 1;
 		getBitsRes := 0;
 		getBits(1);
 		csl_tmp    := csl_tmp + getBitsRes;
 	end
 	GetNbOneBits.readByte : action dataIn:[byte] ==>
 	guard
 	 	cptBit < 1	&& getBitsRes = 1
 	do
		getNbBits  := 1;
 		getBitsRes := 0;
 		getBits2(byte);
 		csl_tmp    := csl_tmp + getBitsRes;
 	end
	GetNbOneBitsEnd : action ==>
 	guard
 	 	getBitsRes = 0 && (coc_sp_v[csl_c][3] & TermCodingPass) = 0
 	do
 		CodeBlockSetLBlock(csl_tmp);
 		getNbBits  := cblk_lblock[csl_c][csl_r][csl_s][csl_w2][csl_h2] + 
 					  LOG2[cblk_nbCodingPasses[csl_s][csl_w2][csl_h2]];
 		getBitsRes := 0;
 	end
 	GetNbOneBitsEnd_TermCP : action ==>
 	guard
 	 	getBitsRes = 0 && (coc_sp_v[csl_c][3] & TermCodingPass) != 0
 	do
 		CodeBlockSetLBlock(csl_tmp);
 		csl_tmp    := cblk_nbCodingPasses[csl_s][csl_w2][csl_h2];
 		getNbBits  := cblk_lblock[csl_c][csl_r][csl_s][csl_w2][csl_h2];
 		getBitsRes := 0;
 		cblk_size[csl_s][csl_w2][csl_h2] := 0;
 	end
/******************************************************************************
 * GetSize
 *****************************************************************************/
	GetSize : action ==>
 	guard
 	 	cptBit >= getNbBits
 	var
 		uint(size= 8) h,
 		uint(size= 8) w,
 		uint(size= 8) npasses,
 		uint(size= 8) zeroBP
 	do
		getBits(getNbBits);
		cblk_size[csl_s][csl_w2][csl_h2] := cblk_size[csl_s][csl_w2][csl_h2] + getBitsRes;
		cblk_exists[csl_c][csl_r][csl_s][csl_w2][csl_h2] := true;
		if DEBUG_TRACE = true then
 			h       := cblk_h[csl_s][csl_w2][csl_h2];
 			w       := cblk_w[csl_s][csl_w2][csl_h2];
 			npasses := cblk_nbCodingPasses[csl_s][csl_w2][csl_h2];
 			zeroBP  := cblk_zeroBitPlane[csl_s][csl_w2][csl_h2];
 			println("# CodeBlock("+w+", "+h+") c = "+csl_c+" r = "+csl_r+" p = "+csl_p+" s = "+csl_s+" w = "+csl_w+" h = "+csl_h+" : number of coding passes = "+npasses+" : length = "+getBitsRes+" : zeroBitPlane = "+zeroBP);
		end
		loopIncr_swh();
 	end
	GetSize_TermCP : action ==> cbInfoSegSize:[(segSize>>8 & 0xff), segSize&0xff]
 	guard
 	 	cptBit >= getNbBits && csl_tmp = 1
 	var
 		uint(size= 8) h,
 		uint(size= 8) w,
 		uint(size= 8) npasses,
 		uint(size= 8) zeroBP,
 		uint(size=16) segSize
 	do
		getBits(getNbBits);
		cblk_size[csl_s][csl_w2][csl_h2] := cblk_size[csl_s][csl_w2][csl_h2] + getBitsRes;
		cblk_exists[csl_c][csl_r][csl_s][csl_w2][csl_h2] := true;
		segSize    := getBitsRes;
		if DEBUG_TRACE = true then
 			h       := cblk_h[csl_s][csl_w2][csl_h2];
 			w       := cblk_w[csl_s][csl_w2][csl_h2];
 			npasses := cblk_nbCodingPasses[csl_s][csl_w2][csl_h2];
 			zeroBP  := cblk_zeroBitPlane[csl_s][csl_w2][csl_h2];
 			println("# CodeBlock("+w+", "+h+") c = "+csl_c+" r = "+csl_r+" p = "+csl_p+" s = "+csl_s+" w = "+csl_w+" h = "+csl_h+" : number of coding passes = "+npasses+" : length = "+cblk_size[csl_s][csl_w2][csl_h2]+" : zeroBitPlane = "+zeroBP);
		end
		loopIncr_swh();
 	end
 	GetSize_TermCPloop : action ==> cbInfoSegSize:[(segSize>>8 & 0xff), segSize&0xff]
 	guard
 	 	cptBit >= getNbBits && csl_tmp != 1
 	var
 		uint(size=16) segSize
 	do
		getBits(getNbBits);
		cblk_size[csl_s][csl_w2][csl_h2] := cblk_size[csl_s][csl_w2][csl_h2] + getBitsRes;
		segSize    := getBitsRes;
		getNbBits  := cblk_lblock[csl_c][csl_r][csl_s][csl_w2][csl_h2];
 		getBitsRes := 0;
		csl_tmp    := csl_tmp - 1;
 	end 	
/******************************************************************************
 * WriteData
 *****************************************************************************/
  	WriteInit : action  ==> 
  						cbInfo:[
  							idx_0, idx_1, idx_2, idx_3,
  							cb_w, cb_h, npasses, zeroBP,
  							cb_size_0, cb_size_1,
  							coc_sp_v[csl_c][3]
  						],
  						CD:[0x100]
	var
 		uint(size= 8) idx_0     =   csl_c,  
 		uint(size= 8) idx_1     = ((csl_r&0xf)<<4) + (csl_s&0xf), 
 		uint(size= 8) idx_2     =   csl_w2&0xff, 
 		uint(size= 8) idx_3     =   csl_h2&0xff, 
 		uint(size= 8) cb_w      = cblk_w[csl_s][csl_w2][csl_h2],
 		uint(size= 8) cb_h      = cblk_h[csl_s][csl_w2][csl_h2],
 		uint(size= 8) npasses  := cblk_nbCodingPasses[csl_s][csl_w2][csl_h2],
 		uint(size= 8) zeroBP    = cblk_zeroBitPlane[csl_s][csl_w2][csl_h2],
 		uint(size=16) cb_size   = cblk_size[csl_s][csl_w2][csl_h2],
 		uint(size= 8) cb_size_0 = (cb_size>>8) & 0xff,
 		uint(size= 8) cb_size_1 =  cb_size     & 0xff
 	do
 	 	if cb_size = 0 then
 	 		npasses := 0;
 	 	end
 	end
 	WriteData.stuffingByte : action dataIn:[data] ==>
	guard
 		cptBit = 0 && (word & 0x00FF) = 0x00FF
 	do
 		cptBit := 8;
 		println("stuffingByte");
 	end
 	WriteData.default : action dataIn:[data] ==> CD:[data]
	guard
 		cblk_size[csl_s][csl_w2][csl_h2] != 0
  	do
		cblk_size[csl_s][csl_w2][csl_h2] := cblk_size[csl_s][csl_w2][csl_h2] - 1;
 	end
 	WriteDataEnd : action ==>
 	guard
 		cblk_size[csl_s][csl_w2][csl_h2] = 0
 	do
 		loopIncr_swh();
 	end 
/******************************************************************************
 * idle
 *****************************************************************************/
 	Idle : action ==>
 	end
/******************************************************************************
 * Scheduler
 *****************************************************************************/	
	schedule fsm getSIZ_st:
		// getSIZ
		getSIZ_st             ( GetSIZ                 ) --> getSIZloop_st;
		// getSIZloop
		getSIZloop_st         ( GetSIZloop             ) --> getSIZloop_st;
		getSIZloop_st         ( EndGetSIZloop          ) --> getSOT_st;
		// getSOT
		getSOT_st             ( GetSOT                 ) --> getCOC_st;
		// getCOC 
		getCOC_st             ( GetCOC                 ) --> getCOCloop_st;
		getCOC_st             ( GetCOCEnd              ) --> loopInit_main_st;
		// getCOCloop
		getCOCloop_st         ( GetCOCloop             ) --> getCOCloop_st;
		getCOCloop_st         ( EndGetCOCloop          ) --> getCOC_st;
		// loopmain 1 
		loopInit_main_st      ( LoopInit_main          ) --> loopStart_main_st;
		loopInit_main_st      ( WaitInit_main          ) --> loopInit_main_st;
		loopStart_main_st     ( LoopStart_main         ) --> loopInit_swh_st1;
		loopStart_main_st     ( LoopIncr_main          ) --> loopStart_main_st;
		loopStart_main_st     ( LoopEnd_main           ) --> getSOT_st;
		// loopSWH 1
		loopInit_swh_st1      ( LoopInit_swh1          ) --> isZeroLength_st;
		loopStart_swh_st1     ( LoopStart_swh1         ) --> checkCBsizeNoNull_st;
		loopStart_swh_st1     ( Goto_swh2              ) --> loopInit_swh_st2;
		// isZeroLength
		isZeroLength_st       ( IsZeroLength           ) --> loopStart_main_st;
		isZeroLength_st       ( IsNotZeroLength        ) --> checkCBsizeNoNull_st;
		// checkCBsizeNoNull
		checkCBsizeNoNull_st  ( checkCBsizeNoNull      ) --> ifCodeBlockExists_st;
		checkCBsizeNoNull_st  ( checkCBsizeNull        ) --> loopStart_swh_st1;
		// ifCodeBlockExists
		ifCodeBlockExists_st  ( CodeBlockExists        ) --> ifCodeBlockExists2_st;
		ifCodeBlockExists_st  ( CodeBlockNotExists     ) --> ttUpdateIncl_st;
		ifCodeBlockExists2_st ( CodeBlockExistsGONext  ) --> loopStart_swh_st1;
		ifCodeBlockExists2_st ( CodeBlockExistsContinu ) --> getNumCodingPasse_st;
		// get if include
		ttUpdateIncl_st       ( TagTreeUpdateIncl      ) --> ttUpdateLoopIncl_st;
		ttUpdateLoopIncl_st   ( TagTreeUpdateLoop      ) --> ttUpdateLoopIncl_st;
		ttUpdateLoopIncl_st   ( TagTreeUpdateLoopEnd   ) --> ttUpdateEndIncl_st;
		ttUpdateEndIncl_st    ( TagTreeUpdateNoEndIncl ) --> ttUpdateLoopIncl_st;
		ttUpdateEndIncl_st    ( TagTreeUpdateEndIncl   ) --> zeroBitPlane_st;
		// get number of bit plane
		zeroBitPlane_st       ( ZeroBitPlane           ) --> ttUpdateBD_st;
		zeroBitPlane_st       ( ZeroBitPlaneGONext     ) --> loopStart_swh_st1;
		zeroBitPlaneLoop_st   ( ZeroBitPlaneLoop       ) --> ttUpdateBD_st;
		zeroBitPlaneLoop_st   ( ZeroBitPlaneEnd        ) --> getNumCodingPasse_st;
		ttUpdateBD_st         ( TagTreeUpdateBD        ) --> ttUpdateLoopBD_st;
		ttUpdateLoopBD_st     ( TagTreeUpdateLoop      ) --> ttUpdateLoopBD_st;
		ttUpdateLoopBD_st     ( TagTreeUpdateLoopEnd   ) --> ttUpdateEndBD_st;
		ttUpdateEndBD_st      ( TagTreeUpdateNoEndBD   ) --> ttUpdateLoopBD_st;
		ttUpdateEndBD_st      ( TagTreeUpdateEndBD     ) --> zeroBitPlaneLoop_st;
		// get number of coding passe
		getNumCodingPasse_st  ( GetNumCodingPasse      ) --> getNumCodingPasseGetBit_st;
		getNumCodingPasse_st  ( Idle                   ) --> getLblock_st;
		getNumCodingPasseGetBit_st ( GetBits           ) --> getNumCodingPasse_st;
		getNumCodingPasseGetBit_st ( GetBits2          ) --> getNumCodingPasseGetBit_st;
		// get size of codec block data
		getLblock_st          ( GetLblock              ) --> getNbOneBits_st;
		getNbOneBits_st       ( GetNbOneBits           ) --> getNbOneBits_st;
		getNbOneBits_st       ( GetNbOneBitsEnd        ) --> getSize_st;
		getNbOneBits_st       ( GetNbOneBitsEnd_TermCP ) --> getSize_TermCP_st;
		getSize_st            ( GetSize                ) --> loopStart_swh_st1;
		getSize_st            ( GetBits2               ) --> getSize_st;
		getSize_TermCP_st     ( GetSize_TermCP         ) --> loopStart_swh_st1;
		getSize_TermCP_st     ( GetSize_TermCPloop     ) --> getSize_TermCP_st;
		getSize_TermCP_st     ( GetBits2               ) --> getSize_TermCP_st;
		//
		//
		// loopSWH 2
		loopInit_swh_st2      ( LoopInit_swh2          ) --> checkCBsizeNoNull_st2;
		loopStart_swh_st2     ( LoopStart_swh2         ) --> checkCBsizeNoNull_st2;
		loopStart_swh_st2     ( LoopEnd_swh2           ) --> loopStart_main_st;
		// checkCBsizeNoNull
		checkCBsizeNoNull_st2 ( checkCBsizeNoNull      ) --> writeInit_st;
		checkCBsizeNoNull_st2 ( checkCBsizeNull        ) --> loopStart_swh_st2;
		// writeInit
		writeInit_st          ( WriteInit              ) --> noWriteData_st;
		writeInit_st          ( WriteDataEnd           ) --> loopStart_swh_st2;
		// noWriteData
		noWriteData_st        ( WriteData              ) --> writeData_st;
		noWriteData_st        ( WriteDataEnd           ) --> loopStart_swh_st2;
		// writeData
		writeData_st          ( WriteData              ) --> writeData_st;
		writeData_st          ( WriteDataEnd           ) --> loopStart_swh_st2;
	end
/******************************************************************************
 * Priority
 *****************************************************************************/	
	priority
		LoopStart_main        > LoopIncr_main;
		GetNumCodingPasse     > Idle;
		LoopStart_swh2        > LoopEnd_swh2;
	end
 end
