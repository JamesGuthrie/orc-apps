/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Endri Bezati <endri.bezati@epfl.ch>
// Modified Hossam Amer

package jpeg.encoder.hw;

import jpeg.encoder.common.Tables.HT_Bits;
import jpeg.encoder.common.Tables.lumaDCValues;
import jpeg.encoder.common.Tables.lumaACValues;
import jpeg.encoder.common.Tables.chromaDCValues;
import jpeg.encoder.common.Tables.chromaACValues;

actor Huffman420()
	int(size=32) In,
	int(size=32) SOI
		==> 
			int(size=4) Bit,
			int(size=32) Count:
			
	int blockCount := 0;
	int maxBlock := 0;
	int count := 0;
	int send_idx := 0;
	int last_DC := 0;
	int cur_HT := 0;
	bool CheckType := false;
	int isAC := 0; // 0: DC, 2:AC
	int Block_Type := 0;
	int SzWidth := 0;

	int bo_v :=0;
	int bo_ZRL :=0;
	int cur_idx :=0;
	int offset := 0;
		
	// receive_block
	int EOB_idx := 0;
	bool done := false;
	int ZRL :=0;
	bool zero := false;
	int ob_log2;
	int code_jdx;
	//GenerateHT
	int v := 0;
	int ht_idx :=0;
	int Counter := 0;
	int code_idx := 0;
	int max_len := 0;
	int idx := 0;
	int code :=0;
	bool rb_done;

	//outputbuffer
	int bit_length := 0;
	int v_abs := 0;

	// Temporary buffers to store the data of the Huffman table definition.
	List(type:List(type:int(size=9), size=17), size=4) ht_codes_len := [[0:for int i in 0 .. 16]: for int j in 0 .. 3];
	
	List(type:int(size=4), size=2048) out_buffer :=  [0:for int i in 0 .. 2047];
	
	List(type:int(size=32), size=64) rBlock := [0:for int i in 0 .. 63];
	
	
	//List(type:int(size=32), size=3) Last_DC := [0, 0, 0];
	
	int Last_DC_Y := 0;
	int Last_DC_Cb := 0;
	int Last_DC_Cr := 0;
	
	// The constructed Huffman tables.
	// Index 0 is DC Huffman table.
	// Index 1 is AC Huffman table.
	// all lists of size four because: 0 > lumaDC, 1 > lumaAC, 2 > chromaDC, 3 > chromaAC	
			
	List(type:int(size = 32), size = 4) to_read := [0, 0, 0, 0];
	List(type:List(type:int(size=9), size=256), size = 4) ht_codes_list := [[0:for int i in 0 .. 255]: for int j in 0 .. 3];
	List(type:List(type:List(type:int(size=32), size=256), size=2), size  = 4) ht_lookup_bitlen := [ [[0:for int i in 0 .. 255]: for int j in 0 .. 1]: for int k in 0 .. 3];
	
	List(type:List(type:List(type:List ( type: int(size=4), size=17), size=256), size=2), size = 4)  ht_lookup_bits := [ [[[0:for int i in 0 .. 16]:for int j in 0 .. 255]:for int k in 0 .. 1]: for int m in 0 .. 3];
	List(type:List(type:List(type: int(size=9), size=256), size=2), size = 4) ht_lookup_code := [[[0:for int i in 0 .. 255]:for int j in 0 .. 1]: for int k in 0 .. 3];
	bool counter_ht_done := false;
	int block_mode := 0; // a variable used to access the appropriate huffman tables 
	int buildHT_turn := 0;	// a variable used for generating huffman tables
			
			
	function abs(int x) --> int :
		if x < 0 then
			-x
		else
			x
		end
	end

	GetSzW: action SOI:[w] ==> 
	do
		SzWidth := w;
	end
	
	GetSzH: action SOI:[h] ==>
	do
		maxBlock := (4 + 2) * ((SzWidth + 15) >> 4) * ((h + 15) >> 4);
	end
	
	GetHT: action ==> 
	do
		to_read[0] := 0;
		to_read[1] := 0;
		to_read[2] := 0;
		to_read[3] := 0;
		
		idx := 1;
		while idx <= 16
		do
			// check the Tables.cal for knowing the order of the tables
			ht_codes_len[0][idx-1] := HT_Bits[0][idx];
			ht_codes_len[1][idx-1] := HT_Bits[2][idx];
			ht_codes_len[2][idx-1] := HT_Bits[1][idx];
			ht_codes_len[3][idx-1] := HT_Bits[3][idx];
			
			to_read[0] := to_read[0] + ht_codes_len[0][idx-1];
			to_read[1] := to_read[1] + ht_codes_len[1][idx-1];
			to_read[2] := to_read[2] + ht_codes_len[2][idx-1];
			to_read[3] := to_read[3] + ht_codes_len[3][idx-1];
			idx := idx + 1;
		end	
	end
	
	buildHT.start: action ==> 
	do
		Counter := 0;
		counter_ht_done := false;
		v := 0;
		ht_idx := 0;
		cur_HT := 0;
		
		//println("buildHT.start");
	end

  	builtHT.loop: action ==> 
	guard 
	 	Counter < 16 and buildHT_turn <= 3
	do	
		code_idx := 0;
		max_len := ht_codes_len[buildHT_turn][Counter];
		while code_idx != max_len do
			ht_lookup_bitlen[buildHT_turn][cur_HT][ht_idx] := Counter + 1;
			idx := Counter;
			code := v;
			while idx >= 0 do
				if code != 0 then
					ht_lookup_bits[buildHT_turn][cur_HT][ht_idx][idx] := code & 1;
					code := code >> 1;
				else
					ht_lookup_bits[buildHT_turn][cur_HT][ht_idx][idx] := 0;
				end
					
				idx := idx - 1;
			end
			ht_lookup_code[buildHT_turn][cur_HT][ht_codes_list[buildHT_turn][ht_idx]] := ht_idx;
			v := v + 1;
			ht_idx := ht_idx + 1;
			code_idx := code_idx + 1;
		end
		v := v << 1;
		Counter := Counter + 1;
	end
	
	builtHT.controller: action ==>
	guard 	
		Counter = 16 and
		buildHT_turn <= 3
	do
		buildHT_turn := buildHT_turn + 1;
		Counter := 0;
		v := 0;
		ht_idx := 0;		
		isAC := 0;
		
		if(buildHT_turn = 2) then
			cur_HT := 0;
		else
			cur_HT := 1;
		end			
	end	 
  		
	EOI: action ==>
	guard 
		blockCount = maxBlock
	do
		maxBlock := 0;
		blockCount := 0;
	
		//reset globals
		Block_Type := 0;
		Last_DC_Y := 0;
		Last_DC_Cb := 0;
		Last_DC_Cr := 0;
		cur_HT := 0;
	
		offset := 0;
		count := 0;
		send_idx := 0;
		last_DC := 0;
		CheckType := false;
		isAC := 0;
		
		to_read[0] := 0;
		to_read[1] := 0;
		to_read[2] := 0;
		to_read[3] := 0; 
		counter_ht_done := false;
		block_mode := 0;
		buildHT_turn := 0;
		
		cur_HT := 0;
		v := 0;
		ht_idx := 0;
		
//		println("End of Image Fak!");
	end
	
	ChangeType: action ==> 
	guard
		(Block_Type = 4 or Block_Type = 6) and CheckType
		and buildHT_turn > 3
	do
		if Block_Type = 6 then
			Block_Type := 0;
		end
		CheckType := false;
	end
	
	receiveBlock.start: action ==> 
	guard
		buildHT_turn > 3
	do
		Counter := 0;
	end
	
	receiveBlock.body: action In:[token] ==>
	do
		rBlock[Counter] := token;
		Counter := Counter + 1;
	end
	
	receiveBlock.finish: action ==> 
	guard
		Counter = 64
	do
		EOB_idx := 0;
		
		//println("Block received!");
	end
	
	
	OutputBuffer.TestZRL: action ==> 
	do
		ob_log2 := 0;
		v_abs := abs(bo_v);
		
	
		if (bo_ZRL != 16) then
			if (bo_v != 0) then
				while v_abs != 0 do
					ob_log2 := ob_log2 + 1;
					v_abs := v_abs >> 1;
				end
				code_jdx := (bo_ZRL << 4) + ob_log2;
			else
				code_jdx := 0x00;
			end
		else
			code_jdx := 0xF0;
		end
		
		// Calculating the blockmode according to the block type; AC or DC
		if (isAC = 0) then 
			if(Block_Type <= 3) then
				block_mode := 0;
			else
				block_mode := 2;
			end	
		end
		
		if(isAC = 2) then 
			if(Block_Type <= 3) then 
				block_mode := 1;
			else
				block_mode := 3;
			end	
		end					
		
		cur_idx := ht_lookup_code[block_mode][cur_HT][code_jdx];
		bit_length := 0;
		
//		println("OutputBuffer.TestZRL Fak: block mode, cur_idx, cur_HT, trials: " + block_mode + ", " + cur_idx +
//		 ", " + cur_HT + ", " + ht_lookup_code[0][cur_HT][code_jdx] + ", " + ht_lookup_code[1][cur_HT][code_jdx] + ", " + 
//		 ht_lookup_code[2][cur_HT][code_jdx] + ", " + ht_lookup_code[3][cur_HT][code_jdx]);
	end
	
	
	
	OutputBuffer.bit_length: action ==>
	do
		// Write the huffman code and the value to the output buffer.
		bit_length := ht_lookup_bitlen[block_mode][cur_HT][cur_idx];

		foreach int j in 0 .. (bit_length - 1) do
			out_buffer[offset + j] := ht_lookup_bits[block_mode][cur_HT][cur_idx][j];
		end
		
		// Write the value
		if (bo_v < 0) then
			// 2 complement
			v_abs := bo_v + (1 << ob_log2) - 1;
		else
			v_abs := bo_v;
		end
		offset := offset + bit_length;
		
//		println("OutputBuffer.bit_length: block mode, bit_length: " + block_mode + ", " + ht_lookup_bitlen[0][cur_HT][cur_idx]
//		+ ", " + ht_lookup_bitlen[1][cur_HT][cur_idx] + ", " + ht_lookup_bitlen[2][cur_HT][cur_idx] + ", " + ht_lookup_bitlen[3][cur_HT][cur_idx]);
	end
		
	OutputBuffer.out_v_abs: action ==> 
	do	
		foreach int j in 1 .. ob_log2 do
			out_buffer[offset + ob_log2 - j] := v_abs & 1;
			v_abs := v_abs >> 1;
		end
		
		offset := offset + ob_log2;
	end	
	
	
	CheckEOB: action ==> 
	do
		EOB_idx := 63;
		
		rb_done := rBlock[EOB_idx] != 0;
		while (not rb_done)
		do
			EOB_idx := EOB_idx - 1;
			if (EOB_idx = 0)
			then
				rb_done := true;
			else
				rb_done := rBlock[EOB_idx] != 0;
			end
		end	
		
		cur_HT := 0;
		isAC := 0;
		
		if Block_Type = 4 then
			last_DC := Last_DC_Cb;
		else
			if Block_Type = 5 then
				last_DC := Last_DC_Cr;
			else
				last_DC := Last_DC_Y;
			end
		end
		
		offset := 0;
		// init BuildOutputBuffer
		bo_v := rBlock[0] - last_DC;
		bo_ZRL := 0;
		
		//println("CheckEOB");
	end	
	
	BuildOutput.start: action ==> 
	do
		if Block_Type = 4 then
			Last_DC_Cb := rBlock[0];
		else
			if Block_Type = 5 then	
				Last_DC_Cr := rBlock[0];
			else
				Last_DC_Y := rBlock[0];
			end
		end
		
		isAC := 2;
		cur_HT := 1;
		idx := 1;
		done := (idx > EOB_idx);
		
		//println("BuildOutput.start");	
	end
	
	BuildOutput.notDone: action ==> 
	guard
		not done
	do
		ZRL := 0;
		zero := (rBlock[idx] = 0);
		while (zero)
		do
			ZRL := ZRL + 1;
			idx := idx + 1;
			zero := (rBlock[idx] = 0 and ZRL < 15);
		end
		if rBlock[idx] = 0 then
			bo_v := 0;
			bo_ZRL := 16;
		else
			bo_v := rBlock[idx];
			bo_ZRL := ZRL;
		end
		
		//println("BuildOutput.notDone");
	end
	
	BuildOutput.notDoneContinue: action ==>
	do
		idx := idx + 1;
		done := idx > EOB_idx;
		
		//println("BuildOutput.notDoneContinue");
	end
	
	BuildOutput.Done: action ==> 
	guard
		done
		do
			// println("BuildOutput.Done");
	end
	
	AddEOB: action ==>
	guard
		EOB_idx < 63
	do
		bo_v := 0;
		bo_ZRL := 0;
	end
	
	NoEOB: action ==>
	guard
		EOB_idx >= 63
	end
	
	BuildOutput.finish: action ==> Count:[offset]
	do
		count := count + 1;
		send_idx := 0;
		blockCount := blockCount + 1;
	end
	
	
	int b;
	sendBits: action ==> Bit:[b]
	do
		b := out_buffer[send_idx];
		send_idx := send_idx + 1;
	end

	doneSend: action ==>
	guard
		send_idx = offset
	do
		Block_Type := Block_Type + 1;
		CheckType := true;	
//		println("doneSend BITS!");
	end
	
	// With nested loops for software -> Working version
	HT_codes_list: action ==> 
		var 
			int turn := 0,
			int iterations := 0,
			int value
		do		
			while(turn<=3) 
			do
				ht_idx := 0;
				iterations := to_read[turn];
	
				while (iterations != 0) do
					if(turn = 0) then
						value :=  lumaDCValues[ht_idx];
					else 
						if(turn = 1) then
							value := lumaACValues[ht_idx];
						else
							if(turn = 2) then
								value := chromaDCValues[ht_idx];
							else
								value := chromaACValues [ht_idx];
							end
						end
					end		
					ht_codes_list[turn][ht_idx] :=  value;
					ht_idx := ht_idx + 1;
					iterations := iterations - 1;
				end	// end inner loop
							
				turn := turn + 1;		
				
			end// end outer loop
	end

	schedule fsm s0:
	
		s0			(GetSzW)						--> s01;
		s01			(GetSzH)						--> s1;
		
		s1			(GetHT)							--> s11;
	
		s11			(HT_codes_list)					--> s112;
	
		s112		(buildHT.start)					--> s113;
		
		s113	 	(builtHT.loop) 					 --> s113;
		s113 	 	(builtHT.controller)			 --> s2;
		s2 		 	(builtHT.loop)					 --> s113;				
		
		s2			(receiveBlock.start)			--> s21;
		s21			(receiveBlock.body)				--> s21;
		s21			(receiveBlock.finish)			--> s3;
		
		s2			(ChangeType)					--> s2;
		s2			(EOI)							--> s0;
		
		
		s3			(CheckEOB)						--> s31;
		
		s31			(OutputBuffer.TestZRL)			--> s311;
		s311		(OutputBuffer.bit_length)		--> s312;
		s312		(OutputBuffer.out_v_abs)		--> s32; 
		
		
		s32			(BuildOutput.start)				--> s33;
		s33			(BuildOutput.notDone)			-->	s331;
		s33			(BuildOutput.Done)				--> s34;
				
		s331		(OutputBuffer.TestZRL)			--> s3311;
		s3311		(OutputBuffer.bit_length)		--> s3312;
		s3312		(OutputBuffer.out_v_abs)		--> s332; 
		
		s332		(BuildOutput.notDoneContinue)	--> s33;
		
		s34			(AddEOB)						--> s341;
		
		s341		(OutputBuffer.TestZRL)			--> s3411;
		s3411		(OutputBuffer.bit_length)		--> s3412;
		s3412		(OutputBuffer.out_v_abs)		--> s35;
		
		
		s34			(NoEOB)							--> s35;	
		
		s35			(BuildOutput.finish)			--> s4;
		
		s4			(sendBits)						--> s4;
		s4			(doneSend)						--> s2;
		
	end
	
	priority
		EOI > ChangeType > receiveBlock.start;
		receiveBlock.finish > receiveBlock.body;
		doneSend > sendBits;
	end
	
end