/*
 * Copyright (c) 2010, Regents of the Akatech SA, EPFL
 * 
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Akatech SA, EPFL nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
package jpeg.decoder.idct;

actor scaled_1d_idct () int(size=32) In ==> int(size=32) Out :

	function pmul_1_1(int X) --> int
	var
		int Temp1 = (X >> 3) - (X >> 7) :
		X - Temp1
	end

	function pmul_1_2(int X) --> int
	var
		int Temp1 = (X >> 3) - (X >> 7),
		int Temp2 = Temp1 - (X >> 11) :
		Temp1 + (Temp2 >> 1)
	end

	function pmul_2_1(int X) --> int
	var
		int Temp1 = (X >> 9) - X :
		(Temp1 >> 2) - Temp1
	end

	function pmul_2_2(int X) --> int :
		(X >> 1)
	end

	function pmul_3_1(int X) --> int
	var
		int Temp1 = X + (X >> 5),
		int Temp2 = (Temp1 >> 2) :
		Temp2 + (X >> 4)
	end

	function pmul_3_2(int X) --> int
	var
		int Temp1 = X + (X >> 5),
		int Temp2 = (Temp1 >> 2) :
		Temp1 - Temp2
	end

	action In:[ x ] repeat 8 ==> Out:[ y ] repeat 8
	var
		int tmp_1,
		int tmp_2,
		int tmp_3,
		int tmp_4,
		int xa,
		int xb, 
		List(type: int, size=8) y
	do
		xa := x[1] + x[7];
		xb := x[1] - x[7];
		x[1] := xa + x[3];
		x[3] := xa - x[3];
		x[7] := xb + x[5];
		x[5] := xb - x[5];
		tmp_1 := pmul_1_1(x[3]);
		tmp_4 := pmul_1_2(x[3]);
		tmp_3 := pmul_1_1(x[5]);
		tmp_2 := pmul_1_2(x[5]);
		x[3] := tmp_1 - tmp_2;
		x[5] := tmp_3 + tmp_4;
		tmp_1 := pmul_2_1(x[1]);
		tmp_4 := pmul_2_2(x[1]);
		tmp_3 := pmul_2_1(x[7]);
		tmp_2 := pmul_2_2(x[7]);
		x[1] := tmp_1 + tmp_2;
		x[7] := tmp_3 - tmp_4;
		tmp_1 := pmul_3_1(x[2]);
		tmp_4 := pmul_3_2(x[2]);
		tmp_3 := pmul_3_1(x[6]);
		tmp_2 := pmul_3_2(x[6]);
		x[2] := tmp_1 - tmp_2;
		x[6] := tmp_3 + tmp_4;
		xa := x[0] + x[4];
		xb := x[0] - x[4];
		x[0] := xa + x[6];
		x[6] := xa - x[6];
		x[4] := xb + x[2];
		x[2] := xb - x[2];
		y := [ x[0] + x[1], x[4] + x[5], x[2] + x[3], x[6] + x[7], x[6] - x[7], x[2]
		- x[3], x[4] - x[5], x[0] - x[1] ];
	end

end


      
     
