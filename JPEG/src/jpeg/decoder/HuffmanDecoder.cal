/*
 * Copyright (c) 2010, Regents of the Akatech SA, EPFL
 * 
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Akatech SA, EPFL nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Author : Felix Abecassis
 * Modified: Abdellah Elguindy, HT tables reduction
 * Modified: ghislain roquier, remove free actions
 */
  
package jpeg.decoder;
 
actor HuffmanDecoder() uint(size=8) Bit, uint(size=8) HT, int(size=16) SOI ==> int(size=24) Block :

	uint(size=3) v_read_HT := 0;
	uint(size=16) cur_val := 0;
	uint cur_len := 0;
	uint(size=32) to_read := 0;
	uint(size=32) to_readHT := 0;
	uint(size=32) cur_HT;
	int idx;
	uint code;
	int count := 0;
	int mbcount;
	int bitcount := 0;
	uint(size=8) bits;
	
	// The indexes of each HT.
	int(size=8) dctab[3] = [0, 1, 1];
	int(size=8) actab[3] = [2, 3, 3];
	
	
	uint(size=8) ht_lookup_codelen[4][256];
	// Values have to be adjusted!!!
	int GUESSEDSIZE = 256;
	int ht_lookup_code_index[4][GUESSEDSIZE];
	int ht_lookup_code_value[4][GUESSEDSIZE];

	uint(size=8) ht_codes_len[16];
	uint(size=8) ht_codes_list[256];
	
	uint cur_count := 0;
	int(size=32) comp := 0;
	int subsampling[3] = [4, 1, 1];
	int lastDC[3];
	uint(size=24) block[64];
		
	readbit: action Bit:[b] ==>
	guard 
		to_read != 0, bitcount = 0
	do
		bits := b;
		// The bit sequence is translated to a decimal number.
		cur_val := cur_val * 2 + ((bits >> 7) & 1);
	   	to_read := to_read - 1;
	    cur_len := cur_len + 1;
	    
	    bitcount := bitcount + 1;
	end

	readbit.already_read: action ==>
	guard 
		to_read != 0, bitcount != 0
	do
		// The bit sequence is translated to a decimal number.
		cur_val := cur_val * 2 + ((bits >> 7 - bitcount) & 1);
	   	to_read := to_read - 1;
	    cur_len := cur_len + 1;
	    bitcount := (bitcount + 1) & 7;
	end
	
	// Procedures
	procedure get_HT_val(uint(size=32) i, uint(size=16) j)
	var
		int b := 0
	begin
		while (j >= ht_lookup_code_index[i][b])
		do
			b := b + 1;
		end
		code := ht_lookup_code_value[i][b - 1];
	end
	
	procedure generate_HT()
	var
		int v,
		uint(size=8) len,
		uint(size=8) code_idx,
		uint(size=16) spread,
		int u
	begin
		u := 0;
		v := 0;
		code_idx := 0;
		spread := 32768;
		// Depending on the size of the code, we "spread" the bit sequence on the array so that every value 
		// prefixed by this sequence refers to the same code.
		// For example if the code 23 is encoded by 1111110111 (10 bits), in the array all values ranging from
		// 1111110111000000 (16 bits) to 1111110111111111 (16 bits) refers to code 23.
		foreach int i in 0 .. 15
		do
			len := i + 1;
			foreach int j in 0 .. ht_codes_len[i] - 1
			do
				ht_lookup_codelen[cur_HT][ht_codes_list[code_idx]] := len;
				ht_lookup_code_index[cur_HT][u] := v;
				ht_lookup_code_value[cur_HT][u] := ht_codes_list[code_idx];
				u := u + 1;
				v := v + spread;
				code_idx := code_idx + 1;
			end
			spread := spread >> 1;
		end
		ht_lookup_code_index[cur_HT][u] := 1000000000;
	end
	
	
	getSOI: action SOI:[w, h] ==>
	do
		mbcount := 6 * w * h;
	end

	
	receive_HT_len:action HT:[b] repeat 17 ==>
	var
		uint sum := 0
	do
		idx := 0;
		// HT selection
		cur_HT := (b[0] | (b[0] >> 0x03)) & 0x03;
	
		foreach int i in 0 .. 15
		do
			ht_codes_len[i] := b[i + 1];
			sum := sum + ht_codes_len[i];
		end
		to_readHT := sum;
	end
	
	receive_code:action HT:[b] ==>
	guard (to_readHT > 0)
	do
		ht_codes_list[idx] := b;
		idx := idx + 1;
		to_readHT := to_readHT - 1;
	end
	
	build_HT:action ==>
	guard (to_readHT = 0)
	do
		generate_HT();
		v_read_HT := v_read_HT + 1;
	end
	
	done_HT:action ==>
	guard (v_read_HT = 4)
	do
		code := 0xFFFF;
		// Begin with DC Luminance
		comp := 0;
		cur_HT := dctab[comp];
		cur_val := 0;
		cur_len := 0;
		to_read := 16;
	end

	
	// End of DC, proceed with AC.
	DC.done:action ==>
	guard (to_read = 0)
	var
		int v
	do
		to_read := code & 0xF;
		cur_len := to_read;

		v := cur_val >> (16 - to_read);	
		if (v < (1 << (cur_len - 1))) 
		then
			v := v + (-1 << cur_len) + 1;
		end
		
		v := v + lastDC[comp];
		lastDC[comp] := v;

		cur_HT := actab[comp];
		block := [0 : for int i in 0 .. 63];
		idx := 1;
		block[0] := v;
	end
	
		
	get_code: action ==>
	do
		get_HT_val(cur_HT, cur_val);
		to_read := ht_lookup_codelen[cur_HT][code];
	    cur_len := to_read;
	end
			
	bool eob := false;
	
  	AC.decode_coef: action ==>
	var
		int v, int r
	do
		to_read := code & 0xF;
		cur_len := to_read;
		r := (code >> 4);
		idx := idx + r;
		v := cur_val >> (16 - to_read);	
		if v < (1 << (cur_len - 1))
		then
			v := v + (-1 << cur_len) + 1;
		end
		
		block[idx] := v;
		eob := idx = 63;
		idx := idx + 1;
	end
	
  	AC.eob: action ==> Block:[block] repeat 64
	guard (code = 0 or eob)
	do
		cur_count := cur_count + 1;
		if (cur_count = subsampling[comp])
		then
			cur_count := 0;
			comp := (comp + 1) mod 3;
		end
		cur_HT := dctab[comp];
		cur_len := 0;
		to_read := 0;

		count := count + 1;
	end
	
	EOI: action ==>
	guard count = mbcount
	do
		count := 0;
		bitcount := 0;
		mbcount := 0;
		v_read_HT := 0;
		cur_val := 0;
		cur_len := 0;
		to_read := 0;
		to_readHT := 0;	
		lastDC := [0, 0, 0];
	end
		
	// Schedule FSM
	schedule fsm waitSOI:
		waitSOI(getSOI) --> wait_HT;
		
		wait_HT(receive_HT_len)-->wait_code;
		wait_code(receive_code)-->wait_code;
		wait_code(build_HT)-->wait_HT;
		wait_HT(done_HT)-->wait_DC_len;
		
		wait_DC_len(EOI) --> waitSOI;
		wait_DC_len(readbit) --> wait_DC_len;
		wait_DC_len(get_code) --> wait_DC;
		
		wait_DC(readbit) --> wait_DC;
		wait_DC(DC.done) --> wait_AC_len;

		wait_AC_len(readbit) --> wait_AC_len;
		wait_AC_len(get_code) --> wait_AC;

		wait_AC(readbit) --> wait_AC;
		wait_AC(AC.eob) --> wait_DC_len;
		wait_AC(AC.decode_coef) --> wait_AC_len;
	end
	
	priority
		done_HT > receive_HT_len;
		EOI > readbit > get_code > DC;
		readbit > get_code > AC;
		AC.eob > AC.decode_coef;
	end

end