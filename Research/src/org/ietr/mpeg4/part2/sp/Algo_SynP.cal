/********************************************************************************
FU realizing Syntax Parsing for MPEG-2 MP
*****************************************************************************/

// This FU has been modified by Mickael Raulet (INSA of Rennes) 
package org.ietr.mpeg4.part2.sp;

import std.util.BitOps.*;
import org.ietr.mpeg2.mp.ParserUtils.*;
import org.sc29.wg11.common.BitstreamReadUtils.*;
import org.ietr.mpeg4.part2.sp.vldTables.*;

actor Algo_SynP()
		uint(size=8) BYTE 
		==> 
		:

	int (size = 8) VLC_ERROR = -1;
	
	procedure log2bin(uint(size=32) value, uint(size=32) res[1])
	var
		int invalue
	begin 
	  invalue := value;
	  res[0] := 0;
	  while (invalue!=0) do
		invalue := invalue >> 1;
		res[0] := res[0] + 1;
	  end
	end
	bool DEBUG_BITSTREAM = false;
	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
	uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL];
	uint(size= 2) zeroByte := 0;
	/* */
  	action BYTE:[ b ] ==>
	guard 
		fifo[FIFO_CPT_BITS] <= (FIFO_SIZE-1)<<3
	var
		uint(size=4) fifo_idx  =  fifo[FIFO_IDX]
	do
		if zeroByte != 3 or b != EPR_VALUE then
			if b = START_CODE_VALUE and zeroByte = 3 then
				fifo[fifo_idx]      := b + START_CODE_FLAG;
			else
				fifo[fifo_idx]      := b;
			end
			fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] + 8;
			if DEBUG_BITSTREAM then
				println("fifo["+fifo_idx+"] := "+b+" \t "+fifo[FIFO_CPT_BITS]);
			end
			fifo[FIFO_IDX]      := (fifo_idx+1) & (FIFO_SIZE-1);
		end
		if b = 0 then
			zeroByte := ((zeroByte << 1) + 1) & 0x3;
		else
			zeroByte := 0;
		end
	end
	
	uint(size=1) moreDataFlag;
	//*************************************************************/


 	procedure more_rbsp_data()   
  	var 
  		uint(size=4) cptBits = (fifo[FIFO_CPT_BITS] - 1) & 7,
		int(size=32) res[1],
 		uint(size=9) idx     = getFifoIdx(fifo[FIFO_CPT_BITS], fifo)
	begin
		if (fifo[(idx + 1) & 7]) != 0 or ( (fifo[(idx + 3) & 7] & 0x100) = 0 and (fifo[(idx + 4) & 7] & 0x100) = 0 ) then 
				moreDataFlag:=1; 
			else 
				showBits ((cptBits + 1), fifo, res);
				moreDataFlag:=if(res[0] = 1<< cptBits) then 0 else 1 end;
			end
	end
	  
	
	/*************************************************************
	*************************************************************
	********              NAL Unit HEADER                ********
	*************************************************************
	*************************************************************/

	int VOP_START_CODE                  = 182;
	int VOL_START_CODE                  = 32; //0x20
 


	look_for_Sequence_Header: action ==>
	end
	uint(size=8) start_code;
	read_start_code: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		//println("=========== start code ===========");
		vld_u_name(  8, fifo, res, "start_code                           ");
		start_code := res[0];
	end 
 
	look_for_other_header: action ==>
	end



	look_for.vol: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		start_code = VOL_START_CODE
	do
		println("VOL");
	end

	look_for.vop: action ==>
	guard
		start_code = VOP_START_CODE 
	do
		println("VOP");
	end
 
	/**************************************************************************
	 * sequence_header_start_code
	 *************************************************************************/
	bool vol_control_parameters;
	bool vbv_parameters;
    uint(size=8) vop_time_increment_resolution_bits;

	read_vol.start : action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1],
		bool is_object_layer_identifier
	do
		vld_u_name(  1, fifo, res, "random_accessible_vol                           ");
		vld_u_name(  8, fifo, res, "video_object_type_indication                           ");
		vld_u_name(  1, fifo, res, "is_object_layer_identifier                           ");
		is_object_layer_identifier := res[0] = 1;
		if (is_object_layer_identifier) then	
			vld_u_name(  4, fifo, res, "video_object_layer_verid                           ");	
			vld_u_name(  3, fifo, res, "video_object_layer_priority                           ");
		end	
		vld_u_name(  4, fifo, res, "aspect_ratio_info                           ");	
		/*if (aspect_ratio_info == Òextended_PARÓ) {	
			par_width	8
			par_height	8
		}*/
		vld_u_name(  1, fifo, res, "vol_control_parameters                           ");
		vol_control_parameters := res[0] = 1;
		if (vol_control_parameters) then	
			vld_u_name(  2, fifo, res, "chroma_format                           ");
			vld_u_name(  1, fifo, res, "low_delay                           ");
			vld_u_name(  1, fifo, res, "vbv_parameters                           ");
			vbv_parameters := res[0] = 1;
			if (vbv_parameters) then	
				vld_u_name(  15, fifo, res, "first_half_bit_rate                           ");
				vld_u_name(  1, fifo, res, "marker_bit                           ");
			end
		end
	end

	read_vol.vbv_parameters1: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		if (vol_control_parameters) then	
			if (vbv_parameters) then	
				vld_u_name(  15, fifo, res, "latter_half_bit_rate                           ");
				vld_u_name(  1, fifo, res, "marker_bit                           ");
				vld_u_name(  15, fifo, res, "first_half_vbv_buffer_size                           ");
				vld_u_name(  1, fifo, res, "marker_bit                           ");
				vld_u_name(  3, fifo, res, "latter_half_vbv_buffer_size                           ");
				vld_u_name(  11, fifo, res, "first_half_vbv_occupancy                           ");
				vld_u_name(  1, fifo, res, "marker_bit                           ");
			end
		end
	end

	read_vol.vbv_parameters2: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		if (vol_control_parameters) then	
			if (vbv_parameters) then	
				vld_u_name(  15, fifo, res, "latter_half_vbv_occupancy                           ");
				vld_u_name(  1, fifo, res, "marker_bit                           ");
			end
		end	
	end

	read_vol.video_object_layer_shape: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1],
		bool fixed_vop_rate,
	    uint(size=16) vop_time_increment_resolution
	do
		vld_u_name(  2, fifo, res, "video_object_layer_shape                           ");
		vld_u_name(  1, fifo, res, "marker_bit                           ");
		vld_u_name(  16, fifo, res, "vop_time_increment_resolution                           ");
		vop_time_increment_resolution := res[0]; 
	    log2bin(vop_time_increment_resolution-1, res);
	    vop_time_increment_resolution_bits :=  if res[0] > 1 then res[0] else 1 end;
		vld_u_name(  1, fifo, res, "marker_bit                           ");
		vld_u_name(  1, fifo, res, "fixed_vop_rate                           ");
		fixed_vop_rate := res[0]=1;
		if (fixed_vop_rate) then	
			vld_u_name(  1, fifo, res, "vop_time_increment_resolution_bits                           ");
		end
		vld_u_name(  1, fifo, res, "marker_bit                           ");
		vld_u_name(  13, fifo, res, "video_object_layer_width                           ");
		vld_u_name(  1, fifo, res, "marker_bit                           ");
		vld_u_name(  13, fifo, res, "video_object_layer_height                           ");
		vld_u_name(  1, fifo, res, "interlaced                           ");
		vld_u_name(  1, fifo, res, "obmc_disable                           ");
		vld_u_name(  1, fifo, res, "sprite_enable                           ");
		vld_u_name(  1, fifo, res, "not_8_bit                           ");
		vld_u_name(  1, fifo, res, "quant_type                           ");
		vld_u_name(  1, fifo, res, "complexity_estimation_disable                           ");
		vld_u_name(  1, fifo, res, "resync_marker_disable                           ");
		vld_u_name(  1, fifo, res, "data_partitioned                           ");
		vld_u_name(  1, fifo, res, "scalability                           ");
	end

	/**************************************************************************
	 * VOP
	 *************************************************************************/
	uint(size=2) vop_coding_type;
	bool vop_coded;
	bool round;
	int BITS_QUANT                      = 5;
	int(size=BITS_QUANT+1) vop_quant;
	int(size=BITS_QUANT+1) prev_quant;
	int(size=7) intra_dc_threshold_table[8] = [ 32, 13, 15, 17, 19, 21, 23, 1];
	int(size=7) intra_dc_vlc_thr;
	int VOP_FCODE_FOR_LENGTH            = 3;
	int(size=VOP_FCODE_FOR_LENGTH+1) fcode;
	

	read_vop : action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1]
	do
		vld_u_name(  2, fifo, res, "vop_coding_type                           ");
		vop_coding_type := res[0];
	end

	int B_VOP                           = 2;
	int P_VOP                           = 1;
	int I_VOP                           = 0;
	
	read_vop_coding_type.supported : action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		vop_coding_type = I_VOP or vop_coding_type = P_VOP
	var
		int(size=32) res[1],
		bool modulo_time_base := true,
		int time_incr := 0
	do
		if vop_coding_type = I_VOP then println("I_VOP"); else println("P_VOP"); end 
		while(modulo_time_base) do
			vld_u_name(  1, fifo, res, "modulo_time_base                           ");
			modulo_time_base := res[0]=1;
			time_incr := time_incr + 1;
		end
		vld_u_name(  1, fifo, res, "marker_bit                           ");
		vld_u_name(  vop_time_increment_resolution_bits, fifo, res, "vop_time_increment                           ");
		vld_u_name(  1, fifo, res, "marker_bit                           ");
		vld_u_name(  1, fifo, res, "vop_coded                           ");
		vop_coded:=res[0]=1;
	end

	read_vop_coding_type.unsupported : action ==>
	guard
		vop_coding_type != I_VOP, vop_coding_type != P_VOP
	do
		println("unsupported");
	end
	
	read_vop_coded.coded:action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		vop_coded
	var
		int(size=32) res[1]
	do
		if vop_coding_type = P_VOP then
			vld_u_name(  1, fifo, res, "vop_rounding_type                           ");
			round := res[0] = 1;
		else
			round:= false;
		end
		vld_u_name(  3, fifo, res, "intra_dc_vlc_thr                           ");
		intra_dc_vlc_thr := intra_dc_threshold_table[res[0]];
		vld_u_name(  5, fifo, res, "vop_quant                           ");
		vop_quant := res[0];
		prev_quant:=vop_quant;
 		if (vop_coding_type != I_VOP) then
			vld_u_name(  3, fifo, res, "vop_fcode_forward                           ");
			fcode := res[0];
		else
			fcode := 0;
		end
 		if (vop_coding_type = B_VOP) then
			vld_u_name(  3, fifo, res, "vop_fcode_backward                           ");
		end
	end
	
	read_vop_coded.uncoded:action ==>
	guard
		not vop_coded
	do
	// TODO: the model does not communicate to the display driver
    // to re-use the current VOP in place of the uncoded one.
	
	end
	/**************************************************************************
	 * MB
	 *************************************************************************/

	 
	 int(size=8) derived_mb_type;
	 int(size=3) cbpc;
	 bool is_intra;
	 bool btype_is_Q;

	int(size=8) mcbpc_intra_table[64][2] = [
		[-1, 0], [20, 6], [36, 6], [52, 6], [4, 4],  [4, 4],  [4, 4],  [4, 4],
		[19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 3],
		[35, 3], [35, 3], [35, 3], [35, 3], [35, 3], [35, 3], [35, 3], [35, 3],
		[51, 3], [51, 3], [51, 3], [51, 3], [51, 3], [51, 3], [51, 3], [51, 3],
		[3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],
		[3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],
		[3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],
		[3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1],  [3, 1]
	];
		
	int(size=8) mcbpc_inter_table[257][2] = [
		[VLC_ERROR, 0], [255, 9], [52, 9], [36, 9], [20, 9], [49, 9], [35, 8], [35, 8],
		[19, 8], [19, 8], [50, 8], [50, 8], [51, 7], [51, 7], [51, 7], [51, 7],
		[34, 7], [34, 7], [34, 7], [34, 7], [18, 7], [18, 7], [18, 7], [18, 7],
		[33, 7], [33, 7], [33, 7], [33, 7], [17, 7], [17, 7], [17, 7], [17, 7],
		[4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6],
		[48, 6], [48, 6], [48, 6], [48, 6], [48, 6], [48, 6], [48, 6], [48, 6],
		[3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5],
		[3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5],
		[32, 4], [32, 4], [32, 4], [32, 4], [32, 4], [32, 4], [32, 4], [32, 4],
		[32, 4], [32, 4], [32, 4], [32, 4], [32, 4], [32, 4], [32, 4], [32, 4],
		[32, 4], [32, 4], [32, 4], [32, 4], [32, 4], [32, 4], [32, 4], [32, 4],
		[32, 4], [32, 4], [32, 4], [32, 4], [32, 4], [32, 4], [32, 4], [32, 4],
		[16, 4], [16, 4], [16, 4], [16, 4], [16, 4], [16, 4], [16, 4], [16, 4],
		[16, 4], [16, 4], [16, 4], [16, 4], [16, 4], [16, 4], [16, 4], [16, 4],
		[16, 4], [16, 4], [16, 4], [16, 4], [16, 4], [16, 4], [16, 4], [16, 4],
		[16, 4], [16, 4], [16, 4], [16, 4], [16, 4], [16, 4], [16, 4], [16, 4],
		[2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3],
		[2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3],
		[2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3],
		[2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3],
		[2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3],
		[2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3],
		[2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3],
		[2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3],
		[1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3],
		[1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3],
		[1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3],
		[1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3],
		[1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3],
		[1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3],
		[1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3],
		[1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3],
		[0, 1]
	];
	
	int(size=8) cbpy_table[64][2] = [
		[-1, 0], [-1, 0], [6, 6],  [9, 6],  [8, 5],  [8, 5],  [4, 5],  [4, 5],
		[2, 5],  [2, 5],  [1, 5],  [1, 5],  [0, 4],  [0, 4],  [0, 4],  [0, 4],
		[12, 4], [12, 4], [12, 4], [12, 4], [10, 4], [10, 4], [10, 4], [10, 4],
		[14, 4], [14, 4], [14, 4], [14, 4], [5, 4],  [5, 4],  [5, 4],  [5, 4],
		[13, 4], [13, 4], [13, 4], [13, 4], [3, 4],  [3, 4],  [3, 4],  [3, 4],
		[11, 4], [11, 4], [11, 4], [11, 4], [7, 4],  [7, 4],  [7, 4],  [7, 4],
		[15, 2], [15, 2], [15, 2], [15, 2], [15, 2], [15, 2], [15, 2], [15, 2],
		[15, 2], [15, 2], [15, 2], [15, 2], [15, 2], [15, 2], [15, 2], [15, 2]
	];

	procedure get_mcbpc(int(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
	 						  int(size=32) res[1],String name)
	var 
		int index
	begin
	  	if (vop_coding_type = I_VOP) then
		  	showBits(9, fifo, res);  		
		
			index := res[0];
			index := index >> 3;
			flushBits(mcbpc_intra_table[index][1], fifo); 
			
		
			res[0] := mcbpc_intra_table[index][0];
		
			if DEBUG_PARSER then
				println("          "+name+" vld : "+res[0]);
			end
		else
			showBits(9, fifo, res);
			index := if res[0] < 256 then res[0] else 256 end;
			flushBits(mcbpc_inter_table[index][1], fifo); 
			res[0] := mcbpc_inter_table[index][0];
			if DEBUG_PARSER then
				println("          "+name+" vld : "+res[0]);
			end
		end
	end
	
	procedure get_cbpy(int(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
	 						  int(size=32) res[1],String name, bool intra)
	var 
		int index
	begin
		showBits(6, fifo, res);
		index := res[0];
		flushBits(cbpy_table[index][1], fifo); 
		res[0] := cbpy_table[index][0];

		if (not intra) then
			res[0] := 15 - res[0];
		end
		if DEBUG_PARSER then
			println("          "+name+" vld : "+res[0]);
		end
	end
	
	int(size=3) dquant_table[4] = [ -1, -2, 1, 2 ];
	
	read_mb.start: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		bool not_coded,
		int(size=32) res[1]
	do
		if (vop_coding_type != I_VOP) then
			vld_u_name(  1, fifo, res, "not_coded                           ");
			not_coded := res[0] = 1;
		else
			not_coded := false;
		end
		if  not not_coded or vop_coding_type = I_VOP then
			get_mcbpc( fifo, res, "mcbpc                           ");
			derived_mb_type := res[0] & 7;
			cbpc := (res[0] >> 4);
			is_intra := (derived_mb_type = 3 || derived_mb_type = 4);
			btype_is_Q := (derived_mb_type = 1 || derived_mb_type = 4);
			if (is_intra) then
				vld_u_name(  1, fifo, res, "ac_pred_flag                           ");
			end
			get_cbpy( fifo, res, "cbpy                           ", is_intra);
			prev_quant:=vop_quant;	
			if  (btype_is_Q) then
				vld_u_name(  2, fifo, res, "dquant                           ");
				vop_quant:=vop_quant+dquant_table[res[0]];
		 	    if ( vop_quant > 31 ) then 
		            vop_quant := 31 ;
				end
		        if ( vop_quant < 1 ) then
		            vop_quant := 1 ;
				end
			end
		end
	end
	/**************************************************************************
	 * Block
	 *************************************************************************/
	int (size=4) cmp;
	bool last;
	int(size=8) run;
	int(size=8) level;
	int ESCAPE=3;
	
	int(size=3) dc_lum_tab[8][2] :=[	[0, 0], [4, 3], [3, 3], [0, 3],
		[2, 2], [2, 2], [1, 2], [1, 2]
	];
	
	procedure get_dc_dif(int(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		 						  int(size=32) res[1],String name, int(size=16) dc_size)
	var
		int msb
	begin
		vld_u(  dc_size, fifo, res);
		msb := res[0] >> (dc_size - 1);
	
		if (msb = 0) then
			res[0] := -1 * (res[0] ^ ((1 << dc_size) - 1));
		end
		if DEBUG_PARSER then
			println("          "+name+" vld : "+res[0]);
		end
	end
	
	procedure get_dc_size_lum(int(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		 						  int(size=32) res[1],String name)
	var 
		int code,
		int val
	begin
		showBits(11, fifo, res);
		code := res[0];
		val := 11;
		while (val > 3) do
			if (res[0] = 1) then
				flushBits(val, fifo); 
				val := 0;
			else
				code := code >> 1;
				val := val - 1;
			end
		end
	
		if val = 0 then
			res[0] := val + 1; 
		else
			flushBits(dc_lum_tab[code][1], fifo); 
			res[0] := dc_lum_tab[code][0];
		end
		if DEBUG_PARSER then
			println("          "+name+" vld : "+res[0]);
		end
	
	end


	read_block.start: action ==>
	do
		cmp:=0;
	end

	read_block_dc: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var
		int(size=32) res[1],
		int dc_size,
		int dc_dif
	do
		last:=false;
		if is_intra then
			if prev_quant < intra_dc_vlc_thr then
				if cmp < 4  then 
					get_dc_size_lum( fifo, res,"dc_size                ");
					dc_size := res[0];
				else
					//get_dc_size_chrom( fifo, res,"dc_size                ");
					//dc_size := res[0];
				end
	      		if dc_size > 0  then 
	      			get_dc_dif( fifo, res,"dc_dif                ", dc_size);
		      		dc_dif := res[0];
		      	else 
		      		dc_dif := 0; 
		      	end
      			if dc_size > 8 then
					vld_u_name(  1, fifo, res, "marker_bit                           ");
      			end
			end
		end
			
	end
	
	function GET_BITS(int cache, int n) --> int : ((cache)>>(32-(n))) end
	read_block_coeff: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	var 
		uint res[1]
	do
		get_coeff(fifo, res, "get_coeff            ", is_intra);
	end

	read_block_coeff_done: action ==>
	guard last	
	end

	procedure get_coeff(int(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		 						  uint(size=32) res[1],String name, bool is_intra)
	var 
		uint cache,
		uint(size=1) intra = if is_intra then 1 else 0 end,
		int skip[3] = [1, 1, 2],
		int mode
	begin
		showBits(32, fifo, res);
		cache := res[0];
		if (GET_BITS(cache, 7) != ESCAPE) then
			last := DCT3D[intra][GET_BITS(cache, 12)][1] = 1;
			run  := DCT3D[intra][GET_BITS(cache, 12)][2];
			level := DCT3D[intra][GET_BITS(cache, 12)][3];
			flushBits(DCT3D[intra][GET_BITS(cache, 12)][0] + 1, fifo);
			level := if ((GET_BITS(cache, DCT3D[intra][GET_BITS(cache, 12)][0] + 1) & 1) = 1) then -level else level end;
		else
			cache := cache << 7;
			mode := GET_BITS(cache, 2);
			if (mode < 3) then
				cache := cache << skip[mode];
		
				last := DCT3D[intra][GET_BITS(cache, 12)][1] = 1;
				run  := DCT3D[intra][GET_BITS(cache, 12)][2];
				level := DCT3D[intra][GET_BITS(cache, 12)][3];
				if (mode < 2) then
					level := level + max_level[intra][if last then 1 else 0 end][run];
				else
					run := run +  max_run[intra][if last then 1 else 0 end][level] + 1;
				end
				
				flushBits(DCT3D[intra][7 + skip[mode] + GET_BITS(cache, 12)][0] + 1, fifo);
		
				level := if ((GET_BITS(cache, DCT3D[intra][GET_BITS(cache, 12)][0] + 1) & 1) = 1) then -level else level end;
			else
		
				cache := cache << 2;
				last :=  GET_BITS(cache, 1) = 1;
				run  := (GET_BITS(cache, 7)&0x3f);
				level := (GET_BITS(cache, 20)&0xfff);
			
				flushBits(30, fifo);
		
				level := level << 20 >> 20;
			end

		end
		if DEBUG_PARSER then
			println("          "+name+" run : "+ run+" level : "+ level+" last : "+ last);
		end
	end

	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		not IsStartCode(fifo)
   	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then		
  			println("start_code.search");
   		end
	end
	start_code.done: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3,
		IsStartCode(fifo)
	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then
			println("start_code.done");
		end
	end

	byte_align_a: action ==>
	guard
		fifo[FIFO_CPT_BITS] >= (FIFO_SIZE-1)<<3
	do
		byte_align(fifo);
	end
	
	/**************************************************************************
	 **************************************************************************
	 ********        undefined                            *********************
	 **************************************************************************
	 *************************************************************************/
  	bool actorNotFinished := true;
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("Algo_Parser doesn't manage this case yet");
		actorNotFinished := false;
	end
	
	
//********************************************************************************************************************************** 
	schedule fsm look_for_Sequence_Header :
		look_for_Sequence_Header						( look_for_Sequence_Header							) --> byte_align_a;

	    // FIXME: add minimal error resilience.
	    // byte align, then look for a starting on any byte boundary.
	    // is hex 00000100.
	    byte_align_a    ( byte_align_a    ) --> search_start_code;
	
		// search start code
		search_start_code          			( start_code.search					    ) --> search_start_code;
		search_start_code			            ( start_code.done					) --> read_start_code;
	    

		// read start code
		read_start_code							( read_start_code								) --> find_header;
		//
		find_header	  									( look_for_other_header						) --> look_for_Sequence_Header;
		find_header	  									( look_for.vol	  							) --> read_vol;
		find_header	  									( look_for.vop	  							) --> read_vop;

		// vol
		read_vol ( read_vol.start ) --> read_vol_vbv_parameters;
		read_vol_vbv_parameters ( read_vol.vbv_parameters1 ) --> read_vol_vbv_parameters2;
		read_vol_vbv_parameters2 ( read_vol.vbv_parameters2 ) --> read_vol_video_object_layer_shape;
		read_vol_video_object_layer_shape ( read_vol.video_object_layer_shape ) --> look_for_Sequence_Header;

		// vop
		read_vop ( read_vop ) --> read_vop_coding_type;
		read_vop_coding_type ( read_vop_coding_type.supported ) --> read_vop_coded;
		read_vop_coding_type ( read_vop_coding_type.unsupported ) --> look_for_Sequence_Header;
		read_vop_coded (read_vop_coded.coded ) --> read_mb;
		read_vop_coded (read_vop_coded.uncoded ) --> look_for_Sequence_Header;
		
		// start MB
		read_mb (read_mb.start) --> read_block;
		
		// start block
		read_block (read_block.start) --> read_block_dc;
		read_block_dc (read_block_dc) --> read_block_coeff;
		read_block_coeff (read_block_coeff) --> read_block_coeff;
		read_block_coeff (read_block_coeff_done) --> look_for_Sequence_Header;
		// undefined
		undefined	  					( undefined		    				) --> undefined;

	end

	priority
		look_for > look_for_other_header;
		read_block_coeff_done > read_block_coeff;
	end

end
