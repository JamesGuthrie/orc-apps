package org.ietr.mpegh.part2.main.intra;
import std.util.Math.*;

unit  IntraFunctions :

	procedure intraPlanarPred0(uint(size=8) src[64 * 64], uint(size=8) top[129] , uint(size=8) left [129], 
		int  stride)
	begin
		foreach uint y in 0 .. 4-1
		do
			foreach uint x in 0 .. 4-1
			do
				src[x + y * stride] := ((3 - x) * left[y + 1] + (x + 1) * top[5] + (3 - y) * top[x + 1]  + (y + 1) * left[5] + 4) >> 3;
			end
		end
	end
	
	procedure intraPlanarPred1(uint(size=8) src[64 * 64], uint(size=8) top[129] , uint(size=8) left [129], 
		int  stride)
	begin
		foreach uint y in 0 .. 8-1
		do
			foreach uint x in 0 .. 8-1
			do
				src[x + y * stride] := ((7 - x) * left[y + 1] + (x + 1) * top[9] + (7 - y) * top[x + 1]  + (y + 1) * left[9] + 8) >> 4;
			end
		end
	end
	
	procedure intraPlanarPred2(uint(size=8) src[64 * 64], uint(size=8) top[129] , uint(size=8) left [129], 
		int  stride)
	begin
		foreach uint y in 0 .. 16-1
		do
			foreach uint x in 0 .. 16-1
			do
				src[x + y * stride] := ((15 - x) * left[y + 1] + (x + 1) * top[17]  + (15 - y) * top[x + 1]  + (y + 1) * left[17] + 16) >> 5;
			end
		end
	end
	
	procedure intraPlanarPred3(uint(size=8) src[64 * 64], uint(size=8) top[129] , uint(size=8) left [129], 
		int  stride)
	begin
		foreach uint y in 0 .. 32-1
		do
			foreach uint x in 0 .. 32-1
			do
				src[x + y * stride] := ((31 - x) * left[y + 1] + (x + 1) * top[33]  + (31 - y) * top[x + 1]  + (y + 1) * left[33] + 32) >> 6;
			end
		end
	end
	
//	procedure intraPlanarPred_generic(uint(size=8) src[64 * 64], uint(size=8) top[129] , uint(size=8) left [129], 
//		int  stride, int trafoSize)
//	var
//		int size_ := 1 << trafoSize
//	begin
//		foreach uint y in 0 .. size_-1
//		do
//			foreach uint x in 0 .. size_-1
//			do
//				src[x + y * stride] := ((size_ - 1 - x) * left[y + 1] + (x + 1) * top[size_ + 1] + (size_ - 1 - y) * top[x + 1]  + (y + 1) * left[size_ + 1] + size_) >> (trafoSize + 1);
//			end
//		end
//	end
	
//////////////////////////////////////////////////OldProc//////////////////////////////////////////////////////
//	procedure intraAngularPred_(uint(size=7) nS)
//	var
//		uint(size=6) OFFSET = 33,
//		uint(size=6) angle := predMode & 63,
//		uint(size=8) refMain[128+33],
//		int(size=9) iIdx,
//		uint(size=5) iFact
//	begin
//		if(angle>=18) then 
//			refMain[OFFSET] := pNeighb_above[0];
//			foreach uint x in 1 .. nS
//			do
//				refMain[x+OFFSET] := pNeighb_above[x-1+1];
//			end
//			if(intraPredAngle[angle]<0) then
//				foreach int k in (nS*intraPredAngle[angle])>>5 .. -1
//				do
//					refMain[k+OFFSET] :=
//						pNeighb_left[((k*invAngle[angle]+128)>>8)-1+1];
//				end
//			else
//				foreach uint x in nS+1 .. 2*nS
//				do
//					refMain[x+OFFSET] := pNeighb_above[x-1+1];
//				end
//			end
//		else  
//			refMain[OFFSET] := pNeighb_above[0];
//			foreach uint x in 1 .. nS
//			do
//				refMain[x+OFFSET] := pNeighb_left[x-1+1];
//			end
//			if(intraPredAngle[angle]<0) then
//				foreach int k in (nS*intraPredAngle[angle])>>5 .. -1
//				do
//					refMain[k+OFFSET] :=
//						pNeighb_above[((k*invAngle[angle]+128)>>8)-1+1];
//				end
//			else
//				foreach uint x in nS+1 .. 2*nS
//				do
//					refMain[x+OFFSET] := pNeighb_left[x-1+1];
//				end
//			end
//		end
//		if(angle>=18) then
//			foreach uint y in 0 .. nS-1
//			do
//				iIdx  := ((y+1)*intraPredAngle[angle])>>5;
//				iFact := ((y+1)*intraPredAngle[angle])&31;
//				foreach uint x in 0 .. nS-1
//				do
//					if(iFact!=0) then
//						lumaComp[x + y * 64] :=
//							((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
//							iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
//					else
//						lumaComp[x + y * 64] := refMain[x+iIdx+1 +OFFSET];
//					end
//				end
//			end
//		else
//			foreach uint y in 0 .. nS-1
//			do
//				iIdx  := ((y+1)*intraPredAngle[angle])>>5;
//				iFact := ((y+1)*intraPredAngle[angle])&31;
//				foreach uint x in 0 .. nS-1
//				do
//					if(iFact!=0) then
//						lumaComp[y + x * 64] :=
//							((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
//							iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
//					else
//						lumaComp[y + x * 64] := refMain[x+iIdx+1 +OFFSET];
//					end
//				end
//			end
//		end
//	end
//	


//////////////////////////////////////////////////NewProc//////////////////////////////////////////////////////
//if(predMode>=18) then 
//			refMain[OFFSET] := pNeighb_above[0];
//			if angle < 0 and last < -1 then
//				foreach int x in 1 .. size_
//				do
//					refMain[x+OFFSET] := pNeighb_above[x-1+1];
//				end
//				foreach int m in 0 .. last + 1 do
//					x_ := last; 
//            		refMain[x_+OFFSET] := pNeighb_left[-1 + ((x_ * invAngle[predMode - 11] + 128) >> 8)];
//            		x_ := x_ - 1;
//            	end
//			end
//			foreach uint y in 0 .. size_-1
//			do
//				iIdx  := ((y+1)*angle)>>5;
//				iFact := ((y+1)*angle)&31;
//				if(iFact!=0) then
//					foreach uint x in 0 .. size_-1
//					do
//						lumaComp[x + y * 64] := ((32-iFact)*refMain[x+iIdx+1 +OFFSET] + iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
//					end
//				else 
//					foreach uint x in 0 .. size_-1 
//					do
//						lumaComp[x + y * 64] := refMain[x+iIdx+1 +OFFSET];
//					end
//				end
//			end
//			if (predMode = 26 ) then
//				foreach uint y in 0 .. size_-1
//				do
//					lumaComp[y * 64] := clip_i32(pNeighb_above[0+1] + ((pNeighb_left[y+1]-pNeighb_left[0])>>1), 0, 255);
//				end
//			end
//		else  
//			refMain[OFFSET] := pNeighb_above[0];
//			if angle < 0 and last < -1 then
//				foreach int x in 1 .. size_
//				do
//					refMain[x+OFFSET] := pNeighb_above[x-1+1];
//				end
//				foreach int m in 0 .. last + 1 do
//					x_ := last; 
//            		refMain[x_+OFFSET] := pNeighb_above[-1 + ((x_ * invAngle[predMode - 11] + 128) >> 8)];
//            		x_ := x_ - 1;
//            	end
//			end
//			foreach uint x in 0 .. size_ - 1
//			do
//				iIdx  := ((x+1)*angle)>>5;
//				iFact := ((x+1)*angle)&31;
//				
//					if(iFact!=0) then
//						foreach uint y in 0 .. size_-1
//						do
//						lumaComp[x + y * 64] :=
//							((32-iFact)*refMain[y+iIdx+1 +OFFSET] +
//							iFact*refMain[y+iIdx+2 +OFFSET]+16) >> 5;
//						end
//					else
//						foreach uint y in 0 .. size_-1
//						do
//							lumaComp[x + y * 64] := refMain[y+iIdx+1 +OFFSET];
//						end
//					end
//				end
//			end
//			if (predMode = 10 ) then
//				foreach uint x in 0 .. size_-1
//				do
//					lumaComp[x] := clip_i32(pNeighb_left[0+1] + ((pNeighb_above[x+1]-pNeighb_above[0])>>1), 0, 255);
//				end
//			end	
//		end		
	

end