package org.ietr.mpegh.part2.main.intra;
import std.util.Math.*;

unit  IntraFunctions :
	
	int(size=7) intraPredAngle[64] = [0, 0, 32, 26, 21, 17, 13, 9, 5, 2, 0, -2,
	-5, -9, -13, -17, -21, -26, -32, -26, -21, -17, -13, -9, -5, -2, 0, 2, 5,
	9, 13, 17, 21, 26, 32];

	int(size=16) invAngle[64] =
	[  0,     0,  -256, -315,  -390,  -482, -630,  -910, -1638, -4096,
	   0, -4096, -1638, -910,  -630,  -482, -390,  -315,  -256,  -315,
	-390,  -482,  -630, -910, -1638, -4096,    0, -4096, -1638,  -910,
	-630,  -482,  -390, -315,  -256];
	
	@optimize_c(condition="OPEN_HEVC_ENABLE", name="pred_planar_0_8_sse")
	procedure intraPlanarPred0(uint(size=8) src[64 * 64], uint(size=8) top[129] , uint(size=8) left [129], 
		int  stride)
	begin
		foreach uint y in 0 .. 4-1
		do
			foreach uint x in 0 .. 4-1
			do
				src[x + y * stride] := ((3 - x) * left[y + 1] + (x + 1) * top[5] + (3 - y) * top[x + 1]  + (y + 1) * left[5] + 4) >> 3;
			end
		end
	end
	
	@optimize_c(condition="OPEN_HEVC_ENABLE", name="pred_planar_1_8_sse")
	procedure intraPlanarPred1(uint(size=8) src[64 * 64], uint(size=8) top[129] , uint(size=8) left [129], 
		int  stride)
	begin
		foreach uint y in 0 .. 8-1
		do
			foreach uint x in 0 .. 8-1
			do
				src[x + y * stride] := ((7 - x) * left[y + 1] + (x + 1) * top[9] + (7 - y) * top[x + 1]  + (y + 1) * left[9] + 8) >> 4;
			end
		end
	end
	@optimize_c(condition="OPEN_HEVC_ENABLE", name="pred_planar_2_8_sse")
	procedure intraPlanarPred2(uint(size=8) src[64 * 64], uint(size=8) top[129] , uint(size=8) left [129], 
		int  stride)
	begin
		foreach uint y in 0 .. 16-1
		do
			foreach uint x in 0 .. 16-1
			do
				src[x + y * stride] := ((15 - x) * left[y + 1] + (x + 1) * top[17]  + (15 - y) * top[x + 1]  + (y + 1) * left[17] + 16) >> 5;
			end
		end
	end
	
	@optimize_c(condition="OPEN_HEVC_ENABLE", name="pred_planar_3_8_sse")
	procedure intraPlanarPred3(uint(size=8) src[64 * 64], uint(size=8) top[129] , uint(size=8) left [129], 
		int  stride)
	begin
		foreach uint y in 0 .. 32-1
		do
			foreach uint x in 0 .. 32-1
			do
				src[x + y * stride] := ((31 - x) * left[y + 1] + (x + 1) * top[33]  + (31 - y) * top[x + 1]  + (y + 1) * left[33] + 32) >> 6;
			end
		end
	end
	
	@optimize_c(condition="OPEN_HEVC_ENABLE", name="pred_angular_0_8_sse")
	procedure intraAngularPred0(uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int stride, int idx, uint(size=8)mode, int _size)
	var
		uint(size=6) OFFSET = 33,
		uint(size=6) angle := mode & 63,
		uint(size=8) refMain[128+33],
		int(size=9) iIdx,
		uint(size=5) iFact
	begin
		if(angle=26 || angle = 10) then
			intraAngularVertOrHor(angle=26,lumaComp, pNeighb_above, pNeighb_left, _size);
		else
			/* Implementation of Intra_Angular(2..9,11..25,27..34) prediction
			 * mode.
			 */
			if(angle>=18) then 
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. _size
				do
					refMain[x+OFFSET] := pNeighb_above[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (_size*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_left[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in _size+1 .. 2*_size
					do
						refMain[x+OFFSET] := pNeighb_above[x-1+1];
					end
				end
			else  
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. _size
				do
					refMain[x+OFFSET] := pNeighb_left[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (_size*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_above[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in _size+1 .. 2*_size
					do
						refMain[x+OFFSET] := pNeighb_left[x-1+1];
					end
				end
			end
			if(angle>=18) then
				foreach uint y in 0 .. _size-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. _size-1
					do
						if(iFact!=0) then
							lumaComp[x + y * 64] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[x + y * 64] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			else
				foreach uint y in 0 .. _size-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. _size-1
					do
						if(iFact!=0) then
							lumaComp[y + x * 64] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[y + x * 64] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			end
		end
	end
	
	@optimize_c(condition="OPEN_HEVC_ENABLE", name="pred_angular_1_8_sse")
	procedure intraAngularPred1(uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int stride, int idx, uint(size=8)mode, int _size)
	var
		uint(size=6) OFFSET = 33,
		uint(size=6) angle := mode & 63,
		uint(size=8) refMain[128+33],
		int(size=9) iIdx,
		uint(size=5) iFact
	begin
		if(angle=26 || angle = 10) then
			intraAngularVertOrHor(angle=26,lumaComp, pNeighb_above, pNeighb_left, _size);
		else
			/* Implementation of Intra_Angular(2..9,11..25,27..34) prediction
			 * mode.
			 */
			if(angle>=18) then 
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. _size
				do
					refMain[x+OFFSET] := pNeighb_above[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (_size*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_left[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in _size+1 .. 2*_size
					do
						refMain[x+OFFSET] := pNeighb_above[x-1+1];
					end
				end
			else  
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. _size
				do
					refMain[x+OFFSET] := pNeighb_left[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (_size*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_above[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in _size+1 .. 2*_size
					do
						refMain[x+OFFSET] := pNeighb_left[x-1+1];
					end
				end
			end
			if(angle>=18) then
				foreach uint y in 0 .. _size-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. _size-1
					do
						if(iFact!=0) then
							lumaComp[x + y * 64] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[x + y * 64] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			else
				foreach uint y in 0 .. _size-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. _size-1
					do
						if(iFact!=0) then
							lumaComp[y + x * 64] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[y + x * 64] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			end
		end
	end
	
	@optimize_c(condition="OPEN_HEVC_ENABLE", name="pred_angular_2_8_sse")
	procedure intraAngularPred2(uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int stride, int idx, uint(size=8)mode, int _size)
	var
		uint(size=6) OFFSET = 33,
		uint(size=6) angle := mode & 63,
		uint(size=8) refMain[128+33],
		int(size=9) iIdx,
		uint(size=5) iFact
	begin
		if(angle=26 || angle = 10) then
			intraAngularVertOrHor(angle=26,lumaComp, pNeighb_above, pNeighb_left, _size);
		else
			/* Implementation of Intra_Angular(2..9,11..25,27..34) prediction
			 * mode.
			 */
			if(angle>=18) then 
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. _size
				do
					refMain[x+OFFSET] := pNeighb_above[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (_size*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_left[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in _size+1 .. 2*_size
					do
						refMain[x+OFFSET] := pNeighb_above[x-1+1];
					end
				end
			else  
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. _size
				do
					refMain[x+OFFSET] := pNeighb_left[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (_size*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_above[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in _size+1 .. 2*_size
					do
						refMain[x+OFFSET] := pNeighb_left[x-1+1];
					end
				end
			end
			if(angle>=18) then
				foreach uint y in 0 .. _size-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. _size-1
					do
						if(iFact!=0) then
							lumaComp[x + y * 64] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[x + y * 64] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			else
				foreach uint y in 0 .. _size-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. _size-1
					do
						if(iFact!=0) then
							lumaComp[y + x * 64] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[y + x * 64] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			end
		end
	end
	
	@optimize_c(condition="OPEN_HEVC_ENABLE", name="pred_angular_3_8_sse")
	procedure intraAngularPred3(uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int stride, int idx, uint(size=8)mode, int _size)
	var
		uint(size=6) OFFSET = 33,
		uint(size=6) angle := mode & 63,
		uint(size=8) refMain[128+33],
		int(size=9) iIdx,
		uint(size=5) iFact
	begin
		if(angle=26 || angle = 10) then
			intraAngularVertOrHor(angle=26,lumaComp, pNeighb_above, pNeighb_left, _size);
		else
			/* Implementation of Intra_Angular(2..9,11..25,27..34) prediction
			 * mode.
			 */
			if(angle>=18) then 
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. _size
				do
					refMain[x+OFFSET] := pNeighb_above[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (_size*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_left[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in _size+1 .. 2*_size
					do
						refMain[x+OFFSET] := pNeighb_above[x-1+1];
					end
				end
			else  
				refMain[OFFSET] := pNeighb_above[0];
				foreach uint x in 1 .. _size
				do
					refMain[x+OFFSET] := pNeighb_left[x-1+1];
				end
				if(intraPredAngle[angle]<0) then
					foreach int k in (_size*intraPredAngle[angle])>>5 .. -1
					do
						refMain[k+OFFSET] :=
							pNeighb_above[((k*invAngle[angle]+128)>>8)-1+1];
					end
				else
					foreach uint x in _size+1 .. 2*_size
					do
						refMain[x+OFFSET] := pNeighb_left[x-1+1];
					end
				end
			end
			if(angle>=18) then
				foreach uint y in 0 .. _size-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. _size-1
					do
						if(iFact!=0) then
							lumaComp[x + y * 64] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[x + y * 64] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			else
				foreach uint y in 0 .. _size-1
				do
					iIdx  := ((y+1)*intraPredAngle[angle])>>5;
					iFact := ((y+1)*intraPredAngle[angle])&31;
					foreach uint x in 0 .. _size-1
					do
						if(iFact!=0) then
							lumaComp[y + x * 64] :=
								((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
								iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
						else
							lumaComp[y + x * 64] := refMain[x+iIdx+1 +OFFSET];
						end
					end
				end
			end
		end
	end

	/* Implementation of Intra_angular(10,26) prediction mode. */
	procedure intraAngularVertOrHor(bool isVertical, uint(size=8)lumaComp[4096], uint(size=8) pNeighb_above[129], uint(size=8) pNeighb_left[129], int _size)
	var
		uint(size=1) minVal
	begin
		minVal := if(_size>16) then 0 else 1 end;
		if(isVertical) then
			if(minVal!=0) then
				foreach uint y in 0 .. _size-1
				do
					lumaComp[y * 64] := clip_i32(pNeighb_above[0+1]+
						((pNeighb_left[y+1]-pNeighb_above[0])>>1), 0, 255);
				end
			end
			foreach uint x in minVal .. _size-1
			do
				foreach uint y in 0 .. _size-1
				do
					lumaComp[x + y * 64] := pNeighb_above[x+1];
				end
			end
		else
			if(minVal!=0) then
				foreach uint x in 0 .. _size-1
				do
					lumaComp[x] := clip_i32(pNeighb_left[0+1]+
						((pNeighb_above[x+1]-pNeighb_above[0])>>1), 0, 255);
				end
			end
			foreach uint x in 0 .. _size-1
			do
				foreach uint y in minVal .. _size-1
				do
					lumaComp[x + y * 64] := pNeighb_left[y+1];
				end
			end
		end
	end
	
	
//	procedure intraPlanarPred_generic(uint(size=8) src[64 * 64], uint(size=8) top[129] , uint(size=8) left [129], 
//		int  stride, int trafoSize)
//	var
//		int size_ := 1 << trafoSize
//	begin
//		foreach uint y in 0 .. size_-1
//		do
//			foreach uint x in 0 .. size_-1
//			do
//				src[x + y * stride] := ((size_ - 1 - x) * left[y + 1] + (x + 1) * top[size_ + 1] + (size_ - 1 - y) * top[x + 1]  + (y + 1) * left[size_ + 1] + size_) >> (trafoSize + 1);
//			end
//		end
//	end
	
//////////////////////////////////////////////////OldProc//////////////////////////////////////////////////////
//	procedure intraAngularPred_(uint(size=7) nS)
//	var
//		uint(size=6) OFFSET = 33,
//		uint(size=6) angle := predMode & 63,
//		uint(size=8) refMain[128+33],
//		int(size=9) iIdx,
//		uint(size=5) iFact
//	begin
//		if(angle>=18) then 
//			refMain[OFFSET] := pNeighb_above[0];
//			foreach uint x in 1 .. nS
//			do
//				refMain[x+OFFSET] := pNeighb_above[x-1+1];
//			end
//			if(intraPredAngle[angle]<0) then
//				foreach int k in (nS*intraPredAngle[angle])>>5 .. -1
//				do
//					refMain[k+OFFSET] :=
//						pNeighb_left[((k*invAngle[angle]+128)>>8)-1+1];
//				end
//			else
//				foreach uint x in nS+1 .. 2*nS
//				do
//					refMain[x+OFFSET] := pNeighb_above[x-1+1];
//				end
//			end
//		else  
//			refMain[OFFSET] := pNeighb_above[0];
//			foreach uint x in 1 .. nS
//			do
//				refMain[x+OFFSET] := pNeighb_left[x-1+1];
//			end
//			if(intraPredAngle[angle]<0) then
//				foreach int k in (nS*intraPredAngle[angle])>>5 .. -1
//				do
//					refMain[k+OFFSET] :=
//						pNeighb_above[((k*invAngle[angle]+128)>>8)-1+1];
//				end
//			else
//				foreach uint x in nS+1 .. 2*nS
//				do
//					refMain[x+OFFSET] := pNeighb_left[x-1+1];
//				end
//			end
//		end
//		if(angle>=18) then
//			foreach uint y in 0 .. nS-1
//			do
//				iIdx  := ((y+1)*intraPredAngle[angle])>>5;
//				iFact := ((y+1)*intraPredAngle[angle])&31;
//				foreach uint x in 0 .. nS-1
//				do
//					if(iFact!=0) then
//						lumaComp[x + y * 64] :=
//							((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
//							iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
//					else
//						lumaComp[x + y * 64] := refMain[x+iIdx+1 +OFFSET];
//					end
//				end
//			end
//		else
//			foreach uint y in 0 .. nS-1
//			do
//				iIdx  := ((y+1)*intraPredAngle[angle])>>5;
//				iFact := ((y+1)*intraPredAngle[angle])&31;
//				foreach uint x in 0 .. nS-1
//				do
//					if(iFact!=0) then
//						lumaComp[y + x * 64] :=
//							((32-iFact)*refMain[x+iIdx+1 +OFFSET] +
//							iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
//					else
//						lumaComp[y + x * 64] := refMain[x+iIdx+1 +OFFSET];
//					end
//				end
//			end
//		end
//	end
//	


//////////////////////////////////////////////////NewProc//////////////////////////////////////////////////////
//if(predMode>=18) then 
//			refMain[OFFSET] := pNeighb_above[0];
//			if angle < 0 and last < -1 then
//				foreach int x in 1 .. size_
//				do
//					refMain[x+OFFSET] := pNeighb_above[x-1+1];
//				end
//				foreach int m in 0 .. last + 1 do
//					x_ := last; 
//            		refMain[x_+OFFSET] := pNeighb_left[-1 + ((x_ * invAngle[predMode - 11] + 128) >> 8)];
//            		x_ := x_ - 1;
//            	end
//			end
//			foreach uint y in 0 .. size_-1
//			do
//				iIdx  := ((y+1)*angle)>>5;
//				iFact := ((y+1)*angle)&31;
//				if(iFact!=0) then
//					foreach uint x in 0 .. size_-1
//					do
//						lumaComp[x + y * 64] := ((32-iFact)*refMain[x+iIdx+1 +OFFSET] + iFact*refMain[x+iIdx+2 +OFFSET]+16) >> 5;
//					end
//				else 
//					foreach uint x in 0 .. size_-1 
//					do
//						lumaComp[x + y * 64] := refMain[x+iIdx+1 +OFFSET];
//					end
//				end
//			end
//			if (predMode = 26 ) then
//				foreach uint y in 0 .. size_-1
//				do
//					lumaComp[y * 64] := clip_i32(pNeighb_above[0+1] + ((pNeighb_left[y+1]-pNeighb_left[0])>>1), 0, 255);
//				end
//			end
//		else  
//			refMain[OFFSET] := pNeighb_above[0];
//			if angle < 0 and last < -1 then
//				foreach int x in 1 .. size_
//				do
//					refMain[x+OFFSET] := pNeighb_above[x-1+1];
//				end
//				foreach int m in 0 .. last + 1 do
//					x_ := last; 
//            		refMain[x_+OFFSET] := pNeighb_above[-1 + ((x_ * invAngle[predMode - 11] + 128) >> 8)];
//            		x_ := x_ - 1;
//            	end
//			end
//			foreach uint x in 0 .. size_ - 1
//			do
//				iIdx  := ((x+1)*angle)>>5;
//				iFact := ((x+1)*angle)&31;
//				
//					if(iFact!=0) then
//						foreach uint y in 0 .. size_-1
//						do
//						lumaComp[x + y * 64] :=
//							((32-iFact)*refMain[y+iIdx+1 +OFFSET] +
//							iFact*refMain[y+iIdx+2 +OFFSET]+16) >> 5;
//						end
//					else
//						foreach uint y in 0 .. size_-1
//						do
//							lumaComp[x + y * 64] := refMain[y+iIdx+1 +OFFSET];
//						end
//					end
//				end
//			end
//			if (predMode = 10 ) then
//				foreach uint x in 0 .. size_-1
//				do
//					lumaComp[x] := clip_i32(pNeighb_left[0+1] + ((pNeighb_above[x+1]-pNeighb_above[0])>>1), 0, 255);
//				end
//			end	
//		end		
	

end