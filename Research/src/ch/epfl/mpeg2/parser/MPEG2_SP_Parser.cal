/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
  
// Author: Cesar Laurent <cesar.laurent@epfl.ch>

package ch.epfl.mpeg2.parser;

import ch.epfl.mpeg2.parser.MPEG2_Tables.macroblock_address_increment_table;
import ch.epfl.mpeg2.parser.MPEG2_Tables.macroblock_type_table;

actor MPEG2_SP_Parser()
	uint(size=1) Bitstream
		==>
			:
			
	// ////////////////////////////////////////////////////////////////////////
	// State Variables
	
	// Start Code Values :
	uint(size=8)	PICTURE_START_CODE		= 0x00;
 	uint(size=8)	SLICE_BEGIN_START_CODE	= 0x01;
 	uint(size=8)	SLICE_END_START_CODE 	= 0xAF;
	uint(size=8)	USER_DATA_START_CODE 	= 0xB2;
	uint(size=8)	SEQUENCE_HEADER_CODE 	= 0xB3;
	uint(size=8)	SEQUENCE_ERROR_CODE 	= 0xB4;
	uint(size=8)	EXTENSION_START_CODE 	= 0xB5;
	uint(size=8)	SEQUENCE_END_CODE 		= 0xB7;
	uint(size=8)	 GROUP_START_CODE		= 0xB8;
	
	// Extension Start Code Identifier Values :
	uint(size=4)	SEQUENCE_EXTENSION_ID 					= 0x1;
	uint(size=4)	SEQUENCE_DISPLAY_EXTENSION_ID 			= 0x2;
	uint(size=4)	QUANT_MATRIX_EXTENSION_ID 				= 0x3;
	uint(size=4)	COPYRIGHT_EXTENSION_ID 					= 0x4;
	uint(size=4)	SEQUENCE_SCALABLE_EXTENSION_ID			= 0x5;
	uint(size=4)	PICTURE_DISPLAY_EXTENSION_ID 			= 0x7;
	uint(size=4)	PICTURE_CODING_EXTENSION_ID 			= 0x8;
	uint(size=4)	PICTURE_SPATIAL_SCALABLE_EXTENSION_ID 	= 0x9;
	uint(size=4)	PICTURE_TEMPORAL_SCALABLE_EXTENSION_ID	= 0xA;
	uint(size=4)	CAMERA_PARAMETERS_EXTENSION_ID 			= 0xB;
	uint(size=4)	ITUT_EXTENSION_ID 						= 0xC;
	
	// Nextbits and Buffer
	uint(size=32)	nextbits := 0;
	uint(size=1)	bit_buffer[1024];
	
	// Check if MPEG2 or ISO/IEC 11172-2 (MPEG1)
	bool	check_MPEG2 := false;
	
	// Video information
	uint(size=12) 	horizontal_size_value;
	uint(size=12)	vertical_size_value;
	uint(size=4) 	aspect_ration_information;
	uint(size=4) 	frame_rate_code;
	uint(size=18)	bit_rate_value;
	uint(size=10)	vbv_buffer_size_value;
	
	uint(size=8)	profile_and_level_indication;
	uint(size=1)	progressive_sequence;
	uint(size=2)	chroma_format;
	uint(size=2)	horizontal_size_extension;
	uint(size=2)	vertical_size_extension;
	uint(size=12)	bit_rate_extension;
	uint(size=8)	vbv_buffer_size_extension;
	uint(size=1)	low_delay;
	uint(size=2)	frame_rate_extension_n;
	uint(size=5)	frame_rate_extension_d;
		// Calculated values
		uint(size=14)	horizontal_size;
		uint(size=14)	vertical_size;
	
	// Sequence Display Extension
	uint(size=3)	video_format;
	uint(size=1)	colour_description;
	uint(size=8)	colour_primaries;
	uint(size=8)	transfer_characteristics;
	uint(size=8)	matrix_coefficients;
	uint(size=14)	display_horizontal_size;
	uint(size=14)	display_vertical_size;
		
	// Quantiser matrices
	uint(size=1)	load_intra_quantiser_matrix;
	uint(size=1)	load_non_intra_quantiser_matrix;
	uint(size=8)	intra_quantiser_matrix[64];
	uint(size=8)	non_intra_quantiser_matrix[64];
	
	// Extension and User Data
	uint(size=1)	eud_i;				// the i in extension_and_user_data(i). This variable is set in the action before any extension_and_user_data(i)
	uint(size=8)	user_data[512];
	uint(size=1)	ud_counter := 0;
	
	// Copyright Extension
	uint(size=1)	copyright_flag;
	uint(size=8)	copyright_identifier;
	uint(size=1)	original_or_copy;
	uint(size=7)	reserved;
	uint(size=20)	copyright_number_1;
	uint(size=22)	copyright_number_2;
	uint(size=22)	copyright_number_3;
	
	// Group of Pictures Header
	uint(size=25)	time_code;
	uint(size=1)	closed_gop;
	uint(size=1)	broken_link;
	
	// Picture Header
	uint(size=10)	temporal_reference;
	uint(size=3)	picture_coding_type;
	uint(size=16)	vbv_delay;
	uint(size=1)	full_pel_forward_vector;
	uint(size=4)	forward_f_code;
	uint(size=1)	full_pel_backward_vector;
	uint(size=4)	backward_f_code;
	uint(size=8)	extra_information_picture;
	uint(size=1)	extra_bit_picture;
	
	// Picture Coding Extension
	uint(size=4)	f_code00; 		// (forward horizontal) 
	uint(size=4)	f_code01;		// (forward vertical) 
	uint(size=4)	f_code10; 		// (backward horizontal) 
	uint(size=4)	f_code11; 		// (backward vertical) 
	uint(size=2)	intra_dc_precision;
	uint(size=2)	picture_structure;
	uint(size=1)	top_field_first;
	uint(size=1)	frame_pred_frame_dct;
	uint(size=1)	concealment_motion_vectors;
	uint(size=1)	q_scale_type;
	uint(size=1)	intra_vlc_format;
	uint(size=1)	alternate_scan;
	uint(size=1)	repeat_first_field;
	uint(size=1)	chroma_420_type;
	uint(size=1)	progressive_frame;
	uint(size=1)	composite_display_flag;
	
	uint(size=1)	v_axis;
	uint(size=3)	field_sequence;
	uint(size=1)	sub_carrier;
	uint(size=7)	burst_amplitude;
	uint(size=8)	sub_carrier_phase;
	
	// Slice
	uint(size=8)	slice_vertical_position; // It is given by the start code of the slice !
	uint(size=3)	slice_vertical_position_extension;
	uint(size=5)	quantiser_scale_code;
	uint(size=1)	slice_extension_flag;
	uint(size=1)	intra_slice;
	uint(size=1)	slice_picture_id_enable;
	uint(size=6)	slice_picture_id;
	uint(size=1)	extra_bit_slice;
	uint(size=8)	extra_information_slice;
	
	// Macroblock
	uint(size=8)	mb_macroblock_escape_counter := 0;	// To count the number of macroblock escape !
	uint(size=8)	mb_address_increment_vld_counter := 0; // To count the number of time we do the action
	uint(size=8)	macroblock_address_increment;
	uint(size=1)	mb_address_increment_flag := 0;	// Flag is set to 1 when the vlc is decoded
	
	uint(size=1)	mb_type_flag := 0;
	uint(size=8)	mb_type_vld_counter := 0;
	uint(size=1)	macroblock_quant;
	uint(size=1)	macroblock_motion_forward;
	uint(size=1)	macroblock_motion_backward;
	uint(size=1)	macroblock_pattern;
	uint(size=1)	macroblock_intra;
	uint(size=1)	spatial_temporal_weight_code_flag;
	
	uint(size=2)	frame_motion_type;
	uint(size=2)	field_motion_type;
	uint(size=1)	dct_type;
	
	
	
	// ////////////////////////////////////////////////////////////////////////
	// Functions / Procedures

	procedure compute_nextbits(int start, int stop)
	var
		uint(size=512) res := 0
	begin
		foreach int i in start .. stop do
			res := res << 1 | bit_buffer[i];
		end
		nextbits := res;
	end
	
	function test23zeros(uint(size=1) bit[24]) --> bool:
		bit[0]  = 0 and bit[1]  = 0 and bit[2]  = 0 and bit[3]  = 0 and
		bit[4]  = 0 and bit[5]  = 0 and bit[6]  = 0 and bit[7]  = 0 and
		bit[8]  = 0 and bit[9]  = 0 and bit[10] = 0 and bit[11] = 0 and
		bit[12] = 0 and bit[13] = 0 and bit[14] = 0 and bit[15] = 0 and
		bit[16] = 0 and bit[17] = 0 and bit[18] = 0 and bit[19] = 0 and
		bit[20] = 0 and bit[21] = 0 and bit[22] = 0
	end
		
	// ////////////////////////////////////////////////////////////////////////
	// Untagged Actions

	// ////////////////////////////////////////////////////////////////////////
	// Action
	
	// Start Code Actions
	
	start_code_prefix: action Bitstream: [token] repeat 24 ==>	// Check the 23 zeros of the start code prefix and put the 24th bit into nextbits
	guard
		test23zeros(token)
	do
		nextbits := token[23];
	end
	
	eat_stuffing_bit:action Bitstream: [token] ==>	// Eat stuffing bit when not byte aligned
	guard
		nextbits = 0
	do
		nextbits := token;
	end
	
	read_start_code: action Bitstream: [token] repeat 8 ==>	// Put start_code into nextbits
	guard
		nextbits = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 7];
		compute_nextbits(0, 7);
	end
	
	read_extension_start_code: action Bitstream: [token] repeat 4 ==>	// Put extension_start_code into nextbits
	guard
		nextbits = EXTENSION_START_CODE
	do
		bit_buffer := [token[i]: for int i in 0 .. 3];
		compute_nextbits(0, 3);
	end
		
	LOOK_FOLLOWING_BITS: action Bitstream: [token] repeat 128 ==>	// Debug tool
	do
		bit_buffer := [token[i]: for int i in 0 .. 127];
	end

	
	// Sequence Header
	
	sh_sequence_header: action Bitstream: [token] repeat 63 ==>
	guard
		nextbits = SEQUENCE_HEADER_CODE
	do
		bit_buffer := [token[i]: for int i in 0 .. 61];
		compute_nextbits(0, 11);
		horizontal_size_value := nextbits;
		compute_nextbits(12, 23);
		vertical_size_value := nextbits;
		compute_nextbits(24, 27);
		aspect_ration_information := nextbits;
		compute_nextbits(28, 31);
		frame_rate_code := nextbits;
		compute_nextbits(32 , 49);
		bit_rate_value := nextbits;
		compute_nextbits(50, 50);		// marker_bit
		compute_nextbits(51, 60);
		vbv_buffer_size_value := nextbits;
		compute_nextbits(61, 61);		// constrained_parameters_flag
		load_intra_quantiser_matrix := token[62];
	end
	
	sh_read_intra_quantiser_matrix: action Bitstream: [token] repeat 513 ==>
	guard
		load_intra_quantiser_matrix = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 511];
		foreach int i in 0 .. 63 do
			compute_nextbits(8*i, 8*i + 8);
			intra_quantiser_matrix[i] := nextbits;
		end
		load_non_intra_quantiser_matrix := token[512];
	end
	
	sh_check_non_intra_quantiser_matrix: action Bitstream: [token] ==>
	guard
		load_intra_quantiser_matrix = 0
	do
		load_non_intra_quantiser_matrix := token;
	end
	
	sh_read_non_intra_quantiser_matrix: action Bitstream: [token] repeat 512 ==>
	guard
		load_non_intra_quantiser_matrix = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 511];
		foreach int i in 0 .. 63 do
			compute_nextbits(8*i, 8*i + 8);
			non_intra_quantiser_matrix[i] := nextbits;
		end
	end
	
	sh_not_read_non_intra_quantiser_matrix: action ==>
	guard
		load_non_intra_quantiser_matrix = 0
	end
	
	// Sequence Extension
	
	se_sequence_extension: action Bitstream: [token] repeat 44 ==>
	guard
		nextbits = SEQUENCE_EXTENSION_ID
	do
		bit_buffer := [token[i]: for int i in 0 .. 43];
		compute_nextbits(0, 7);
		profile_and_level_indication := nextbits;
		compute_nextbits(8, 8);
		progressive_sequence := nextbits;
		compute_nextbits(9, 10);
		chroma_format := nextbits;
		compute_nextbits(11, 12);
		horizontal_size_extension := nextbits;
		compute_nextbits(13, 14);
		vertical_size_extension := nextbits;
		compute_nextbits(15, 26);
		bit_rate_extension := nextbits;
		compute_nextbits(27, 27);		// marker_bit
		compute_nextbits(28, 35);
		vbv_buffer_size_extension := nextbits;
		compute_nextbits(36, 36);
		low_delay := nextbits;
		compute_nextbits(37, 38);
		frame_rate_extension_n := nextbits;
		compute_nextbits(39, 43);
		frame_rate_extension_d := nextbits;
		
		// Calculating horizontal_size and vertical_size
		horizontal_size := horizontal_size_extension*12 + horizontal_size_value;
		vertical_size := vertical_size_extension*12 + vertical_size_value; 		
		
		eud_i := 0;	// Set the i for extension_and_user_data(0)
		check_MPEG2 := true;
	end
	
	se_not_next_extension_start_code: action ==>
	guard
		check_MPEG2 = false,
		nextbits != SEQUENCE_EXTENSION_ID
	do
		println("Error extension start code - MPEG1!");
	end
	
	// User Data
	
	ud_user_data: action ==>
	guard
		nextbits = USER_DATA_START_CODE
	do
		ud_counter := 0;
	end
	
	ud_read_user_data: action Bitstream: [token] repeat 8 ==>
	do
		bit_buffer := [token[i]: for int i in 0 .. 7];
		compute_nextbits(0, 7);
		user_data[ud_counter] := nextbits;
		ud_counter := ud_counter + 1;
	end

	// Sequence Display Extension
	
	sde_sequence_display_extension: action Bitstream: [token] repeat 4 ==>
	guard
		nextbits = SEQUENCE_DISPLAY_EXTENSION_ID,
		eud_i = 0
	do
		bit_buffer := [token[i]: for int i in 0 .. 3];
		compute_nextbits(0, 2);
		video_format := nextbits;
		compute_nextbits(3, 3);
		colour_description := nextbits;
	end
	
	sde_read_colour: action Bitstream: [token] repeat 53 ==>
	guard
		colour_description = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 52];
		compute_nextbits(0, 7);
		colour_primaries := nextbits;
		compute_nextbits(8, 15);
		transfer_characteristics := nextbits;
		compute_nextbits(16, 23);
		matrix_coefficients := nextbits;
		compute_nextbits(24, 37);
		display_horizontal_size := nextbits;
		compute_nextbits(38, 38);		// marker bit
		compute_nextbits(39, 52);
		display_vertical_size := nextbits;
	end
	
	sde_not_read_colour: action Bitstream: [token] repeat 29 ==>
	guard
		colour_description = 0
	do
		bit_buffer := [token[i]: for int i in 0 .. 28];
		compute_nextbits(0, 13);
		display_horizontal_size := nextbits;
		compute_nextbits(14, 14);		// marker bit
		compute_nextbits(15, 28);
		display_vertical_size := nextbits;
	end
	
	// Quant Matrix Extension
	
	quant_matrix_extension: action Bitstream: [token] ==>
	guard
		nextbits = QUANT_MATRIX_EXTENSION_ID,
		eud_i = 2
	do
		load_intra_quantiser_matrix := token;
	end
	
	// Copyright Extension
	
	copyright_extension: action Bitstream: [token] repeat 84 ==>
	guard
		nextbits = COPYRIGHT_EXTENSION_ID,
		eud_i = 2
	do
		bit_buffer := [token[i]: for int i in 0 .. 83];
		compute_nextbits(0, 0);
		copyright_flag := nextbits;
		compute_nextbits(1, 8);
		copyright_identifier := nextbits;
		compute_nextbits(9, 9);
		original_or_copy := nextbits;
		compute_nextbits(10, 16);
		reserved := nextbits;
		compute_nextbits(17, 17);		// marker bit
		compute_nextbits(18, 37);
		copyright_number_1 := nextbits;
		compute_nextbits(38, 38);		// marker bit
		compute_nextbits(39, 60);
		copyright_number_2 := nextbits;
		compute_nextbits(61, 61);		// marker bit
		compute_nextbits(62, 83);
		copyright_number_3 := nextbits;
	end
		
	// Picture Display Extension	// Not codded yet
		
	picture_display_extension: action ==>
	guard
		nextbits = PICTURE_DISPLAY_EXTENSION_ID,
		eud_i = 2
	do
		println("Entering Picture Display Extension !");
	end
	
	// ITU-T Extension				// Not codded yet
	
	ITUT_extension: action ==>
	guard
		nextbits = ITUT_EXTENSION_ID,
		eud_i =2
	end
	
	// Group of Pictures Header
	
	group_of_pictures_header: action Bitstream: [token] repeat 27 ==>
	guard
		nextbits = GROUP_START_CODE
	do
		bit_buffer := [token[i]: for int i in 0 .. 26];
		compute_nextbits(0, 24);
		time_code := nextbits;
		compute_nextbits(25, 25);
		closed_gop := nextbits;
		compute_nextbits(26, 26);
		broken_link := nextbits;
		
		eud_i := 1;	// Set the i for extension_and_user_data(1)
	end
	
	// Picture Header
	
	ph_picture_header: action Bitstream: [token] repeat 29 ==>
	guard
		nextbits = PICTURE_START_CODE
	do
		bit_buffer := [token[i]: for int i in 0 .. 28];
		compute_nextbits(0, 9);
		temporal_reference := nextbits;
		compute_nextbits(10, 12);
		picture_coding_type := nextbits;
		compute_nextbits(13, 18);
		vbv_delay := nextbits;
	end
	
	ph_picture_coding_type_2: action Bitstream: [token] repeat 4 ==>
	guard
		picture_coding_type = 2
	do
		bit_buffer := [token[i]: for int i in 0 .. 3];
		compute_nextbits(0, 0);
		full_pel_forward_vector := nextbits;
		compute_nextbits(1, 3);
		forward_f_code := nextbits;
	end
	
	ph_picture_coding_type_3: action Bitstream: [token] repeat 8 ==>
	guard
		picture_coding_type = 3
	do
		bit_buffer := [token[i]: for int i in 0 .. 7];
		compute_nextbits(0, 0);
		full_pel_forward_vector := nextbits;
		compute_nextbits(1, 3);
		forward_f_code := nextbits;
		compute_nextbits(4, 4);
		full_pel_backward_vector := nextbits;
		compute_nextbits(5, 7);
		backward_f_code := nextbits;
	end
	
	ph_picture_coding_type_else: action Bitstream: [token] ==>
	guard
		picture_coding_type != 2,
		picture_coding_type != 3
	end
	
	ph_extra_bit_picture_1: action Bitstream: [token] repeat 9 ==>
	guard
		token[0] = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 8];
		compute_nextbits(0, 0);
		extra_bit_picture := nextbits;
		compute_nextbits(1, 8);
		extra_information_picture := nextbits;
	end
	
	ph_extra_bit_picture_0: action Bitstream: [token] ==>
	guard
		token = 0
	do
		extra_bit_picture := token;
	end
	
	// Picture Coding Extension
	
	pce_picture_coding_extension: action Bitstream: [token] repeat 30 ==>
	guard
		nextbits = PICTURE_CODING_EXTENSION_ID
	do
		bit_buffer := [token[i]: for int i in 0 .. 29];
		compute_nextbits(0, 3);
		f_code00 := nextbits;
		compute_nextbits(4, 7);
		f_code01 := nextbits;
		compute_nextbits(8, 11);
		f_code10 := nextbits;
		compute_nextbits(12, 15);
		f_code11 := nextbits; 
		compute_nextbits(16, 17);
		intra_dc_precision := nextbits;
		compute_nextbits(18, 19);
		picture_structure := nextbits;
		compute_nextbits(20, 20);
		top_field_first := nextbits;
		compute_nextbits(21, 21);
		frame_pred_frame_dct := nextbits;
		compute_nextbits(22, 22);
		concealment_motion_vectors := nextbits;
		compute_nextbits(23, 23);
		q_scale_type := nextbits;
		compute_nextbits(24, 24);
		intra_vlc_format := nextbits;
		compute_nextbits(25, 25);
		alternate_scan := nextbits;
		compute_nextbits(26, 26);
		repeat_first_field := nextbits;
		compute_nextbits(27, 27);
		chroma_420_type := nextbits;
		compute_nextbits(28, 28);
		progressive_frame := nextbits;
		compute_nextbits(29, 29);
		composite_display_flag := nextbits;
		
		eud_i := 2;	// Set the i for extension_and_user_data(1)
	end
	
	pce_composite_display: action Bitstream: [token] repeat 20 ==>
	guard
		composite_display_flag = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 19];
		compute_nextbits(0, 0);
		v_axis := nextbits;
		compute_nextbits(1, 3);
		field_sequence := nextbits;
		compute_nextbits(4, 4);
		sub_carrier := nextbits;
		compute_nextbits(5, 11);
		burst_amplitude := nextbits;
		compute_nextbits(12, 19);
		sub_carrier_phase := nextbits;
	end
	
	pce_not_composite_display: action ==>
	guard
		composite_display_flag = 0
	end
	
	// Slice
	
	sl_big_slice: action Bitstream: [token] repeat 8 ==>
	guard
		SLICE_BEGIN_START_CODE <= nextbits,
		SLICE_END_START_CODE >= nextbits,
		vertical_size > 2800
	do
		slice_vertical_position := nextbits;
		bit_buffer := [token[i]: for int i in 0 .. 7];
		compute_nextbits(0, 2);
		slice_vertical_position_extension := nextbits;
		compute_nextbits(3, 7);
		quantiser_scale_code := nextbits;
	end
	
	sl_small_slice: action Bitstream: [token] repeat 5 ==>
	guard
		SLICE_BEGIN_START_CODE <= nextbits,
		SLICE_END_START_CODE >= nextbits,
		vertical_size < 2800
	do
		slice_vertical_position := nextbits;
		bit_buffer := [token[i]: for int i in 0 .. 4];
		compute_nextbits(0, 4);
		quantiser_scale_code := nextbits;
	end
	
	sl_slice_extension: action Bitstream: [token] repeat 9 ==>
	guard
		token[0] = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 8];
		compute_nextbits(0, 0);
		slice_extension_flag := nextbits;
		compute_nextbits(1, 1);
		intra_slice := nextbits;
		compute_nextbits(2, 2);
		slice_picture_id_enable := nextbits;
		compute_nextbits(3, 8);
		slice_picture_id := nextbits;
	end
	
	sl_extra_information_slice: action Bitstream: [token] repeat 9 ==>
	guard
		token[0] = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 8];
		compute_nextbits(0, 0);
		extra_bit_slice := nextbits;
		compute_nextbits(1, 8);
		extra_information_slice := nextbits;		
	end
	
	sl_slice_end: action Bitstream: [token] ==>
	guard
		token = 0
	do
		extra_bit_slice := token;
	end
	
	// Macroblocks
	
	begin_macroblock: action ==>
	do
	// !!! SET ALL THE VLC VARIABLES TO 0 !!!
		mb_macroblock_escape_counter := 0;		// To count the number of macroblock escape !
		
		mb_address_increment_vld_counter := 0;	// To count the number of time we do the action
		macroblock_address_increment := 0;
		mb_address_increment_flag := 0;			// Flag is set to 1 when the vlc is decoded		
		
		mb_type_vld_counter := 0;
		mb_type_flag := 0;
	end

	macroblock_escape: action Bitstream: [token] repeat 11 ==>
	guard
		// Nextbits = 0000 0001 000 -> Macroblock escape
		token[0] = 0, token[1] = 0, token[2] = 0, token[3] = 0,
		token[4] = 0, token[5] = 0, token[6] = 0, token[7] = 1,
		token[8] = 0, token[9] = 0, token[10] = 0
	do
		mb_macroblock_escape_counter := mb_macroblock_escape_counter + 1;
	end
	
	mb_address_increment: action Bitstream: [token] ==>
	guard
		mb_address_increment_flag = 0
	do
		int(size=8) mb_addr_inc_val;
		bit_buffer[mb_address_increment_vld_counter] := token; 													// Place the new token into bit_buffer
		compute_nextbits(0, mb_address_increment_vld_counter);													// Compute the tokens into nextbits
		mb_addr_inc_val := macroblock_address_increment_table[mb_address_increment_vld_counter][nextbits - 1];	// Look in the VLC table
		if mb_addr_inc_val != -1 then
			macroblock_address_increment := 33*mb_macroblock_escape_counter + mb_addr_inc_val;					// Calculate the address increment
			mb_address_increment_flag := 1;																		// Set the end flag to 1
		end
		mb_address_increment_vld_counter := mb_address_increment_vld_counter + 1;								// Update the counter

	end

	mb_type: action Bitstream: [token] ==>
	guard
		mb_address_increment_flag = 1,
		mb_type_flag = 0
	do
		int(size=2) macroblock_type;
		bit_buffer[mb_type_vld_counter] := token;
		compute_nextbits(0, mb_type_vld_counter);
		macroblock_type := macroblock_type_table[picture_coding_type -1][mb_type_vld_counter][nextbits -1][0];
		if macroblock_type != -1 then
			macroblock_quant 							:= macroblock_type;
			macroblock_motion_forward					:= macroblock_type_table[picture_coding_type -1][mb_type_vld_counter][nextbits -1][1];
			macroblock_motion_backward					:= macroblock_type_table[picture_coding_type -1][mb_type_vld_counter][nextbits -1][2];
			macroblock_pattern							:= macroblock_type_table[picture_coding_type -1][mb_type_vld_counter][nextbits -1][3];
			macroblock_intra							:= macroblock_type_table[picture_coding_type -1][mb_type_vld_counter][nextbits -1][4];
			spatial_temporal_weight_code_flag			:= macroblock_type_table[picture_coding_type -1][mb_type_vld_counter][nextbits -1][5];
			mb_type_flag := 1;
		end
		mb_type_vld_counter := mb_type_vld_counter + 1;
	end
	
	mb_frame_motion_type: action Bitstream: [token] repeat 2 ==>
	guard
		mb_type_flag = 1,
		macroblock_motion_forward = 1 or macroblock_motion_backward = 1,
		picture_structure = 11,
		frame_pred_frame_dct = 0
	do
		bit_buffer := [token[i]: for int i in 0 .. 1];
		compute_nextbits(0, 1);
		frame_motion_type := nextbits;
	end
	
	mb_not_frame_motion_type: action ==>
	guard
		mb_type_flag = 1 or
		(macroblock_motion_forward != 1 and macroblock_motion_backward != 1) or
		picture_structure != 11 or
		frame_pred_frame_dct != 0
	end
	
	mb_field_motion_type: action Bitstream: [token] repeat 2 ==>
	guard
		macroblock_motion_forward = 1 or macroblock_motion_backward = 1,
		picture_structure != 11
	do
		bit_buffer := [token[i]: for int i in 0 .. 1];
		compute_nextbits(0, 1);
		field_motion_type := nextbits;
	end
	
	mb_not_field_motion_type: action ==>
	guard
		(macroblock_motion_forward != 1 and macroblock_motion_backward != 1) or
		picture_structure = 11
	end
	
	mb_dct_type: action Bitstream: [token] ==>
	guard
		picture_structure = 11,
		frame_pred_frame_dct = 0,
		macroblock_intra = 1 or macroblock_pattern = 1
	do
		dct_type := token;
	end
	
	mb_not_dct_type: action ==>
	guard
		picture_structure != 11 or
		frame_pred_frame_dct != 0 or
		(macroblock_intra != 1 and macroblock_pattern != 1)
	end

	schedule fsm next_start_code :
	
		// Read the next start code
		next_start_code				(start_code_prefix)						-->		read_start_code;
		read_start_code				(eat_stuffing_bit)						-->		read_start_code;
		read_start_code				(read_start_code)						-->		go_to_code;
		
		// Read the next extension start code
		go_to_code					(read_extension_start_code)				-->		go_to_extension_code;
	
		// Sequence Header
		go_to_code					(sh_sequence_header)					-->		load_q_matrix;
		load_q_matrix				(sh_read_intra_quantiser_matrix)		-->		load_nq_matrix;
		load_q_matrix				(sh_check_non_intra_quantiser_matrix)	-->		load_nq_matrix;
		load_nq_matrix				(sh_read_non_intra_quantiser_matrix)	-->		next_start_code;
		load_nq_matrix				(sh_not_read_non_intra_quantiser_matrix)-->		next_start_code;
		
		// Sequence Extension
		go_to_extension_code		(se_sequence_extension)					-->		next_start_code;		
		go_to_extension_code		(se_not_next_extension_start_code)		-->		next_start_code;	// This case means MPEG1 --> stop ! 
		
		// Begining of the do-loop 1
		
		// Sequence Display Extension																										
		go_to_extension_code		(sde_sequence_display_extension)		-->		sde_read_colour;
		sde_read_colour				(sde_read_colour)						-->		next_start_code;
		sde_read_colour				(sde_not_read_colour)					-->		next_start_code;
		// Quant Matrix Extension
		go_to_extension_code		(quant_matrix_extension)				-->		load_q_matrix;
		// Copyright Extension
		go_to_extension_code		(copyright_extension)					-->		next_start_code;
		// Picture Display Extension	// Not codded yet
		go_to_extension_code		(picture_display_extension)				-->		next_start_code;
		// ITU-T Extension				// What is ITU-t_data ? This action is remplaced by eat_bit !
		go_to_extension_code		(ITUT_extension)						-->		next_start_code;
	
		// User Data
		go_to_code					(ud_user_data)							-->		read_user_data;
		read_user_data				(ud_read_user_data)						-->		read_user_data;
		read_user_data				(start_code_prefix)						-->		read_start_code;
		
		// Group of Pictures Header
		go_to_code					(group_of_pictures_header)				-->		next_start_code;
		
		// Picture Header
		go_to_code					(ph_picture_header)						-->		begin_picture_header;
		begin_picture_header		(ph_picture_coding_type_2)				-->		ph_extra_bit_picture;
		begin_picture_header		(ph_picture_coding_type_3)				-->		ph_extra_bit_picture;
		begin_picture_header		(ph_picture_coding_type_else)			-->		ph_extra_bit_picture;
		ph_extra_bit_picture		(ph_extra_bit_picture_1)				-->		ph_extra_bit_picture;
		ph_extra_bit_picture		(ph_extra_bit_picture_0)				-->		next_start_code;

		// Picture Coding Extension
		go_to_extension_code		(pce_picture_coding_extension)			--> 	pce_composite_display;
		pce_composite_display		(pce_composite_display)					-->		next_start_code;
		pce_composite_display		(pce_not_composite_display)				-->		next_start_code;
		
		// Slice
		go_to_code					(sl_big_slice)							-->		sl_slice_extension;	
		go_to_code					(sl_small_slice)						-->		sl_slice_extension;
		sl_slice_extension			(sl_slice_extension)					-->		sl_extra_info_slice;
		sl_slice_extension			(sl_slice_end)							-->		begin_macroblock;
		sl_extra_info_slice			(sl_extra_information_slice)			-->		sl_extra_info_slice;
		sl_extra_info_slice			(sl_slice_end)							-->		begin_macroblock;
		
		// Macorblock
		begin_macroblock			(begin_macroblock)						-->		macroblock_escape;
		begin_macroblock			(start_code_prefix)						-->		read_start_code;
		macroblock_escape			(macroblock_escape)						-->		macroblock_escape;
		macroblock_escape			(mb_address_increment)					-->		macroblock_addr_inc;
		macroblock_addr_inc			(mb_address_increment)					-->		macroblock_addr_inc;
		macroblock_addr_inc			(mb_type)								-->		macroblock_type;
		macroblock_type				(mb_type)								-->		macroblock_type;
		macroblock_type				(mb_frame_motion_type)					-->		field_motion_type;
		macroblock_type				(mb_not_frame_motion_type)				-->		field_motion_type;
		field_motion_type			(mb_field_motion_type)					-->		dct_type;
		field_motion_type			(mb_not_field_motion_type)				-->		dct_type;
		dct_type					(mb_dct_type)							-->		next_start_code; // To be continued
		dct_type					(mb_not_dct_type)						-->		next_start_code;
				
		
		
		// debug						(LOOK_FOLLOWING_BITS)					-->		next_start_code;
		
	end
	
	priority
		start_code_prefix	>	ud_read_user_data;
		start_code_prefix	>	begin_macroblock;
	end	
	
end