/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
  
// Author: Cesar Laurent <cesar.laurent@epfl.ch>

package ch.epfl.mpeg2.parser;

import ch.epfl.mpeg2.parser.MPEG2_Tables.macroblock_address_increment_table;
import ch.epfl.mpeg2.parser.MPEG2_Tables.macroblock_type_table;
import ch.epfl.mpeg2.parser.MPEG2_Tables.motion_code_table;
import ch.epfl.mpeg2.parser.MPEG2_Tables.codded_block_pattern_table;
import ch.epfl.mpeg2.parser.MPEG2_Tables.DCT_coefficients_table;
import ch.epfl.mpeg2.parser.MPEG2_Tables.quantiser_scale_table;
import ch.epfl.mpeg2.parser.MPEG2_Tables.quantiser_matrix_default;

actor MPEG2_SP_Parser()
	uint(size=1) Bitstream
		==> 
			int(size=13) QFS, 
			uint(size=2) ALTERNATE_SCAN, 
			int(size=16) SIZE,
			uint(size=1) MB_INTRA,
			uint(size=8) QUANTISER_SCALE,
			uint(size=8) INTRA_QUANTISER_MATRIX,
			uint(size=8) NON_INTRA_QUANTISER_MATRIX:
			
	// ////////////////////////////////////////////////////////////////////////
	// State Variables
	
	// Start Code Values :
	uint(size=8)	PICTURE_START_CODE		= 0x00;
 	uint(size=8)	SLICE_BEGIN_START_CODE	= 0x01;
 	uint(size=8)	SLICE_END_START_CODE 	= 0xAF;
	uint(size=8)	USER_DATA_START_CODE 	= 0xB2;
	uint(size=8)	SEQUENCE_HEADER_CODE 	= 0xB3;
	uint(size=8)	SEQUENCE_ERROR_CODE 	= 0xB4;
	uint(size=8)	EXTENSION_START_CODE 	= 0xB5;
	uint(size=8)	SEQUENCE_END_CODE 		= 0xB7;
	uint(size=8)	GROUP_START_CODE		= 0xB8;
	
	// Extension Start Code Identifier Values :
	uint(size=4)	SEQUENCE_EXTENSION_ID 					= 0x1;
	uint(size=4)	SEQUENCE_DISPLAY_EXTENSION_ID 			= 0x2;
	uint(size=4)	QUANT_MATRIX_EXTENSION_ID 				= 0x3;
	uint(size=4)	COPYRIGHT_EXTENSION_ID 					= 0x4;
	uint(size=4)	SEQUENCE_SCALABLE_EXTENSION_ID			= 0x5;
	uint(size=4)	PICTURE_DISPLAY_EXTENSION_ID 			= 0x7;
	uint(size=4)	PICTURE_CODING_EXTENSION_ID 			= 0x8;
	uint(size=4)	PICTURE_SPATIAL_SCALABLE_EXTENSION_ID 	= 0x9;
	uint(size=4)	PICTURE_TEMPORAL_SCALABLE_EXTENSION_ID	= 0xA;
	uint(size=4)	CAMERA_PARAMETERS_EXTENSION_ID 			= 0xB;
	uint(size=4)	ITUT_EXTENSION_ID 						= 0xC;
	
	// Nextbits and Buffer
	uint(size=32)	nextbits := 0;
	uint(size=1)	bit_buffer[1024];
	
	// Check if MPEG2 or ISO/IEC 11172-2 (MPEG1)
	bool	check_MPEG2 := false;
	
	// Video information
	uint(size=12) 	horizontal_size_value;
	uint(size=12)	vertical_size_value;
	uint(size=4) 	aspect_ration_information;
	uint(size=4) 	frame_rate_code;
	uint(size=18)	bit_rate_value;
	uint(size=10)	vbv_buffer_size_value;
	
	uint(size=8)	profile_and_level_indication;
	uint(size=1)	progressive_sequence;
	uint(size=2)	chroma_format;
	uint(size=2)	horizontal_size_extension;
	uint(size=2)	vertical_size_extension;
	uint(size=12)	bit_rate_extension;
	uint(size=8)	vbv_buffer_size_extension;
	uint(size=1)	low_delay;
	uint(size=2)	frame_rate_extension_n;
	uint(size=5)	frame_rate_extension_d;
		// Calculated values
		uint(size=14)	horizontal_size;
		uint(size=14)	vertical_size;
	uint(size=12)	mb_width;
	
	// Sequence Display Extension
	uint(size=3)	video_format;
	uint(size=1)	colour_description;
	uint(size=8)	colour_primaries;
	uint(size=8)	transfer_characteristics;
	uint(size=8)	matrix_coefficients;
	uint(size=14)	display_horizontal_size;
	uint(size=14)	display_vertical_size;
		
	// Quantiser matrices
	uint(size=1)	load_intra_quantiser_matrix;
	uint(size=1)	load_non_intra_quantiser_matrix;
	uint(size=8)	intra_quantiser_matrix[64];
	uint(size=8)	non_intra_quantiser_matrix[64];
	
	// Extension and User Data
	uint(size=1)	eud_i;				// the i in extension_and_user_data(i). This variable is set in the action before any extension_and_user_data(i)
	uint(size=8)	user_data[512];
	uint(size=1)	ud_counter := 0;
	
	// Copyright Extension
	uint(size=1)	copyright_flag;
	uint(size=8)	copyright_identifier;
	uint(size=1)	original_or_copy;
	uint(size=7)	reserved;
	uint(size=20)	copyright_number_1;
	uint(size=22)	copyright_number_2;
	uint(size=22)	copyright_number_3;
	
	// Group of Pictures Header
	uint(size=25)	time_code;
	uint(size=1)	closed_gop;
	uint(size=1)	broken_link;
	
	// Picture Header
	uint(size=10)	temporal_reference;
	uint(size=3)	picture_coding_type;
	uint(size=16)	vbv_delay;
	uint(size=1)	full_pel_forward_vector;
	uint(size=4)	forward_f_code;
	uint(size=1)	full_pel_backward_vector;
	uint(size=4)	backward_f_code;
	uint(size=8)	extra_information_picture;
	uint(size=1)	extra_bit_picture;
	
	// Picture Coding Extension
	uint(size=4)	f_code[2][2];
	uint(size=2)	intra_dc_precision;
	uint(size=2)	picture_structure;
	uint(size=1)	top_field_first;
	uint(size=1)	frame_pred_frame_dct;
	uint(size=1)	concealment_motion_vectors;
	uint(size=1)	q_scale_type;
	uint(size=1)	intra_vlc_format;
	uint(size=1)	alternate_scan;
	uint(size=1)	repeat_first_field;
	uint(size=1)	chroma_420_type;
	uint(size=1)	progressive_frame;
	uint(size=1)	composite_display_flag;
	
	uint(size=1)	v_axis;
	uint(size=3)	field_sequence;
	uint(size=1)	sub_carrier;
	uint(size=7)	burst_amplitude;
	uint(size=8)	sub_carrier_phase;
	
	// Slice
	uint(size=8)	slice_vertical_position; // It is given by the start code of the slice !
	uint(size=3)	slice_vertical_position_extension;
	uint(size=12)	mb_row;
	uint(size=24)	previous_macroblock_address;
	uint(size=5)	quantiser_scale_code;
	uint(size=1)	slice_extension_flag;
	uint(size=1)	intra_slice;
	uint(size=1)	slice_picture_id_enable;
	uint(size=6)	slice_picture_id;
	uint(size=1)	extra_bit_slice;
	uint(size=8)	extra_information_slice;
	uint(size=8)	quantiser_scale;
	
	// Macroblock
	uint(size=8)	mb_macroblock_escape_counter := 0;	// To count the number of macroblock escape !
	int(size=9)		mb_address_increment_vld_counter := 0; // To count the number of time we do the action
	uint(size=8)	macroblock_address_increment;
	uint(size=1)	mb_address_increment_flag := 0;	// Flag set to 1 when the vlc is decoded
	uint(size=1)	mb_start_code_flag := 0;		// Flag set to 1 if we are in fact decoding a start_code into address increment.
	uint(size=24)	macroblock_address;
	
	uint(size=1)	mb_type_flag := 0;
	uint(size=8)	mb_type_vld_counter := 0;
	uint(size=1)	macroblock_quant;
	uint(size=1)	macroblock_motion_forward;
	uint(size=1)	macroblock_motion_backward;
	uint(size=1)	macroblock_pattern;
	uint(size=1)	macroblock_intra;
	uint(size=1)	spatial_temporal_weight_code_flag;
	
	uint(size=2)	frame_motion_type;
	uint(size=2)	field_motion_type;
	uint(size=2)	motion_vector_count;	// Codded in frame_motion_type or field_motion_type
	uint(size=1)	mv_format;				// Codded in frame_motion_type or field_motion_type : 0 = Field, 1 = Frame
	uint(size=1)	dmv;					// Codded in frame_motion_type or field_motion_type
	uint(size=1)	dct_type;
	
	// Motion Vectors
	int(size=6)		motion_code[4][2][2];
	uint(size=8)	motion_residual[4][2][2];
	int(size=2)		dmvector[2];
	uint(size=1)	motion_vertical_field_select[4][2];
	uint(size=2)	mv_r;	// "r" variable
	uint(size=1)	mv_s;	// "s" variable
	uint(size=1)	mv_t;	// "t" variable
	
	uint(size=1)	mv_motion_code_flag;		// VLD flag
	uint(size=4)	mv_motion_code_vld_counter;
	uint(size=1)	mv_motion_residual_flag;	// VLD flag
	uint(size=4)	mv_motion_residual_vld_counter;
	uint(size=1)	mv_dmvector_flag;			// VLD flag
	uint(size=4)	mv_dmvector_vld_counter;
	uint(size=2)	mv_transition_flag;
	
	// Codded Block Pattern
	uint(size=1)	cbp_flag;					// VLD flag
	uint(size=5)	cbp_vld_counter;
	uint(size=9)	codded_block_pattern_420;
	uint(size=6)	cbp;
	
	// Block
	int(size=13) qfs[64];
	uint qfs_counter := 0;
	uint(size=3)	bk_i;
	uint(size=3)	block_count = 6; // because 4:2:0
	uint(size=1)	bk_DCT_coef_table_to_use;
	uint(size=9)	dct_dc_size_luminance;
	uint(size=11)	dct_dc_differential;
	int(size=12)	dct_diff;
	uint(size=9)	half_range;
	uint(size=10)	dct_dc_size_chrominance;
	uint(size=1)	bk_lum_flag;
	uint(size=5)	bk_lum_vld_counter;
	uint(size=1)	bk_chrom_flag;
	uint(size=5)	bk_chrom_vld_counter;
	uint(size=1)	bk_diff_flag;
	uint(size=5)	bk_diff_vld_counter;
	uint(size=1)	pattern_code[12];
	
	uint(size=1) 	bk_coef_flag;
	uint(size=5)	bk_coef_vld_counter;
	int(size=8)		bk_coef_vld;
	
	uint(size=1)	bk_end_of_block_flag;
	uint(size=1)	bk_escape_flag;
	uint(size=6)	run;
	uint(size=11)	level;
	int(size=12)	signed_level;
	uint(size=1)	bk_DC_coef_flag; // 0 = DC coef., 1 = other coef.
	uint(size=16)	dct_dc_pred[3];
	
	// DEBUG
	uint(size=16)	currentMB := 0;
	
	// ////////////////////////////////////////////////////////////////////////
	// Functions / Procedures

	procedure compute_nextbits(int start, int stop)
	var
		uint(size=512) res := 0
	begin
		foreach int i in start .. stop do
			res := res << 1 | bit_buffer[i];
		end
		nextbits := res;
	end
	
	function test23zeros(uint(size=1) bit[24]) --> bool:
		bit[0]  = 0 and bit[1]  = 0 and bit[2]  = 0 and bit[3]  = 0 and
		bit[4]  = 0 and bit[5]  = 0 and bit[6]  = 0 and bit[7]  = 0 and
		bit[8]  = 0 and bit[9]  = 0 and bit[10] = 0 and bit[11] = 0 and
		bit[12] = 0 and bit[13] = 0 and bit[14] = 0 and bit[15] = 0 and
		bit[16] = 0 and bit[17] = 0 and bit[18] = 0 and bit[19] = 0 and
		bit[20] = 0 and bit[21] = 0 and bit[22] = 0
	end
		
	// ////////////////////////////////////////////////////////////////////////
	// Untagged Actions

	// ////////////////////////////////////////////////////////////////////////
	// Action
	
	// Start Code Actions
	
	start_code_prefix: action Bitstream: [token] repeat 24 ==>	// Check the 23 zeros of the start code prefix and put the 24th bit into nextbits
	guard
		test23zeros(token)
	do
		nextbits := token[23];
	end
	
	eat_stuffing_bit:action Bitstream: [token] ==>	// Eat stuffing bit when not byte aligned
	guard
		nextbits = 0
	do
		nextbits := token;
	end
	
	read_start_code: action Bitstream: [token] repeat 8 ==>	// Put start_code into nextbits
	guard
		nextbits = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 7];
		compute_nextbits(0, 7);
	end
	
	read_extension_start_code: action Bitstream: [token] repeat 4 ==>	// Put extension_start_code into nextbits
	guard
		nextbits = EXTENSION_START_CODE
	do
		bit_buffer := [token[i]: for int i in 0 .. 3];
		compute_nextbits(0, 3);
	end
		
	LOOK_FOLLOWING_BITS: action Bitstream: [token] repeat 128 ==>	// Debug tool
	do
		bit_buffer := [token[i]: for int i in 0 .. 127];
	end

	
	// Sequence Header
	
	sh_sequence_header: action Bitstream: [token] repeat 63 ==>
	guard
		nextbits = SEQUENCE_HEADER_CODE
	do
		bit_buffer := [token[i]: for int i in 0 .. 61];
		compute_nextbits(0, 11);
		horizontal_size_value := nextbits;
		compute_nextbits(12, 23);
		vertical_size_value := nextbits;
		compute_nextbits(24, 27);
		aspect_ration_information := nextbits;
		compute_nextbits(28, 31);
		frame_rate_code := nextbits;
		compute_nextbits(32 , 49);
		bit_rate_value := nextbits;
		compute_nextbits(50, 50);		// marker_bit
		compute_nextbits(51, 60);
		vbv_buffer_size_value := nextbits;
		compute_nextbits(61, 61);		// constrained_parameters_flag
		load_intra_quantiser_matrix := token[62];
	end
	
	sh_read_intra_quantiser_matrix: action Bitstream: [token] repeat 513 ==> INTRA_QUANTISER_MATRIX: [intra_quantiser_matrix] repeat 64
	guard
		load_intra_quantiser_matrix = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 511];
		foreach int i in 0 .. 63 do
			compute_nextbits(8*i, 8*i + 7);
			intra_quantiser_matrix[i] := nextbits;
		end
		load_non_intra_quantiser_matrix := token[512];
	end
	
	sh_check_non_intra_quantiser_matrix: action Bitstream: [token] ==>
	guard
		load_intra_quantiser_matrix = 0
	do
		load_non_intra_quantiser_matrix := token;
	end
	
	sh_read_non_intra_quantiser_matrix: action Bitstream: [token] repeat 512 ==> NON_INTRA_QUANTISER_MATRIX: [non_intra_quantiser_matrix] repeat 64
	guard
		load_non_intra_quantiser_matrix = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 511];
		foreach int i in 0 .. 63 do
			compute_nextbits(8*i, 8*i + 7);
			non_intra_quantiser_matrix[i] := nextbits;
		end
	end
	
	sh_not_read_non_intra_quantiser_matrix: action ==>
	guard
		load_non_intra_quantiser_matrix = 0
	end
	
	// Sequence Extension
	
	se_sequence_extension: action Bitstream: [token] repeat 44 ==> SIZE: [horizontal_size >> 4, vertical_size >> 4]
	guard
		nextbits = SEQUENCE_EXTENSION_ID
	do
		bit_buffer := [token[i]: for int i in 0 .. 43];
		compute_nextbits(0, 7);
		profile_and_level_indication := nextbits;
		compute_nextbits(8, 8);
		progressive_sequence := nextbits;
		compute_nextbits(9, 10);
		chroma_format := nextbits;
		compute_nextbits(11, 12);
		horizontal_size_extension := nextbits;
		compute_nextbits(13, 14);
		vertical_size_extension := nextbits;
		compute_nextbits(15, 26);
		bit_rate_extension := nextbits;
		compute_nextbits(27, 27);		// marker_bit
		compute_nextbits(28, 35);
		vbv_buffer_size_extension := nextbits;
		compute_nextbits(36, 36);
		low_delay := nextbits;
		compute_nextbits(37, 38);
		frame_rate_extension_n := nextbits;
		compute_nextbits(39, 43);
		frame_rate_extension_d := nextbits;
		
		// Calculating horizontal_size and vertical_size
		horizontal_size := horizontal_size_extension*12 + horizontal_size_value;
		vertical_size := vertical_size_extension*12 + vertical_size_value; 		
		mb_width := (horizontal_size + 15)/16;
		
		eud_i := 0;	// Set the i for extension_and_user_data(0)
		check_MPEG2 := true;
	end
	
	se_not_next_extension_start_code: action ==>
	guard
		check_MPEG2 = false,
		nextbits != SEQUENCE_EXTENSION_ID
	do
		println("Error extension start code - MPEG1!");
	end
	
	// User Data
	
	ud_user_data: action ==>
	guard
		nextbits = USER_DATA_START_CODE
	do
		ud_counter := 0;
	end
	
	ud_read_user_data: action Bitstream: [token] repeat 8 ==>
	do
		bit_buffer := [token[i]: for int i in 0 .. 7];
		compute_nextbits(0, 7);
		user_data[ud_counter] := nextbits;
		ud_counter := ud_counter + 1;
	end

	// Sequence Display Extension
	
	sde_sequence_display_extension: action Bitstream: [token] repeat 4 ==>
	guard
		nextbits = SEQUENCE_DISPLAY_EXTENSION_ID,
		eud_i = 0
	do
		bit_buffer := [token[i]: for int i in 0 .. 3];
		compute_nextbits(0, 2);
		video_format := nextbits;
		compute_nextbits(3, 3);
		colour_description := nextbits;
	end
	
	sde_read_colour: action Bitstream: [token] repeat 53 ==>
	guard
		colour_description = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 52];
		compute_nextbits(0, 7);
		colour_primaries := nextbits;
		compute_nextbits(8, 15);
		transfer_characteristics := nextbits;
		compute_nextbits(16, 23);
		matrix_coefficients := nextbits;
		compute_nextbits(24, 37);
		display_horizontal_size := nextbits;
		compute_nextbits(38, 38);		// marker bit
		compute_nextbits(39, 52);
		display_vertical_size := nextbits;
	end
	
	sde_not_read_colour: action Bitstream: [token] repeat 29 ==>
	guard
		colour_description = 0
	do
		bit_buffer := [token[i]: for int i in 0 .. 28];
		compute_nextbits(0, 13);
		display_horizontal_size := nextbits;
		compute_nextbits(14, 14);		// marker bit
		compute_nextbits(15, 28);
		display_vertical_size := nextbits;
	end
	
	// Quant Matrix Extension
	
	quant_matrix_extension: action Bitstream: [token] ==>
	guard
		nextbits = QUANT_MATRIX_EXTENSION_ID,
		eud_i = 2
	do
		load_intra_quantiser_matrix := token;
	end
	
	// Copyright Extension
	
	copyright_extension: action Bitstream: [token] repeat 84 ==>
	guard
		nextbits = COPYRIGHT_EXTENSION_ID,
		eud_i = 2
	do
		bit_buffer := [token[i]: for int i in 0 .. 83];
		compute_nextbits(0, 0);
		copyright_flag := nextbits;
		compute_nextbits(1, 8);
		copyright_identifier := nextbits;
		compute_nextbits(9, 9);
		original_or_copy := nextbits;
		compute_nextbits(10, 16);
		reserved := nextbits;
		compute_nextbits(17, 17);		// marker bit
		compute_nextbits(18, 37);
		copyright_number_1 := nextbits;
		compute_nextbits(38, 38);		// marker bit
		compute_nextbits(39, 60);
		copyright_number_2 := nextbits;
		compute_nextbits(61, 61);		// marker bit
		compute_nextbits(62, 83);
		copyright_number_3 := nextbits;
	end
		
	// Picture Display Extension	// Not codded yet
		
	picture_display_extension: action ==>
	guard
		nextbits = PICTURE_DISPLAY_EXTENSION_ID,
		eud_i = 2
	do
		println("Entering Picture Display Extension !");
	end
	
	// ITU-T Extension				// Not codded yet
	
	ITUT_extension: action ==>
	guard
		nextbits = ITUT_EXTENSION_ID,
		eud_i =2
	end
	
	// Group of Pictures Header
	
	group_of_pictures_header: action Bitstream: [token] repeat 27 ==>
	guard
		nextbits = GROUP_START_CODE
	do
		bit_buffer := [token[i]: for int i in 0 .. 26];
		compute_nextbits(0, 24);
		time_code := nextbits;
		compute_nextbits(25, 25);
		closed_gop := nextbits;
		compute_nextbits(26, 26);
		broken_link := nextbits;
		eud_i := 1;	// Set the i for extension_and_user_data(1)
	end
	
	// Picture Header
	
	ph_picture_header: action Bitstream: [token] repeat 29 ==>
	guard
		nextbits = PICTURE_START_CODE
	do
		bit_buffer := [token[i]: for int i in 0 .. 28];
		compute_nextbits(0, 9);
		temporal_reference := nextbits;
		compute_nextbits(10, 12);
		picture_coding_type := nextbits;
		compute_nextbits(13, 18);
		vbv_delay := nextbits;	
	end
	
	ph_picture_coding_type_2: action Bitstream: [token] repeat 4 ==>
	guard
		picture_coding_type = 2
	do
		bit_buffer := [token[i]: for int i in 0 .. 3];
		compute_nextbits(0, 0);
		full_pel_forward_vector := nextbits;
		compute_nextbits(1, 3);
		forward_f_code := nextbits;
	end
	
	ph_picture_coding_type_3: action Bitstream: [token] repeat 8 ==>
	guard
		picture_coding_type = 3
	do
		bit_buffer := [token[i]: for int i in 0 .. 7];
		compute_nextbits(0, 0);
		full_pel_forward_vector := nextbits;
		compute_nextbits(1, 3);
		forward_f_code := nextbits;
		compute_nextbits(4, 4);
		full_pel_backward_vector := nextbits;
		compute_nextbits(5, 7);
		backward_f_code := nextbits;
	end
	
	ph_picture_coding_type_else: action Bitstream: [token] ==>
	guard
		picture_coding_type != 2,
		picture_coding_type != 3
	end
	
	ph_extra_bit_picture_1: action Bitstream: [token] repeat 9 ==>
	guard
		token[0] = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 8];
		compute_nextbits(0, 0);
		extra_bit_picture := nextbits;
		compute_nextbits(1, 8);
		extra_information_picture := nextbits;
	end
	
	ph_extra_bit_picture_0: action Bitstream: [token] ==>
	guard
		token = 0
	do
		extra_bit_picture := token;
	end
	
	// Picture Coding Extension
	
	pce_picture_coding_extension: action Bitstream: [token] repeat 30 ==>
	guard
		nextbits = PICTURE_CODING_EXTENSION_ID
	do
		bit_buffer := [token[i]: for int i in 0 .. 29];
		compute_nextbits(0, 3);
		f_code[0][0] := nextbits;
		compute_nextbits(4, 7);
		f_code[0][1] := nextbits;
		compute_nextbits(8, 11);
		f_code[1][0] := nextbits;
		compute_nextbits(12, 15);
		f_code[1][1] := nextbits; 
		compute_nextbits(16, 17);
		intra_dc_precision := nextbits;
		compute_nextbits(18, 19);
		picture_structure := nextbits;
		compute_nextbits(20, 20);
		top_field_first := nextbits;
		compute_nextbits(21, 21);
		frame_pred_frame_dct := nextbits;
		compute_nextbits(22, 22);
		concealment_motion_vectors := nextbits;
		compute_nextbits(23, 23);
		q_scale_type := nextbits;
		compute_nextbits(24, 24);
		intra_vlc_format := nextbits;
		compute_nextbits(25, 25);
		alternate_scan := nextbits;
		compute_nextbits(26, 26);
		repeat_first_field := nextbits;
		compute_nextbits(27, 27);
		chroma_420_type := nextbits;
		compute_nextbits(28, 28);
		progressive_frame := nextbits;
		compute_nextbits(29, 29);
		composite_display_flag := nextbits;
		
		eud_i := 2;	// Set the i for extension_and_user_data(1)
	end
	
	pce_composite_display: action Bitstream: [token] repeat 20 ==>
	guard
		composite_display_flag = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 19];
		compute_nextbits(0, 0);
		v_axis := nextbits;
		compute_nextbits(1, 3);
		field_sequence := nextbits;
		compute_nextbits(4, 4);
		sub_carrier := nextbits;
		compute_nextbits(5, 11);
		burst_amplitude := nextbits;
		compute_nextbits(12, 19);
		sub_carrier_phase := nextbits;
	end
	
	pce_not_composite_display: action ==>
	guard
		composite_display_flag = 0
	end
	
	// Slice
	
	sl_big_slice: action Bitstream: [token] repeat 8 ==>
	guard
		SLICE_BEGIN_START_CODE <= nextbits,
		SLICE_END_START_CODE >= nextbits,
		vertical_size > 2800
	do
		slice_vertical_position := nextbits;
		bit_buffer := [token[i]: for int i in 0 .. 7];
		compute_nextbits(0, 2);
		slice_vertical_position_extension := nextbits;
		mb_row := (slice_vertical_position_extension << 7) + slice_vertical_position - 1;
		compute_nextbits(3, 7);
		quantiser_scale_code := nextbits;
	end
	
	sl_small_slice: action Bitstream: [token] repeat 5 ==>
	guard
		SLICE_BEGIN_START_CODE <= nextbits,
		SLICE_END_START_CODE >= nextbits,
		vertical_size < 2800
	do
		slice_vertical_position := nextbits;
		mb_row := slice_vertical_position - 1;
		bit_buffer := [token[i]: for int i in 0 .. 4];
		compute_nextbits(0, 4);
		quantiser_scale_code := nextbits;
	end
	
	sl_slice_extension: action Bitstream: [token] repeat 9 ==>
	guard
		token[0] = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 8];
		compute_nextbits(0, 0);
		slice_extension_flag := nextbits;
		compute_nextbits(1, 1);
		intra_slice := nextbits;
		compute_nextbits(2, 2);
		slice_picture_id_enable := nextbits;
		compute_nextbits(3, 8);
		slice_picture_id := nextbits;
	end
	
	sl_extra_information_slice: action Bitstream: [token] repeat 9 ==>
	guard
		token[0] = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 8];
		compute_nextbits(0, 0);
		extra_bit_slice := nextbits;
		compute_nextbits(1, 8);
		extra_information_slice := nextbits;		
	end
	
	sl_slice_end: action Bitstream: [token] ==>
	guard
		token = 0
	do
		extra_bit_slice := token;
		// Exporting the quantiser_scale
		if q_scale_type = 0 then
			quantiser_scale := 2*quantiser_scale_code;
		else
			quantiser_scale := quantiser_scale_table[quantiser_scale_code];		
		end
		// Calculating prev_mb_addr
		previous_macroblock_address := (mb_row * mb_width) - 1;
		// Reset the dct_dc_pred[cc]
		dct_dc_pred[0] := 128*(1 << intra_dc_precision);
		dct_dc_pred[1] := dct_dc_pred[0];
		dct_dc_pred[2] := dct_dc_pred[0];
		// DEBUG
		// println("MB : " + currentMB);
	end
	
	// Macroblocks
	
	begin_macroblock: action ==>
	do
		// !!! SET ALL THE VLC VARIABLES TO 0 !!!
		mb_macroblock_escape_counter := 0;		// To count the number of macroblock escape !
		mb_address_increment_vld_counter := 0;	// To count the number of time we do the action
		macroblock_address_increment := 0;
		mb_address_increment_flag := 0;			// Flag is set to 1 when the vlc is decoded	
		mb_start_code_flag := 0;				// In case of start code prefix
		mb_type_vld_counter := 0;
		mb_type_flag := 0;
		cbp_flag := 0;
		cbp_vld_counter := 0;
	end
	
	/* If we are reading 8 times 0, that means we are reading the begining of the start code prefix, 0x001. 
	 * (see ISO/IEC 13818-2 : 2000 p.32, the contition at the bottom of the page "while 
	 * (nextbits() != '000 0000 0000 0000 0000 0000')"
	 * In this case, we go to mb_reading_start_code_prefix to read the others 0 and then go to read_start_code.*/
	mb_macroblock_address: action Bitstream: [token] ==>
	guard
		mb_address_increment_flag = 0 and
		mb_start_code_flag = 0
	var
		int(size=8) mb_addr_inc_val
	do
		bit_buffer[mb_address_increment_vld_counter] := token; 													
		compute_nextbits(0, mb_address_increment_vld_counter);													
		mb_addr_inc_val := macroblock_address_increment_table[mb_address_increment_vld_counter][nextbits];		
		if mb_addr_inc_val != -1 then
			if mb_addr_inc_val = -2 then		// macroblock_escape
				mb_macroblock_escape_counter := mb_macroblock_escape_counter + 1;
				mb_address_increment_vld_counter := -1;
			else
				if mb_addr_inc_val = -3 then	// this means we are reading a start code !
					mb_start_code_flag := 1;
				else	
					macroblock_address_increment := 33*mb_macroblock_escape_counter + mb_addr_inc_val;					
					mb_address_increment_flag := 1;																		
					macroblock_address := previous_macroblock_address + macroblock_address_increment;
					if macroblock_address_increment > 1 then // This means some macroblock are skipped
						// Reset the dct_dc_pred[cc]
						dct_dc_pred[0] := 128*(1 << intra_dc_precision);
						dct_dc_pred[1] := dct_dc_pred[0];
						dct_dc_pred[2] := dct_dc_pred[0];
					end
				end
			end
		end
		mb_address_increment_vld_counter := mb_address_increment_vld_counter + 1;	
	end

	mb_reading_start_code_prefix: action Bitstream: [token] repeat 15 ==>
	guard
		mb_start_code_flag = 1
	do
		foreach int i in 0 .. 14 do
			if token[i] != 0 then
			println("START CODE ERROR IN MACROBLOCK");
			end
		end
		nextbits := token[14];
	end

	mb_type: action Bitstream: [token] ==>
	guard
		mb_address_increment_flag = 1 and
		mb_type_flag = 0
	var
		int(size=8) macroblock_type
	do
		bit_buffer[mb_type_vld_counter] := token;
		compute_nextbits(0, mb_type_vld_counter);
		macroblock_type := macroblock_type_table[picture_coding_type -1][mb_type_vld_counter][nextbits][0];
		if macroblock_type != -1 then
			macroblock_quant 							:= macroblock_type;
			macroblock_motion_forward					:= macroblock_type_table[picture_coding_type -1][mb_type_vld_counter][nextbits][1];
			macroblock_motion_backward					:= macroblock_type_table[picture_coding_type -1][mb_type_vld_counter][nextbits][2];
			macroblock_pattern							:= macroblock_type_table[picture_coding_type -1][mb_type_vld_counter][nextbits][3];
			macroblock_intra							:= macroblock_type_table[picture_coding_type -1][mb_type_vld_counter][nextbits][4];
			spatial_temporal_weight_code_flag			:= macroblock_type_table[picture_coding_type -1][mb_type_vld_counter][nextbits][5];
			mb_type_flag := 1;
			// Choosing the VLD table to use for DCT coefficients
			bk_DCT_coef_table_to_use := macroblock_intra * intra_vlc_format;
		end
		// AFFICHAGE DEBUG
		// println("MB_TYPE_ERROR : nextbits = " + nextbits + ", counter = " + mb_type_vld_counter + ", picture_coding_type = " + picture_coding_type);
		
		mb_type_vld_counter := mb_type_vld_counter + 1;
	end
	
	mb_frame_motion_type: action Bitstream: [token] repeat 2 ==>
	guard
		mb_type_flag = 1,
		macroblock_motion_forward = 1 or macroblock_motion_backward = 1,
		picture_structure = 11,
		frame_pred_frame_dct = 0
	do
		bit_buffer := [token[i]: for int i in 0 .. 1];
		compute_nextbits(0, 1);
		frame_motion_type := nextbits;
		if frame_motion_type = 1 then
			motion_vector_count := 2;
			mv_format := 0; // = Field
			dmv := 0;
		else
			if frame_motion_type = 2 then
				motion_vector_count := 1;
				mv_format := 0; // = Field
				dmv := 0;
			else
				if frame_motion_type = 3 then
					motion_vector_count := 1;
					mv_format := 1; // = Frame
					dmv := 1;
				end
			end
		end
	end
	
	mb_not_frame_motion_type: action ==>
	guard
		mb_type_flag = 1 and
		(macroblock_motion_forward != 1 and macroblock_motion_backward != 1) or
		picture_structure != 11 or
		frame_pred_frame_dct != 0
	end
	
	mb_field_motion_type: action Bitstream: [token] repeat 2 ==>
	guard
		macroblock_motion_forward = 1 or macroblock_motion_backward = 1,
		picture_structure != 11
	do
		bit_buffer := [token[i]: for int i in 0 .. 1];
		compute_nextbits(0, 1);
		field_motion_type := nextbits;
		if field_motion_type = 1 then
			motion_vector_count := 1;
			mv_format := 0; // = Field
			dmv := 0;
		else 
			if field_motion_type = 2 then
				motion_vector_count := 2;
				mv_format := 0; // = Field
				dmv := 0;
			else
				if field_motion_type = 3 then
					motion_vector_count := 1;
					mv_format := 0; // = Field
					dmv := 1;
				end
			end
		end
	end
	
	mb_not_field_motion_type: action ==>
	guard
		(macroblock_motion_forward != 1 and macroblock_motion_backward != 1) or
		picture_structure = 11
	end
	
	mb_dct_type: action Bitstream: [token] ==>
	guard
		picture_structure = 11,
		frame_pred_frame_dct = 0,
		macroblock_intra = 1 or macroblock_pattern = 1
	do
		dct_type := token;
	end
	
	mb_not_dct_type: action ==>
	guard
		picture_structure != 11 or
		frame_pred_frame_dct != 0 or
		(macroblock_intra != 1 and macroblock_pattern != 1)
	end
	
	mb_macroblock_quant: action Bitstream: [token] repeat 5 ==>
	guard
		macroblock_quant = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 4];
		compute_nextbits(0, 4);
		quantiser_scale_code := nextbits;
		if q_scale_type = 0 then
			quantiser_scale := 2*quantiser_scale_code;
		else
			quantiser_scale := quantiser_scale_table[quantiser_scale_code];		
		end
		
	end
	
	mb_not_macroblock_quant: action ==>
	guard
		macroblock_quant = 0
	end
	
	// Motion Vectors

	mv_begin_motion_vector_0: action ==>
	guard
		macroblock_motion_forward = 1 or
		(macroblock_intra = 1 and concealment_motion_vectors = 1)
	do
		mv_r := 0;						// Setting up motion vector variables
		mv_s := 0;
		mv_t := 0;
		mv_motion_code_flag := 0;		// Setting vld flags and counter to 0;
		mv_motion_code_vld_counter := 0;
		mv_motion_residual_flag := 0;
		mv_motion_residual_vld_counter := 0;
		mv_dmvector_flag := 0;
		mv_dmvector_vld_counter := 0;
		mv_transition_flag := 0;
	end
	
	mv_not_begin_motion_vector_0: action ==>
	guard
		macroblock_motion_forward != 1 and
		(macroblock_intra != 1 or concealment_motion_vectors != 1)
	end

	mv_motion_vertical_field_select: action Bitstream: [token] ==>
	guard
		motion_vector_count != 1 or
		(motion_vector_count = 1 and mv_format = 0 and dmv != 1)
	do
		motion_vertical_field_select[mv_r][mv_s] := token;
	end
	
	mv_not_motion_vertical_field_select: action ==>
	guard
		motion_vector_count = 1 and
		(mv_format != 0 or dmv = 1)
	end
	
	mv_motion_code: action Bitstream: [token] ==>
	guard
		mv_motion_code_flag = 0
	do
		int(size=8)	mv_mc;
		bit_buffer[mv_motion_code_vld_counter] := token;
		compute_nextbits(0, mv_motion_code_vld_counter);
		mv_mc := motion_code_table[mv_motion_code_vld_counter][nextbits];
		if mv_mc != -1 then
			motion_code[mv_r][mv_s][mv_t] := mv_mc;
			mv_motion_code_flag := 1;
		end
		mv_motion_code_vld_counter := mv_motion_code_vld_counter + 1;
	end
	
	mv_motion_residual: action Bitstream: [token] ==>
	guard
		f_code[mv_s][mv_t] != 1,
		motion_code[mv_r][mv_s][mv_t] != 0,
		mv_motion_code_flag = 1,
		mv_motion_residual_flag = 0
	do
		bit_buffer[mv_motion_residual_vld_counter] := token;
		if mv_motion_residual_vld_counter + 1 = f_code[mv_s][mv_t] - 1 then
			compute_nextbits(0, mv_motion_residual_vld_counter);
			motion_residual[mv_r][mv_s][mv_t] := nextbits;
			mv_motion_residual_flag := 1;
		end
		mv_motion_residual_vld_counter := mv_motion_residual_vld_counter + 1;
	end
	
	mv_dmvector: action Bitstream: [token] ==>
	guard
		dmv = 1,
		mv_motion_code_flag = 1,
		mv_dmvector_flag = 0
	do
		if token = 0 and mv_dmvector_vld_counter = 0 then
			dmvector[mv_t] := 0;
			mv_dmvector_flag := 1;
		else
			bit_buffer[mv_dmvector_vld_counter] := token;
			compute_nextbits(0, mv_dmvector_vld_counter);
			if nextbits = 2 then
				dmvector[mv_t] := 1;
				mv_dmvector_flag := 1;
			else
				if nextbits = 3 then
					dmvector[mv_t] := -1;
					mv_dmvector_flag := 1;
				end
			end
		end
		mv_dmvector_vld_counter := mv_dmvector_vld_counter + 1;	
	end
	
	mv_transition: action ==>
	guard
		mv_motion_code_flag = 1
	do
		if mv_t = 0 then
			mv_t := 1;
			mv_transition_flag := 0;
		else
			if motion_vector_count = 2 and mv_r = 0 then
				mv_r := 1;
				mv_transition_flag := 1;
			else
				mv_transition_flag := 2;
			end
			
		end
		mv_motion_code_flag := 0;		// Setting vld flags and counter to 0;
		mv_motion_code_vld_counter := 0;
		mv_motion_residual_flag := 0;
		mv_motion_residual_vld_counter := 0;
		mv_dmvector_flag := 0;
		mv_dmvector_vld_counter := 0;
	end
	
	mv_transition_to_motion_code: action ==>
	guard
		mv_transition_flag = 0
	end
	
	mv_transition_to_begin: action ==>
	guard
		mv_transition_flag = 1
	end
	
	mv_transition_to_end: action ==>
	guard
		mv_transition_flag = 2
	end
	
	// Eat marker bit
	
	mb_eat_marker_bit: action Bitstream: [token] ==>
	guard
		macroblock_intra = 1,
		concealment_motion_vectors = 1
	end
	
	mb_not_eat_marker_bit: action ==>
	guard
		macroblock_intra != 1 or
		concealment_motion_vectors != 1
	end
	
	mb_codded_block_pattern: action Bitstream: [token] ==>
	guard
		macroblock_pattern = 1,
		cbp_flag = 0
	do
		bit_buffer[cbp_vld_counter] := token;
		if cbp_vld_counter > 1 then
			compute_nextbits(0, cbp_vld_counter);
			codded_block_pattern_420 := codded_block_pattern_table[cbp_vld_counter - 2][nextbits];
			if codded_block_pattern_420 != -1 then
				cbp := codded_block_pattern_420;
				cbp_flag := 1;
			end
		end
		cbp_vld_counter := cbp_vld_counter + 1;
	end
	
	mb_not_or_end_codded_block_pattern: action ==>
	guard
		macroblock_pattern != 1 or
		cbp_flag = 1
	do
		// Preparing for blocks !
		// Setting the "i" (bk_i) to 0
		bk_i := 0;
		// Calculating pattern_code[i]
		foreach int i in 0 .. 11 do
			if macroblock_intra = 1 then
				pattern_code[i] := 1;
			else
				pattern_code[i] := 0;
			end
		end
		if macroblock_pattern = 1 then
			foreach int j in 0 .. 5 do
				if (cbp & (1 << (5-j))) = 1 then
					pattern_code[j] := 1; 
				end
			end
		end
	end
	
	// Block
	
	bk_begin_block: action ==>
	guard
		bk_i < block_count
	do
		// Setting the flags and vld counters to 0
		bk_escape_flag := 0;
		bk_end_of_block_flag := 0;
		bk_coef_flag := 0;
		bk_coef_vld_counter := 0;
		bk_lum_flag := 0;
		bk_lum_vld_counter := 0;
		bk_chrom_flag := 0;
		bk_chrom_vld_counter := 0;
		bk_DC_coef_flag := 0;
		bk_diff_flag := 0;
		bk_diff_vld_counter := 0;
		qfs := [0 : for int i in 0 .. 63];
		qfs_counter := 0; 
		// AFFICHAGE DEBUG
		//println("Block " + bk_i);
	end
	
	bk_not_begin_block: action ==>
	guard
		bk_i >= block_count
	end
	
	bk_pattern_code_0: action  ==>
	guard
		pattern_code[bk_i] = 0
	do
		bk_i := bk_i + 1;
		// AFFICHAGE DEBUG
		//println("PATTERN_CODE_0");
	end
	
	bk_pattern_code_1_small_intra: action ==>
	guard
		pattern_code[bk_i] = 1,
		macroblock_intra = 1,
		bk_i < 4
	do
		bk_DC_coef_flag := 1;
	end

	bk_pattern_code_1_big_intra: action ==>
	guard
		pattern_code[bk_i] = 1,
		macroblock_intra = 1,
		bk_i >= 4
	do
		bk_DC_coef_flag := 1;
	end
	
	bk_pattern_code_1_non_intra: action ==>
	guard
		macroblock_intra != 1
	do
		// Reset the dct_dc_pred[cc]
		dct_dc_pred[0] := 128*(1 << intra_dc_precision);
		dct_dc_pred[1] := dct_dc_pred[0];
		dct_dc_pred[2] := dct_dc_pred[0];
	end
	
	bk_dct_dc_size_luminance: action Bitstream: [token] ==>
	guard
		bk_lum_flag = 0
	do
		bit_buffer[bk_lum_vld_counter] := token;
		compute_nextbits(0, bk_lum_vld_counter);
		// This is table B.12
		if bk_lum_vld_counter = 1 and nextbits = 0 then
			dct_dc_size_luminance := 1;
			bk_lum_flag := 1;
		else
			if bk_lum_vld_counter = 1 and nextbits = 1 then
				dct_dc_size_luminance := 2;
				bk_lum_flag := 1;
			else
				if bk_lum_vld_counter = 2 and nextbits = 4 then
					dct_dc_size_luminance := 0;
					dct_diff := 0;
					bk_lum_flag := 1;
					qfs[0] := dct_dc_pred[0]*8/(1 << intra_dc_precision);
					qfs_counter := 1;
					// AFFICHAGE DEBUG
					//println("luma_DC : 0");
				else
					if bk_lum_vld_counter = 2 and nextbits = 5 then
						dct_dc_size_luminance := 3;
						bk_lum_flag := 1;
					else
						if bk_lum_vld_counter = 2 and nextbits = 6 then
							dct_dc_size_luminance := 4;
							bk_lum_flag := 1;
						else
							if bk_lum_vld_counter = 3 and nextbits = 14 then
								dct_dc_size_luminance := 5;
								bk_lum_flag := 1;
							else
								if bk_lum_vld_counter = 4 and nextbits = 30 then
									dct_dc_size_luminance := 6;
									bk_lum_flag := 1;
								else
									if bk_lum_vld_counter = 5 and nextbits = 62 then
										dct_dc_size_luminance := 7;
										bk_lum_flag := 1;
									else
										if bk_lum_vld_counter = 6 and nextbits = 126 then
											dct_dc_size_luminance := 8;
											bk_lum_flag := 1;
										else
											if bk_lum_vld_counter = 7 and nextbits = 254 then
												dct_dc_size_luminance := 9;
												bk_lum_flag := 1;
											else
												if bk_lum_vld_counter = 8 and nextbits = 510 then
													dct_dc_size_luminance :=10;
													bk_lum_flag := 1;
												else
													if bk_lum_vld_counter = 8 and nextbits = 511 then
														dct_dc_size_luminance := 11;
														bk_lum_flag := 1;
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end			 
			end
		end
		bk_lum_vld_counter := bk_lum_vld_counter + 1;
	end
	
	bk_dct_dc_size_chrominance: action Bitstream: [token] ==>
	guard
		bk_chrom_flag = 0
	do
		bit_buffer[bk_chrom_vld_counter] := token;
		compute_nextbits(0, bk_chrom_vld_counter);
		// This is table B.13
		if bk_chrom_vld_counter = 1 and nextbits = 0 then
			dct_dc_size_chrominance := 0;
			dct_diff := 0;
			bk_chrom_flag := 1;
			if bk_i = 4 then
				qfs[0] := dct_dc_pred[1]* 8/(1 << intra_dc_precision);
			else
				qfs[0] := dct_dc_pred[2]* 8/(1 << intra_dc_precision);
			end
			qfs_counter := 1;
			// AFFICHAGE DEBUG
			//println("chroma_DC : 0");	
		else
			if bk_chrom_vld_counter = 1 and nextbits = 1 then
				dct_dc_size_chrominance := 1;
				bk_chrom_flag := 1;
			else
				if bk_chrom_vld_counter = 1 and nextbits = 2 then
					dct_dc_size_chrominance := 2;
					bk_chrom_flag := 1;
				else
					if bk_chrom_vld_counter = 2 and nextbits = 6 then
						dct_dc_size_chrominance := 3;
						bk_chrom_flag := 1;
					else
						if bk_chrom_vld_counter = 3 and nextbits = 14 then
							dct_dc_size_chrominance := 4;
							bk_chrom_flag := 1;
						else
							if bk_chrom_vld_counter = 4 and nextbits = 30 then
								dct_dc_size_chrominance := 5;
								bk_chrom_flag := 1;
							else
								if bk_chrom_vld_counter = 5 and nextbits = 62 then
									dct_dc_size_chrominance := 6;
									bk_chrom_flag := 1;
								else
									if bk_chrom_vld_counter = 6 and nextbits = 126 then
										dct_dc_size_chrominance := 7;
										bk_chrom_flag := 1;
									else
										if bk_chrom_vld_counter = 7 and nextbits = 254 then
											dct_dc_size_chrominance := 8;
											bk_chrom_flag := 1;
										else
											if bk_chrom_vld_counter = 8 and nextbits = 510 then
												dct_dc_size_chrominance := 9;
												bk_chrom_flag := 1;
											else
												if bk_chrom_vld_counter = 9 and nextbits = 1022 then
													dct_dc_size_chrominance :=10;
													bk_chrom_flag := 1;
												else
													if bk_chrom_vld_counter = 9 and nextbits = 1023 then
														dct_dc_size_chrominance := 11;
														bk_chrom_flag := 1;
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end			 
			end
		end
		bk_chrom_vld_counter := bk_chrom_vld_counter + 1;
	end
	
	bk_dct_dc_differential: action Bitstream: [token] ==>
	guard
		((bk_lum_flag = 1 and dct_dc_size_luminance != 0) or
		(bk_chrom_flag = 1 and dct_dc_size_chrominance != 0)) and
		bk_diff_flag = 0
	var
		uint(size=10) dct_dc_size
	do
		bit_buffer[bk_diff_vld_counter] := token;
		if bk_i < 4 then
			dct_dc_size := dct_dc_size_luminance;
		else
			dct_dc_size := dct_dc_size_chrominance;
		end
		if bk_diff_vld_counter + 1 = dct_dc_size then
			compute_nextbits(0, bk_diff_vld_counter);
			dct_dc_differential := nextbits;
			bk_diff_flag := 1;
			// Calculus of dct_diff
			half_range := 1 << (dct_dc_size - 1);
			if dct_dc_differential >= half_range then
				dct_diff := dct_dc_differential;
			else
				dct_diff := (dct_dc_differential + 1) - 2*half_range;
			end
			if bk_i < 4 then
				signed_level := dct_dc_pred[0] + dct_diff;
				dct_dc_pred[0] := signed_level;
			else
				if bk_i = 4 then
					signed_level := dct_dc_pred[1] + dct_diff;
					dct_dc_pred[1] := signed_level;
				else
					signed_level := dct_dc_pred[2] + dct_diff;
					dct_dc_pred[2] := signed_level;
				end
			end
			signed_level := signed_level * 8/(1 << intra_dc_precision);
			// AFFICHAGE DEBUG
			if bk_i < 4 then //println("luma_DC : " + dct_diff);
			else			 //println("chroma_DC : " + dct_diff);
			end
		end
		bk_diff_vld_counter := bk_diff_vld_counter + 1;
	end	
	
	bk_end_dct_dc_differential: action ==>
	guard
		bk_diff_flag = 1
	do
		qfs[0] := signed_level;
		qfs_counter := qfs_counter + 1;
	end
	
	bk_no_dct_dc_differential: action ==>
	guard
		((bk_lum_flag = 1 and dct_dc_size_luminance = 0) or
		(bk_chrom_flag = 1 and dct_dc_size_chrominance = 0))
	end
	
	bk_dct_coefficients: action Bitstream: [token] ==>
	guard
		bk_coef_flag = 0
	do
		bit_buffer[bk_coef_vld_counter] := token;
		compute_nextbits(0, bk_coef_vld_counter);
		bk_coef_vld := DCT_coefficients_table[bk_DCT_coef_table_to_use][bk_coef_vld_counter][nextbits][0];
		if bk_coef_vld != -1 then
			if bk_coef_vld = -4 then 		// See Notes 3 and 4 of table B.14
				if bk_DC_coef_flag = 0 then
					run :=  0;
					level := 1;
					bk_coef_flag := 1;
					bk_DC_coef_flag := 1;
				else
					bk_coef_vld_counter := bk_coef_vld_counter + 1;	
				end
			else
				if bk_coef_vld = -2 then	// End of block
					bk_end_of_block_flag := 1;
					bk_coef_flag := 1;
					bk_DC_coef_flag := 1;
				else
					if bk_coef_vld = -3 then // Escape
						bk_escape_flag := 1;
						bk_coef_flag := 1;
						bk_DC_coef_flag := 1;
					else
						run := bk_coef_vld;
						level := DCT_coefficients_table[bk_DCT_coef_table_to_use][bk_coef_vld_counter][nextbits][1];
						bk_coef_flag := 1;
						bk_DC_coef_flag := 1;
					end			
				end
			end
		else
			bk_coef_vld_counter := bk_coef_vld_counter + 1;
		end			
	end
	
	bk_signe_level: action Bitstream: [token] ==>
	guard
		bk_coef_flag = 1,
		bk_end_of_block_flag = 0,
		bk_escape_flag = 0
	do
		if token = 1 then 
			signed_level := - level;
		else
			signed_level := level;
		end
		bk_coef_flag := 0;
		bk_coef_vld_counter := 0;
		bk_DC_coef_flag := 1;
		qfs[qfs_counter + run] := signed_level;
		qfs_counter := qfs_counter + run + 1;
		// AFFICHAGE DEBUG
		//println("run : " + run + " level : " + signed_level);	
	end
	
	bk_escape: action Bitstream: [token] repeat 18 ==>
	guard
		bk_escape_flag = 1
	do
		bit_buffer := [token[i]: for int i in 0 .. 17];
		compute_nextbits(0, 5);
		run := nextbits;
		compute_nextbits(6, 17);
		signed_level := nextbits;
		if signed_level >= 2048 then
			signed_level := signed_level - 4096;
		end
		bk_coef_flag := 0;
		bk_escape_flag := 0;
		bk_coef_vld_counter := 0;
		bk_DC_coef_flag := 1;
		qfs[qfs_counter + run] := signed_level;
		qfs_counter := qfs_counter + run + 1;
		// AFFICHAGE DEBUG
		//println("run : " + run + " level : " + signed_level);
	end
	
	bk_end_of_block: action ==> QFS: [qfs] repeat 64, MB_INTRA: [macroblock_intra],  QUANTISER_SCALE: [quantiser_scale], ALTERNATE_SCAN: [alternate_scan]
	guard
		bk_end_of_block_flag = 1
	do
		bk_i := bk_i + 1;
		// AFFICHAGE DEBUG
		//println("EOB");
		// DEBUG
		/*
		if bk_i = 6 then 
			currentMB := currentMB + 1;
			println("MB : " + currentMB);
		end
		*/
	end
	
	schedule fsm next_start_code :
	
		// Read the next start code
		next_start_code				(start_code_prefix)						-->		read_start_code;
		read_start_code				(eat_stuffing_bit)						-->		read_start_code;
		read_start_code				(read_start_code)						-->		go_to_code;
		
		// Read the next extension start code
		go_to_code					(read_extension_start_code)				-->		go_to_extension_code;
	
		// Sequence Header
		go_to_code					(sh_sequence_header)					-->		load_q_matrix;
		load_q_matrix				(sh_read_intra_quantiser_matrix)		-->		load_nq_matrix;
		load_q_matrix				(sh_check_non_intra_quantiser_matrix)	-->		load_nq_matrix;
		load_nq_matrix				(sh_read_non_intra_quantiser_matrix)	-->		next_start_code;
		load_nq_matrix				(sh_not_read_non_intra_quantiser_matrix)-->		next_start_code;
		
		// Sequence Extension
		go_to_extension_code		(se_sequence_extension)					-->		next_start_code;		
		go_to_extension_code		(se_not_next_extension_start_code)		-->		next_start_code;	// This case means MPEG1 --> stop ! 
		
		// Begining of the do-loop 1
		
		// Sequence Display Extension																										
		go_to_extension_code		(sde_sequence_display_extension)		-->		sde_read_colour;
		sde_read_colour				(sde_read_colour)						-->		next_start_code;
		sde_read_colour				(sde_not_read_colour)					-->		next_start_code;
		// Quant Matrix Extension
		go_to_extension_code		(quant_matrix_extension)				-->		load_q_matrix;
		// Copyright Extension
		go_to_extension_code		(copyright_extension)					-->		next_start_code;
		// Picture Display Extension	// Not codded yet
		go_to_extension_code		(picture_display_extension)				-->		next_start_code;
		// ITU-T Extension				// What is ITU-t_data ? This action is remplaced by eat_bit !
		go_to_extension_code		(ITUT_extension)						-->		next_start_code;
	
		// User Data
		go_to_code					(ud_user_data)							-->		read_user_data;
		read_user_data				(ud_read_user_data)						-->		read_user_data;
		read_user_data				(start_code_prefix)						-->		read_start_code;
		
		// Group of Pictures Header
		go_to_code					(group_of_pictures_header)				-->		next_start_code;
		
		// Picture Header
		go_to_code					(ph_picture_header)						-->		begin_picture_header;
		begin_picture_header		(ph_picture_coding_type_2)				-->		ph_extra_bit_picture;
		begin_picture_header		(ph_picture_coding_type_3)				-->		ph_extra_bit_picture;
		begin_picture_header		(ph_picture_coding_type_else)			-->		ph_extra_bit_picture;
		ph_extra_bit_picture		(ph_extra_bit_picture_1)				-->		ph_extra_bit_picture;
		ph_extra_bit_picture		(ph_extra_bit_picture_0)				-->		next_start_code;

		// Picture Coding Extension
		go_to_extension_code		(pce_picture_coding_extension)			--> 	pce_composite_display;
		pce_composite_display		(pce_composite_display)					-->		next_start_code;
		pce_composite_display		(pce_not_composite_display)				-->		next_start_code;
		
		// Slice
		go_to_code					(sl_big_slice)							-->		sl_slice_extension;	
		go_to_code					(sl_small_slice)						-->		sl_slice_extension;
		sl_slice_extension			(sl_slice_extension)					-->		sl_extra_info_slice;
		sl_slice_extension			(sl_slice_end)							-->		begin_macroblock;
		sl_extra_info_slice			(sl_extra_information_slice)			-->		sl_extra_info_slice;
		sl_extra_info_slice			(sl_slice_end)							-->		begin_macroblock;
		
		// Macorblock
		begin_macroblock			(begin_macroblock)						-->		macroblock_address;
		macroblock_address			(mb_macroblock_address)					-->		macroblock_address;
		macroblock_address			(mb_type)								-->		macroblock_type;
		macroblock_address			(mb_reading_start_code_prefix)			-->		read_start_code;
		
		macroblock_type				(mb_type)								-->		macroblock_type;
		macroblock_type				(mb_frame_motion_type)					-->		field_motion_type;
		macroblock_type				(mb_not_frame_motion_type)				-->		field_motion_type;
		field_motion_type			(mb_field_motion_type)					-->		dct_type;
		field_motion_type			(mb_not_field_motion_type)				-->		dct_type;
		dct_type					(mb_dct_type)							-->		quantiser_scale;
		dct_type					(mb_not_dct_type)						-->		quantiser_scale;
		quantiser_scale				(mb_macroblock_quant)					-->		begin_motion_vector_0;
		quantiser_scale				(mb_not_macroblock_quant)				-->		begin_motion_vector_0;

		// Motion Vectors --> NOT TESTED YET
		begin_motion_vector_0		(mv_begin_motion_vector_0)				-->		vertical_field_select;
		begin_motion_vector_0		(mv_not_begin_motion_vector_0)			-->		eat_marker_bit;
		vertical_field_select		(mv_motion_vertical_field_select)		-->		motion_code;
		vertical_field_select		(mv_not_motion_vertical_field_select)	-->		motion_code;
		motion_code					(mv_motion_code)						-->		motion_code;
		motion_code					(mv_motion_residual)					-->		motion_residual;
		motion_code					(mv_dmvector)							-->		dmvector;
		motion_code					(mv_transition)							-->		transition;
		motion_residual				(mv_motion_residual)					-->		motion_residual;
		motion_residual				(mv_dmvector)							-->		dmvector;
		motion_residual				(mv_transition)							-->		transition;
		dmvector					(mv_dmvector)							-->		dmvector;
		dmvector					(mv_transition)							-->		transition;
		transition					(mv_transition_to_motion_code)			-->		motion_code;
		transition					(mv_transition_to_begin)				-->		vertical_field_select;
		transition					(mv_transition_to_end)					-->		eat_marker_bit;
		
		// Codded Block Pattern
		eat_marker_bit				(mb_eat_marker_bit)						-->		codded_block_pattern;
		eat_marker_bit				(mb_not_eat_marker_bit)					-->		codded_block_pattern;
		codded_block_pattern		(mb_codded_block_pattern)				-->		codded_block_pattern;
		codded_block_pattern		(mb_not_or_end_codded_block_pattern)	-->		begin_block;
		
		// Block
		begin_block					(bk_begin_block)						-->		block;
		begin_block					(bk_not_begin_block)					-->		begin_macroblock;
		block						(bk_pattern_code_0)						-->		begin_block;
		block						(bk_pattern_code_1_non_intra)			-->		dct_coefficients;
		block						(bk_pattern_code_1_big_intra)			-->		dct_dc_chrominance;
		block						(bk_pattern_code_1_small_intra)			-->		dct_dc_luminance;
		dct_dc_luminance			(bk_dct_dc_size_luminance)				-->		dct_dc_luminance;
		dct_dc_luminance			(bk_dct_dc_differential)				-->		dct_dc_differential;
		dct_dc_luminance			(bk_no_dct_dc_differential)				-->		dct_coefficients;
		dct_dc_chrominance			(bk_dct_dc_size_chrominance)			-->		dct_dc_chrominance;
		dct_dc_chrominance			(bk_dct_dc_differential)				-->		dct_dc_differential;
		dct_dc_chrominance			(bk_no_dct_dc_differential)				-->		dct_coefficients;
		dct_dc_differential			(bk_dct_dc_differential)				-->		dct_dc_differential;
		dct_dc_differential			(bk_end_dct_dc_differential)			-->		dct_coefficients;
		dct_coefficients			(bk_dct_coefficients)					-->		dct_coefficients;
		dct_coefficients			(bk_signe_level)						-->		dct_coefficients;
		dct_coefficients			(bk_escape)								-->		dct_coefficients;
		dct_coefficients			(bk_end_of_block)						-->		begin_block;
			
		// debug						(LOOK_FOLLOWING_BITS)					-->		next_start_code;
		
	end
	
	priority
		start_code_prefix	>	ud_read_user_data;
		start_code_prefix	>	begin_macroblock;
		mv_motion_residual	>	mv_dmvector	>	mv_transition;
	end	
	
end