/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
package ch.epfl.mpeg4.part10.cbp.synParser.modular.decodePicture;

import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import org.mpeg4.part10.cbp.synParser.modular.cavlcLookUpTables.*;
import std.util.BitOps.*;

actor Algo_Slice_layer_without_partitioning()
	uint(size=8)  RbspByte,
	bool          NewNal,

	int (size=6)  Header1TypeOfVLD,
	int (size=32) Header1VLDParam,

	int (size=6)  Header2TypeOfVLD,
	int (size=32) Header2VLDParam,

	uint(size=5)  DecRefPicMarkingTypeOfVLD,
	int (size=32) DecRefPicMarkingNbBitsToRead,

	uint(size=5)  RefPicListTypeOfVLD,
	int (size=32) RefPicListNbBitsToRead,

	int (size=6)  DataTypeOfVLD,
	int (size=32) DataVLDParam,

	int (size=6)  MbLayerTypeOfVLD,
	int (size=32) MbLayerVLDParam,

	uint(size=5)  MbPredTypeOfVLD,
	int (size=32) MbPredNbBitsToRead,

	uint(size=5)  SubMbPredTypeOfVLD,
	int (size=32) SubMbPredNbBitsToRead,

	int (size=6)  ResTypeOfVLD,
	int (size=32) ResActorLaunched,

	uint(size=5)  ResBlkCavlcTypeOfVLD,
	int (size=32) ResBlkCavlcVLD_Param
		==>
	int (size=32) Header1ValVLD,
	int (size=32) Header2ValVLD,
	int (size=32) DecRefPicMarkingValVLD,
	int (size=32) RefPicListValVLD,
	int (size=32) DataValVLD,
	int (size=32) MbLayerValVLD,
	int (size=32) MbPredValVLD,
	int (size=32) SubMbPredValVLD,
	int (size=32) ResBlkCavlcValVLD
		:

	uint(size=8) callStack[16];
	uint(size=3) stackIdx;

	uint(size=32) nbParamToDecod := 0;

	initialize ==>
	do
		stackIdx := 0;
		callStack[0] := SLICE_HEADER1;
	end

	findOutNextActor.isSliceHeader1: action ==>
	guard
		callStack[stackIdx] = SLICE_HEADER1
	end

	findOutNextActor.isSliceHeader2Avc: action ==>
	guard
		callStack[stackIdx] = SLICE_HEADER2
	end

	findOutNextActor.isRefPicMark: action ==>
	guard
		callStack[stackIdx] = REF_PIC_MARKING
	end

	findOutNextActor.isRefPicList: action ==>
	guard
		callStack[stackIdx] = REF_PIC_LIST
	end

	findOutNextActor.isSliceData: action ==>
	guard
		callStack[stackIdx] = SLICE_DATA
	end

	findOutNextActor.isMbLayer: action ==>
	guard
		callStack[stackIdx] = MB_LAYER
	end

	findOutNextActor.isMbPred: action ==>
	guard
		callStack[stackIdx] = MB_PRED
	end

	findOutNextActor.isSubMbPred: action ==>
	guard
		callStack[stackIdx] = SUB_MB_PRED
	end

	findOutNextActor.isResidual: action ==>
	guard
		callStack[stackIdx] = RESIDUAL
	end

	findOutNextActor.isResidualCavlc: action ==>
	guard
		callStack[stackIdx] = RESIDUAL_BLOCK_CAVLC
	end

	SliceHeader1.GetVLDVal.Launch: action ==>
		Header1ValVLD :[valDecoded]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end

	SliceHeader1.GetVLDVal.Done: action ==>
	guard
		nbParamToDecod = 0
	end

	SliceHeader1.WaitVLDVal: action ==>
	guard
		nbParamToDecod > 0
	end

	SliceHeader1.FunctionWithoutParam: action Header1TypeOfVLD :[ValTypeOfVLD] ==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 0,
		ValTypeOfVLD  != SKIP_NAL
	do
		typeOfVld := ValTypeOfVLD;
		if(ValTypeOfVLD != BYTE_ALIGNED_REQUIRED)then
			nbParamToDecod := nbParamToDecod + 1;
		end
	end

	SliceHeader1.FunctionWith1Param: action
		Header1TypeOfVLD :[ValTypeOfVLD],
		Header1VLDParam  :[Param]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 1
	do
		typeOfVld := ValTypeOfVLD;
		vldParam[0] := Param;
		nbParamToDecod := nbParamToDecod + 1;
	end

	SliceHeader1.LaunchActor: action
		Header1TypeOfVLD :[Function],
		Header1VLDParam  :[Actor]
			==>
	guard
		Function = LAUNCH_ACTOR
	do
		stackIdx       := (stackIdx + 1) &0x0F;
		callStack[stackIdx] := Actor;
	end

	SliceHeader1.Done: action Header1TypeOfVLD :[Function] ==>
	guard
		Function = SKIP_NAL
	end

	SliceHeader2.GetVLDVal.Launch: action ==>
		Header2ValVLD :[valDecoded]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end

	SliceHeader2.GetVLDVal.Done: action ==>
	guard
		nbParamToDecod = 0
	end

	SliceHeader2.WaitVLDVal: action ==>
	guard
		nbParamToDecod > 0
	end

	SliceHeader2.FunctionWithoutParam: action Header2TypeOfVLD :[ValTypeOfVLD] ==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 0,
		ValTypeOfVLD  != SKIP_NAL
	do
		typeOfVld := ValTypeOfVLD;
		if(ValTypeOfVLD != BYTE_ALIGNED_REQUIRED)then
			nbParamToDecod := nbParamToDecod + 1;
		end
	end

	SliceHeader2.FunctionWith1Param: action
		Header2TypeOfVLD :[ValTypeOfVLD],
		Header2VLDParam  :[Param]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 1
	do
		typeOfVld := ValTypeOfVLD;
		vldParam[0] := Param;
		nbParamToDecod := nbParamToDecod + 1;
	end

	SliceHeader2.LaunchActor: action
		Header2TypeOfVLD :[Function],
		Header2VLDParam  :[Actor]
			==>
	guard
		Function = LAUNCH_ACTOR
	do
		stackIdx := (stackIdx + 1) & 0x0F;
		callStack[stackIdx] := Actor;
	end

	SliceHeader2.Done: action Header2TypeOfVLD :[Function] ==>
	guard
		Function = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	RefPicMark.GetVLDVal.Launch: action
			==>
		DecRefPicMarkingValVLD :[valDecoded]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end

	RefPicMark.GetVLDVal.Done: action ==>
	guard
		nbParamToDecod = 0
	end

	RefPicMark.WaitVLDVal: action ==>
	guard
		nbParamToDecod > 0
	end

	RefPicMark.FunctionWithoutParam: action
		DecRefPicMarkingTypeOfVLD :[ValTypeOfVLD]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 0,
		ValTypeOfVLD  != SKIP_NAL
	do
		typeOfVld := ValTypeOfVLD;
		if(ValTypeOfVLD != BYTE_ALIGNED_REQUIRED)then
			nbParamToDecod := nbParamToDecod + 1;
		end
	end

	RefPicMark.FunctionWith1Param: action
		DecRefPicMarkingTypeOfVLD    :[ValTypeOfVLD],
		DecRefPicMarkingNbBitsToRead :[Param]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 1
	do
		typeOfVld := ValTypeOfVLD;
		vldParam[0] := Param;
		nbParamToDecod := nbParamToDecod + 1;
	end

	RefPicMark.Done: action DecRefPicMarkingTypeOfVLD :[Function] ==>
	guard
		Function = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	RefPicList.GetVLDVal.Launch: action
			==>
		RefPicListValVLD :[valDecoded]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end

	RefPicList.GetVLDVal.Done: action ==>
	guard
		nbParamToDecod = 0
	end

	RefPicList.WaitVLDVal: action ==>
	guard
		nbParamToDecod > 0
	end

	RefPicList.FunctionWithoutParam: action
		RefPicListTypeOfVLD :[ValTypeOfVLD]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 0,
		ValTypeOfVLD  != SKIP_NAL
	do
		typeOfVld := ValTypeOfVLD;
		if(ValTypeOfVLD != BYTE_ALIGNED_REQUIRED)then
			nbParamToDecod := nbParamToDecod + 1;
		end
	end

	RefPicList.FunctionWith1Param: action
		RefPicListTypeOfVLD    :[ValTypeOfVLD],
		RefPicListNbBitsToRead :[Param]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 1
	do
		typeOfVld := ValTypeOfVLD;
		vldParam[0] := Param;
		nbParamToDecod := nbParamToDecod + 1;
	end

	RefPicList.Done: action RefPicListTypeOfVLD :[Function] ==>
	guard
		Function = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	SliceData.GetVLDVal.Launch: action ==>
		DataValVLD :[valDecoded]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end

	SliceData.GetVLDVal.Done: action ==>
	guard
		nbParamToDecod = 0
	end

	SliceData.WaitVLDVal: action ==>
	guard
		nbParamToDecod > 0
	end

	SliceData.FunctionWithoutParam: action
		DataTypeOfVLD :[ValTypeOfVLD]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 0,
		ValTypeOfVLD  != SKIP_NAL
	do
		typeOfVld := ValTypeOfVLD;
		if(ValTypeOfVLD != BYTE_ALIGNED_REQUIRED)then
			nbParamToDecod := nbParamToDecod + 1;
		end
	end

	SliceData.FunctionWith1Param: action
		DataTypeOfVLD :[ValTypeOfVLD],
		DataVLDParam  :[Param]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 1
	do
		typeOfVld := ValTypeOfVLD;
		vldParam[0] := Param;
		nbParamToDecod := nbParamToDecod + 1;
	end

	SliceData.LaunchActor: action
		DataTypeOfVLD :[Function],
		DataVLDParam  :[Actor]
			==>
	guard
		Function = LAUNCH_ACTOR
	do
		stackIdx := (stackIdx + 1) & 0x0F;
		callStack[stackIdx] := Actor;
	end

	SliceData.Done: action DataTypeOfVLD :[Function] ==>
	guard
		Function = SKIP_NAL
	do
		typeOfVld := Function;
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	MbLayer.GetVLDVal.Launch: action ==> MbLayerValVLD :[valDecoded]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end

	MbLayer.GetVLDVal.Done: action ==> 
	guard
		nbParamToDecod = 0
	end

	MbLayer.WaitVLDVal: action ==>
	guard
		nbParamToDecod > 0
	end

	MbLayer.FunctionWithoutParam: action
		MbLayerTypeOfVLD :[ValTypeOfVLD]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 0,
		ValTypeOfVLD  != SKIP_NAL
	do
		typeOfVld := ValTypeOfVLD;
		if(ValTypeOfVLD != BYTE_ALIGNED_REQUIRED)then
			nbParamToDecod := nbParamToDecod + 1;
		end
	end

	MbLayer.FunctionWith1Param: action
		MbLayerTypeOfVLD :[ValTypeOfVLD],
		MbLayerVLDParam  :[Param]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 1
	do
		typeOfVld := ValTypeOfVLD;
		vldParam[0] := Param;
		nbParamToDecod := nbParamToDecod + 1;
	end

	MbLayer.LaunchActor : action
		MbLayerTypeOfVLD :[Function],
		MbLayerVLDParam  :[Actor]
			==>
	guard
		Function = LAUNCH_ACTOR
	do
		stackIdx := (stackIdx + 1) & 0x0F;
		callStack[stackIdx] := Actor;
	end

	MbLayer.Done: action
		MbLayerTypeOfVLD :[Function]
			==>
	guard
		Function = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	MbPred.GetVLDVal.Launch: action ==>
		MbPredValVLD :[valDecoded]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end

	MbPred.GetVLDVal.Done: action ==>
	guard
		nbParamToDecod = 0
	end

	MbPred.WaitVLDVal: action ==>
	guard
		nbParamToDecod > 0
	end

	MbPred.FunctionWithoutParam: action MbPredTypeOfVLD :[ValTypeOfVLD] ==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 0,
		ValTypeOfVLD  != SKIP_NAL
	do
		typeOfVld := ValTypeOfVLD;
		if(ValTypeOfVLD != BYTE_ALIGNED_REQUIRED)then
			nbParamToDecod := nbParamToDecod + 1;
		end
	end

	MbPred.FunctionWith1Param: action
		MbPredTypeOfVLD    :[ValTypeOfVLD],
		MbPredNbBitsToRead :[VldParameter]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 1
	do
		typeOfVld := ValTypeOfVLD;
		vldParam[0] := VldParameter;
		nbParamToDecod := nbParamToDecod + 1;
	end

	MbPred.Done: action MbPredTypeOfVLD :[Function] ==>
	guard
		Function = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	SubMbPred.GetVLDVal.Launch: action ==>
			SubMbPredValVLD :[valDecoded]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end

	SubMbPred.GetVLDVal.Done: action ==>
	guard
		nbParamToDecod = 0
	end

	SubMbPred.WaitVLDVal: action ==>
	guard
		nbParamToDecod > 0
	end

	SubMbPred.FunctionWithoutParam: action SubMbPredTypeOfVLD :[ValTypeOfVLD]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 0,
		ValTypeOfVLD  != SKIP_NAL
	do
		typeOfVld := ValTypeOfVLD;
		if(ValTypeOfVLD != BYTE_ALIGNED_REQUIRED)then
			nbParamToDecod := nbParamToDecod + 1;
		end
	end

	SubMbPred.FunctionWith1Param: action
		SubMbPredTypeOfVLD    :[ValTypeOfVLD],
		SubMbPredNbBitsToRead :[VldParam]
			==>
	guard
			NbParamForFunction(ValTypeOfVLD) = 1
	do
		typeOfVld := ValTypeOfVLD;
		vldParam[0] := VldParam;
		nbParamToDecod := nbParamToDecod + 1;
	end

	SubMbPred.Done: action
		SubMbPredTypeOfVLD :[Function]
			==>
	guard
		Function = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end


	Residual.LaunchActor: action
		ResTypeOfVLD     :[Function],
		ResActorLaunched :[Actor]
			==>
	guard
		Function = LAUNCH_ACTOR
	do
		stackIdx := (stackIdx + 1) & 0x0F;
		callStack[stackIdx] := Actor;
	end

	Residual.Done: action
		ResTypeOfVLD :[Function]
			==>
	guard
		Function = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	ResBlkCavlc.GetVLDVal.Launch: action
			==>
		ResBlkCavlcValVLD :[valDecoded]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end

	ResBlkCavlc.GetVLDVal.Done: action
			==>
	guard
		nbParamToDecod = 0
	end

	ResBlkCavlc.FunctionWithoutParam: action
		ResBlkCavlcTypeOfVLD :[ValTypeOfVLD]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 0,
		ValTypeOfVLD != SKIP_NAL
	do
		typeOfVld := ValTypeOfVLD;
		if(ValTypeOfVLD != BYTE_ALIGNED_REQUIRED)then
			nbParamToDecod := nbParamToDecod + 1;
		end
	end

	ResBlkCavlc.FunctionWith1Param: action
		ResBlkCavlcTypeOfVLD :[ValTypeOfVLD],
		ResBlkCavlcVLD_Param :[Param]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 1
	do
		typeOfVld := ValTypeOfVLD;
		vldParam[0] := Param;
		nbParamToDecod := nbParamToDecod + 1;
	end

	ResBlkCavlc.FunctionWith2Param: action
		ResBlkCavlcTypeOfVLD :[ValTypeOfVLD],
		ResBlkCavlcVLD_Param :[Param1 , Param2]
			==>
	guard
		NbParamForFunction(ValTypeOfVLD) = 2
	do
		typeOfVld   := ValTypeOfVLD;
		vldParam[0] := Param1;
		vldParam[1] := Param2;
		nbParamToDecod := nbParamToDecod + 1;
	end

	ResBlkCavlc.WaitVLDVal: action ==>
	guard
		nbParamToDecod > 0
	end

	ResBlkCavlc.Done: action
		ResBlkCavlcTypeOfVLD :[Function]
			==>
	guard
		Function = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end




	bool DEBUG_FLAG_DECODED = false;


	//Contains the Byte which is currently read.
	uint(size=16) WorkingByte      := 0;
	//Contains the number of bit which are not read yet in WorkingByte
	uint(size=4)  CountBufferRbsp  := 0;
	//Contains up to 4 next byte in the flow. It helps for more_rbsp_data()
	uint(size=3)  SizeBufferRbsp   := 0;
	List(type: uint(size=8), size=4) BufferRbsp := [0: for int s in 0 .. 3];
	/* ue(v) and Cavlc coeff_token()*/
	bool          Bit1Found       := false;
	uint(size=5)  leadingZeroBits := 0;
	/* ue(v) only */
	int (size=31) CodeNum         := 0;
	/* u(n) */
	uint(size=5)  BitsCount       := 0;
	uint(size=31) ReadValue       := 0;
	uint(size=1)  TeVal           := 0;
	/* more_rbsp_data() */
	bool          NewNalAlreadyDetected  := false;
	/* Cavlc */
	uint(size=5) NbBitsRead;
	/* Cavlc coeff_token */
	uint(size=3) Idx_nC;
	uint(size=6) coeff_token;
	/* Cavlc total_zeros and run_before */
	uint(size=3) ValRead         := 0;
	/* Cavlc total_zeros */
	uint(size=2) IdxmaxNumCoeff  := 0;
	uint(size=4) TotalCoeffParam := 0;
	/* Cavlc run_before */
	uint(size=8) IdxzerosLeft    := 0;

	uint(size=5) typeOfVld;
	int(size=32) valDecoded;
	int(size=32) vldParam[2];

	uint(size=32) Out_ReadNBits;
	procedure ReadNBitsInWorkingByte(uint(size=32) InitialValue, uint(size=4) NbBitsToRead)
	begin
			Out_ReadNBits    := InitialValue << NbBitsToRead;
			Out_ReadNBits    := Out_ReadNBits + selectBits(WorkingByte >> (8-NbBitsToRead), 0 , NbBitsToRead);
			WorkingByte     := WorkingByte << NbBitsToRead;
			CountBufferRbsp := CountBufferRbsp - NbBitsToRead;
	end


	//Syntaxe decoding have finished the decoding of this Nal
	IsEndOfNal: action ==>
	guard
		typeOfVld    = SKIP_NAL
	do
		CountBufferRbsp := 0;
		SizeBufferRbsp  := 0;
	end

	//We skip all bytes in the current nal
	WaitForNewNal: action NewNal :[IsNewNal], RbspByte :[ValRbsp] ==>
	guard
		IsNewNal = false
	end

	NewNalDetected: action NewNal :[IsNewNal] ==>
	guard
		IsNewNal = true
	do
		SizeBufferRbsp := 0;
	end

	NewNalHasBeenSent: action ==>
	guard
		NewNalAlreadyDetected = true
	end

	ResetNewNalAlreadyDetected: action ==>
	do
		NewNalAlreadyDetected := false;
	end

	IsMoreRbspData: action ==>
	guard
		typeOfVld = MORE_RBSP_DATA
	end

	CheckSizeBufferRbsp.IsEqualOrSupTo2: action ==>
	guard
		SizeBufferRbsp >= 2
	do
		valDecoded := 1;
	end

	CheckSizeBufferRbsp.IsEqualTo1: action ==>
	guard
		SizeBufferRbsp = 1
	do
		if(((WorkingByte = 0 and (BufferRbsp[0] & 0xFF) = 0x03) or 
		   ((BufferRbsp[0] & 0xFF) = 0x80)) and (CountBufferRbsp = 0) )then
			valDecoded := 0;
		else
			valDecoded := 1;
		end
	end

	CheckSizeBufferRbsp.IsEqualTo0: action ==>
	guard
		SizeBufferRbsp = 0
	do
		valDecoded :=
			if( (WorkingByte & 0xFF) = 0x80 )then
				 0
			else
				1
			end;
	end

	FillBufferRbsp: action RbspByte :[ValRbspByte], NewNal :[ValNewNal] ==>
	guard
		SizeBufferRbsp        < 4,
		ValNewNal             = false,
		NewNalAlreadyDetected = false
	do
		BufferRbsp[3]  := BufferRbsp[2];
		BufferRbsp[2]  := BufferRbsp[1];
		BufferRbsp[1]  := BufferRbsp[0];
		BufferRbsp[0]  := ValRbspByte;
		SizeBufferRbsp := SizeBufferRbsp + 1;
	end

	FutureNewNalDetected: action NewNal :[IsNewNal] ==>
	guard
		IsNewNal              = true,
		NewNalAlreadyDetected = false
	do
		NewNalAlreadyDetected := true;
	end

	IsVldUe: action ==>
	guard
		typeOfVld = VLD_UE
	do
		Bit1Found       := false;
		leadingZeroBits := 0;
		CodeNum         := 0;
	end


	IsVldSe: action ==>
	guard
		typeOfVld = VLD_SE
	do
		Bit1Found       := false;
		leadingZeroBits := 0;
		CodeNum         := 0;
	end

	IsReadBits: action ==>
	guard
		typeOfVld = READ_BITS
	do
		BitsCount := vldParam[0];
		ReadValue := 0;
		TeVal     := 0;
	end

	IsVldTe.u: action ==>
	guard
		typeOfVld = VLD_TE,
		vldParam[0]    = 1
	do
		BitsCount := 1;
		ReadValue := 0;
		TeVal     := 1;
	end

	IsVldTe.ue: action ==>
	guard
		typeOfVld = VLD_TE,
		vldParam[0]    > 1
	do
		Bit1Found       := false;
		leadingZeroBits := 0;
		CodeNum         := 0;
	end

	IsCavlcCoeffToken: action ==>
	guard
		typeOfVld= CAVLC_COEFF_TOKEN
	do
		uint(size=8) nC = vldParam[0];
		Idx_nC :=
			if(nC < 0)then
				if(nC = -1)then
					 4
				else
					5
				end
			else
				if(nC >=8)then
					3
				else
					if(nC >=4)then
						2
					else
						nC/2
					end
				end
			end;
		coeff_token := 0;
		NbBitsRead := 0;
	end

	IsCavlcTotalZeros: action ==>
	guard
		typeOfVld = CAVLC_TOTAL_ZEROS
	do
		uint(size=8) maxNumCoeff = vldParam[0];
		uint(size=32) TotalCoeff = vldParam[1];

		IdxmaxNumCoeff :=
			if(maxNumCoeff = 4) then
				0
			else
				if(maxNumCoeff=8) then
					1
				else
					2
				end
			end;
		NbBitsRead      := 0;
		ValRead         := 0;
		TotalCoeffParam := TotalCoeff & 0x0F;
	end

	IsCavlcRunBefore: action ==>
	guard
		typeOfVld = CAVLC_RUN_BEFORE
	do
		uint(size=8) zerosLeft = vldParam[0];
		IdxzerosLeft :=
			if(zerosLeft > 0 and zerosLeft <= 6) then
				zerosLeft - 1
			else
				6
			end;
		NbBitsRead      := 0;
		ValRead         := 0;
	end

	IsCavlcLevelPrefix: action ==>
	guard
		typeOfVld = CAVLC_LEVEL_PREFIX
	do
		Bit1Found       := false;
		leadingZeroBits := 0;
	end

	IsByteAligned: action ==>
	guard
		typeOfVld = BYTE_ALIGNED_REQUIRED
	do
		if(CountBufferRbsp != 8)then
			CountBufferRbsp := 0;
		end
	end

	Buffer.IsEmpty: action ==>
	guard
		CountBufferRbsp = 0,
		SizeBufferRbsp  > 0
	do
		CountBufferRbsp := 8;
		SizeBufferRbsp  := SizeBufferRbsp - 1;
		WorkingByte     := BufferRbsp[SizeBufferRbsp];
	end

	Buffer.IsNotEmpty: action ==>
	guard
		CountBufferRbsp > 0
	end

	GetCodeNum.Launch: action ==>
	var
		uint(size=5) NbBitsToAdd
	do
		if(not Bit1Found)then
			while( ((WorkingByte & 0x80) = 0) and (CountBufferRbsp > 0))
			do
				CountBufferRbsp := CountBufferRbsp - 1;
				WorkingByte     := WorkingByte << 1;
				leadingZeroBits := leadingZeroBits + 1;
			end
			if(CountBufferRbsp > 0)then
				leadingZeroBits := leadingZeroBits + 1;
				Bit1Found       := true;
			end
		end
		if(Bit1Found)then
			NbBitsToAdd :=
				if(CountBufferRbsp < leadingZeroBits)then
					CountBufferRbsp
				else
					leadingZeroBits
				end;
			ReadNBitsInWorkingByte(CodeNum,NbBitsToAdd);
			CodeNum         := Out_ReadNBits;
			leadingZeroBits := leadingZeroBits - NbBitsToAdd;
		end
	end

	GetCodeNum.Finished: action ==>
	guard
		leadingZeroBits = 0
	end

	GetCodeNum.NotFinished: action ==>
	guard
		leadingZeroBits != 0
	end

	SendUeValue: action ==> 
	do
		valDecoded := CodeNum - 1;
	end

	SendSeValue: action ==>
	do
		//CodeNum computed is equal to CodeNum + 1
		if( (CodeNum mod 2) = 0 )then
			valDecoded := CodeNum / 2;
		else
			valDecoded := -CodeNum / 2;
		end
	end

	Get_u.Launch: action ==>
	var
		uint(size=5) NbBitsToAdd
	do
		NbBitsToAdd :=
			if(CountBufferRbsp < BitsCount)then
				CountBufferRbsp
			else
				BitsCount
			end;
		ReadNBitsInWorkingByte(ReadValue,NbBitsToAdd);
		ReadValue       := Out_ReadNBits;
		BitsCount       := BitsCount - NbBitsToAdd;
	end

	Get_u.Finished: action ==>
	guard
		BitsCount = 0
	end

	Get_u.NotFinished: action ==>
	guard
		BitsCount != 0
	end

	SendUValue: action ==>
	do
		valDecoded := ReadValue ^ TeVal;
	end

	GetCavlcCoeffToken.Launch: action ==>
	var
		//delete me! (Bug in the front-end)
		bool titi
	do
		ReadNBitsInWorkingByte(coeff_token,1);
		coeff_token := Out_ReadNBits;
		NbBitsRead  := NbBitsRead + 1;
		titi := TotalCoeffValid[Idx_nC][(NbBitsRead - 1) & 0x0F][coeff_token & 0x3F];
		while((not titi) and (CountBufferRbsp > 0))
		do
			ReadNBitsInWorkingByte(coeff_token,1);
			coeff_token := Out_ReadNBits;
			NbBitsRead  := NbBitsRead + 1;
			titi := TotalCoeffValid[Idx_nC][(NbBitsRead - 1) & 0x0F][coeff_token & 0x3F];
		end
	end

	GetCavlcCoeffToken.NotFinished: action ==>
	guard
		TotalCoeffValid[Idx_nC][(NbBitsRead - 1) & 0x0F][coeff_token & 0x3F] = false
	end

	GetCavlcCoeffToken.Finished: action ==>
	do
		valDecoded := TotalCoeffValue[Idx_nC][(NbBitsRead-1) & 0x0F][coeff_token & 0x3F];
		if(DEBUG_FLAG_DECODED)then
			println("Cavlc CoeffToken; Idx_nc :" + Idx_nC + " ; NbBitsRead : "+NbBitsRead+ " ; coeff_token : "+coeff_token);
		end
	end

	GetCavlcLevelPrefix.Launch: action ==>
	do
		while( ((WorkingByte & 0x80) = 0) and (CountBufferRbsp > 0))
		do
			CountBufferRbsp := CountBufferRbsp - 1;
			WorkingByte     := WorkingByte << 1;
			leadingZeroBits := leadingZeroBits + 1;
		end
		if(CountBufferRbsp > 0)then
			Bit1Found       := true;
			/* We read the one bit value */
			CountBufferRbsp := CountBufferRbsp - 1;
			WorkingByte     := WorkingByte << 1;
		end
	end

	GetCavlcLevelPrefix.NotFinished: action ==>
	guard
		not Bit1Found
	end

	GetCavlcLevelPrefix.Finished: action ==>
	guard
		Bit1Found
	do
		valDecoded := leadingZeroBits;
	end

	GetCavlcTotalZeros.Launch: action ==>
	var
		//delete me!
		bool titi
	do
		ReadNBitsInWorkingByte(ValRead,1);
		ValRead := Out_ReadNBits;
		NbBitsRead      := NbBitsRead + 1;
		titi := TotalZerosValid[IdxmaxNumCoeff][TotalCoeffParam][NbBitsRead & 0x0F][ValRead & 0x07];
		while((not titi) and (CountBufferRbsp > 0))
		do
			ReadNBitsInWorkingByte(ValRead,1);
			ValRead    := Out_ReadNBits;
			NbBitsRead := NbBitsRead + 1;
			titi := TotalZerosValid[IdxmaxNumCoeff][TotalCoeffParam][NbBitsRead & 0x0F][ValRead & 0x07];
		end
	end

	GetCavlcTotalZeros.NotFinished: action ==>
	guard
		not TotalZerosValid[IdxmaxNumCoeff][TotalCoeffParam][NbBitsRead & 0x0F][ValRead & 0x07]
	end

	GetCavlcTotalZeros.Finished: action ==>
	do
		valDecoded := TotalZerosValue[IdxmaxNumCoeff][TotalCoeffParam][NbBitsRead & 0x0F][ValRead & 0x07];
		if(DEBUG_FLAG_DECODED)then
			println("Cavlc TotalZeros; Idx :" + IdxmaxNumCoeff +" ; TotalCoeff :"+TotalCoeffParam+ " ; NbBitsRead : "+NbBitsRead+ " ; Codeword : "+ValRead);
		end
	end

	GetCavlcRunBefore.Launch: action ==>
	var
		//delete me!
		bool titi
	do
		ReadNBitsInWorkingByte(ValRead,1);
		ValRead    := Out_ReadNBits;
		NbBitsRead := NbBitsRead + 1;
		titi := RunBeforeValid[IdxzerosLeft][NbBitsRead & 0x0F][ValRead & 0x07];
		while((not titi) and (CountBufferRbsp > 0))
		do
			ReadNBitsInWorkingByte(ValRead,1);
			ValRead    := Out_ReadNBits;
			NbBitsRead := NbBitsRead + 1;
			titi := RunBeforeValid[IdxzerosLeft][NbBitsRead & 0x0F][ValRead & 0x07];
		end
	end

	GetCavlcRunBefore.NotFinished: action ==>
	guard
		not RunBeforeValid[IdxzerosLeft][NbBitsRead & 0x0F][ValRead & 0x07]
	end

	GetCavlcRunBefore.Finished: action ==>
	do
		valDecoded := RunBeforeValue[IdxzerosLeft][NbBitsRead & 0x0F][ValRead & 0x07];
		if(DEBUG_FLAG_DECODED)then
			print("Run Before; Idx :" + IdxzerosLeft +" ; Run Before :"+RunBeforeValue[IdxzerosLeft][NbBitsRead & 0x0F][ValRead & 0x07]);
			println(" ; NbBitsRead : "+NbBitsRead+ " ; Codeword : "+ValRead);
		end
	end



	schedule fsm FindOutNextActor:
		FindOutNextActor (findOutNextActor.isSliceHeader1    )--> LaunchSlcHead;
		FindOutNextActor (findOutNextActor.isSliceHeader2Avc )--> LaunchSlcHead2Avc;
		FindOutNextActor (findOutNextActor.isRefPicMark      )--> LaunchRefPicMark;
		FindOutNextActor (findOutNextActor.isRefPicList      )--> LaunchRefPicList;
		FindOutNextActor (findOutNextActor.isSliceData       )--> LaunchSliceData;
		FindOutNextActor (findOutNextActor.isMbLayer         )--> LaunchMbLayer;
		FindOutNextActor (findOutNextActor.isMbPred          )--> LaunchMbPred;
		FindOutNextActor (findOutNextActor.isSubMbPred       )--> LaunchSubMbPred;
		FindOutNextActor (findOutNextActor.isResidual        )--> LaunchResidual;
		FindOutNextActor (findOutNextActor.isResidualCavlc   )--> LaunchResBlkCavlc;

		LaunchSlcHead (SliceHeader1.FunctionWithoutParam )--> CheckVLDType;
		LaunchSlcHead (SliceHeader1.FunctionWith1Param   )--> CheckVLDType;
		LaunchSlcHead (SliceHeader1.LaunchActor          )--> FindOutNextActor;
		LaunchSlcHead (SliceHeader1.Done                 )--> LaunchSlcHead;

		LaunchSlcHead2Avc (SliceHeader2.FunctionWithoutParam )--> CheckVLDType;
		LaunchSlcHead2Avc (SliceHeader2.FunctionWith1Param   )--> CheckVLDType;
		LaunchSlcHead2Avc (SliceHeader2.LaunchActor          )--> FindOutNextActor;
		LaunchSlcHead2Avc (SliceHeader2.Done                 )--> FindOutNextActor;
	
		LaunchRefPicMark (RefPicMark.FunctionWithoutParam )--> CheckVLDType;
		LaunchRefPicMark (RefPicMark.FunctionWith1Param   )--> CheckVLDType;
		LaunchRefPicMark (RefPicMark.Done                 )--> LaunchSlcHead2Avc;
		
		LaunchRefPicList (RefPicList.FunctionWithoutParam )--> CheckVLDType;
		LaunchRefPicList (RefPicList.FunctionWith1Param   )--> CheckVLDType;
		LaunchRefPicList (RefPicList.Done                 )--> LaunchSlcHead2Avc;
	
		LaunchSliceData   (SliceData.FunctionWithoutParam   )--> CheckVLDType;
		LaunchSliceData   (SliceData.FunctionWith1Param     )--> CheckVLDType;
		LaunchSliceData   (SliceData.LaunchActor            )--> FindOutNextActor;
		LaunchSliceData   (SliceData.Done                   )--> FindOutNextActor;
		
		LaunchMbLayer    (MbLayer.FunctionWithoutParam    )--> CheckVLDType;
		LaunchMbLayer    (MbLayer.FunctionWith1Param      )--> CheckVLDType;
		LaunchMbLayer    (MbLayer.Done                    )--> FindOutNextActor;
		LaunchMbLayer    (MbLayer.LaunchActor             )--> FindOutNextActor;
		
		LaunchMbPred    (MbPred.FunctionWithoutParam    )--> CheckVLDType;
		LaunchMbPred    (MbPred.FunctionWith1Param      )--> CheckVLDType;
		LaunchMbPred    (MbPred.Done                    )--> FindOutNextActor;
		
		LaunchSubMbPred (SubMbPred.FunctionWithoutParam )--> CheckVLDType;
		LaunchSubMbPred (SubMbPred.FunctionWith1Param   )--> CheckVLDType;
		LaunchSubMbPred (SubMbPred.Done                 )--> FindOutNextActor;
	
		LaunchResidual  (Residual.Done                  )--> FindOutNextActor;
		LaunchResidual  (Residual.LaunchActor           )--> FindOutNextActor;
	
		LaunchResBlkCavlc (ResBlkCavlc.FunctionWithoutParam )--> CheckVLDType;
		LaunchResBlkCavlc (ResBlkCavlc.FunctionWith1Param   )--> CheckVLDType;
		LaunchResBlkCavlc (ResBlkCavlc.FunctionWith2Param   )--> CheckVLDType;
		LaunchResBlkCavlc (ResBlkCavlc.Done                 )--> FindOutNextActor;



		CheckVLDType    (IsEndOfNal                          )--> WaitForNewNal;
		CheckVLDType    (IsByteAligned                       )--> FindOutNextActor;
		CheckVLDType    (IsVldUe                             )--> VLDecoding_Ue;
		CheckVLDType    (IsVldSe                             )--> VLDecoding_Se;
		CheckVLDType    (IsVldTe.ue                          )--> VLDecoding_Ue;
		CheckVLDType    (IsVldTe.u                           )--> Decode_u;
		CheckVLDType    (IsReadBits                          )--> Decode_u;
		CheckVLDType    (IsMoreRbspData                      )--> FillBuffer;
		CheckVLDType    (IsCavlcLevelPrefix                  )--> DecCavlcLevPre;
		CheckVLDType    (IsCavlcCoeffToken                   )--> DecCavlcCofTkn;
		CheckVLDType    (IsCavlcTotalZeros                   )--> DecCavlcTotZer;
		CheckVLDType    (IsCavlcRunBefore                    )--> DecCavlcRunBef;

		/* more_rbsp_data() */
		FillBuffer      (FillBufferRbsp                      )--> FillBuffer;
		FillBuffer      (FutureNewNalDetected                )--> CheckBuffer;
		FillBuffer      (CheckSizeBufferRbsp.IsEqualOrSupTo2 )--> FindOutNextActor;
		FillBuffer      (NewNalHasBeenSent                   )--> CheckBuffer;

		CheckBuffer     (CheckSizeBufferRbsp                 )--> FindOutNextActor;

		/* Skip the others values of the Rbsp */
		WaitForNewNal   (NewNalHasBeenSent                   )--> ResetNewNal;
		WaitForNewNal   (WaitForNewNal                       )--> WaitForNewNal2;
		WaitForNewNal   (NewNalDetected                      )--> FindOutNextActor;

		ResetNewNal     (ResetNewNalAlreadyDetected          )--> FindOutNextActor;

		WaitForNewNal2  (WaitForNewNal                       )--> WaitForNewNal2;
		WaitForNewNal2  (NewNalDetected                      )--> FindOutNextActor;

		/* ue(v) decoding process */
			/*Fill in the WorkingByte if it's empty*/
		VLDecoding_Ue   (Buffer                              )--> GetCodeNum4ue;
		VLDecoding_Ue   (FillBufferRbsp                      )--> VLDecoding_Ue;

		GetCodeNum4ue   (GetCodeNum.Launch                   )--> CheckCodeNum4ue;

		CheckCodeNum4ue (GetCodeNum.NotFinished              )--> VLDecoding_Ue;
		CheckCodeNum4ue (GetCodeNum.Finished                 )--> SendUeValue;

		SendUeValue     (SendUeValue                         )--> FindOutNextActor;

		/* se(v) decoding process */
			/*Fill in the WorkingByte if it's empty*/
		VLDecoding_Se   (Buffer                              )--> GetCodeNum4se;
		VLDecoding_Se   (FillBufferRbsp                      )--> VLDecoding_Se;

		GetCodeNum4se   (GetCodeNum.Launch                   )--> CheckCodeNum4se;

		CheckCodeNum4se (GetCodeNum.NotFinished              )--> VLDecoding_Se;
		CheckCodeNum4se (GetCodeNum.Finished                 )--> SendUeValse;

		SendUeValse     (SendSeValue                         )--> FindOutNextActor;

		/* u(n) decoding process */
			/*Fill in the WorkingByte if it's empty*/
		Decode_u        (Buffer                              )--> Get_u;
		Decode_u        (FillBufferRbsp                      )--> Decode_u;

		Get_u           (Get_u.Launch                        )--> Check_u_Val;

		Check_u_Val     (Get_u.NotFinished                   )--> Decode_u;
		Check_u_Val     (Get_u.Finished                      )--> SendUValue;

		SendUValue      (SendUValue                          )--> FindOutNextActor;

		/* Cavlc coeff_token() decoding process */
			/*Fill in the WorkingByte if it's empty*/
		DecCavlcCofTkn  (Buffer                              )--> GetCavlcCofTkn;
		DecCavlcCofTkn  (FillBufferRbsp                      )--> DecCavlcCofTkn;

		GetCavlcCofTkn   (GetCavlcCoeffToken.Launch          )--> ChckCavlcCofTkn;

		ChckCavlcCofTkn (GetCavlcCoeffToken.NotFinished      )--> DecCavlcCofTkn;
		ChckCavlcCofTkn (GetCavlcCoeffToken.Finished         )--> FindOutNextActor;

		/* Cavlc level_prefix decoding process */
			/*Fill in the WorkingByte if it's empty*/
		DecCavlcLevPre  (Buffer                              )--> GetCavlcLevPre;
		DecCavlcLevPre  (FillBufferRbsp                      )--> DecCavlcLevPre;

		GetCavlcLevPre  (GetCavlcLevelPrefix.Launch          )--> ChckCavlcLevPre;

		ChckCavlcLevPre (GetCavlcLevelPrefix.NotFinished     )--> DecCavlcLevPre;
		ChckCavlcLevPre (GetCavlcLevelPrefix.Finished        )--> FindOutNextActor;

		/* Cavlc total_zeros decoding process */
			/*Fill in the WorkingByte if it's empty*/
		DecCavlcTotZer  (Buffer                              )--> GetCavlcTotZer;
		DecCavlcTotZer  (FillBufferRbsp                      )--> DecCavlcTotZer;

		GetCavlcTotZer  (GetCavlcTotalZeros.Launch          )--> ChckCavlcTotZer;

		ChckCavlcTotZer (GetCavlcTotalZeros.NotFinished     )--> DecCavlcTotZer;
		ChckCavlcTotZer (GetCavlcTotalZeros.Finished        )--> FindOutNextActor;

		/* Cavlc run_before decoding process */
			/*Fill in the WorkingByte if it's empty*/
		DecCavlcRunBef  (Buffer                              )--> GetCavlcRunBef;
		DecCavlcRunBef  (FillBufferRbsp                      )--> DecCavlcRunBef;

		GetCavlcRunBef  (GetCavlcRunBefore.Launch            )--> ChckCavlcRunBef;

		ChckCavlcRunBef (GetCavlcRunBefore.NotFinished     )--> DecCavlcRunBef;
		ChckCavlcRunBef (GetCavlcRunBefore.Finished        )--> FindOutNextActor;

	end
	priority
		SliceHeader1.FunctionWithoutParam > SliceHeader1.FunctionWith1Param > SliceHeader1.WaitVLDVal > SliceHeader1.LaunchActor;
		SliceHeader1.LaunchActor      > SliceHeader1.Done;
		SliceHeader1.GetVLDVal.Launch > SliceHeader1.GetVLDVal.Done;

		SliceHeader2.FunctionWithoutParam > SliceHeader2.FunctionWith1Param > SliceHeader2.WaitVLDVal > SliceHeader2.LaunchActor;
		SliceHeader2.LaunchActor > SliceHeader2.Done;
		SliceHeader2.GetVLDVal.Launch > SliceHeader2.GetVLDVal.Done;

		RefPicMark.FunctionWithoutParam  > RefPicMark.FunctionWith1Param  > RefPicMark.WaitVLDVal > RefPicMark.Done;
		RefPicMark.GetVLDVal.Launch > RefPicMark.GetVLDVal.Done;
		RefPicList.FunctionWithoutParam  > RefPicList.FunctionWith1Param  > RefPicList.WaitVLDVal > RefPicList.Done;
		RefPicList.GetVLDVal.Launch > RefPicList.GetVLDVal.Done;

		SliceData.FunctionWithoutParam   > SliceData.FunctionWith1Param   > SliceData.WaitVLDVal          > SliceData.LaunchActor        > SliceData.Done;
		SliceData.GetVLDVal.Launch       > SliceData.GetVLDVal.Done;
		MbLayer.FunctionWithoutParam     > MbLayer.FunctionWith1Param     > MbLayer.WaitVLDVal             > MbLayer.LaunchActor         > MbLayer.Done;
		MbLayer.GetVLDVal.Launch         > MbLayer.GetVLDVal.Done;
		MbPred.FunctionWithoutParam      > MbPred.FunctionWith1Param      > MbPred.WaitVLDVal              > MbPred.Done;
		MbPred.GetVLDVal.Launch          > MbPred.GetVLDVal.Done;
		SubMbPred.FunctionWithoutParam   > SubMbPred.FunctionWith1Param   > SubMbPred.WaitVLDVal           > SubMbPred.Done;
		SubMbPred.GetVLDVal.Launch       > SubMbPred.GetVLDVal.Done;
		ResBlkCavlc.FunctionWithoutParam > ResBlkCavlc.FunctionWith1Param > ResBlkCavlc.FunctionWith2Param > ResBlkCavlc.WaitVLDVal > ResBlkCavlc.Done;
		ResBlkCavlc.GetVLDVal.Launch     > ResBlkCavlc.GetVLDVal.Done;



		NewNalHasBeenSent               > WaitForNewNal                        > NewNalDetected;
		IsVldUe                         > IsReadBits                           > IsCavlcLevelPrefix;  
		IsCavlcLevelPrefix              > IsCavlcRunBefore > IsCavlcCoeffToken > IsVldSe;
		IsVldSe                         > IsVldTe.ue       > IsVldTe.u         > FillBufferRbsp;
		FillBufferRbsp                  > IsMoreRbspData   > IsByteAligned     > IsEndOfNal;
		CheckSizeBufferRbsp             > FillBufferRbsp                       > FutureNewNalDetected > NewNalHasBeenSent;
		GetCodeNum.NotFinished          > GetCodeNum.Finished;
		Buffer.IsNotEmpty               > Buffer.IsEmpty                       > FillBufferRbsp;
		GetCavlcCoeffToken.NotFinished  > GetCavlcCoeffToken.Finished;
		GetCavlcLevelPrefix.NotFinished > GetCavlcLevelPrefix.Finished;
		GetCavlcTotalZeros.NotFinished  > GetCavlcTotalZeros.Finished;
		GetCavlcRunBefore.NotFinished   > GetCavlcRunBefore.Finished;
	end
end
