/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package ch.epfl.mpeg4.part10.cbp.synParser.modular.decodePicture;

import ch.epfl.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import std.util.Math.*;

actor Algo_DecodeResidualBlock_Cavlc()
	int (size=32) ValVLD,
	int (size=8)  Parameters
		==>
	uint(size=5)  TypeOfVLD,
	int (size=32) VLD_Param,
	uint(size=5)  TotalCoeff,
	int (size=12) Value,
	uint(size=4)  Run,
	bool          Last
		:

	bool DEBUG_FLAG_DECODED = false;

	int (size=8)  nC_Val;
	uint(size=8)  totalCoeff   := 0;
	uint(size=8)  TrailingOnes := 0;
	uint(size=5)  suffixLength := 0;
	uint(size=32) level_prefix := 0;
	uint(size=32) level_suffix := 0;
	uint(size=32) levelCode    := 0;
	uint(size=5)  iLoop        := 0;
	uint(size=4)  zerosLeft    := 0;
	uint(size=5)  maxNumCoeff  := 0;
	uint(size=5)  startIdx     := 0;
	uint(size=5)  endIdx       := 0;
	List(type: int (size=16), size=3)  level        := [ 0 : for int i in 1 .. 3];

	ReadCoeffToken.Asked: action
		Parameters  :[nC , MaxNumCoeff , StartIdx , EndIdx]
			==>
		//        mb_field_decoding_flag
		TypeOfVLD :[ CAVLC_COEFF_TOKEN ],
		VLD_Param :[       nC       ]
	do
		nC_Val := nC;
		startIdx    := StartIdx;
		endIdx      := EndIdx;
		maxNumCoeff := MaxNumCoeff;
		if(DEBUG_FLAG_DECODED)then
			println("******************** New Block Cavlc***************************");
			println("nC : "+nC_Val);
		end
		zerosLeft := 0;
	end

	ReadCoeffToken.Done: action ValVLD :[ValOfVLD] ==> TotalCoeff:[totalCoeff]
	do
		totalCoeff   := (ValOfVLD & 0xFF);
		TrailingOnes := (ValOfVLD >> 8);
		if(DEBUG_FLAG_DECODED)then
			println("TotalCoeff : "+(ValOfVLD & 0xFF));
			println("Trailing Ones : "+(ValOfVLD >> 8));
		end
		if(TrailingOnes < 3) then
			levelCode := 2;
		else
			levelCode := 0;
		end
	end

	CheckTotalCoeff.IsGreaterThan0: action ==>
	guard
		totalCoeff > 0
	do
		if((totalCoeff > 10) and (TrailingOnes < 3)) then
			suffixLength := 1;
		else
			suffixLength := 0;
		end
		iLoop     := 0;
	end

	ReadTrailingOnesSign.Asked: action
			==>
		//     trailing_ones_sign_flag
		TypeOfVLD :[ READ_BITS ],
		VLD_Param :[ TrailingOnes ]
	guard
		TrailingOnes > 0
	end

	ReadTrailingOnesSign.Done: action ValVLD :[ValueOfVLD] ==>
	var
		uint(size=1) trailing_ones_sign_flag
	do
		foreach int i in 0 .. TrailingOnes - 1
		do
			trailing_ones_sign_flag := (ValueOfVLD >> (TrailingOnes - 1 - i)) & 1;
			level[iLoop] := 1 - 2 * trailing_ones_sign_flag;
			if(DEBUG_FLAG_DECODED)then
				println("levelT1 : "+level[iLoop]);
			end
			iLoop        := iLoop + 1;
		end
		iLoop := 0;
	end

	SendTrailingOnes: action ==> Value :[level[iLoop-1]], Last :[false]
	guard
		iLoop < TrailingOnes
	do
		iLoop := iLoop + 1;
	end

			//                                      level_prefix
	ReadLevelPrefix.Asked: action ==> TypeOfVLD :[CAVLC_LEVEL_PREFIX]
	guard
		iLoop < totalCoeff
	end

	ReadLevelPrefix.Done: action ValVLD :[ValueOfVLD] ==>
	do
		level_prefix := ValueOfVLD;
		level_suffix := 0;
	end

	ReadLevelSuffix.Asked: action
			==>
		//            level_suffix
		TypeOfVLD :[    READ_BITS    ],
		VLD_Param :[ levelSuffixSize ]
	guard
		   level_prefix >= 14
		or suffixLength  > 0
	var
		int levelSuffixSize
	do
		if((level_prefix = 14) and (suffixLength = 0) )then
			levelSuffixSize := 4;
		else
			if(level_prefix >= 15) then
				levelSuffixSize := level_prefix - 3;
			else
				levelSuffixSize := suffixLength;
			end
		end
	end

	ReadLevelSuffix.Done: action ValVLD :[ValueOfVLD] ==>
	do
		level_suffix := ValueOfVLD;
	end

	ComputeLevel: action ==> Value:[ValLevel], Last :[false]
	var
		int(size=16) ValLevel
	do
		levelCode :=
			if(level_prefix < 15) then
				levelCode + (level_prefix << suffixLength)
			else
				levelCode + (15 << suffixLength)
			end;
		levelCode := levelCode + level_suffix;
		if((level_prefix >= 15) and (suffixLength = 0)) then
			levelCode := levelCode + 15;
		end
		if(level_prefix >= 16) then
			levelCode := levelCode + (1 << (level_prefix - 3)) - 4096;
		end
		if((levelCode mod 2) = 0) then
			ValLevel     := (levelCode + 2) >> 1;
		else
			ValLevel     := (-levelCode - 1) >> 1;
		end

		if(suffixLength = 0)then
			suffixLength := 1;
		end
		if( (abs(ValLevel) > (3 << suffixLength - 1)) and (suffixLength < 6) ) then
			suffixLength := suffixLength + 1;
		end
		if(DEBUG_FLAG_DECODED)then
			println("level : "+ValLevel);
		end
		
		levelCode := 0;
		iLoop     := iLoop + 1;
	end

	ReadTotalZeros.Asked: action
			==>
		//               total_zeros
		TypeOfVLD :[ CAVLC_TOTAL_ZEROS ],
		VLD_Param :[ maxNumCoeff , totalCoeff ]
	guard
		totalCoeff < (endIdx - startIdx + 1)
	end

	ReadTotalZeros.Done: action ValVLD :[total_zeros] ==>
	do
		zerosLeft := total_zeros;
		if(DEBUG_FLAG_DECODED)then
			println("total_zeros : "+total_zeros);
		end
	end

	InitiLoop: action ==>
	do
		iLoop := 0;
	end

	ZerosLeft.GreaterThan0: action
			==>
		//            run_before
		TypeOfVLD :[ CAVLC_RUN_BEFORE ],
		VLD_Param :[ zerosLeft ]
	guard
		iLoop     < totalCoeff - 1,
		zerosLeft > 0
	end

	ReadRunBefore: action ValVLD :[run_before] ==> Run :[run_before]
	do
		if(DEBUG_FLAG_DECODED)then
			println("run_before : "+run_before);
		end
		zerosLeft  := zerosLeft - run_before;
		iLoop      := iLoop + 1;
	end

	SendOthersRun: action ==> Run :[ValRun]
	guard
		iLoop < totalCoeff
	var
		int(size=16) ValRun
	do
		ValRun    := zerosLeft;
		zerosLeft := 0;
		// The first coeffAC will be replaced by coeffDC
		if( (maxNumCoeff = 15) and (iLoop = totalCoeff - 1) )then
			ValRun := ValRun + 1;
		end
		iLoop     := iLoop + 1;
	end

	SendEndResidualBlock: action ==> TypeOfVLD :[SKIP_NAL], Last :[true]
	end

	schedule fsm ReadCoeffToken_Asked:
		ReadCoeffToken_Asked (ReadCoeffToken.Asked )--> ReadCoeffTokenDone;

		ReadCoeffTokenDone (ReadCoeffToken.Done )--> CheckTotalCoeff;

		CheckTotalCoeff (CheckTotalCoeff.IsGreaterThan0 )--> CheckiLoop;
		CheckTotalCoeff (SendEndResidualBlock )-->ReadCoeffToken_Asked;

		CheckiLoop (ReadTrailingOnesSign.Asked )--> ReadTrailingOnesSign;
		CheckiLoop (ReadLevelPrefix.Asked )--> ReadLevelPrefix;
		CheckiLoop (ReadTotalZeros.Asked )--> ReadTotalZerosDone;
		CheckiLoop (InitiLoop )--> Loop4run;

		ReadTrailingOnesSign (ReadTrailingOnesSign.Done )--> SendTrailingOnes;

		SendTrailingOnes (SendTrailingOnes )--> SendTrailingOnes;
		SendTrailingOnes (ReadLevelPrefix.Asked )--> ReadLevelPrefix;
		SendTrailingOnes (ReadTotalZeros.Asked )--> ReadTotalZerosDone;
		SendTrailingOnes (InitiLoop )--> Loop4run;

		CheckiLoop2 (ReadLevelPrefix.Asked )--> ReadLevelPrefix;
		CheckiLoop2 (ReadTotalZeros.Asked )--> ReadTotalZerosDone;
		CheckiLoop2 (InitiLoop )--> Loop4run;


		ReadLevelPrefix (ReadLevelPrefix.Done )--> ReadLevelSuffixAsked;

		ReadLevelSuffixAsked (ReadLevelSuffix.Asked )--> ReadLevelSuffixDone;
		ReadLevelSuffixAsked (ComputeLevel )--> CheckiLoop2;

		ReadLevelSuffixDone (ReadLevelSuffix.Done )--> ComputeLevel;

		ComputeLevel (ComputeLevel )--> CheckiLoop2;

		ReadTotalZerosDone (ReadTotalZeros.Done )--> InitiLoop;

		InitiLoop (InitiLoop )--> Loop4run;

		Loop4run (ZerosLeft.GreaterThan0 )--> ReadRunBefore;
		Loop4run (SendOthersRun )--> SendOthersRun;
		Loop4run (SendEndResidualBlock )--> ReadCoeffToken_Asked;

		SendOthersRun (SendOthersRun )--> SendOthersRun;
		SendOthersRun (SendEndResidualBlock )--> ReadCoeffToken_Asked;

		ReadRunBefore (ReadRunBefore )--> Loop4run;

		SendEndResidualBlock (SendEndResidualBlock )--> ReadCoeffToken_Asked;
	end
	priority
		CheckTotalCoeff.IsGreaterThan0 > SendEndResidualBlock;
		ReadTrailingOnesSign.Asked > ReadLevelPrefix.Asked;
		ReadLevelSuffix.Asked  > ComputeLevel;
		SendTrailingOnes       > ReadLevelPrefix.Asked;
		ReadLevelPrefix.Asked  > ReadTotalZeros.Asked;
		ReadTotalZeros.Asked   > InitiLoop;
		ZerosLeft.GreaterThan0 > SendOthersRun  > SendEndResidualBlock;
	end
end