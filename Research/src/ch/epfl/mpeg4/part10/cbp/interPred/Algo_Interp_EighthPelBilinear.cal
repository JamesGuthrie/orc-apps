/**
 * This software module was originally developed by 
 * He-Yuan Lin (NCKU), 
 * in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
 * for reference purposes and its performance may not have been optimized. 
 * This software module is an implementation of one or more tools as 
 * specified by the ISO/IEC 23002-4.
 * 
 * ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
 * license to copy, distribute, and make derivative works of this software 
 * module or modifications thereof for use in implementations of the 
 * ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 
 * 
 * Those intending to use this software module in products are advised that 
 * its use may infringe existing patents. ISO/IEC have no liability for use 
 * of this software module or modifications thereof.
 * 
 * Copyright is not released for products that do not conform to audiovisual 
 * and image-coding related ITU Recommendations and/or ISO/IEC International 
 * Standards. 
 * 
 * Assurance that the originally developed software module can be used 
 * (1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
 * (2) to develop the ISO/IEC 23002-4: 
 *
 *
 * NCKU grants ISO/IEC all rights necessary to 
 * include the originally developed software module or modifications thereof 
 * in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
 * worldwide, non-exclusive, copyright license to copy, distribute, and make 
 * derivative works for use in implementations of the ISO/IEC 23002-4 in 
 * products that satisfy conformance criteria (if any), and to the extent 
 * that such originally developed software module or portions of it are 
 * included in the ISO/IEC 23002-4.  To the extent that NCKU
 * owns patent rights that would be required to make, use, or 
 * sell the originally developed software module or portions thereof 
 * included in the ISO/IEC 23002-4 in a conforming product, NCKU
 * Rennes will assure the ISO/IEC that it is willing to 
 * negotiate licenses under reasonable and non-discriminatory terms and 
 * conditions with applicants throughout the world.
 *
 * ISO/IEC gives You a free license to this software module or modifications 
 * thereof for the sole  purpose of developing the ISO/IEC 23002-4.
 * 
 * NCKU Rennes retains full right to modify and use the 
 * code for its own purpose, assign or donate the code to a third party and 
 * to inhibit third parties from using the code for products that do not 
 * conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
 * Standards. 
 * 
 * This copyright notice must be included in all copies or derivative works. 
 * Copyright (c) ISO/IEC 2006-2010.
 */
// Algo_Interp_EighthPelBilinear.cal
//
// Author: He-Yuan Lin
//
// Fractional chroma sample interpolation for motion compensation of AVC

//Modified by Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package ch.epfl.mpeg4.part10.cbp.interPred;

actor Algo_Interp_EighthPelBilinear(uint(size=1) numComp)
	int(size=16) Mv, 
	uint(size=8) ReadResultU,
	uint(size=8) ReadResultV, 
	uint(size=6) PartSZ 
		==> 
	uint(size=8) Interp
		:

	uint(size=1) currNumComp:=0;

	int(size=32) x := 0;
	int(size=32) y := 0;
	int(size=32) xOut := 0;
	int(size=32) yOut := 0;
	int(size=32) xFrac ;
	int(size=32) yFrac ;
	int width;
	int height;
	uint(size=8) inbuf[289];

	//chroma sample interpolation process
	function chromaSampleInterpolation( ) --> int
	var
		uint(size=8) A = inbuf[xOut + yOut * 17],
		uint(size=8) B = inbuf[1 + xOut + yOut * 17],
		uint(size=8) C = inbuf[xOut + (1 + yOut) * 17],
		uint(size=8) D = inbuf [1 + xOut + (1 + yOut) * 17]
	:
			( (8-xFrac) * (8-yFrac) * A + (xFrac) * (8-yFrac) * B +
			(8-xFrac)* yFrac * C + xFrac * yFrac * D + 32) >> 6
	end

	getParam: action Mv:[mvX, mvY], PartSZ:[lumaWidth, lumaHeight] ==>
	do
		xFrac := mvX & 7;
		yFrac := mvY & 7;
		width  := lumaWidth/2;
		height := lumaHeight/2;
	end

	// fetch (width+1)x(height+1) pixels
	fetch.uComp: action ReadResultU:[d] ==>
	guard
		x < (width+1) and y < (height+1), currNumComp = 0
	do
		inbuf[y * 17 + x] := d;
		x := x + 1;
		if x >= (width+1) then
			x := 0;
			y := y + 1;
		end
	end

	fetch.vComp: action ReadResultV:[d] ==>
	guard
		x < (width+1) and y < (height+1), currNumComp = 1
	do
		inbuf[y * 17 + x] := d;
		x := x + 1;
		if x >= (width+1) then
			x := 0;
			y := y + 1;
		end
	end

	process.launch: action ==> Interp:[ p ]
	guard
		x = 0 and y = (height+1), currNumComp = numComp
	var
		uint(size=8) p
	do
		p := chromaSampleInterpolation();
		xOut := xOut + 1;
		if xOut >= width then
			xOut := 0;
			yOut := yOut + 1;
		end
	end

	process.skip: action ==>
	guard
		x = 0 and y = (height+1), currNumComp != numComp
	do
		xOut := xOut + 1;
		if xOut >= width then
			xOut := 0;
			yOut := yOut + 1;
		end
	end

	done: action ==>
	guard
		yOut = height
	do
		x := 0;
		y := 0;
		xOut := 0;
		yOut := 0;
		if(currNumComp = 0) then
			currNumComp := 1;
		else
			currNumComp := 0;
		end
	end

	schedule fsm GetParam:
		GetParam      (getParam ) --> InterpolateU;

		InterpolateU  (fetch    ) --> InterpolateU;
		InterpolateU  (process  ) --> InterpolateU;
		InterpolateU  (done     ) --> InterpolateV;

		InterpolateV  (fetch    ) --> InterpolateV;
		InterpolateV  (process  ) --> InterpolateV;
		InterpolateV  (done     ) --> GetParam;
	end

	priority
		done >  fetch > process;
	end
end