/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package ch.epfl.mpeg4.part10.frext.interPred.WeightedPred;

import org.sc29.wg11.mpeg4.part10.MacroBlockInfo.*;
import std.util.Math.*;

actor GeneratePredWeight()
	bool          NewMbL0,
	bool          NewMbL1,
	uint(size=5)  NumRefIdxLXActive,
	int (size=32) PocListX,
	bool          PocIsLTList,
	uint(size=4)  RefIdxL0,
	uint(size=4)  RefIdxL1,
	uint(size=2)  SelectList,
	uint(size=2)  WeightedPredIdc,
	int (size=9)  WeightedParam
		==>
	int (size=9) PredWeightY,
	int (size=9) PredWeightUV
		:

	// [Component][LX][ref_idx]
	int(size=8) offset[3][2][32];
	int(size=9) weight[3][2][32];

	int(size=32)  currPoc;
	uint(size=3)  chrLog2WeightDenom;
	uint(size=5)  iLoop;
	bool          isL0;
	bool          isLTList0[16];
	bool          isLTList1[16];
	uint(size=3)  lumaLog2WeightDenom;
	uint(size=5)  numRefIdxL0Active;
	uint(size=5)  numRefIdxL1Active;
	int (size=32) pocList0[16];
	int (size=32) pocList1[16];
	uint(size=2)  wpIdc;

	procedure computeImplicitWeights(int(size=32) pic0, int(size=32) pic1, bool pict0IsLT, bool pict1IsLT, int(size=8) weights[2])
	begin
		int (size=11) distScaleFactor;
		int (size=8)  tb;
		int (size=8)  td;
		uint(size=14) tx;

		if((pic1 - pic0 = 0) or pict0IsLT or pict1IsLT) then 
			weights[0] := 32; 
			weights[1] := 32; 
		else 
			tb := clip_i32(currPoc - pic0,-128,127); 
			td := clip_i32(pic1 - pic0,-128,127); 
			tx := (16384 + abs(td/2))/td; 
			distScaleFactor := clip_i32((tb*tx+32)>>6, -1024, 1023); 
			distScaleFactor := distScaleFactor>>2; 
			if(distScaleFactor < -64 or distScaleFactor > 128) then 
				weights[0] := 32; 
				weights[1] := 32; 
			else 
				weights[0] := 64 - distScaleFactor; 
				weights[1] := distScaleFactor; 
			end 
		end
	end

	SendWeightParam.launch.l0: action NewMbL0:[isNewMb], RefIdxL0:[refIdx],
		SelectList:[listSelected] ==> PredWeightY:[predInfoY] repeat 3,
		PredWeightUV:[predInfoUV] repeat 6
	guard
		isNewMb and wpIdc != 0 and listSelected = PRED_L0
	do
		int(size=9) predInfoY[3];
		int(size=9) predInfoUV[6];
		uint(size=1) idxL0 = 0;

		predInfoY[0] := lumaLog2WeightDenom;
		predInfoY[1] := weight[0][idxL0][refIdx];
		predInfoY[2] := offset[0][idxL0][refIdx];

		predInfoUV[0] := chrLog2WeightDenom;
		predInfoUV[1] := weight[1][idxL0][refIdx];
		predInfoUV[2] := offset[1][idxL0][refIdx];

		predInfoUV[3] := chrLog2WeightDenom;
		predInfoUV[4] := weight[2][idxL0][refIdx];
		predInfoUV[5] := offset[2][idxL0][refIdx];
	end

	SendWeightParam.launch.l1: action NewMbL1:[isNewMb], RefIdxL1:[refIdx],
		SelectList:[listSelected] ==> PredWeightY:[predInfoY] repeat 3,
		PredWeightUV:[predInfoUV] repeat 6
	guard
		isNewMb and wpIdc != 0 and listSelected = PRED_L1
	do
		int(size=9) predInfoY[3];
		int(size=9) predInfoUV[6];
		uint(size=1) idxL1 = 1;

		predInfoY[0] := lumaLog2WeightDenom;
		predInfoY[1] := weight[0][idxL1][refIdx];
		predInfoY[2] := offset[0][idxL1][refIdx];

		predInfoUV[0] := chrLog2WeightDenom;
		predInfoUV[1] := weight[1][idxL1][refIdx];
		predInfoUV[2] := offset[1][idxL1][refIdx];

		predInfoUV[3] := chrLog2WeightDenom;
		predInfoUV[4] := weight[2][idxL1][refIdx];
		predInfoUV[5] := offset[2][idxL1][refIdx];
	end

	SendWeightParam.launch.biPred: action NewMbL0:[isNewMbL0],
		NewMbL1:[isNewMbL1], RefIdxL0:[refIdxl0], RefIdxL1:[refIdxl1],
		SelectList:[listSelected] ==> PredWeightY:[predInfoY] repeat 6,
		PredWeightUV:[predInfoUV] repeat 12
	guard
		isNewMbL0 and isNewMbL1 and wpIdc != 0 and listSelected = BIPRED
	do
		uint(size=1) idxL0 = 0;
		uint(size=1) idxL1 = 1;

		int(size=9) predInfoY[6];
		int(size=9) predInfoUV[12];
		int(size=8) implicitWeights[2];

		predInfoY[0] := lumaLog2WeightDenom;
		predInfoY[2] := offset[0][idxL0][refIdxl0];
		predInfoY[3] := lumaLog2WeightDenom;
		predInfoY[5] := offset[0][idxL1][refIdxl1];

		predInfoUV[0] := chrLog2WeightDenom;
		predInfoUV[2] := offset[1][idxL0][refIdxl0];
		predInfoUV[6] := chrLog2WeightDenom;
		predInfoUV[8] := offset[1][idxL1][refIdxl1];

		predInfoUV[3] := chrLog2WeightDenom;
		predInfoUV[5] := offset[2][idxL0][refIdxl0];
		predInfoUV[9] := chrLog2WeightDenom;
		predInfoUV[11] := offset[2][idxL1][refIdxl1];

		if(wpIdc = 1) then
			predInfoY[1] := weight[0][idxL0][refIdxl0];
			predInfoY[4] := weight[0][idxL1][refIdxl1];
	
			predInfoUV[1] := weight[1][idxL0][refIdxl0];
			predInfoUV[7] := weight[1][idxL1][refIdxl1];
	
			predInfoUV[4] := weight[2][idxL0][refIdxl0];
			predInfoUV[10] := weight[2][idxL1][refIdxl1];
		else
			computeImplicitWeights(pocList0[refIdxl0], pocList1[refIdxl1], isLTList0[refIdxl0], isLTList1[refIdxl1], implicitWeights);

			predInfoY[1] := implicitWeights[0];
			predInfoY[4] := implicitWeights[1];

			predInfoUV[1] := implicitWeights[0];
			predInfoUV[7] := implicitWeights[1];

			predInfoUV[4] := implicitWeights[0];
			predInfoUV[10] := implicitWeights[1];
		end
	end

	SendWeightParam.skip.l0: action NewMbL0:[isNewMb], RefIdxL0:[refIdx],
		SelectList:[listSelected] ==>
	guard
		isNewMb and wpIdc = 0 and listSelected = PRED_L0
	end

	SendWeightParam.skip.l1: action NewMbL1:[isNewMb], RefIdxL1:[refIdx],
		SelectList:[listSelected] ==>
	guard
		isNewMb and wpIdc = 0 and listSelected = PRED_L1
	end

	SendWeightParam.skip.biPred: action NewMbL0:[isNewMbL0],
		NewMbL1:[isNewMbL1], RefIdxL0:[refIdxl0], RefIdxL1:[refIdxl1],
		SelectList:[listSelected] ==>
	guard
		isNewMbL0 and isNewMbL1 and wpIdc = 0 and listSelected = BIPRED
	end

	getWeightedPredIdc: action NewMbL0:[isNewMbL0], NewMbL1:[isNewMbL1], PocListX:[pocListX] repeat 33, PocIsLTList:[pocIsLTList] repeat 32,
		WeightedPredIdc:[weightPredIdc], NumRefIdxLXActive:[numRefIdxLXAct]
		repeat 2 ==>
	guard
		not isNewMbL0 and not isNewMbL1
	do
		uint(size=1) idxL0 = 0;
		uint(size=1) idxL1 = 1;

		wpIdc := weightPredIdc;
		numRefIdxL0Active := numRefIdxLXAct[0];
		numRefIdxL1Active := numRefIdxLXAct[1];
		if(wpIdc = 2) then
			lumaLog2WeightDenom := 5;
			chrLog2WeightDenom  := 5;
			foreach int Component in 0 .. 2
			do
				foreach int refIdx in 0 .. numRefIdxL0Active - 1
				do
					offset[Component][idxL0][refIdx] := 0;
				end
				foreach int refIdx in 0 .. numRefIdxL1Active - 1
				do
					offset[Component][idxL1][refIdx] := 0;
				end
			end
			currPoc := pocListX[0];
			foreach int i in 0 .. 15
			do
				pocList0[i] := pocListX[i+1];
				pocList1[i] := pocListX[i+17];
				isLTList0[i] := pocIsLTList[i];
				isLTList1[i] := pocIsLTList[i+16];
			end
		end
	end

	getWeightDenom.skip: action ==>
	guard
		wpIdc != 1
	end

	getWeightDenom.launch: action WeightedParam:[lumaDenom, chromaDenom] ==>
	guard
		wpIdc = 1
	do
		lumaLog2WeightDenom := lumaDenom;
		chrLog2WeightDenom  := chromaDenom;
		isL0 := true;
		iLoop := 0;
	end

	getWeightAndOffset.launch: action WeightedParam:[param] repeat 6 ==>
	guard
		iLoop < numRefIdxL0Active and isL0 or
		iLoop < numRefIdxL1Active and not isL0
	do
		uint(size=1) idxLX := if(isL0) then 0 else 1 end;

		foreach uint Component in 0 .. 2
		do
			weight[Component][idxLX][iLoop] := param[2*Component];
			offset[Component][idxLX][iLoop] := param[2*Component + 1];
		end
		iLoop := iLoop + 1;
	end

	getWeightAndOffset.endLoop: action ==>
	guard
		not(iLoop < numRefIdxL0Active and isL0) and
		not(iLoop < numRefIdxL1Active and not isL0)
	end

	getHasL1Comp.isTrue: action WeightedParam:[hasL1Comp] ==>
	guard
		hasL1Comp = 1
	do
		isL0 := false;
		iLoop := 0;
	end

	getHasL1Comp.isFalse: action WeightedParam:[hasL1Comp] ==>
	guard
		hasL1Comp = 0
	end

	schedule fsm GetCommand:
		GetCommand (getWeightedPredIdc )--> GetWeightDenom;
		GetCommand (SendWeightParam    )--> GetCommand;

		GetWeightDenom     (getWeightDenom.launch )--> GetWeightAndOffL0;
		GetWeightDenom     (getWeightDenom.skip   )--> GetCommand;

		GetWeightAndOffL0 (getWeightAndOffset.launch  )--> GetWeightAndOffL0;
		GetWeightAndOffL0 (getWeightAndOffset.endLoop )--> CheckHasL1;
		CheckHasL1        (getHasL1Comp.isTrue        )--> GetWeightAndOffL1;
		CheckHasL1        (getHasL1Comp.isFalse       )--> GetCommand;

		GetWeightAndOffL1 (getWeightAndOffset.launch  )--> GetWeightAndOffL1;
		GetWeightAndOffL1 (getWeightAndOffset.endLoop )--> GetCommand;
	end
end