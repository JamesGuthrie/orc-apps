/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package ch.epfl.mpeg4.part10.frext.synParser.modular.decodePicture;

import org.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import org.mpeg4.part10.Imp_PictureInfo.*;
import org.mpeg4.part10.cbp.synParser.modular.cavlcLookUpTables.*;
import org.mpeg4.part10.frext.synParser.modular.decodePicture.cabacDecoding.*;
import org.mpeg4.part10.cbp.MacroBlockInfo.*;
import std.util.BitOps.*;
import std.util.Math.*;

actor MgntAndVLDecoding()
	uint(size=8)  RbspByte,
	bool          NewNal,
	int (size=32) ValVLD,

	int (size=6)  Header1TypeOfVLD,
	int (size=32) Header1VLDParam,
	int (size=6)  Header2TypeOfVLD,
	int (size=32) Header2VLDParam,
	uint(size=5)  DecRefPicMarkingTypeOfVLD,
	int (size=32) DecRefPicMarkingNbBitsToRead,
	uint(size=5)  RefPicListTypeOfVLD,
	int (size=32) RefPicListNbBitsToRead,
	int (size=6)  DataTypeOfVLD,
	int (size=32) DataVLDParam,
	int (size=6)  MbLayerTypeOfVLD,
	int (size=32) MbLayerVLDParam,
	uint(size=5)  MbPredTypeOfVLD,
	int (size=32) MbPredNbBitsToRead,
	uint(size=5)  SubMbPredTypeOfVLD,
	int (size=32) SubMbPredNbBitsToRead,
	int (size=6)  ResTypeOfVLD,
	int (size=32) ResActorLaunched,
	uint(size=5)  ResBlkCavlcTypeOfVLD,
	int (size=32) ResBlkCavlcVLD_Param,
	uint(size=5)  ResBlkCabacTypeOfVLD,
	int (size=32) ResBlkCabacVLD_Param
		==>
	uint(size=5)  TypeOfVLD,
	int (size=32) VLD_Param,
	int (size=32) Header1ValVLD,
	int (size=32) Header2ValVLD,
	int (size=32) DecRefPicMarkingValVLD,
	int (size=32) RefPicListValVLD,
	int (size=32) DataValVLD,
	int (size=32) MbLayerValVLD,
	int (size=32) MbPredValVLD,
	int (size=32) SubMbPredValVLD,
	int (size=32) ResBlkCavlcValVLD,
	int (size=32) ResBlkCabacValVLD
		:

	uint(size=8)  callStack[16];
	uint(size=32) nbParamToDecod := 0;
	uint(size=3)  stackIdx;

	initialize ==>
	do
		/* We will launch sliceHeader1 at the begining of the picture nal */
		stackIdx     := 0;
		callStack[0] := SLICE_HEADER1;
	end

	/* Choosing next Actor to launch thanks to the call stack */
	findOutNextActor.isSliceHeader1: action ==>
	guard
		callStack[stackIdx] = SLICE_HEADER1
	end

	findOutNextActor.isSliceHeader2: action ==>
	guard
		callStack[stackIdx] = SLICE_HEADER2
	end

	findOutNextActor.isRefPicMark: action ==>
	guard
		callStack[stackIdx] = REF_PIC_MARKING
	end

	findOutNextActor.isRefPicList: action ==>
	guard
		callStack[stackIdx] = REF_PIC_LIST
	end

	findOutNextActor.isSliceData: action ==>
	guard
		callStack[stackIdx] = SLICE_DATA
	end

	findOutNextActor.isMbLayer: action ==>
	guard
		callStack[stackIdx] = MB_LAYER
	end

	findOutNextActor.isMbPred: action ==>
	guard
		callStack[stackIdx] = MB_PRED
	end

	findOutNextActor.isSubMbPred: action ==>
	guard
		callStack[stackIdx] = SUB_MB_PRED
	end

	findOutNextActor.isResidual: action ==>
	guard
		callStack[stackIdx] = RESIDUAL
	end

	findOutNextActor.isResidualCavlc: action ==>
	guard
		callStack[stackIdx] = RESIDUAL_BLOCK_CAVLC
	end

	findOutNextActor.isResidualCabac: action ==>
	guard
		callStack[stackIdx] = RESIDUAL_BLOCK_CABAC
	end

	getVldVal.done: action ==>
	guard
		nbParamToDecod = 0
	end

	waitVLDVal: action ==>
	guard
		nbParamToDecod > 0
	end


	/* Forwarding Slice Header 1 Informations */
	sliceHeader1.vld.withoutParam: action Header1TypeOfVLD:[typeOfVld] ==>
		TypeOfVLD:[typeOfVld]
	guard
		NbParamForFunction(typeOfVld) = 0 and typeOfVld != SKIP_NAL
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	sliceHeader1.vld.with1Param: action Header1TypeOfVLD:[typeOfVld],
		Header1VLDParam:[param] ==> TypeOfVLD:[typeOfVld], VLD_Param:[param]
	guard
		NbParamForFunction(typeOfVld) = 1
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	sliceHeader1.launchActor: action Header1TypeOfVLD:[typeOfVld],
		Header1VLDParam:[actorName] ==>
	guard
		typeOfVld = LAUNCH_ACTOR
	do
		stackIdx := (stackIdx + 1) & 0x0F;
		callStack[stackIdx] := actorName;
	end

	sliceHeader1.done: action Header1TypeOfVLD:[typeOfVld] ==>
	guard
		typeOfVld = SKIP_NAL
	end

	getVldVal.sliceHeader1: action ValVLD:[vldVal] ==> Header1ValVLD:[vldVal]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end


	/* Forwarding Slice Header 2 Informations */
	sliceHeader2.vld.withoutParam: action Header2TypeOfVLD:[typeOfVld] ==>
		TypeOfVLD:[typeOfVld]
	guard
		NbParamForFunction(typeOfVld) = 0 and typeOfVld != SKIP_NAL
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	sliceHeader2.vld.with1Param: action Header2TypeOfVLD:[typeOfVld],
		Header2VLDParam:[param] ==> TypeOfVLD:[typeOfVld], VLD_Param:[param]
	guard
		NbParamForFunction(typeOfVld) = 1
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	sliceHeader2.launchActor: action Header2TypeOfVLD:[typeOfVld],
		Header2VLDParam:[actorName] ==>
	guard
		typeOfVld = LAUNCH_ACTOR
	do
		stackIdx := (stackIdx + 1) & 0x0F;
		callStack[stackIdx] := actorName;
	end

	sliceHeader2.done: action Header2TypeOfVLD:[typeOfVld] ==>
	guard
		typeOfVld = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	getVldVal.sliceHeader2: action ValVLD:[vldVal] ==> Header2ValVLD:[vldVal]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end


	/* Forwarding Slice RefPicMarking Informations */
	refPicMark.vld.withoutParam: action DecRefPicMarkingTypeOfVLD:[typeOfVld]
		==> TypeOfVLD:[typeOfVld]
	guard
		NbParamForFunction(typeOfVld) = 0 and typeOfVld != SKIP_NAL
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	refPicMark.vld.with1Param: action DecRefPicMarkingTypeOfVLD:[typeOfVld],
		DecRefPicMarkingNbBitsToRead:[param] ==> TypeOfVLD:[typeOfVld],
		VLD_Param :[param]
	guard
		NbParamForFunction(typeOfVld) = 1
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	refPicMark.done: action DecRefPicMarkingTypeOfVLD:[typeOfVld] ==>
	guard
		typeOfVld = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	getVldVal.refPicMark: action ValVLD:[vldVal] ==>
		DecRefPicMarkingValVLD:[vldVal]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end


	/* Forwarding RefPicList Informations */
	refPicList.vld.withoutParam: action RefPicListTypeOfVLD:[typeOfVld] ==>
		TypeOfVLD:[typeOfVld]
	guard
		NbParamForFunction(typeOfVld) = 0,
		typeOfVld  != SKIP_NAL
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	refPicList.vld.with1Param: action RefPicListTypeOfVLD:[typeOfVld],
		RefPicListNbBitsToRead:[param] ==> TypeOfVLD:[typeOfVld],
		VLD_Param:[param]
	guard
		NbParamForFunction(typeOfVld) = 1
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	refPicList.done: action RefPicListTypeOfVLD:[typeOfVld] ==>
	guard
		typeOfVld = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	getVldVal.refPicList: action ValVLD:[vldVal] ==> RefPicListValVLD:[vldVal]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end


	/* Forwarding SliceData Informations */
	sliceData.vld.withoutParam: action DataTypeOfVLD:[typeOfVld] ==>
		TypeOfVLD:[typeOfVld]
	guard
		NbParamForFunction(typeOfVld) = 0 and typeOfVld != SKIP_NAL
	do
		if(typeOfVld != BYTE_ALIGNED_REQUIRED)then
			nbParamToDecod := nbParamToDecod + 1;
		end
	end

	sliceData.vld.with1Param: action DataTypeOfVLD:[typeOfVld],
		DataVLDParam:[param] ==> TypeOfVLD:[typeOfVld], VLD_Param:[param]
	guard
		NbParamForFunction(typeOfVld) = 1
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	sliceData.vld.with3Param: action DataTypeOfVLD:[typeOfVLD],
		DataVLDParam:[param] repeat 3 ==> TypeOfVLD:[typeOfVLD],
		VLD_Param:[param] repeat 3
	guard
		NbParamForFunction(typeOfVLD) = 3
	end

	sliceData.vld.with8Param: action DataTypeOfVLD:[typeOfVLD],
		DataVLDParam:[param] repeat 8 ==> TypeOfVLD:[typeOfVLD],
		VLD_Param:[param] repeat 8
	guard
		NbParamForFunction(typeOfVLD) = 8
	end

	sliceData.launchActor: action DataTypeOfVLD:[typeOfVld],
		DataVLDParam:[actorName] ==>
	guard
		typeOfVld = LAUNCH_ACTOR
	do
		stackIdx := (stackIdx + 1) & 0x0F;
		callStack[stackIdx] := actorName;
	end

	sliceData.done: action DataTypeOfVLD:[typeOfVld] ==> TypeOfVLD:[typeOfVld]
	guard
		typeOfVld = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	getVldVal.sliceData: action ValVLD:[vldVal] ==> DataValVLD:[vldVal]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end


	/* Forwarding MbLayer Informations */
	mbLayer.vld.withoutParam: action MbLayerTypeOfVLD:[typeOfVld] ==>
		TypeOfVLD:[typeOfVld]
	guard
		NbParamForFunction(typeOfVld) = 0 and typeOfVld != SKIP_NAL
	do
		if(typeOfVld != BYTE_ALIGNED_REQUIRED and
			typeOfVld != CABAC_INIT_ARITHM)then
			nbParamToDecod := nbParamToDecod + 1;
		end
	end

	mbLayer.vld.with1Param: action MbLayerTypeOfVLD:[typeOfVld],
		MbLayerVLDParam:[param] ==> TypeOfVLD:[typeOfVld], VLD_Param:[param]
	guard
		NbParamForFunction(typeOfVld) = 1
	do
		if(typeOfVld != CABAC_SEND_MB_TYPE) then
			nbParamToDecod := nbParamToDecod + 1;
		end
	end

	mbLayer.vld.with2Param: action MbLayerTypeOfVLD :[typeOfVld],
		MbLayerVLDParam:[param] repeat 2 ==> TypeOfVLD:[typeOfVld],
		VLD_Param:[param] repeat 2
	guard
		NbParamForFunction(typeOfVld) = 2
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	mbLayer.launchActor : action MbLayerTypeOfVLD:[typeOfVld],
		MbLayerVLDParam:[actorName] ==>
	guard
		typeOfVld = LAUNCH_ACTOR
	do
		stackIdx := (stackIdx + 1) & 0x0F;
		callStack[stackIdx] := actorName;
	end

	mbLayer.done: action MbLayerTypeOfVLD:[typeOfVld] ==>
	guard
		typeOfVld = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	getVldVal.mbLayer: action ValVLD:[vldVal] ==> MbLayerValVLD:[vldVal]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end


	/* Forwarding MbPred Informations */
	mbPred.vld.withoutParam: action MbPredTypeOfVLD:[typeOfVld] ==>
		TypeOfVLD:[typeOfVld]
	guard
		NbParamForFunction(typeOfVld) = 0 and typeOfVld != SKIP_NAL
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	mbPred.vld.with1Param: action MbPredTypeOfVLD:[typeOfVld],
		MbPredNbBitsToRead:[param] ==> TypeOfVLD:[typeOfVld],
		VLD_Param:[param]
	guard
		NbParamForFunction(typeOfVld) = 1
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	mbPred.vld.with2Param: action MbPredTypeOfVLD:[typeOfVld],
		MbPredNbBitsToRead:[param] repeat 2 ==> TypeOfVLD:[typeOfVld],
		VLD_Param:[param] repeat 2
	guard
		NbParamForFunction(typeOfVld) = 2
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	mbPred.done: action MbPredTypeOfVLD:[typeOfVld] ==>
	guard
		typeOfVld = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	getVldVal.mbPred: action ValVLD:[vldVal] ==> MbPredValVLD:[vldVal]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end


	/* Forwarding SubMbPred Informations */
	subMbPred.vld.withoutParam: action SubMbPredTypeOfVLD:[typeOfVld] ==>
		TypeOfVLD:[typeOfVld]
	guard
		NbParamForFunction(typeOfVld) = 0,
		typeOfVld  != SKIP_NAL
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	subMbPred.vld.with1Param: action SubMbPredTypeOfVLD:[typeOfVld],
		SubMbPredNbBitsToRead :[param] ==> TypeOfVLD:[typeOfVld],
		VLD_Param:[param]
	guard
		NbParamForFunction(typeOfVld) = 1
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	subMbPred.done: action SubMbPredTypeOfVLD:[typeOfVld] ==>
	guard
		typeOfVld = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	getVldVal.subMbPred: action ValVLD:[vldVal] ==> SubMbPredValVLD:[vldVal]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end


	/* Forwarding Residual Informations */
	residual.launchActor: action ResTypeOfVLD:[typeOfVld],
		ResActorLaunched:[actorName] ==>
	guard
		typeOfVld = LAUNCH_ACTOR
	do
		stackIdx := (stackIdx + 1) & 0x0F;
		callStack[stackIdx] := actorName;
	end

	residual.done: action ResTypeOfVLD:[typeOfVld] ==>
	guard
		typeOfVld = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end


	/* Forwarding ResidualBlockCavlc Informations */
	resBlkCavlc.vld.withoutParam: action ResBlkCavlcTypeOfVLD:[typeOfVld]
		==> TypeOfVLD:[typeOfVld]
	guard
		NbParamForFunction(typeOfVld) = 0,
		typeOfVld != SKIP_NAL
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	resBlkCavlc.vld.with1Param: action ResBlkCavlcTypeOfVLD:[typeOfVld],
		ResBlkCavlcVLD_Param:[param] ==> TypeOfVLD:[typeOfVld],
		VLD_Param:[param]
	guard
		NbParamForFunction(typeOfVld) = 1
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	resBlkCavlc.vld.with2Param: action ResBlkCavlcTypeOfVLD :[typeOfVld],
		ResBlkCavlcVLD_Param:[param] repeat 2 ==> TypeOfVLD:[typeOfVld],
		VLD_Param:[param] repeat 2
	guard
		NbParamForFunction(typeOfVld) = 2
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	resBlkCavlc.done: action ResBlkCavlcTypeOfVLD:[typeOfVld] ==>
	guard
		typeOfVld = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	getVldVal.resBlkCavlc: action ValVLD:[vldVal] ==>
		ResBlkCavlcValVLD:[vldVal]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end


	/* Forwarding ResidualBlockCabac Informations */
	resBlkCabac.vld.withoutParam: action ResBlkCabacTypeOfVLD:[typeOfVLD] ==>
		TypeOfVLD:[typeOfVLD]
	guard
		NbParamForFunction(typeOfVLD) = 0 and typeOfVLD != SKIP_NAL
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	resBlkCabac.vld.with1Param: action ResBlkCabacTypeOfVLD:[typeOfVLD],
		ResBlkCabacVLD_Param :[param] ==> TypeOfVLD:[typeOfVLD],
		VLD_Param:[param]
	guard
		NbParamForFunction(typeOfVLD) = 1
	do
		nbParamToDecod := nbParamToDecod + 1;
	end

	resBlkCabac.done: action ResBlkCabacTypeOfVLD:[typeOfVLD] ==>
	guard
		typeOfVLD = SKIP_NAL
	do
		stackIdx := (stackIdx - 1) & 0x0F;
	end

	getVldVal.resBlkCabac: action ValVLD:[vldVal] ==>
		ResBlkCabacValVLD:[vldVal]
	guard
		nbParamToDecod > 0
	do
		nbParamToDecod := nbParamToDecod - 1;
	end

	/*************************************************************************/
	/*************************************************************************/
	/*************************************************************************/
	/*********************** VLDECODING ACTOR                 ****************/
	/*************************************************************************/
	/*************************************************************************/
	bool DEBUG_FLAG_DECODED = false;
	bool DEBUG_CABAC = false;

	uint(size=2) RENORM_D       = 0;
	uint(size=2) DECODE_BYPASS  = 1;
	uint(size=2) SKIP           = 2;

	//Contains the Byte which is currently read.
	uint(size=16) WorkingByte      := 0;
	//Contains the number of bit which are not read yet in WorkingByte
	uint(size=4)  CountBufferRbsp  := 0;
	//Contains up to 4 next byte in the flow. It helps for more_rbsp_data()
	//and Cabac initialisation
	uint(size=3)  SizeBufferRbsp   := 0;
	List(type: uint(size=8), size=4) BufferRbsp := [0: for int s in 0 .. 3];
	/* ue(v) and Cavlc coeff_token()*/
	bool          Bit1Found       := false;
	uint(size=5)  leadingZeroBits := 0;
	/* ue(v) only */
	int (size=31) CodeNum         := 0;
	/* u(n) */
	uint(size=5)  BitsCount       := 0;
	uint(size=31) ReadValue       := 0;
	uint(size=1)  TeVal           := 0;
	/* more_rbsp_data() */
	bool          NewNalAlreadyDetected  := false;

	/* Cavlc */
	uint(size=5) NbBitsRead;
	/* Cavlc coeff_token */
	uint(size=3) Idx_nC;
	uint(size=6) coeff_token;
	/* Cavlc total_zeros and run_before */
	uint(size=3) ValRead         := 0;
	/* Cavlc total_zeros */
	uint(size=2) IdxmaxNumCoeff  := 0;
	uint(size=4) TotalCoeffParam := 0;
	/* Cavlc run_before */
	uint(size=8) IdxzerosLeft    := 0;

	/* Cabac inittialisation */
	int (size=3) cabacInitIdc;
	int (size=6) pStateIdx[640];
	int (size=8) sliceQpY;
	uint(size=1) valMPS[640];
	/* Cabac Arithmetic Decoding */
	int (size=16) codIRange;
	int (size=16) codIOffset;
	/* Cabac Mb type parsing */
	uint(size=5)  syntaxElement;
	int (size=6)  binIdx;
	uint(size=1)  binVal;
	uint(size=32) binString;
	uint(size=32) binStringPrefix;
	uint(size=3)  cabacFLRemainBits;
	uint(size=8)  cMax;
	bool          hasSuffix;
	bool          isTUForMvd;
	bool          prefixDecoded;
	uint(size=2)  cabacEndDecodeBin;
	uint(size=11) ctxIdx;
	bool          byPass;
	bool          signedVal;
	uint(size=2)  UEGk;

	bool          askSignedFlag;
	uint(size=4)  ctxBlockCat;
	int (size=32) currMbAddr;
	uint(size=6)  currMbType;
	uint(size=3)  currMbPartIdx;
	uint(size=6)  currSubMbType;
	uint(size=3)  currSubMbPartIdx;
	bool          first0Found := true;
	bool          isL0;
	uint(size=4)  levelListIdx;
	uint(size=4)  luma4x4Idx;
	uint(size=6)  mbTypeNeighbours[2][16];
	bool          neighboursAvail[2][16] :=
		[[true : for int s in 0 .. 15]: for int t in 0 .. 1];
	uint(size=1)  neighboursCbfChroma[2][17];
	uint(size=1)  neighboursCbfLumaAc[2][16];
	uint(size=1)  neighboursCbfLumaDc[2];
	uint(size=2)  neighboursCbpLuma[2];
	uint(size=2)  neighboursCbpChroma[2];
	uint(size=4)  neighboursIntraPredC[2];
	bool          neighbourMbSkip[2];
	//Contains mvd's values for neighbours for current Mb and also for future
	//Mb.
	//predLX - luma4x4Idx - isAorBNeighb - xOrYComponent
	int(size=16)  neighbourMvdLX[2][20][2][2];
	uint(size=4)  neighbourSubMbType[20][2];
	//             [isL0][luma4x4Idx][aOrB]
	uint(size=4)  neighbourRefIdx[2][20][2];
	uint(size=5)  numDecodAbsLvlEq1;
	uint(size=5)  numDecodAbsLvlGt1;
	//[mbAddr][predLX][aOrB][lumaIdx][vertOrHor]
	int (size=16) pictureNeighbMvdLX[POW2_PICWIDTH_BLK_PLUS1][2][2][4][2];
	int (size=16) pictureNeighbSubMbTp[POW2_PICWIDTH_BLK_PLUS1][2][4];
	//[mbAddr][predLX][aOrB][lumaIdx][vertOrHor]
	uint(size=4)  pictureNeighbRefIdx[POW2_PICWIDTH_BLK_PLUS1][2][2][4];
	uint(size=6)  prevCbp;
	bool          prevMbAvail;
	int(size=8)   prevMbQpDelta;
	uint(size=1)  priorDecBinVal[4];
	bool          signedFlag;
	bool          signedFlagDecoded;
	bool          signedFlagRemaining;
	uint(size=4)  sliceType;

	uint(size=5)   typeOfVld;
	int(size=32)   valDecoded;
	int(size=32)   vldParam[8];

	//Table 9.39 - Assignment of ctxIdxIncto binIdx for all ctxIdxOffset
	//We give lot of parameters, but the structure doesn't exist yet, that's
	//why we can't give some informations related together in one variable
	function getCtxIdxInc(uint(size=11) ctxIdxOffset, bool neighbAvail[2],
		uint(size=6) neighbMbType[2], uint(size=4) locNeighbSubMbType[2],
		uint(size=3) locNeighbMbPtIdx[2], int(size=16) locNeighbMvdLX[2][2],
		uint(size=4) locNeighbRefIdx[2], bool isCurrMbTab[2], uint(size=4)
		neighboursBlk8x8Idx[2], uint(size=1) priorTab[2], uint(size=1)
		neighbourCbf[2]) --> uint(size=3) :

		if(syntaxElement != CABAC_CODED_BLOCK_FLAG and
		   syntaxElement != CABAC_SIGNIFICANT_COEFF_FLAG and
		   syntaxElement != CABAC_LAST_SIGNIFICANT_COEFF_FLAG and
		   syntaxElement != CABAC_COEFF_ABS_LEVEL_MINUS1) then
			if(binIdx = 0) then
				getCtxIdxIncBinIdxEq0(ctxIdxOffset, neighbAvail,
					neighbMbType, locNeighbSubMbType, locNeighbMbPtIdx,
					locNeighbMvdLX, locNeighbRefIdx, isCurrMbTab,
					neighboursBlk8x8Idx, priorTab)
			else if(binIdx = 1)then
				getCtxIdxIncBinIdxEq1(ctxIdxOffset, neighbAvail, neighbMbType,
					isCurrMbTab, neighboursBlk8x8Idx, priorTab, binIdx,
					neighboursCbpLuma, neighboursCbpChroma)
			else if(binIdx = 2) then
				getCtxIdxIncBinIdxEq2(ctxIdxOffset, neighbAvail, neighbMbType,
					isCurrMbTab, neighboursBlk8x8Idx, priorTab, binIdx,
					priorDecBinVal, neighboursCbpLuma, neighboursCbpChroma)
			else if(binIdx = 3) then
				getCtxIdxIncBinIdxEq3(ctxIdxOffset, neighbAvail, neighbMbType,
					isCurrMbTab, neighboursBlk8x8Idx, priorTab, binIdx,
					neighboursCbpLuma, neighboursCbpChroma)
			else if(binIdx = 4) then
				getCtxIdxIncBinIdxEq4(ctxIdxOffset, binIdx, priorDecBinVal)
			else if(binIdx = 5) then
				getCtxIdxIncBinIdxEq5(ctxIdxOffset, binIdx, priorDecBinVal)
			else
				getCtxIdxIncBinIdxSup5(ctxIdxOffset)
			end end end end end end
		else if(syntaxElement = CABAC_CODED_BLOCK_FLAG) then
			getCtxIdxIncCodedBlockFlag(neighbAvail, currMbType, neighbMbType,
				neighbourCbf) +
			ctxIdxBlockCatOffset[0][ctxBlockCat]
		else if(syntaxElement = CABAC_COEFF_ABS_LEVEL_MINUS1) then
			getCtxIdxIncCoeffAbsLvlMin1(ctxBlockCat, binIdx, numDecodAbsLvlGt1,
				numDecodAbsLvlEq1) +
			ctxIdxBlockCatOffset[2][ctxBlockCat]
		else
			getCtxIdxIncSignCoeff(ctxBlockCat, levelListIdx) +
			ctxIdxBlockCatOffset[1][ctxBlockCat]
		end end end
	end

	function getCtxIdxIncBinIdxEq0(uint(size=11) ctxIdxOffset, bool neighbAvail[2],
		uint(size=6) neighbMbType[2], uint(size=4) locNeighbSubMbType[2],
		uint(size=3) locNeighbMbPtIdx[2], int(size=16) locNeighbMvdLX[2][2],
		uint(size=4) locNeighbRefIdx[2], bool isCurrMbTab[2], uint(size=4)
		neighboursBlk8x8Idx[2], uint(size=1) priorTab[2]) --> uint(size=3) :
		if(ctxIdxOffset = 0 or ctxIdxOffset = 3 or ctxIdxOffset = 27) then
			getCtxIdxIncMbType(neighbAvail, neighbMbType, ctxIdxOffset)
		else if(ctxIdxOffset = 11 or ctxIdxOffset = 24) then
			getCtxIdxIncMbSkipFlag(neighbAvail, neighbourMbSkip)
		else if(ctxIdxOffset = 40 or ctxIdxOffset = 47) then
			getCtxIdxIncMvdLX(ctxIdxOffset, neighbAvail, neighbMbType,
				locNeighbMbPtIdx, isL0, locNeighbSubMbType, locNeighbMvdLX)
		else if(ctxIdxOffset = 54) then
			getCtxIdxIncRefIdxLX(neighbAvail, neighbMbType, locNeighbRefIdx,
				locNeighbMbPtIdx, isL0, locNeighbSubMbType)
		else if(ctxIdxOffset = 60) then
			getCtxIdxIncMbQpDelta(prevMbAvail, mbTypeNeighbours[0][0], prevCbp,
				prevMbQpDelta)
		else if(ctxIdxOffset = 64) then
			getCtxIdxIncIntraChromPred(neighbAvail, neighbMbType,
				neighboursIntraPredC)
		else if(ctxIdxOffset = 70) then
			/* We don't manage field */
			42
			/*ctxIdxInc := getCtxIdxIncMbFieldDec([neighbourAAvail,
				neighbourBAvail], [true, true]);*/
		else if(ctxIdxOffset = 73 or ctxIdxOffset = 77) then
			getCtxIdxIncCodBlkPattern(binIdx, ctxIdxOffset, neighbAvail,
				neighbMbType, isCurrMbTab, neighboursCbpLuma,
				neighboursBlk8x8Idx, priorTab, neighboursCbpChroma)
		else if(ctxIdxOffset = 399) then
			42
			/*ctxIdxInc := getCtxIdxIncTrsfSz8x8(bool neighbourAvail[2],
				bool neighbourTrsfSz8x8[2]);*/
		else
			0
		end end end end end end end end end
	end

	/* Cabac procedures */
	procedure getCtxIdx(uint(size=11) ctxIdxOffset)
	begin
		uint(size=4) neighbourAIdx[16] = [5, 0, 7, 2, 1, 4, 3, 6, 13, 8, 15,
			10, 9, 12, 11, 14];
		uint(size=4) neighbourBIdx[16] = [10, 11, 0, 1, 14, 15, 4, 5, 2, 3,
			8, 9, 6, 7, 12, 13];
		uint(size=2) invNeighbour8x8A[4] = [1, 0, 3, 2];
		uint(size=2) invNeighbour8x8B[4] = [2, 3, 0, 1];

		//Remove these variables when the bug #49 will be fixed
		uint(size=1) priorTab[2];
		bool         isCurrMbTab[2];
		uint(size=1) neighbourCbf[2];
		bool         neighbAvail[2];
		uint(size=6) neighbMbType[2];
		uint(size=4) neighboursBlk8x8Idx[2];
		uint(size=3) locNeighbMbPtIdx[2];
		uint(size=4) locNeighbSubMbType[2];
		int(size=16) locNeighbMvdLX[2][2];
		uint(size=4) locNeighbRefIdx[2];
		uint(size=1) idxPredLX;

		if(syntaxElement != CABAC_CODED_BLOCK_FLAG and
		   syntaxElement != CABAC_SIGNIFICANT_COEFF_FLAG and
		   syntaxElement != CABAC_LAST_SIGNIFICANT_COEFF_FLAG and
		   syntaxElement != CABAC_COEFF_ABS_LEVEL_MINUS1) then

			if(binIdx = 3 and ctxIdxOffset = 73) then
				priorTab    := [priorDecBinVal[2],priorDecBinVal[1]];
				isCurrMbTab := [true,true];
				neighbAvail := [neighboursAvail[0][binIdx<<2], neighboursAvail[1][binIdx<<2]];
				neighbMbType := [mbTypeNeighbours[0][binIdx<<2], mbTypeNeighbours[1][binIdx<<2]];
				neighboursBlk8x8Idx := [invNeighbour8x8A[binIdx], invNeighbour8x8B[binIdx]];
			end
			if(binIdx = 2 and ctxIdxOffset = 73) then
				priorTab    := [0,priorDecBinVal[0]];
				isCurrMbTab := [false,true];
				neighbAvail := [neighboursAvail[0][binIdx<<2], neighboursAvail[1][binIdx<<2]];
				neighbMbType := [mbTypeNeighbours[0][binIdx<<2], mbTypeNeighbours[1][binIdx<<2]];
				neighboursBlk8x8Idx := [invNeighbour8x8A[binIdx], invNeighbour8x8B[binIdx]];
			end
			if(binIdx = 1 and (ctxIdxOffset = 73 or ctxIdxOffset = 77)) then
				priorTab    := [priorDecBinVal[0],0];
				isCurrMbTab := [true,false];
				neighbAvail :=
					if(ctxIdxOffset = 73) then
						[neighboursAvail[0][binIdx<<2], neighboursAvail[1][binIdx<<2]]
					else
						[neighboursAvail[0][0], neighboursAvail[1][0]]
					end;
				neighbMbType :=
					if(ctxIdxOffset = 73) then
						[mbTypeNeighbours[0][binIdx<<2], mbTypeNeighbours[1][binIdx<<2]]
					else
						[mbTypeNeighbours[0][0], mbTypeNeighbours[1][0]]
					end;
				neighboursBlk8x8Idx := [invNeighbour8x8A[binIdx], invNeighbour8x8B[binIdx]];
			end
			if(binIdx = 0) then
				if(ctxIdxOffset = 0 or ctxIdxOffset = 3 or ctxIdxOffset = 27) then
					neighbAvail := [neighboursAvail[0][0], neighboursAvail[1][0]];
					neighbMbType := [mbTypeNeighbours[0][0], mbTypeNeighbours[1][0]];
				else if(ctxIdxOffset = 11 or ctxIdxOffset = 24) then
					neighbAvail := [neighboursAvail[0][0], neighboursAvail[1][0]];
				else if(ctxIdxOffset = 40 or ctxIdxOffset = 47) then
					neighbAvail := [neighboursAvail[0][luma4x4Idx],
						neighboursAvail[1][luma4x4Idx]];
					neighbMbType := [mbTypeNeighbours[0][luma4x4Idx],
						mbTypeNeighbours[1][luma4x4Idx]];
					locNeighbSubMbType := [neighbourSubMbType[luma4x4Idx][0],
						neighbourSubMbType[luma4x4Idx][1]];
					locNeighbMbPtIdx[0] := lumaIdxToMbPartIdx(neighbourAIdx[luma4x4Idx], neighbMbType[0],
						locNeighbSubMbType[0]);
					locNeighbMbPtIdx[1] := lumaIdxToMbPartIdx(neighbourBIdx[luma4x4Idx], neighbMbType[1],
						locNeighbSubMbType[1]);
					idxPredLX := if(isL0) then 0 else 1 end;
					foreach int i in 0 .. 1
					do
						foreach int j in 0 .. 1
						do
							locNeighbMvdLX[i][j] :=
								neighbourMvdLX[idxPredLX][luma4x4Idx][i][j];
						end
					end
				else if(ctxIdxOffset = 54) then
					neighbAvail := [neighboursAvail[0][luma4x4Idx],
						neighboursAvail[1][luma4x4Idx]];
					neighbMbType := [mbTypeNeighbours[0][luma4x4Idx],
						mbTypeNeighbours[1][luma4x4Idx]];
					locNeighbSubMbType := [neighbourSubMbType[luma4x4Idx][0],
						neighbourSubMbType[luma4x4Idx][1]];
					locNeighbMbPtIdx[0] := lumaIdxToMbPartIdx(neighbourAIdx[luma4x4Idx], neighbMbType[0],
						locNeighbSubMbType[0]);
					locNeighbMbPtIdx[1] := lumaIdxToMbPartIdx(neighbourBIdx[luma4x4Idx], neighbMbType[1],
						locNeighbSubMbType[1]);
					idxPredLX := if(isL0) then 0 else 1 end;
					locNeighbRefIdx := [neighbourRefIdx[idxPredLX][luma4x4Idx]
						[0], neighbourRefIdx[idxPredLX][luma4x4Idx][1]];
				else if(ctxIdxOffset = 64) then
					neighbAvail := [neighboursAvail[0][0], neighboursAvail[1][0]];
					neighbMbType := [mbTypeNeighbours[0][0], mbTypeNeighbours[1][0]];
				else if(ctxIdxOffset = 73 or ctxIdxOffset = 77) then
					priorTab    := [0,0];
					isCurrMbTab := [false,false];
					neighbAvail := [neighboursAvail[0][binIdx<<2], neighboursAvail[1][binIdx<<2]];
					neighbMbType := [mbTypeNeighbours[0][binIdx<<2], mbTypeNeighbours[1][binIdx<<2]];
					neighboursBlk8x8Idx := [invNeighbour8x8A[binIdx], invNeighbour8x8B[binIdx]];
				end end end end end end
			end
		else if(syntaxElement = CABAC_CODED_BLOCK_FLAG) then
			neighbAvail := [neighboursAvail[0][luma4x4Idx], neighboursAvail[1][luma4x4Idx]];
			neighbMbType := [mbTypeNeighbours[0][luma4x4Idx], mbTypeNeighbours[1][luma4x4Idx]];
			neighbourCbf :=
				if(ctxBlockCat = 0) then
					[neighboursCbfLumaDc[0], neighboursCbfLumaDc[1]]
				else if(ctxBlockCat <= 2) then
					[neighboursCbfLumaAc[0][luma4x4Idx], neighboursCbfLumaAc[1]
						[luma4x4Idx]]
				else if(ctxBlockCat = 3) then
					[neighboursCbfChroma[0][0], neighboursCbfChroma[1][0]]
				else
					[neighboursCbfChroma[0][1+luma4x4Idx],
						neighboursCbfChroma[1][1+luma4x4Idx]]
				end end end;
		end end

		ctxIdx :=
			//ctxIdxInc
			getCtxIdxInc(ctxIdxOffset, neighbAvail, neighbMbType,
				locNeighbSubMbType, locNeighbMbPtIdx, locNeighbMvdLX,
				locNeighbRefIdx, isCurrMbTab, neighboursBlk8x8Idx, priorTab,
				neighbourCbf) +
			//+ ctxIdxOffset
			if(binIdx = 1 and (ctxIdxOffset = 3 or ctxIdxOffset = 17 or ctxIdxOffset = 32)) then
				//if(mb_type = I_PCM) then
				276
			else
				ctxIdxOffset
			end;
	end

	//9.3.3.2.1
	procedure decodeDecision()
	begin
		uint(size=2) qCodIRangeIdx;
		uint(size=8) codIRangeLPS;

		qCodIRangeIdx := (codIRange >> 6) & 0x03;
		codIRangeLPS  := rangeTabLPS[pStateIdx[ctxIdx]][qCodIRangeIdx];
		codIRange     := codIRange - codIRangeLPS;

		if(DEBUG_CABAC) then
	  		println("codIRange := "+codIRange+ " codIOffset := " + codIOffset+"  codIRangeLPS : "+ codIRangeLPS);
	  	end
		if(codIOffset >= codIRange) then
			binVal     := 1 - valMPS[ctxIdx];
			codIOffset := codIOffset - codIRange;
			codIRange  := codIRangeLPS;
			
			if(pStateIdx[ctxIdx] = 0) then
				valMPS[ctxIdx] := 1 - valMPS[ctxIdx];
			end
			pStateIdx[ctxIdx] := transIdxLPS[pStateIdx[ctxIdx]];
		else
			binVal := valMPS[ctxIdx]; 
			pStateIdx[ctxIdx] := transIdxMPS[pStateIdx[ctxIdx]];
		end
	end

	procedure updateNeighbourRefIdx(uint(size=4) sizeMbPart,
		uint(size=2) mbPartIdx, int(size=16) refIdx)
	begin
		uint(size=4) invNeighbourAIdx[16] = [1, 4, 3, 6, 5, 16, 7, 17, 9, 12,
			11, 14, 13, 18, 15, 19];
		uint(size=4) invNeighbourBIdx[16] = [2, 3, 8, 9, 6, 7, 12, 13, 10, 11,
			16, 17, 14, 15, 18, 19];
		uint(size=4) idx;
		uint(size=1) idxPredLX = if(isL0) then 0 else 1 end;

		if(sizeMbPart = SZ_16x16) then
			foreach uint idxLoop in 0 .. 15
			do
				neighbourRefIdx[idxPredLX][invNeighbourAIdx[idxLoop]][0]
					:= refIdx;
				neighbourRefIdx[idxPredLX][invNeighbourBIdx[idxLoop]][1]
					:= refIdx;
			end
		else if(sizeMbPart = SZ_16x8) then
			foreach uint idxLoop in 8*mbPartIdx .. 8*mbPartIdx+7
			do
				neighbourRefIdx[idxPredLX][invNeighbourAIdx[idxLoop]][0]
					:= refIdx;
				neighbourRefIdx[idxPredLX][invNeighbourBIdx[idxLoop]][1]
					:= refIdx;
			end
		else if(sizeMbPart = SZ_8x16) then
			foreach int i in 0 .. 1
			do
				foreach uint j in 0 .. 3
				do
					idx := mbPartIdx*4 + i*8 +j;
					neighbourRefIdx[idxPredLX][invNeighbourAIdx[idx]][0]
						:= refIdx;
					neighbourRefIdx[idxPredLX][invNeighbourBIdx[idx]][1]
						:= refIdx;
				end
			end
		else
			foreach uint i in 0 .. 3
			do
				idx := mbPartIdx*4 + i;
				neighbourRefIdx[idxPredLX][invNeighbourAIdx[idx]][0]
					:= refIdx;
				neighbourRefIdx[idxPredLX][invNeighbourBIdx[idx]][1]
					:= refIdx;
			end
		end end end
	end

	procedure updateNeighbourMvdLX(uint(size=4) sizeMbPart, uint(size=2) mbPartIdx, int(size=16) mvd)
	begin
		uint(size=4) invNeighbourAIdx[16] = [1, 4, 3, 6, 5, 16, 7, 17, 9, 12, 11,
			14, 13, 18, 15, 19];
		uint(size=4) invNeighbourBIdx[16] = [2, 3, 8, 9, 6, 7, 12, 13, 10, 11,
			16, 17, 14, 15, 18, 19];
		uint(size=4) idx;
		uint(size=2) idxLX =
			if(syntaxElement = CABAC_MVD_LX_0) then
				0
			else
				1
			end;
		uint(size=1) idxPredLX = if(isL0) then 0 else 1 end;

		if(sizeMbPart = SZ_16x16) then
			foreach uint idxLoop in 0 .. 15
			do
				neighbourMvdLX[idxPredLX][invNeighbourAIdx[idxLoop]][0][idxLX]
					:= mvd;
				neighbourMvdLX[idxPredLX][invNeighbourBIdx[idxLoop]][1][idxLX]
					:= mvd;
			end
		else if(sizeMbPart = SZ_16x8) then
			foreach uint idxLoop in 8*mbPartIdx .. 8*mbPartIdx+7
			do
				neighbourMvdLX[idxPredLX][invNeighbourAIdx[idxLoop]][0][idxLX]
					:= mvd;
				neighbourMvdLX[idxPredLX][invNeighbourBIdx[idxLoop]][1][idxLX]
					:= mvd;
			end
		else if(sizeMbPart = SZ_8x16) then
			foreach int i in 0 .. 1
			do
				foreach uint j in 0 .. 3
				do
					idx := mbPartIdx*4 + i*8 +j;
					neighbourMvdLX[idxPredLX][invNeighbourAIdx[idx]][0][idxLX]
						:= mvd;
					neighbourMvdLX[idxPredLX][invNeighbourBIdx[idx]][1][idxLX]
						:= mvd;
				end
			end
		else
			foreach uint i in 0 .. 3
			do
				idx := mbPartIdx*4 + i;
				neighbourMvdLX[idxPredLX][invNeighbourAIdx[idx]][0][idxLX]
					:= mvd;
				neighbourMvdLX[idxPredLX][invNeighbourBIdx[idx]][1][idxLX]
					:= mvd;
			end
		end end end
	end

	procedure updateNeighbourSubMvdLX(uint(size=4) sizeSubMbPart, uint(size=2) mbPartIdx, uint(size=2) subMbPartIdx, int(size=16) mvd)
	begin
		uint(size=4) invNeighbourAIdx[16] = [1, 4, 3, 6, 5, 16, 7, 17, 9, 12, 11,
			14, 13, 18, 15, 19];
		uint(size=4) invNeighbourBIdx[16] = [2, 3, 8, 9, 6, 7, 12, 13, 10, 11,
			16, 17, 14, 15, 18, 19];
		uint(size=4) idx;
		uint(size=2) idxLX =
			if(syntaxElement = CABAC_MVD_LX_0) then
				0
			else
				1
			end;
		uint(size=1) idxPredLX = if(isL0) then 0 else 1 end;

		if(sizeSubMbPart = SZ_8x8) then
			foreach uint i in 0 .. 3
			do
				idx := 4*mbPartIdx + i;
				neighbourMvdLX[idxPredLX][invNeighbourAIdx[idx]][0][idxLX]
					:= mvd;
				neighbourMvdLX[idxPredLX][invNeighbourBIdx[idx]][1][idxLX]
					:= mvd;
			end
		else if(sizeSubMbPart = SZ_8x4) then
			foreach uint i in 0 .. 1
			do
				idx := 4*mbPartIdx + 2*subMbPartIdx + i;
				neighbourMvdLX[idxPredLX][invNeighbourAIdx[idx]][0][idxLX]
					:= mvd;
				neighbourMvdLX[idxPredLX][invNeighbourBIdx[idx]][1][idxLX]
					:= mvd;
			end
		else if(sizeSubMbPart = SZ_4x8) then
			foreach uint i in 0 .. 1
			do
				idx := 4*mbPartIdx + subMbPartIdx + 2*i;
				neighbourMvdLX[idxPredLX][invNeighbourAIdx[idx]][0][idxLX]
					:= mvd;
				neighbourMvdLX[idxPredLX][invNeighbourBIdx[idx]][1][idxLX]
					:= mvd;
			end
		else
			idx := 4*mbPartIdx + subMbPartIdx;
			neighbourMvdLX[idxPredLX][invNeighbourAIdx[idx]][0][idxLX]
				:= mvd;
			neighbourMvdLX[idxPredLX][invNeighbourBIdx[idx]][1][idxLX]
				:= mvd;
		end end end
	end

	/* Read bits procedure */
	uint(size=32) Out_ReadNBits;
	procedure ReadNBitsInWorkingByte(uint(size=32) InitialValue, uint(size=4) NbBitsToRead)
	begin
		Out_ReadNBits    := InitialValue << NbBitsToRead;
		Out_ReadNBits    := Out_ReadNBits + selectBits(WorkingByte >> (8-NbBitsToRead), 0 , NbBitsToRead);
		WorkingByte     := WorkingByte << NbBitsToRead;
		CountBufferRbsp := CountBufferRbsp - NbBitsToRead;
	end


	//Syntaxe decoding have finished the decoding of this Nal
	IsEndOfNal: action ==>
	guard
		typeOfVld = SKIP_NAL
	do
		CountBufferRbsp := 0;
		SizeBufferRbsp  := 0;
	end

	//We skip all bytes in the current nal
	WaitForNewNal: action NewNal :[IsNewNal], RbspByte :[ValRbsp] ==>
	guard
		IsNewNal = false
	end

	NewNalDetected: action NewNal :[IsNewNal] ==>
	guard
		IsNewNal = true
	do
		SizeBufferRbsp := 0;
	end

	NewNalHasBeenSent: action ==>
	guard
		NewNalAlreadyDetected = true
	end

	ResetNewNalAlreadyDetected: action ==>
	do
		NewNalAlreadyDetected := false;
	end

	IsMoreRbspData: action ==>
	guard
		typeOfVld = MORE_RBSP_DATA
	end

	CheckSizeBufferRbsp.IsEqualOrSupTo2: action ==>
	guard
		SizeBufferRbsp >= 2
	do
		valDecoded := 1;
	end

	CheckSizeBufferRbsp.IsEqualTo1: action ==>
	guard
		SizeBufferRbsp = 1
	do
		valDecoded := 
			if(((WorkingByte = 0 and (BufferRbsp[0] & 0xFF) = 0x03) or 
			   ((BufferRbsp[0] & 0xFF) = 0x80)) and (CountBufferRbsp = 0) )then
				0
			else
				1
			end;
	end

	CheckSizeBufferRbsp.IsEqualTo0: action ==>
	guard
		SizeBufferRbsp = 0
	do
		valDecoded :=
			if( (WorkingByte & 0xFF) = 0x80 )then
				 0
			else
				1
			end;
	end

	FillBufferRbsp: action RbspByte :[ValRbspByte], NewNal :[ValNewNal] ==>
	guard
		SizeBufferRbsp        < 4,
		ValNewNal             = false,
		NewNalAlreadyDetected = false
	do
		BufferRbsp[3]  := BufferRbsp[2];
		BufferRbsp[2]  := BufferRbsp[1];
		BufferRbsp[1]  := BufferRbsp[0];
		BufferRbsp[0]  := ValRbspByte;
		SizeBufferRbsp := SizeBufferRbsp + 1;
	end

	FutureNewNalDetected: action NewNal :[IsNewNal] ==>
	guard
		IsNewNal              = true,
		NewNalAlreadyDetected = false
	do
		NewNalAlreadyDetected := true;
	end

	IsVldUe: action ==>
	guard
		typeOfVld = VLD_UE
	do
		Bit1Found       := false;
		leadingZeroBits := 0;
		CodeNum         := 0;
	end

	IsVldSe: action ==>
	guard
		typeOfVld = VLD_SE
	do
		Bit1Found       := false;
		leadingZeroBits := 0;
		CodeNum         := 0;
	end

	IsReadBits: action ==>
	guard
		typeOfVld = READ_BITS
	do
		BitsCount := vldParam[0];
		ReadValue := 0;
		TeVal     := 0;
	end

	IsVldTe.u: action ==>
	guard
		typeOfVld = VLD_TE,
		vldParam[0]    = 1
	do
		BitsCount := 1;
		ReadValue := 0;
		TeVal     := 1;
	end

	IsVldTe.ue: action ==>
	guard
		typeOfVld = VLD_TE,
		vldParam[0]    > 1
	do
		Bit1Found       := false;
		leadingZeroBits := 0;
		CodeNum         := 0;
	end

	IsCavlcCoeffToken: action ==>
	guard
		typeOfVld = CAVLC_COEFF_TOKEN
	do
		int(size=32) nC = vldParam[0];
		Idx_nC :=
			if(nC < 0)then
				if(nC = -1)then
					 4
				else
					5
				end
			else
				if(nC >=8)then
					3
				else
					if(nC >=4)then
						2
					else
						nC/2
					end
				end
			end;
		coeff_token := 0;
		NbBitsRead := 0;
	end

	IsCavlcTotalZeros: action ==>
	guard
		typeOfVld = CAVLC_TOTAL_ZEROS
	do
		int(size=32) maxNumCoeff = vldParam[0];
		int(size=32) TotalCoeff = vldParam[1];
		IdxmaxNumCoeff :=
			if(maxNumCoeff = 4) then
				0
			else
				if(maxNumCoeff=8) then
					1
				else
					2
				end
			end;
		NbBitsRead      := 0;
		ValRead         := 0;
		TotalCoeffParam := TotalCoeff & 0x0F;
	end

	IsCavlcRunBefore: action ==>
	guard
		typeOfVld = CAVLC_RUN_BEFORE
	do
		int(size=32) zerosLeft = vldParam[0];
		IdxzerosLeft :=
			if(zerosLeft > 0 and zerosLeft <= 6) then
				zerosLeft - 1
			else
				6
			end;
		NbBitsRead      := 0;
		ValRead         := 0;
	end

	isCabacInit: action ==>
	guard
		typeOfVld = CABAC_INIT
	do
		cabacInitIdc := vldParam[0];
		sliceQpY     := vldParam[1];
		sliceType    := vldParam[2];
	end

	isCabacInitArithm: action ==>
	guard
		typeOfVld = CABAC_INIT_ARITHM
	end

	isCabacGetMbType: action ==>
	guard
		typeOfVld = CABAC_SEND_MB_TYPE
	do
		uint(size=4) neighbourAIdx[12] = [1, 3, 4, 5, 6, 7,  9, 11, 12, 13, 14, 15];
		uint(size=4) neighbourBIdx[12] = [2, 3, 6, 7, 8, 9, 10, 11, 12, 13, 14 ,15];

		currMbType := vldParam[0];
		foreach int i in 0 .. 11
		do
			mbTypeNeighbours[0][neighbourAIdx[i]] := currMbType;
			mbTypeNeighbours[1][neighbourBIdx[i]] := currMbType;
		end
	end

	isCabacDecod.withoutParam: action ==>
	guard
		NbParamForFunction(typeOfVld) = 0 && typeOfVld >= CABAC_DECOD_MINI
	do
		binIdx        := -1;
		binString     :=  0;
		syntaxElement := typeOfVld;
		byPass        := (syntaxElement = CABAC_COEFF_SIGN_FLAG);
		prefixDecoded := false;

		//Needed for FL decoding.
		cabacFLRemainBits :=
			if(syntaxElement != CABAC_REM_INTRA4x4_8x8_PRED_MODE) then
				1
			else
				3
			end;
		if(syntaxElement = CABAC_COEFF_ABS_LEVEL_MINUS1) then
			cMax := 14;
			hasSuffix := true;
			signedVal := false;
			CodeNum   := 0;
		end
	end

	isCabacDecod.with1Param: action ==>
	guard
		NbParamForFunction(typeOfVld) = 1 && typeOfVld >= CABAC_DECOD_MINI
	do
		uint(size=10) neighbChrReceiv;

		binIdx        := -1;
		binString     :=  0;
		syntaxElement := typeOfVld;
		byPass        := false;
		prefixDecoded := false;

		if(syntaxElement = CABAC_CODED_BLOCK_FLAG)then
			luma4x4Idx  := (vldParam[0] >> 4) & 0x0F;
			ctxBlockCat := vldParam[0] & 0x0F;
			neighbChrReceiv := (vldParam[0] >> 14) & 0x3FF;
			neighboursCbfChroma[0][0] := (neighbChrReceiv >> 9)&1;
			neighboursCbfChroma[1][0] := (neighbChrReceiv >> 4)&1;
			neighboursCbfChroma[0][0+1] := (neighbChrReceiv >> 6)&1;
			neighboursCbfChroma[0][2+1] := (neighbChrReceiv >> 8)&1;
			neighboursCbfChroma[1][0+1] := (neighbChrReceiv >> 2)&1;
			neighboursCbfChroma[1][1+1] := (neighbChrReceiv >> 3)&1;
		else if(syntaxElement = CABAC_MB_SKIP_FLAG) then
			//Used by mb_skip_flag decoding
			neighbourMbSkip[0] := getFlag(vldParam[0], 1);
			neighbourMbSkip[1] := getFlag(vldParam[0], 0);
			neighboursAvail[0][0] := getFlag(vldParam[0], 2);
			neighboursAvail[1][0] := getFlag(vldParam[0], 3);
		else if(syntaxElement = CABAC_MB_TYPE)then
			sliceType := vldParam[0];
			hasSuffix := true;
		else if(syntaxElement = CABAC_MVD_LX_0 or
			syntaxElement = CABAC_MVD_LX_1) then
			cMax := 9;
			hasSuffix := true;
			signedVal := true;
			CodeNum   := 0;
			currMbPartIdx := (vldParam[0] >> 3) & 0x07;
			//We took a neighbour of the first partition of the sub_macroblock
			currSubMbType := neighbourSubMbType[4*currMbPartIdx+1][0];
			currSubMbPartIdx := vldParam[0] & 0x07;
			isL0 := getFlag(vldParam[0], 6);
			luma4x4Idx := partIdxToLuma4x4(currMbType, currMbPartIdx,
				currSubMbType, currSubMbPartIdx);
		else if(syntaxElement = CABAC_REF_IDX_LX) then
			currMbPartIdx := vldParam[0] & 0x07;
			isL0 := getFlag(vldParam[0], 3);
			currSubMbType := neighbourSubMbType[4*currMbPartIdx+1][0];
			currSubMbPartIdx := 0;
			luma4x4Idx := partIdxToLuma4x4(currMbType, currMbPartIdx,
				currSubMbType, currSubMbPartIdx);
		else
			//ctxBlockCat did not change.
			levelListIdx := vldParam[0];
		end end end end end
		numDecodAbsLvlEq1 := 0;
		numDecodAbsLvlGt1 := 0;
		cabacFLRemainBits := 1;
	end

	isCabacDecod.with2Param: action ==>
	guard
		NbParamForFunction(typeOfVld) = 2 && typeOfVld >= CABAC_DECOD_MINI
	do
		binIdx        := -1;
		binString     :=  0;
		syntaxElement := typeOfVld;
		byPass        := false;
		prefixDecoded := false;

		if(typeOfVld = CABAC_INTRA_CHROMA_PRED_MODE) then
			neighboursIntraPredC[0] := vldParam[0];
			neighboursIntraPredC[1] := vldParam[1];
			cMax := 3;
		else if (typeOfVld = CABAC_CODED_BLOCK_PATERN) then
			neighboursCbpLuma[0]   := vldParam[0] mod 16;
			neighboursCbpLuma[1]   := vldParam[1] mod 16;
			neighboursCbpChroma[0] := vldParam[0]  /  16;
			neighboursCbpChroma[1] := vldParam[1]  /  16;
			cabacFLRemainBits := 4;
			hasSuffix     := true;
			cMax := 2;
		else
			prevCbp := vldParam[0];
			prevMbQpDelta := vldParam[1];
		end end
	end

	IsCavlcLevelPrefix: action ==>
	guard
		typeOfVld = CAVLC_LEVEL_PREFIX
	do
		Bit1Found       := false;
		leadingZeroBits := 0;
	end

	IsByteAligned: action ==>
	guard
		typeOfVld = BYTE_ALIGNED_REQUIRED
	do
		if(CountBufferRbsp != 8)then
			CountBufferRbsp := 0;
		end
	end

	isCabacInitMbVal: action ==>
	guard
		typeOfVld = CABAC_INIT_MB_VAL
	do
		uint(size=4)  neighbourAIdx[4] = [0, 2, 8, 10];
		uint(size=4)  neighbourBIdx[4] = [0, 1, 4,  5];
		uint(size=32) picWidthInMbs = vldParam[7];

		/* Saving neighbour mvd */
		if(vldParam[6] < currMbAddr) then
			currMbAddr := -1;
		end
		foreach int mbAddr in currMbAddr + 2 .. vldParam[6]
		do
			foreach int lumaIdx in 0 .. 3
			do
				foreach int vertOrHor in 0 .. 1
				do
					foreach int aOrB in 0 .. 1
					do
						foreach int idxPredLX in 0 .. 1
						do
							pictureNeighbMvdLX[mbAddr &
								MASK_POW2_PICWIDTH_BLK_PLUS1][idxPredLX][aOrB]
								[lumaIdx][vertOrHor] := 0;
						end
					end
				end
			end
		end
		if(currMbAddr != -1) then
			foreach int lumaIdx in 0 .. 3
			do
				foreach int aOrB in 0 .. 1
				do
					foreach int idxPredLX in 0 .. 1
					do
						foreach int vertOrHor in 0 .. 1
						do
							pictureNeighbMvdLX[currMbAddr &
								MASK_POW2_PICWIDTH_BLK_PLUS1][idxPredLX][aOrB]
								[lumaIdx][vertOrHor] := neighbourMvdLX
								[idxPredLX][16+lumaIdx][aOrB][vertOrHor];
						end
						pictureNeighbRefIdx[currMbAddr &
							MASK_POW2_PICWIDTH_BLK_PLUS1][idxPredLX][aOrB][lumaIdx] :=
							neighbourRefIdx[idxPredLX][16+lumaIdx][aOrB];
					end
					pictureNeighbSubMbTp[currMbAddr &
						MASK_POW2_PICWIDTH_BLK_PLUS1][aOrB][lumaIdx] :=
						neighbourSubMbType[16+lumaIdx][aOrB];
				end
			end
		end
		foreach int i in 0 .. 15
		do
			neighboursCbfLumaAc[0][i] := 0;
			neighboursCbfLumaAc[1][i] := 0;
		end

		currMbAddr := vldParam[6];
		/* Getting neighbour parameters */
		prevMbAvail := getFlag(vldParam[0], 2);
		foreach int i in 0 .. 3
		do
			neighboursAvail[0][neighbourAIdx[i]] := getFlag(vldParam[0], 0);
			neighboursAvail[1][neighbourBIdx[i]] := getFlag(vldParam[0], 1);
			mbTypeNeighbours[0][neighbourAIdx[i]] := vldParam[1];
			mbTypeNeighbours[1][neighbourBIdx[i]] := vldParam[2];
			neighboursCbfLumaAc[0][neighbourAIdx[i]]    := (vldParam[3] >> (neighbourAIdx[i] + 5)) & 1;
			neighboursCbfLumaAc[1][neighbourBIdx[i]]    := (vldParam[4] >> (neighbourBIdx[i] + 10)) & 1;
			foreach int idxPredLX in 0 .. 1
			do
				foreach int vertOrHor in 0 .. 1
				do
					neighbourMvdLX[idxPredLX][neighbourAIdx[i]][0][vertOrHor] :=
						pictureNeighbMvdLX[(currMbAddr-1) &
						MASK_POW2_PICWIDTH_BLK_PLUS1][idxPredLX][0][i]
						[vertOrHor];
					neighbourMvdLX[idxPredLX][neighbourBIdx[i]][1][vertOrHor] :=
						pictureNeighbMvdLX[(currMbAddr-picWidthInMbs) &
						MASK_POW2_PICWIDTH_BLK_PLUS1][idxPredLX][1][i]
						[vertOrHor];
				end
				neighbourRefIdx[idxPredLX][neighbourAIdx[i]][0] :=
					pictureNeighbRefIdx[(currMbAddr-1) &
							MASK_POW2_PICWIDTH_BLK_PLUS1][idxPredLX][0][i];
				neighbourRefIdx[idxPredLX][neighbourBIdx[i]][1] :=
					pictureNeighbRefIdx[(currMbAddr-picWidthInMbs) &
								MASK_POW2_PICWIDTH_BLK_PLUS1][idxPredLX][1][i];
			end
			neighbourSubMbType[neighbourAIdx[i]][0] :=
				pictureNeighbSubMbTp[(currMbAddr-1) &
						MASK_POW2_PICWIDTH_BLK_PLUS1][0][i];
			neighbourSubMbType[neighbourBIdx[i]][1] :=
				pictureNeighbSubMbTp[(currMbAddr-picWidthInMbs) &
							MASK_POW2_PICWIDTH_BLK_PLUS1][1][i];
		end
		neighboursCbfLumaDc[0] := (vldParam[5]>>1) & 1;
		neighboursCbfLumaDc[1] := vldParam[5] & 1;

		luma4x4Idx := 0;
		currMbPartIdx := 0;
		
	end

	Buffer.IsEmpty: action ==>
	guard
		CountBufferRbsp = 0,
		SizeBufferRbsp  > 0
	do
		CountBufferRbsp := 8;
		SizeBufferRbsp  := SizeBufferRbsp - 1;
		WorkingByte     := BufferRbsp[SizeBufferRbsp];
	end

	Buffer.IsNotEmpty: action ==>
	guard
		CountBufferRbsp > 0
	end

	GetCodeNum.Launch: action ==>
	var
		uint(size=5) NbBitsToAdd
	do
		if(not Bit1Found)then
			while( ((WorkingByte & 0x80) = 0) and (CountBufferRbsp > 0))
			do
				CountBufferRbsp := CountBufferRbsp - 1;
				WorkingByte     := WorkingByte << 1;
				leadingZeroBits := leadingZeroBits + 1;
			end
			if(CountBufferRbsp > 0)then
				leadingZeroBits := leadingZeroBits + 1;
				Bit1Found       := true;
			end
		end
		if(Bit1Found)then
			NbBitsToAdd :=
				if(CountBufferRbsp < leadingZeroBits)then
					CountBufferRbsp
				else
					leadingZeroBits
				end;
			ReadNBitsInWorkingByte(CodeNum,NbBitsToAdd);
			CodeNum         := Out_ReadNBits;
			leadingZeroBits := leadingZeroBits - NbBitsToAdd;
		end
	end

	GetCodeNum.Finished: action ==>
	guard
		leadingZeroBits = 0
	end

	GetCodeNum.NotFinished: action ==>
	guard
		leadingZeroBits != 0
	end

	SendUeValue: action ==>
	do
		valDecoded := CodeNum - 1;
	end

	SendSeValue: action ==>
	do
		//CodeNum computed is equal to CodeNum + 1
		if( (CodeNum mod 2) = 0 )then
			valDecoded := CodeNum / 2;
		else
			valDecoded := -CodeNum / 2;
		end
	end

	Get_u.Launch: action ==>
	var
		uint(size=5) NbBitsToAdd
	do
		NbBitsToAdd :=
			if(CountBufferRbsp < BitsCount)then
				CountBufferRbsp
			else
				BitsCount
			end;
		ReadNBitsInWorkingByte(ReadValue,NbBitsToAdd);
		ReadValue       := Out_ReadNBits;
		BitsCount       := BitsCount - NbBitsToAdd;
	end

	Get_u.Finished: action ==>
	guard
		BitsCount = 0
	end

	Get_u.NotFinished: action ==>
	guard
		BitsCount != 0
	end

	SendUValue: action ==>
	do
		valDecoded := ReadValue ^ TeVal;
	end

	GetCavlcCoeffToken.Launch: action ==>
	do
		ReadNBitsInWorkingByte(coeff_token,1);
		coeff_token := Out_ReadNBits;
		NbBitsRead  := NbBitsRead + 1;
		while((not TotalCoeffValid[Idx_nC][(NbBitsRead - 1) & 0x0F]
			[coeff_token & 0x3F]) and (CountBufferRbsp > 0))
		do
			ReadNBitsInWorkingByte(coeff_token,1);
			coeff_token := Out_ReadNBits;
			NbBitsRead  := NbBitsRead + 1;
		end
	end

	GetCavlcCoeffToken.NotFinished: action ==>
	guard
		TotalCoeffValid[Idx_nC][(NbBitsRead - 1) & 0x0F][coeff_token & 0x3F] = false
	end

	GetCavlcCoeffToken.Finished: action ==>
	do
		if(DEBUG_FLAG_DECODED)then
			println("Cavlc CoeffToken; Idx_nc :" + Idx_nC + " ; NbBitsRead : "+NbBitsRead+ " ; coeff_token : "+coeff_token);
		end
		valDecoded := TotalCoeffValue[Idx_nC][(NbBitsRead-1) & 0x0F][coeff_token & 0x3F];
	end

	GetCavlcLevelPrefix.Launch: action ==>
	do
		while( ((WorkingByte & 0x80) = 0) and (CountBufferRbsp > 0))
		do
			CountBufferRbsp := CountBufferRbsp - 1;
			WorkingByte     := WorkingByte << 1;
			leadingZeroBits := leadingZeroBits + 1;
		end
		if(CountBufferRbsp > 0)then
			Bit1Found       := true;
			/* We read the one bit value */
			CountBufferRbsp := CountBufferRbsp - 1;
			WorkingByte     := WorkingByte << 1;
		end
	end

	GetCavlcLevelPrefix.NotFinished: action ==>
	guard
		not Bit1Found
	end

	GetCavlcLevelPrefix.Finished: action ==>
	guard
		Bit1Found
	do
		 valDecoded := leadingZeroBits;
	end

	GetCavlcTotalZeros.Launch: action ==>
	do
		ReadNBitsInWorkingByte(ValRead,1);
		ValRead := Out_ReadNBits;
		NbBitsRead      := NbBitsRead + 1;
		while((not TotalZerosValid[IdxmaxNumCoeff][TotalCoeffParam]
			[NbBitsRead & 0x0F][ValRead & 0x07]) and (CountBufferRbsp > 0))
		do
			ReadNBitsInWorkingByte(ValRead,1);
			ValRead    := Out_ReadNBits;
			NbBitsRead := NbBitsRead + 1;
		end
	end

	GetCavlcTotalZeros.NotFinished: action ==>
	guard
		not TotalZerosValid[IdxmaxNumCoeff][TotalCoeffParam][NbBitsRead & 0x0F][ValRead & 0x07]
	end

	GetCavlcTotalZeros.Finished: action ==>
	do
		if(DEBUG_FLAG_DECODED)then
			println("Cavlc TotalZeros; Idx :" + IdxmaxNumCoeff +" ; TotalCoeff :"+TotalCoeffParam+ " ; NbBitsRead : "+NbBitsRead+ " ; Codeword : "+ValRead);
		end
		valDecoded := TotalZerosValue[IdxmaxNumCoeff][TotalCoeffParam][NbBitsRead & 0x0F][ValRead & 0x07];
	end

	GetCavlcRunBefore.Launch: action ==>
	do
		ReadNBitsInWorkingByte(ValRead,1);
		ValRead    := Out_ReadNBits;
		NbBitsRead := NbBitsRead + 1;
		while((not RunBeforeValid[IdxzerosLeft][NbBitsRead & 0x0F]
			[ValRead & 0x07]) and (CountBufferRbsp > 0))
		do
			ReadNBitsInWorkingByte(ValRead,1);
			ValRead    := Out_ReadNBits;
			NbBitsRead := NbBitsRead + 1;
		end
	end

	GetCavlcRunBefore.NotFinished: action ==>
	guard
		not RunBeforeValid[IdxzerosLeft][NbBitsRead & 0x0F][ValRead & 0x07]
	end

	GetCavlcRunBefore.Finished: action ==>
	do
		if(DEBUG_FLAG_DECODED)then
			print("Run Before; Idx :" + IdxzerosLeft +" ; Run Before :"+
				RunBeforeValue[IdxzerosLeft][NbBitsRead & 0x0F]
				[ValRead & 0x07]);
			println(" ; NbBitsRead : "+NbBitsRead+ " ; Codeword : "+ValRead);
		end
		valDecoded := RunBeforeValue[IdxzerosLeft][NbBitsRead & 0x0F]
			[ValRead & 0x07];
	end

/******* Cabac Decoding *******/

	/* Initialization process */
	cabacInitContextVar: action ==>
	do
		int preCtxState;

		foreach int i in 0 .. 459 do
			//Should be modify : CabacContextInit I and PB should be merged and
			//we should use the index cabacInitIdc + 1
			preCtxState :=
				if(cabacInitIdc = -1) then
					computePreCtxState(sliceQpY, Cabac_Context_Init_I[i][0],
						Cabac_Context_Init_I[i][1])
				else
					computePreCtxState(sliceQpY, Cabac_Context_Init_PB
						[cabacInitIdc][i][0], Cabac_Context_Init_PB
						[cabacInitIdc][i][1])
				end;				
			if(preCtxState  <=  63)  then
				pStateIdx[i] := 63 - preCtxState;
				valMPS[i]    := 0 ;
			else 
				pStateIdx[i] := preCtxState - 64;
				valMPS[i]    := 1;
			end
		end
	end

	cabacInitArithDecod: action ==>
	guard
		//There are more than 9 bits in the buffers
		SizeBufferRbsp > 1 or
		SizeBufferRbsp = 1 and CountBufferRbsp >= 1
	do
		uint(size=4) nbBitInFirstByte = CountBufferRbsp;

		codIRange	:= 0x01FE;
		ReadNBitsInWorkingByte(0, CountBufferRbsp);

		CountBufferRbsp := 8;
		SizeBufferRbsp  := SizeBufferRbsp - 1;
		WorkingByte     := BufferRbsp[SizeBufferRbsp];

		ReadNBitsInWorkingByte(Out_ReadNBits, 9- nbBitInFirstByte);
		codIOffset := Out_ReadNBits;
	end

	cabacGetCtxIdx: action ==>
	do
		uint(size=11) ctxIdxOffset;
		bool          ctxIdxOffParam1;
		int(size=32)  ctxIdxOffParam2;


		//Only needed for Fixed Lenght decoding
		cabacFLRemainBits := cabacFLRemainBits - 1;

		//Begining of DecodeBin(ctxIdx)
		if(byPass) then
			cabacEndDecodeBin := DECODE_BYPASS;
		else
			binIdx := binIdx + 1;
			ctxIdxOffParam1 :=
				syntaxElement != CABAC_MB_SKIP_FLAG && prefixDecoded ||
				syntaxElement = CABAC_MB_SKIP_FLAG &&
					(sliceType != SLICE_TYPE_B);
			ctxIdxOffParam2 :=
				if(syntaxElement = CABAC_MB_TYPE or
					syntaxElement = CABAC_SUB_MB_TYPE) then
					sliceType
				else
					ctxBlockCat
				end;
			ctxIdxOffset := getCtxIdxOff(syntaxElement, ctxIdxOffParam1,
				ctxIdxOffParam2);
			getCtxIdx(ctxIdxOffset);
			if(ctxIdx = 276) then
				//9.3.3.2.4 : decodeTerminate()
				codIRange := codIRange - 2;
				if(codIOffset >= codIRange) then
					binVal := 1;
					cabacEndDecodeBin := SKIP;
				else
					binVal := 0;
					cabacEndDecodeBin := RENORM_D;
				end
			else
				decodeDecision();
				cabacEndDecodeBin := RENORM_D;
			end
			if(not isCabacFL(syntaxElement, not prefixDecoded)) then
				binString := binString << 1;
				binString := binString + binVal;
			end
		end
	end

	cabacRenormD.launch: action ==>
	guard
		codIRange < 0x0100 and cabacEndDecodeBin = RENORM_D
	do
		codIRange := codIRange << 1;
		ReadNBitsInWorkingByte(codIOffset, 1);
		codIOffset := Out_ReadNBits;
	end

	cabacEndDecode.skip: action ==>
	guard
		//RenormD is finished
		codIRange >= 0x0100 and cabacEndDecodeBin = RENORM_D or
		//no Extra Renorm or Decode Asked
		cabacEndDecodeBin = SKIP
	end

	decodeByPass: action ==>
	guard
		cabacEndDecodeBin = DECODE_BYPASS
	do
		ReadNBitsInWorkingByte(codIOffset, 1);
		codIOffset := Out_ReadNBits;
		if(codIOffset >= codIRange) then
			binVal := 1;
			codIOffset := codIOffset - codIRange;
		else
			binVal := 0;
		end

		if(askSignedFlag) then
			signedFlag := (binVal != 0);
			signedFlagDecoded := true;
		else if(syntaxElement = CABAC_COEFF_ABS_LEVEL_MINUS1 or
			syntaxElement = CABAC_MVD_LX_0 or
			syntaxElement = CABAC_MVD_LX_1) then
			//Needed for UEGk
			if(not first0Found and binVal = 0) then
				first0Found := true;
				binVal := 1;
			end
			if(not first0Found) then
				binIdx := binIdx + 1;
			else
				binIdx  := binIdx - 1;
				CodeNum := (CodeNum << 1) + binVal;
			end
		end end
	end

	cabacCheckBinarization.done: action ==>
	guard
		binarizationDone(binIdx, binString, syntaxElement, cabacFLRemainBits,
			binVal, not prefixDecoded, cMax, byPass, sliceType, signedFlagDecoded),
		not hasSuffix || prefixDecoded and not signedFlagRemaining || signedFlagDecoded ||
		skipSuffixDecoding(syntaxElement, signedVal, binVal, binIdx, binString, sliceType)
	do
		uint(size=4) sizePart;

		uint(size=4) invNeighbourAIdx[16] = [1, 4, 3, 6, 5, 0, 7, 0, 9, 12, 11,
			14, 13, 0, 15, 0];
		uint(size=4) invNeighbourBIdx[16] = [2, 3, 8, 9, 6, 7, 12, 13, 10, 11,
			0, 0, 14, 15, 0, 0];
		uint(size=4) invNeigAWithPicNeig[16] = [1, 4, 3, 6, 5, 16, 7, 17, 9, 12, 11,
			14, 13, 18, 15, 19];
		uint(size=4) invNeigBWithPicNeig[16] = [2, 3, 8, 9, 6, 7, 12, 13, 10, 11,
			16, 17, 14, 15, 18, 19];

		valDecoded :=
			if(isCabacFL(syntaxElement, not prefixDecoded)) then
				binString + (binVal << binIdx)
			else if(syntaxElement = CABAC_CODED_BLOCK_PATERN) then
				if(binVal = 1)then
					(2 << 4) + binStringPrefix
				else
					(binIdx << 4) + binStringPrefix
				end
			else if(isCabacTU(syntaxElement, not prefixDecoded or
				isTUForMvd)) then
				if(binVal = 1 && (not prefixDecoded or not (syntaxElement =
					CABAC_MVD_LX_0 or syntaxElement = CABAC_MVD_LX_1)))then
					cMax
				else
					binIdx
				end
			else if(syntaxElement = CABAC_COEFF_ABS_LEVEL_MINUS1 ||
				syntaxElement = CABAC_MVD_LX_0 || syntaxElement =
				CABAC_MVD_LX_1) then
				cMax + CodeNum - (1 << UEGk)
			else if(byPass) then
				binVal
			else if(syntaxElement = CABAC_MB_QP_DELTA) then
				if( ((binIdx + 1) & 1) = 0 )then
					(binIdx + 1) / 2
				else
					-binIdx / 2
				end
			else if(isCabacU(syntaxElement)) then
				binIdx
			else
				getBinarizationValue(binIdx, binString, sliceType, not prefixDecoded, syntaxElement)
			end end end end end end end;

		if(signedFlag) then
			signedFlag := false;
			valDecoded := - valDecoded;
		end

		if(syntaxElement = CABAC_COEFF_ABS_LEVEL_MINUS1) then
			if(abs(valDecoded + 1) > 1) then
				numDecodAbsLvlGt1 := numDecodAbsLvlGt1 + 1;
			else if(abs(valDecoded + 1) = 1) then
				numDecodAbsLvlEq1 := numDecodAbsLvlEq1 + 1;
			end end
		else if(syntaxElement = CABAC_CODED_BLOCK_FLAG) then
			if(ctxBlockCat <= 2) then
				neighboursCbfLumaAc[0][invNeighbourAIdx[luma4x4Idx]] := valDecoded;
				neighboursCbfLumaAc[1][invNeighbourBIdx[luma4x4Idx]] := valDecoded;
			else if(ctxBlockCat = 4) then
				neighboursCbfChroma[0][1+invNeighbourAIdx[luma4x4Idx]] := valDecoded;
				neighboursCbfChroma[1][1+invNeighbourBIdx[luma4x4Idx]] := valDecoded;
			end end
		else if(syntaxElement = CABAC_SUB_MB_TYPE) then
			foreach int i in 4*currMbPartIdx .. 4*currMbPartIdx+3
			do
				neighbourSubMbType[invNeigAWithPicNeig[i]][0] := valDecoded;
				neighbourSubMbType[invNeigBWithPicNeig[i]][1] := valDecoded;
			end
			currMbPartIdx := currMbPartIdx + 1;
		else if(syntaxElement = CABAC_MVD_LX_0 or
			    syntaxElement = CABAC_MVD_LX_1) then
			if(currMbType = BLOCK_TYPE_P_8x8 or currMbType = BLOCK_TYPE_B_8x8) then
				sizePart := SizeSubMbPart(currMbType, currSubMbType);
				updateNeighbourSubMvdLX(sizePart, currMbPartIdx, currSubMbPartIdx, valDecoded);
			else
				sizePart := SizeMbPart(currMbType);
				updateNeighbourMvdLX(sizePart, currMbPartIdx, valDecoded);
			end
		else if(syntaxElement = CABAC_REF_IDX_LX) then
			sizePart := SizeMbPart(currMbType);
			updateNeighbourRefIdx(sizePart, currMbPartIdx, valDecoded);
		end end end end end

		hasSuffix := false;
		signedFlagDecoded := false;
		askSignedFlag := false;
		isTUForMvd := false;
	end

	cabacCheckBinarization.notFinished: action ==>
	do
		if(isCabacFL(syntaxElement, not prefixDecoded)) then
			binString := binString + (binVal << binIdx);
		end
		//Only needed by coded_block_pattern and mb_type_I
		priorDecBinVal[binIdx & 3] := binVal;
	end

	cabacInitForSuffix: action ==>
	guard
		binarizationDone(binIdx, binString, syntaxElement, cabacFLRemainBits,
			binVal, not prefixDecoded, cMax, byPass, sliceType, signedFlagDecoded)
	do
		prefixDecoded   := true;
		binStringPrefix := binString + (binVal << binIdx);
		binString := 0;
		if(syntaxElement = CABAC_COEFF_ABS_LEVEL_MINUS1) then
			byPass      := true;
			first0Found := false;
			binIdx := 0;
			CodeNum   := 0;
			UEGk := 0;
		else if (syntaxElement = CABAC_MVD_LX_0 or syntaxElement =
			CABAC_MVD_LX_1) then
			first0Found := false;
			byPass      := true;
			if(binVal = 1 and not signedFlagRemaining) then
				first0Found := false;
				binIdx := 3;
				UEGk   := 3;
				signedFlagRemaining := true;
				CodeNum   := 0;
			else
				//We will decode the sign flag and stop decoding after that
				askSignedFlag := true;
				hasSuffix := false;
				//if the UEG3 has not been launched
				if(not signedFlagRemaining) then
					isTUForMvd := true;
				end
				signedFlagRemaining := false;
			end
		else
			binIdx := -1;
		end end
	end
	schedule fsm FindOutNextActor:
		FindOutNextActor (findOutNextActor.isSliceHeader1  )--> SlcHead1;
		FindOutNextActor (findOutNextActor.isSliceHeader2  )--> SlcHead2;
		FindOutNextActor (findOutNextActor.isRefPicMark    )--> RefPicMark;
		FindOutNextActor (findOutNextActor.isRefPicList    )--> RefPicList;
		FindOutNextActor (findOutNextActor.isSliceData     )--> SliceData;
		FindOutNextActor (findOutNextActor.isMbLayer       )--> MbLayer;
		FindOutNextActor (findOutNextActor.isMbPred        )--> MbPred;
		FindOutNextActor (findOutNextActor.isSubMbPred     )--> SubMbPred;
		FindOutNextActor (findOutNextActor.isResidual      )--> Residual;
		FindOutNextActor (findOutNextActor.isResidualCavlc )--> ResBlkCavlc;
		FindOutNextActor (findOutNextActor.isResidualCabac )--> ResBlkCabac;

		SlcHead1 (sliceHeader1.vld         )--> SlcHead1;
		SlcHead1 (waitVLDVal               )--> SlcHeadGetVLDVal;
		SlcHead1 (sliceHeader1.launchActor )--> FindOutNextActor;
		SlcHead1 (sliceHeader1.done        )--> SlcHead1;
			SlcHeadGetVLDVal (getVldVal.sliceHeader1 )--> SlcHeadGetVLDVal;
			SlcHeadGetVLDVal (getVldVal.done         )--> SlcHead1;

		SlcHead2 (sliceHeader2.vld         )--> SlcHead2;
		SlcHead2 (waitVLDVal               )--> SlcHead2AvcGetVLDVal;
		SlcHead2 (sliceHeader2.launchActor )--> FindOutNextActor;
		SlcHead2 (sliceHeader2.done        )--> FindOutNextActor;
			SlcHead2AvcGetVLDVal (getVldVal.sliceHeader2 )--> SlcHead2AvcGetVLDVal;
			SlcHead2AvcGetVLDVal (getVldVal.done         )--> SlcHead2;
	
		RefPicMark (refPicMark.vld  )--> RefPicMark;
		RefPicMark (waitVLDVal      )--> RefPicMarkGetVLDVal;
		RefPicMark (refPicMark.done )--> FindOutNextActor;
			RefPicMarkGetVLDVal (getVldVal.refPicMark )--> RefPicMarkGetVLDVal;
			RefPicMarkGetVLDVal (getVldVal.done       )--> RefPicMark;
		
		RefPicList (refPicList.vld  )--> RefPicList;
		RefPicList (waitVLDVal      )--> RefPicListGetVLDVal;
		RefPicList (refPicList.done )--> FindOutNextActor;
			RefPicListGetVLDVal (getVldVal.refPicList )--> RefPicListGetVLDVal;
			RefPicListGetVLDVal (getVldVal.done       )--> RefPicList;
	
		SliceData (sliceData.vld         )--> SliceData;
		SliceData (waitVLDVal            )--> SliceDataGetVLDVal;
		SliceData (sliceData.launchActor )--> FindOutNextActor;
		SliceData (sliceData.done        )--> FindOutNextActor;
			SliceDataGetVLDVal (getVldVal.sliceData )--> SliceDataGetVLDVal;
			SliceDataGetVLDVal (getVldVal.done      )--> SliceData;
		
		MbLayer (mbLayer.vld         )--> MbLayer;
		MbLayer (waitVLDVal          )--> MbLayerGetVLDVal;
		MbLayer (mbLayer.done        )--> FindOutNextActor;
		MbLayer (mbLayer.launchActor )--> FindOutNextActor;
			MbLayerGetVLDVal (getVldVal.mbLayer )--> MbLayerGetVLDVal;
			MbLayerGetVLDVal (getVldVal.done    )--> MbLayer;
		
		MbPred (mbPred.vld  )--> MbPred;
		MbPred (waitVLDVal  )--> LaunchMbPredGetVLDVal;
		MbPred (mbPred.done )--> FindOutNextActor;
			LaunchMbPredGetVLDVal (getVldVal.mbPred )--> LaunchMbPredGetVLDVal;
			LaunchMbPredGetVLDVal (getVldVal.done   )--> MbPred;
		
		SubMbPred (subMbPred.vld  )--> SubMbPred;
		SubMbPred (waitVLDVal     )--> SubMbPredGetVLDVal;
		SubMbPred (subMbPred.done )--> FindOutNextActor;
			SubMbPredGetVLDVal (getVldVal.subMbPred )--> SubMbPredGetVLDVal;
			SubMbPredGetVLDVal (getVldVal.done      )--> SubMbPred;
	
		Residual (residual )--> FindOutNextActor;
	
		ResBlkCavlc (resBlkCavlc.vld  )--> ResBlkCavlc;
		ResBlkCavlc (waitVLDVal       )--> ResBlkCavlcGetVLDVal;
		ResBlkCavlc (resBlkCavlc.done )--> FindOutNextActor;
			ResBlkCavlcGetVLDVal (getVldVal.resBlkCavlc )--> ResBlkCavlcGetVLDVal;
			ResBlkCavlcGetVLDVal (getVldVal.done        )--> ResBlkCavlc;

		ResBlkCabac (resBlkCabac.vld  )--> ResBlkCabac;
		ResBlkCabac (waitVLDVal       )--> ResBlkCabacGetVLDVal;
		ResBlkCabac (resBlkCabac.done )--> FindOutNextActor;
			ResBlkCabacGetVLDVal (getVldVal.resBlkCabac )--> ResBlkCabacGetVLDVal;
			ResBlkCabacGetVLDVal (getVldVal.done        )--> ResBlkCabac;


	/*******************************************************************************/
	/*******************************************************************************/
	/**************                VLDECODING                         **************/
	/*******************************************************************************/
	/*******************************************************************************/
		CheckVLDType    (IsEndOfNal         )--> WaitForNewNal;
		CheckVLDType    (IsByteAligned      )--> CheckVLDType;
		CheckVLDType    (IsVldUe            )--> VLDecoding_Ue;
		CheckVLDType    (IsVldSe            )--> VLDecoding_Se;
		CheckVLDType    (IsVldTe.ue         )--> VLDecoding_Ue;
		CheckVLDType    (IsVldTe.u          )--> Decode_u;
		CheckVLDType    (IsReadBits         )--> Decode_u;
		CheckVLDType    (IsMoreRbspData     )--> FillBuffer;
		CheckVLDType    (IsCavlcLevelPrefix )--> DecCavlcLevPre;
		CheckVLDType    (IsCavlcCoeffToken  )--> DecCavlcCofTkn;
		CheckVLDType    (IsCavlcTotalZeros  )--> DecCavlcTotZer;
		CheckVLDType    (IsCavlcRunBefore   )--> DecCavlcRunBef;
		CheckVLDType    (isCabacInit        )--> CabacInitContextVar;
		CheckVLDType    (isCabacInitArithm  )--> CabacInitArithDecod;
		CheckVLDType    (isCabacInitMbVal   )--> CheckVLDType;
		CheckVLDType    (isCabacGetMbType   )--> CheckVLDType;
		CheckVLDType    (isCabacDecod       )--> CabacGetCtxIdx;

		/* more_rbsp_data() */
		FillBuffer      (FillBufferRbsp                      )--> FillBuffer;
		FillBuffer      (FutureNewNalDetected                )--> CheckBuffer;
		FillBuffer      (CheckSizeBufferRbsp.IsEqualOrSupTo2 )--> CheckVLDType;
		FillBuffer      (NewNalHasBeenSent                   )--> CheckBuffer;
		CheckBuffer     (CheckSizeBufferRbsp                 )--> CheckVLDType;

		/* Skip the others values of the Rbsp */
		WaitForNewNal   (NewNalHasBeenSent          )--> ResetNewNal;
		WaitForNewNal   (WaitForNewNal              )--> WaitForNewNal2;
		WaitForNewNal   (NewNalDetected             )--> CheckVLDType;
		ResetNewNal     (ResetNewNalAlreadyDetected )--> CheckVLDType;
		WaitForNewNal2  (WaitForNewNal              )--> WaitForNewNal2;
		WaitForNewNal2  (NewNalDetected             )--> CheckVLDType;

		/* ue(v) decoding process */
			/*Fill in the WorkingByte if it's empty*/
		VLDecoding_Ue   (Buffer                 )--> GetCodeNum4ue;
		VLDecoding_Ue   (FillBufferRbsp         )--> VLDecoding_Ue;
		GetCodeNum4ue   (GetCodeNum.Launch      )--> CheckCodeNum4ue;
		CheckCodeNum4ue (GetCodeNum.NotFinished )--> VLDecoding_Ue;
		CheckCodeNum4ue (GetCodeNum.Finished    )--> SendUeValue;
		SendUeValue     (SendUeValue            )--> CheckVLDType;

		/* se(v) decoding process */
			/*Fill in the WorkingByte if it's empty*/
		VLDecoding_Se   (Buffer                 )--> GetCodeNum4se;
		VLDecoding_Se   (FillBufferRbsp         )--> VLDecoding_Se;
		GetCodeNum4se   (GetCodeNum.Launch      )--> CheckCodeNum4se;
		CheckCodeNum4se (GetCodeNum.NotFinished )--> VLDecoding_Se;
		CheckCodeNum4se (GetCodeNum.Finished    )--> SendUeValse;
		SendUeValse     (SendSeValue            )--> CheckVLDType;

		/* u(n) decoding process */
			/*Fill in the WorkingByte if it's empty*/
		Decode_u        (Buffer            )--> Get_u;
		Decode_u        (FillBufferRbsp    )--> Decode_u;
		Get_u           (Get_u.Launch      )--> Check_u_Val;
		Check_u_Val     (Get_u.NotFinished )--> Decode_u;
		Check_u_Val     (Get_u.Finished    )--> SendUValue;
		SendUValue      (SendUValue        )--> CheckVLDType;

		/* Cavlc coeff_token() decoding process */
			/*Fill in the WorkingByte if it's empty*/
		DecCavlcCofTkn  (Buffer                         )--> GetCavlcCofTkn;
		DecCavlcCofTkn  (FillBufferRbsp                 )--> DecCavlcCofTkn;
		GetCavlcCofTkn  (GetCavlcCoeffToken.Launch      )--> ChckCavlcCofTkn;
		ChckCavlcCofTkn (GetCavlcCoeffToken.NotFinished )--> DecCavlcCofTkn;
		ChckCavlcCofTkn (GetCavlcCoeffToken.Finished    )--> CheckVLDType;

		/* Cavlc level_prefix decoding process */
			/*Fill in the WorkingByte if it's empty*/
		DecCavlcLevPre  (Buffer                          )--> GetCavlcLevPre;
		DecCavlcLevPre  (FillBufferRbsp                  )--> DecCavlcLevPre;
		GetCavlcLevPre  (GetCavlcLevelPrefix.Launch      )--> ChckCavlcLevPre;
		ChckCavlcLevPre (GetCavlcLevelPrefix.NotFinished )--> DecCavlcLevPre;
		ChckCavlcLevPre (GetCavlcLevelPrefix.Finished    )--> CheckVLDType;

		/* Cavlc total_zeros decoding process */
			/*Fill in the WorkingByte if it's empty*/
		DecCavlcTotZer  (Buffer                         )--> GetCavlcTotZer;
		DecCavlcTotZer  (FillBufferRbsp                 )--> DecCavlcTotZer;
		GetCavlcTotZer  (GetCavlcTotalZeros.Launch      )--> ChckCavlcTotZer;
		ChckCavlcTotZer (GetCavlcTotalZeros.NotFinished )--> DecCavlcTotZer;
		ChckCavlcTotZer (GetCavlcTotalZeros.Finished    )--> CheckVLDType;

		/* Cavlc run_before decoding process */
			/*Fill in the WorkingByte if it's empty*/
		DecCavlcRunBef  (Buffer                        )--> GetCavlcRunBef;
		DecCavlcRunBef  (FillBufferRbsp                )--> DecCavlcRunBef;
		GetCavlcRunBef  (GetCavlcRunBefore.Launch      )--> ChckCavlcRunBef;
		ChckCavlcRunBef (GetCavlcRunBefore.NotFinished )--> DecCavlcRunBef;
		ChckCavlcRunBef (GetCavlcRunBefore.Finished    )--> CheckVLDType;

		/* Cabac Init */
		CabacInitContextVar (cabacInitContextVar )--> CabacInitArithDecod;
		CabacInitArithDecod (Buffer.IsEmpty      )--> CabacInitArithDecod;
		CabacInitArithDecod (cabacInitArithDecod )--> CheckVLDType;
		CabacInitArithDecod (FillBufferRbsp      )--> CabacInitArithDecod;

		/* Cabac Decode Syntax Element */
		CabacGetCtxIdx     (cabacGetCtxIdx      )--> CabacFillOutBuffer;
		CabacFillOutBuffer (Buffer              )--> EndDecodeBin;
		CabacFillOutBuffer (FillBufferRbsp      )--> CabacFillOutBuffer;
		CabacFillOutBuffer (cabacEndDecode.skip )--> CabacCheckBinarization;
		EndDecodeBin (cabacRenormD.launch  )--> CabacFillOutBuffer;
		EndDecodeBin (cabacEndDecode.skip  )--> CabacCheckBinarization;
		EndDecodeBin (decodeByPass         )--> CabacCheckBinarization;

		CabacCheckBinarization (cabacCheckBinarization.done        )--> CheckVLDType;
		CabacCheckBinarization (cabacInitForSuffix                 )--> CabacGetCtxIdx;
		CabacCheckBinarization (cabacCheckBinarization.notFinished )--> CabacGetCtxIdx;
	end
	priority
		sliceHeader1.vld > waitVLDVal > sliceHeader1.launchActor;
		sliceHeader1.launchActor      > sliceHeader1.done;
		getVldVal.sliceHeader1        > getVldVal.done;
		sliceHeader2.vld > waitVLDVal > sliceHeader2.launchActor;
		sliceHeader2.launchActor      > sliceHeader2.done;
		getVldVal.sliceHeader2        > getVldVal.done;
		refPicMark.vld  > waitVLDVal  > refPicMark.done;
		getVldVal.refPicMark          > getVldVal.done;
		refPicList.vld  > waitVLDVal  > refPicList.done;
		getVldVal.refPicList          > getVldVal.done;
		sliceData.vld > waitVLDVal    > sliceData.launchActor;
		sliceData.launchActor         > sliceData.done;
		getVldVal.sliceData           > getVldVal.done;
		mbLayer.vld   > waitVLDVal    > mbLayer.launchActor;
		mbLayer.launchActor           > mbLayer.done;
		getVldVal.mbLayer             > getVldVal.done;
		mbPred.vld      > waitVLDVal  > mbPred.done;
		getVldVal.mbPred              > getVldVal.done;
		subMbPred.vld   > waitVLDVal  > subMbPred.done;
		getVldVal.subMbPred           > getVldVal.done;
		resBlkCavlc.vld > waitVLDVal  > resBlkCavlc.done;
		getVldVal.resBlkCavlc         > getVldVal.done;
		resBlkCabac.vld > waitVLDVal  > resBlkCabac.done;
		getVldVal.resBlkCabac         > getVldVal.done;
		/*******************************************************************************/
		/*******************************************************************************/
		/**************                VLDECODING                         **************/
		/*******************************************************************************/
		/*******************************************************************************/
		NewNalHasBeenSent               > WaitForNewNal                        > NewNalDetected;
		IsVldUe                         > IsReadBits                           > IsCavlcLevelPrefix;  
		IsCavlcLevelPrefix              > IsCavlcRunBefore > IsCavlcCoeffToken > IsVldSe;
		IsVldSe                         > IsVldTe.ue       > IsVldTe.u         > FillBufferRbsp;
		FillBufferRbsp                  > IsMoreRbspData   > IsByteAligned     > IsEndOfNal;
		CheckSizeBufferRbsp             > FillBufferRbsp                       > FutureNewNalDetected > NewNalHasBeenSent;
		GetCodeNum.NotFinished          > GetCodeNum.Finished;
		Buffer.IsNotEmpty               > Buffer.IsEmpty                       > FillBufferRbsp;
		GetCavlcCoeffToken.NotFinished  > GetCavlcCoeffToken.Finished;
		GetCavlcLevelPrefix.NotFinished > GetCavlcLevelPrefix.Finished;
		GetCavlcTotalZeros.NotFinished  > GetCavlcTotalZeros.Finished;
		GetCavlcRunBefore.NotFinished   > GetCavlcRunBefore.Finished;
		Buffer > cabacInitArithDecod    > FillBufferRbsp;
		cabacCheckBinarization.done     > cabacInitForSuffix > cabacCheckBinarization.notFinished;
	end
end
