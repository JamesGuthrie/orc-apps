/*
 * Copyright (c) 2011, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Damien de Saint Jorre <damien.desaintjorre@epfl.ch>
package ch.epfl.mpeg4.part10.frext.synParser.modular.decodePicture;

import org.sc29.wg11.mpeg4.part10.MacroBlockInfo.*;
import ch.epfl.mpeg4.part10.cbp.synParser.modular.decodePicture.decodingFunctions.*;
import std.util.BitOps.*;

//Clean me !!
actor Algo_DecodeResidual()
	bool          CodedBlockFlag,
	uint(size=16) Parameters,
	uint(size=5)  TotalCoeffCavlc
		==>
	bool          IsCabac,
	int (size=6)  TypeOfVLD,
	int (size=32) ActorLaunched,
	int (size=8)  ResBlkParamCavlc,
	int (size=16) ResBlkParamCabac,
	int (size=32) Feedback,
	bool          Skip_Block
		:

	bool         CAVLC_ENTROPY = false;
//	bool         CABAC_ENTROPY = true;
	uint(size=2) LUMA_DC_COMPONENT      = 0;
	uint(size=2) LUMA_AC_COMPONENT      = 1;
	uint(size=2) CHROMA_DC_COMPONENT    = 2;
	uint(size=2) CHROMA_AC_COMPONENT    = 3;
	uint(size=1) iCb = 0;
	uint(size=1) iCr = 1;

	uint(size=2) RESIDUAL_LUMA_LUMA_OUTPUT = 0;
//	uint(size=2) RESIDUAL_LUMA_CHROMA1_OUTPUT := 0;
//	uint(size=2) RESIDUAL_LUMA_CHROMA2_OUTPUT := 0;

	bool          bmFlag;
	uint(size=16) cbfChrNeighbA;
	uint(size=16) cbfChrNeighbB;
	int (size=5)  startIdx;
	uint(size=4)  endIdx;
	uint(size=4)  StartIdxSent;
	uint(size=4)  EndIdxSent;
	uint(size=2)  chroma_array_type;
	uint(size=2)  NumC8x8;
	bool          entropyCodingMode;
	uint(size=6)  mb_type;
	bool          transform_size_8x8_flag;
	uint(size=6)  CodedBlockPatternLuma;
	uint(size=6)  CodedBlockPatternChroma;
	uint(size=4)  ActorSelected;
	List(type: uint(size=5), size = 24 ) TotalCoeffTabLuma;
	List(type: List(type: uint(size=5), size = 24 ), size=2) TotalCoeffTabChroma;
	List(type: bool        , size = 24 ) MbExists := [true : for int s in 0 .. 23];
	List(type: uint(size=5), size = 16 ) IdxLeftNeighbour  = [16, 0,17, 2, 1, 4, 3, 6,18, 8,19,10, 9,12,11,14];
	List(type: uint(size=5), size = 16 ) IdxAboveNeighbour = [20,21, 0, 1,22,23, 4, 5, 2, 3, 8, 9, 6, 7,12,13];
	uint(size=5)  IdxCurrMb := 0;
	uint(size=3)  i8x8Loop;
	uint(size=3)  iCbCrLoop;
	uint(size=2)  Component_type := 0;
	uint(size=5)  maxNumCoeff;
	uint(size=2)  ResidualLumaOutput := 0;
	uint(size=4)  ctxBlkCat;
	uint(size=16) cbfAcLuma;
	uint(size=1)  cbfDcLuma;
	uint(size=16) cbfChroma;

	GetParameters: action Parameters :[param] repeat 34 ==>
	var
		bool LeftMbExists,
		bool AboveMbExists
	do

		entropyCodingMode := getFlag(param[0],0);
		transform_size_8x8_flag  := getFlag(param[0],1);
		bmFlag                   := getFlag(param[0],2);
		LeftMbExists             := getFlag(param[0],3);
		AboveMbExists            := getFlag(param[0],4);
		mb_type                  := param[1];
		startIdx                 := param[2];
		endIdx                   := param[3];
		CodedBlockPatternLuma    := param[4];
		CodedBlockPatternChroma  := param[5];
		chroma_array_type        := param[6];
		NumC8x8                  := param[7];
		ActorSelected :=
			if(entropyCodingMode = CAVLC_ENTROPY)then
				RESIDUAL_BLOCK_CAVLC
			else
				RESIDUAL_BLOCK_CABAC
			end;
		TotalCoeffTabLuma   :=  [0: for int i in 0 .. 23];
		TotalCoeffTabChroma := [[0: for int i in 0 .. 23]: for int j in 0 .. 1];
		foreach int i in 0 .. 3
		do
			TotalCoeffTabLuma  [16+i]      := param[8 + i];
			TotalCoeffTabChroma[iCb][16+i] := param[8 + 4 + i];
			TotalCoeffTabChroma[iCr][16+i] := param[8 + 8 + i];
			MbExists           [16+i]      := LeftMbExists;

			TotalCoeffTabLuma  [20+i]      := param[20 + i];
			TotalCoeffTabChroma[iCb][20+i] := param[20 + 4 + i];
			TotalCoeffTabChroma[iCr][20+i] := param[20 + 8 + i];
			MbExists           [20+i]      := AboveMbExists;
		end
		cbfChrNeighbA := param[32];
		cbfChrNeighbB := param[33];
		ResidualLumaOutput := RESIDUAL_LUMA_LUMA_OUTPUT;
		i8x8Loop   := 1;
		IdxCurrMb  := 0;
		cbfAcLuma  := 0;
		cbfDcLuma  := 0;
		cbfChroma  := 0;
	end

	ResLumaOutput.IsLuma: action ==> Feedback:[TotalCoeffTabLuma] repeat 16
	guard
		ResidualLumaOutput = RESIDUAL_LUMA_LUMA_OUTPUT
	do
		i8x8Loop := 0;
	end

	ResLuma_Launch16x16DCResBlock: action
			==>
		TypeOfVLD     :[LAUNCH_ACTOR],
		ActorLaunched :[ActorSelected]
	guard
		bmFlag   = false and startIdx = 0 and Is_Intra_16x16(mb_type)
	do
		Component_type := LUMA_DC_COMPONENT;
		maxNumCoeff    := 16;
		StartIdxSent   :=  0;
		EndIdxSent     := 15;
		ctxBlkCat      :=  0;
	end

	ResLuma_CheckTransfSzAndCavlc: action ==>
	guard
		not transform_size_8x8_flag or not entropyCodingMode
	do
		IdxCurrMb      := 0;
		ctxBlkCat :=
			if(Is_Intra_16x16(mb_type)) then
				1
			else
				2
			end;
		Component_type := LUMA_AC_COMPONENT;
	end

	

	ResLuma_CheckCodedBlockPattern: action ==>
	guard
		(CodedBlockPatternLuma & 1) = 1
	do
		Component_type := LUMA_AC_COMPONENT;
	end

	ResLuma_LaunchResBlk_1: action
			==>
		TypeOfVLD     :[ LAUNCH_ACTOR  , LAUNCH_ACTOR  , LAUNCH_ACTOR  , LAUNCH_ACTOR  ],
		ActorLaunched :[ ActorSelected , ActorSelected , ActorSelected , ActorSelected ]
	do
		if(not bmFlag and endIdx > 0 and Is_Intra_16x16(mb_type)) then
			maxNumCoeff    := 15;
			StartIdxSent   :=
				if(0 > startIdx - 1) then
					0
				else
					startIdx - 1
				end;
			EndIdxSent     :=  endIdx - 1;
		else
			maxNumCoeff    := 16;
			StartIdxSent   := startIdx;
			EndIdxSent     := endIdx;
		end
	end

	resLumaLaunchResCabac: action ==> TypeOfVLD:[LAUNCH_ACTOR],
		ActorLaunched:[ActorSelected]
	do
		maxNumCoeff    := 64;
		StartIdxSent   := 4*startIdx;
		EndIdxSent     := 4*endIdx + 3;
	end

	ResetLevelTab: action ==> Skip_Block :[true , true , true , true]
	do
		TotalCoeffTabLuma[IdxCurrMb    ]   := 0;
		TotalCoeffTabLuma[IdxCurrMb + 1]   := 0;
		TotalCoeffTabLuma[IdxCurrMb + 2]   := 0;
		TotalCoeffTabLuma[IdxCurrMb + 3]   := 0;
		if(Component_type = LUMA_AC_COMPONENT) then
			cbfAcLuma := setFlag(false, IdxCurrMb    , cbfAcLuma);
			cbfAcLuma := setFlag(false, IdxCurrMb + 1, cbfAcLuma);
			cbfAcLuma := setFlag(false, IdxCurrMb + 2, cbfAcLuma);
			cbfAcLuma := setFlag(false, IdxCurrMb + 3, cbfAcLuma);
		end
		IdxCurrMb := IdxCurrMb + 4;
	end

	EndLoop8x8.IsEqualToFalse: action ==>
	guard
		i8x8Loop < 4
	do
		i8x8Loop := i8x8Loop + 1;
		CodedBlockPatternLuma := (CodedBlockPatternLuma >> 1);
	end

	ResLuma_CheckCavlc8x8: action ==>
	guard
		entropyCodingMode = CAVLC_ENTROPY,
		transform_size_8x8_flag  = true
	end

	/*Not implemented yet: CABAC
	else
		for(i8x8=0;i8x8<4;i8x8++)
		{
			if(CodeBlockPatternLuma & (1<<i8x8)) // ==> action CheckCodedBlockPattern
				residual_block(...);
			else
				for(i=0;i<64;i++)
					level8x8[i8x8][i]=0;
		}
*/
	SendResBlockParameters.cavlc: action ==> ResBlkParamCavlc:[nC, maxNumCoeff,
		StartIdxSent, EndIdxSent], Skip_Block:[false], IsCabac:[false]
	guard
		not entropyCodingMode
	var
		int(size=8) nC =
			if(Component_type = LUMA_DC_COMPONENT or
				Component_type = LUMA_AC_COMPONENT) then
				if(MbExists[IdxLeftNeighbour[IdxCurrMb]] and 
					MbExists[IdxAboveNeighbour[IdxCurrMb]])then
						(TotalCoeffTabLuma[IdxLeftNeighbour[IdxCurrMb]] +
						TotalCoeffTabLuma[IdxAboveNeighbour[IdxCurrMb]] + 1)
						>> 1
				else
					TotalCoeffTabLuma[IdxLeftNeighbour[IdxCurrMb]] +
					TotalCoeffTabLuma[IdxAboveNeighbour[IdxCurrMb]]
				end
			else if(Component_type = CHROMA_DC_COMPONENT) then
				if(chroma_array_type = 1) then
					-1
				else
					-2
				end
			else
				if(MbExists[IdxLeftNeighbour[IdxCurrMb]] and
					MbExists[IdxAboveNeighbour[IdxCurrMb]])then
						(TotalCoeffTabChroma[iCbCrLoop]
							[IdxLeftNeighbour[IdxCurrMb]] +
						TotalCoeffTabChroma[iCbCrLoop]
							[IdxAboveNeighbour[IdxCurrMb]] + 1) >> 1
				else
					TotalCoeffTabChroma[iCbCrLoop]
						[IdxLeftNeighbour[IdxCurrMb]] +
					TotalCoeffTabChroma[iCbCrLoop]
						[IdxAboveNeighbour[IdxCurrMb]]
				end
			end end
	do
		IdxCurrMb := IdxCurrMb + 1;
	end

	SendResBlockParameters.cabac: action ==> ResBlkParamCabac:[ctxBlkCat,
		maxNumCoeff, StartIdxSent, EndIdxSent, IdxCurrMb - 1, cbfChNeighbours],
		Skip_Block:[false], IsCabac:[true]
	guard
		entropyCodingMode
	var
		uint(size= 10) cbfChNeighbours =
			if(iCbCrLoop = 0)then
				((cbfChrNeighbA & 0x1F) << 5) + (cbfChrNeighbB & 0x1F)
			else
				(cbfChrNeighbA & 0x03E0) + ((cbfChrNeighbB & 0x03E0) >> 5)
			end
	do
		if(Component_type != CHROMA_DC_COMPONENT or IdxCurrMb = 0) then
			IdxCurrMb := IdxCurrMb + 1;
		end
	end

	GetFeedback.cavlc: action TotalCoeffCavlc:[valTotalCoeff] ==>
	guard
		not entropyCodingMode
	do
		if(Component_type = LUMA_AC_COMPONENT) then
			TotalCoeffTabLuma[IdxCurrMb - 1]   := valTotalCoeff;
		else if(Component_type = CHROMA_AC_COMPONENT)then
			TotalCoeffTabChroma[iCbCrLoop][IdxCurrMb - 1] := valTotalCoeff;
		end end
	end

	GetFeedback.cabac: action CodedBlockFlag:[codedBlock] ==>
	guard
		entropyCodingMode
	do
		if(Component_type = LUMA_AC_COMPONENT) then
			cbfAcLuma := setFlag(codedBlock, IdxCurrMb - 1, cbfAcLuma);
			//TotalCoeffTabLuma is used to know if the partition is coded or if it's skipped
			TotalCoeffTabLuma[IdxCurrMb - 1] :=
				if(codedBlock) then 1 else 0 end;
		else if(Component_type = CHROMA_DC_COMPONENT) then
			cbfChroma := setFlag(codedBlock, 5*iCbCrLoop + 4, cbfChroma);
			iCbCrLoop := iCbCrLoop + 1;
		else if(Component_type = CHROMA_AC_COMPONENT) then
			cbfChroma := setFlag(codedBlock, IdxCurrMb - 1 + 5*iCbCrLoop, cbfChroma);
		else //Component_type = LUMA_DC_COMPONENT
			cbfDcLuma := setFlag(codedBlock, 0, 0);
		end end end
	end

	ChromaArrayTypeVal.IsEqualTo1or2: action ==>
	guard
		chroma_array_type = 1 or chroma_array_type= 2
	do
		iCbCrLoop := 0;
		i8x8Loop  := 0;
	end

	ChromaDCResBlk: action
			==>
		TypeOfVLD     :[ LAUNCH_ACTOR  , LAUNCH_ACTOR  ],
		ActorLaunched :[ ActorSelected , ActorSelected ]
	guard
		(CodedBlockPatternChroma & 3) != 0,
		startIdx = 0
	do
		Component_type := CHROMA_DC_COMPONENT;
		StartIdxSent   := 0;
		EndIdxSent     := 4 * NumC8x8 - 1;
		maxNumCoeff    := 4 * NumC8x8;
		ctxBlkCat      := 3;
		IdxCurrMb      := 0;
	end

	ChromaAcComponentPresent: action ==>
	guard
		(CodedBlockPatternChroma & 2) != 0,
		endIdx > 0
	do
		Component_type := CHROMA_AC_COMPONENT;
		StartIdxSent :=
			if(0 > startIdx - 1) then
				0
			else
				startIdx - 1
			end;
		iCbCrLoop   := 0;
		i8x8Loop    := 0;
		IdxCurrMb   := 0;
		EndIdxSent  := endIdx - 1;
		maxNumCoeff := 15;
		ctxBlkCat   := 4;
	end

	ChromaLoopiCbCr: action ==>
	guard
		iCbCrLoop < 1
	do
		iCbCrLoop := iCbCrLoop + 1;
		i8x8Loop  := 0;
		IdxCurrMb := 0;
	end

	SendChromaCoeffToken: action ==> Feedback:[TotCoefChrm] repeat 16
	var
		List(type:uint(size=5), size=16) TotCoefChrm
	do
		if(NumC8x8 = 1)then
			foreach int i in 0 .. 3
			do
				TotCoefChrm[i]    := TotalCoeffTabChroma[iCbCrLoop][i];
				TotCoefChrm[4+i]  := TotalCoeffTabChroma[iCbCrLoop][i];
				TotCoefChrm[8+i]  := TotalCoeffTabChroma[iCbCrLoop][i];
				TotCoefChrm[12+i] := TotalCoeffTabChroma[iCbCrLoop][i];
			end
		else
			println("NumC8x8 != 1 :"+NumC8x8+" not implemented yet in a lot of actor !");
			while true do end
		end
	end

	ChromaAcLoopi8x8: action
			==>
		TypeOfVLD     :[ LAUNCH_ACTOR  , LAUNCH_ACTOR  , LAUNCH_ACTOR  , LAUNCH_ACTOR  ],
		ActorLaunched :[ ActorSelected , ActorSelected , ActorSelected , ActorSelected ]
	guard
		i8x8Loop < NumC8x8
	do
		i8x8Loop := i8x8Loop + 1;
	end

	SendSkipChromaDc: action ==> Skip_Block :[ true , true ]
	end

	ChromaAcComponentNotPresent: action
			==>
		Feedback:[[0: for int i in 0 .. 31]] repeat 32,
		Skip_Block:[[true: for int i in 0 ..  7]] repeat  8
	guard
		i8x8Loop < NumC8x8
	do
		i8x8Loop := i8x8Loop + 1;
	end

	ChromaArrayTypeVal.IsEqualTo3: action ==>
	guard
		chroma_array_type = 3
	do
		println("ChromaArrayTypeVal.IsEqualTo3 not implemented yet !");
	end


	SendEndResidual: action ==> TypeOfVLD :[SKIP_NAL],
		Feedback:[cbfDcLuma, cbfAcLuma, cbfChroma]
	end

	//remove me !!
	bool actorNotFinished := true;
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("DecodeResidual doesn't manage this case yet");
		actorNotFinished := false;
	end

	schedule fsm GetParameters:
		GetParameters (GetParameters )--> ResLumaCheckIntra16x16;

				/* residual_luma()*/
				ResLumaCheckIntra16x16       (ResLuma_Launch16x16DCResBlock         )--> ResLumaSendResBlkPar1;
				ResLumaCheckIntra16x16       (ResLuma_CheckTransfSzAndCavlc         )--> CheckCodeBlockBmFlag;
				ResLumaCheckIntra16x16       (ResLuma_CheckCodedBlockPattern        )--> ResLumaLaunchCabac;
	
				ResLumaSendResBlkPar1        (SendResBlockParameters                )--> ResLumaGetTotalCoeff1;
				ResLumaGetTotalCoeff1        (GetFeedback                           )--> ResLumaCheckTrnsSzAndEntropy;

				ResLumaCheckTrnsSzAndEntropy (ResLuma_CheckTransfSzAndCavlc         )--> CheckCodeBlockBmFlag;
				ResLumaCheckTrnsSzAndEntropy (ResLuma_CheckCodedBlockPattern        )--> ResLumaLaunchCabac;

				CheckCodeBlockBmFlag         (ResLuma_CheckCodedBlockPattern        )--> CheckBmFlagEndIx;
				CheckCodeBlockBmFlag         (ResetLevelTab                         )--> CheckEndLoop8x8;
	
				CheckBmFlagEndIx             (ResLuma_LaunchResBlk_1                )--> ResLumaSendResBlkPar2_0;

				ResLumaLaunchCabac (resLumaLaunchResCabac )--> ResLumaSendResBlkPar2_3;

				ResLumaSendResBlkPar2_0      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_0;
				ResLumaGetTotalCoeff2_0      (GetFeedback                         )--> ResLumaSendResBlkPar2_1;
				ResLumaSendResBlkPar2_1      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_1;
				ResLumaGetTotalCoeff2_1      (GetFeedback                         )--> ResLumaSendResBlkPar2_2;
				ResLumaSendResBlkPar2_2      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_2;
				ResLumaGetTotalCoeff2_2      (GetFeedback                         )--> ResLumaSendResBlkPar2_3;
				ResLumaSendResBlkPar2_3      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_3;
				ResLumaGetTotalCoeff2_3      (GetFeedback                         )--> CheckEndLoop8x8;

				CheckEndLoop8x8              (EndLoop8x8.IsEqualToFalse             )--> CheckCodeBlockBmFlag;
				CheckEndLoop8x8              (ResLuma_CheckCavlc8x8                 )--> ResidualLumaFinished;


			CheckEndLoop8x8 (ResLumaOutput.IsLuma      )--> CheckChromaArrayType;
			CheckEndLoop8x8 (undefined )--> undefined;

			ResidualLumaFinished (ResLumaOutput.IsLuma )--> CheckChromaArrayType;
			ResidualLumaFinished (undefined )-->undefined;


		CheckChromaArrayType        (ChromaArrayTypeVal.IsEqualTo1or2 )--> CheckChromaDc;
		CheckChromaArrayType        (ChromaArrayTypeVal.IsEqualTo3    )--> undefined;
		CheckChromaArrayType        (SendEndResidual                  )--> GetParameters;


		CheckChromaDc               (ChromaDCResBlk                   )--> ChromaDCSendResBlockParam_1;
		CheckChromaDc               (SendSkipChromaDc                 )--> CheckChromaAC;

		ChromaDCSendResBlockParam_1 (SendResBlockParameters           )--> ChromaDCGetTotalCoeff_1;
		ChromaDCGetTotalCoeff_1     (GetFeedback                      )--> ChromaDCSendResBlockParam_2;
		ChromaDCSendResBlockParam_2 (SendResBlockParameters           )--> ChromaDCGetTotalCoeff_2;
		ChromaDCGetTotalCoeff_2     (GetFeedback                      )--> CheckChromaAC;


		CheckChromaAC               (ChromaAcComponentPresent         )--> CheckLoopi8x8;
		CheckChromaAC               (ChromaAcComponentNotPresent      )--> SendEndResidual;

		CheckLoopiCbCr              (ChromaLoopiCbCr                  )--> CheckLoopi8x8;
		CheckLoopiCbCr              (SendEndResidual                  )--> GetParameters;

		CheckLoopi8x8               (ChromaAcLoopi8x8                 )--> ChromaAcSendResBlockPar_1;
		CheckLoopi8x8               (SendChromaCoeffToken             )--> CheckLoopiCbCr;
	
		ChromaAcSendResBlockPar_1   (SendResBlockParameters           )--> ChromaAcGetTotalCoeff_1;
		ChromaAcGetTotalCoeff_1     (GetFeedback                    )--> ChromaAcSendResBlockPar_2;
		ChromaAcSendResBlockPar_2   (SendResBlockParameters           )--> ChromaAcGetTotalCoeff_2;
		ChromaAcGetTotalCoeff_2     (GetFeedback                    )--> ChromaAcSendResBlockPar_3;
		ChromaAcSendResBlockPar_3   (SendResBlockParameters           )--> ChromaAcGetTotalCoeff_3;
		ChromaAcGetTotalCoeff_3     (GetFeedback                    )--> ChromaAcSendResBlockPar_4;
		ChromaAcSendResBlockPar_4   (SendResBlockParameters           )--> ChromaAcGetTotalCoeff_4;
		ChromaAcGetTotalCoeff_4     (GetFeedback                    )--> CheckLoopi8x8;

		ChromaAcComponentNotPresent (ChromaAcComponentNotPresent      )--> ChromaAcComponentNotPresent;
		ChromaAcComponentNotPresent (SendEndResidual                  )--> GetParameters;

		SendEndResidual             (SendEndResidual )--> GetParameters;

		undefined (undefined )--> undefined;
	end
	priority
		ResLuma_Launch16x16DCResBlock         > ResLuma_CheckTransfSzAndCavlc;
		ResLuma_CheckTransfSzAndCavlc         > ResLuma_CheckCodedBlockPattern;
		ResLuma_CheckCodedBlockPattern        > ResetLevelTab;
		EndLoop8x8.IsEqualToFalse             > ResLuma_CheckCavlc8x8           > ResLumaOutput.IsLuma;
		ResLumaOutput.IsLuma                  > undefined;
		ChromaArrayTypeVal.IsEqualTo1or2      > ChromaArrayTypeVal.IsEqualTo3   > SendEndResidual;
		ChromaDCResBlk                        > SendSkipChromaDc;
		ChromaAcComponentPresent              > ChromaAcComponentNotPresent;
		ChromaAcLoopi8x8                      > SendChromaCoeffToken;
		ChromaLoopiCbCr                       > SendEndResidual;
		ChromaAcComponentNotPresent           > SendEndResidual;
	end
end