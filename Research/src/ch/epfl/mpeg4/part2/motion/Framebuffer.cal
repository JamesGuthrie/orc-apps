/* 
* Copyright (c) 2004-2005 Xilinx Inc.
* All Rights Reserved
*
* Disclaimer:  THIS PROGRAM IS PROVIDED "AS IS" WITH NO WARRANTY 
*              WHATSOEVER AND XILINX SPECIFICALLY DISCLAIMS ANY 
*              IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
*              A PARTICULAR PURPOSE, OR AGAINST INFRINGEMENT.
*/
package ch.epfl.mpeg4.part2.motion;

import org.sc29.wg11.mpeg4.part2.Constants.*;

import org.ietr.mpeg4.part2.sp.ConstantsBtype.*;

actor Framebuffer () 
	int(size=MV_SZ) MV, int(size=BTYPE_SZ) BTYPE, uint(size=8) WD 
	==> 
	int(size=FLAG_SZ) halfpel, uint(size=PIX_SZ-1) RD :
 
 	int SAMPLES_PER_MB    = 16;
 	int SAMPLES_PER_MB_UV = 8;
  
  	int COMP_PER_MB = 6;

  	int MAXW_IN_SAMPLES    = MAXW_IN_MB * SAMPLES_PER_MB;
  	int MAXW_IN_SAMPLES_UV = MAXW_IN_MB * SAMPLES_PER_MB_UV;
  
  	int MAXH_IN_SAMPLES    = MAXH_IN_MB * SAMPLES_PER_MB;
  	int MAXH_IN_SAMPLES_UV = MAXH_IN_MB * SAMPLES_PER_MB_UV;
  
  	int HALF_SEARCH = (SEARCHWIN_IN_MB + 1) / 2;

	// luma and chroma buffers
  	int(size=PIX_SZ) framebuffer[MAXH_IN_SAMPLES][MAXW_IN_SAMPLES];
  	int(size=PIX_SZ) framebuffer_u[MAXH_IN_SAMPLES_UV][MAXW_IN_SAMPLES_UV];
  	int(size=PIX_SZ) framebuffer_v[MAXH_IN_SAMPLES_UV][MAXW_IN_SAMPLES_UV];
 
  	// properties of the VOP_Y
  	int vop_width := 0;             // width in macro blocks
  	int vop_height := 0;             // width in macro blocks
  	int vop_width_in_samples;  // width in samples
  	int vop_height_in_samples; // height in samples
  	int vop_rounding_mode;     // rounding mode: 0,1 

   	// properties of the VOP_U          
  	int vop_width_in_samples_U;
  	int vop_height_in_samples_U; 
    
   
  	int(size=MV_SZ) mvx;     // Motion vector x
  	int(size=MV_SZ) mvy;     // Motion vector y

  	// reading from the frame buffers
  	int mbx_read;
  	int mby_read;
  	int mbx;
  	int mby;
 
  	int outstanding_writes;    // number of outstanding block writes (used to keep in synch with reads)

 	int max_outstanding_writes; // Maximum number of outstanding writes (unit: 8x8 blocks) before
                                // we risk "read-before-write"   
	int comp_so_far;

	//*****IF Y********
  // Move pointers to next block
  	procedure advance_block()
  	begin
  		outstanding_writes := outstanding_writes + 1;
    	// Advance to next block
    	comp_so_far := comp_so_far + 1;
    	if (comp_so_far = COMP_PER_MB) then
			mbx_read := mbx_read + 1;
	  		comp_so_far := 0;
      		if (mbx_read = vop_width) then
        		mbx_read := 0;
        		mby_read := mby_read + 1;
      		end
    	end
    end
  
    // Start a new VOP by setting VOP parameters and initializing the block scan

  cmd.newVop: action BTYPE:[ cmd ] ==>
  guard
    (cmd & NEWVOP) != 0
  do
    vop_rounding_mode := if (cmd & ROUND_TYPE) != 0 then 1 else 0 end;    
    comp_so_far := 0;
  end


  get_w_h: action BTYPE:[ w, h ] ==>
  do
    vop_width := w;
    vop_height := h;
    
    vop_width_in_samples := w*SAMPLES_PER_MB;
    vop_height_in_samples := h*SAMPLES_PER_MB;
    
    vop_width_in_samples_U := w*SAMPLES_PER_MB_UV;
    vop_height_in_samples_U := h*SAMPLES_PER_MB_UV;
        
    // Compute the maximum number of writes that can be "outstanding"
    // before we risk reading a block before it is written:
    // the total number of 8x8 blocks in a frame less half the searchwin.    
    max_outstanding_writes := (vop_height - HALF_SEARCH) * vop_width * COMP_PER_MB;
	
    // Advance to next frame
    mbx_read := 0;
    mby_read := 0;		
  end  
	
	// Pure texture
  	cmd.noMotion: action BTYPE:[ cmd ] ==>
 	guard
    	(cmd & INTRA) != 0		
  	do
  		advance_block();
  	end
  
  // Pure motion
  	cmd.motion: action BTYPE:[ cmd ] ==>
  	guard
    	(cmd & MOTION) != 0
  	end

  // Encode flags on halfpel: bit2 = interp. x
  //                          bit1 = interp. y
  //                          bit0 = round
  read_mv: action MV:[ x , y ] ==> halfpel:[ flags ]
  var
    int(size=FLAG_SZ) flags = ((x & 1) << 2) + ((y & 1) << 1) + vop_rounding_mode
  do
    mvx := (x >> 1);
    mvy := (y >> 1);
  end

  // No change in the block
  cmd.neither: action BTYPE:[ cmd ] ==> halfpel:[ 0 ]
  do
    mvx := 0;
    mvy := 0;
  end


//*****IF Y********
  // Read one 9x9 block from the frame buffer
  read_fb.Y: action ==> RD:[rd] repeat 81
  guard 
  	outstanding_writes < max_outstanding_writes,
  	comp_so_far < 4
  var
    List(type:uint(size=8), size=81) rd,
    int x = mbx_read*SAMPLES_PER_MB + 8*(comp_so_far & 1) + mvx,
    int y := mby_read*SAMPLES_PER_MB + 8*(comp_so_far >> 1) + mvy,
    int i, int j,
    int x_start, int x_end,
    int y_start, int y_end
    
  do
	x_start := x;
	x_end := x + 8;
	if x < 0 then
   	  x_start := 0;
    else 
      if (x + 8) > vop_width_in_samples then
        if x >= vop_width_in_samples then
          x_start := vop_width_in_samples - 1;
          x_end := vop_width_in_samples - 1;
       	end
        x_end := vop_width_in_samples;
      end
    end

	y_start := y;
	y_end := y + 8;
	if y < 0 then
   	  y_start := 0;
    else 
      if (y + 8) > vop_height_in_samples then
        if y >= vop_height_in_samples then
		  y_start := vop_height_in_samples - 1;
		  y_end := vop_height_in_samples - 1;
        end
        y_end := vop_height_in_samples;
      end
    end

	i := x_start - x;
	j := y_start - y;
	foreach int row in y_start .. y_end do
		foreach int col in x_start .. x_end do
	      rd[9*j + i] := framebuffer[row][col];
	      i := i + 1;
		end
	    i := x_start - x;
	    j := j + 1;
	end

	// horizontal padding
	if x < 0 then
		foreach int m in 0 .. 8 do
			foreach int n in 0 .. (x_start - x) do
				 rd[9*m + n] := rd[9*m + (x_start - x)];
			end  
		end
	elsif (x + 8) >= vop_width_in_samples then
		foreach int m in 0 .. 8 do
			foreach int n in (x_end - x) .. 8 do
				 rd[9 * m + n] := rd[9 * m + (x_end - x) - 1];
			end
		end
	end
	
	// vertical padding
    if y < 0 then
		foreach int m in 0 .. 8 do
			foreach int n in 0 .. (y_start - y) do
				 rd[9*n + m] := rd[9*(y_start-y) + m];
			end  
		end
	elsif (y + 8) >= vop_height_in_samples then
		foreach int m in 0 .. 8 do
			foreach int n in (y_end - y) .. 8 do
				 rd[9 * n + m] := rd[9*(y_end - y - 1) + m];
			end  
		end
	end
    advance_block();
  end



//*****IF U********  
  read_fb.U:  action ==> RD:[rd] repeat 81
  guard 
  	outstanding_writes < max_outstanding_writes, comp_so_far = 4
  var
    List(type:uint(size=8), size=81) rd,
    int x = mbx_read*SAMPLES_PER_MB_UV + mvx,
    int y := mby_read*SAMPLES_PER_MB_UV + mvy,
    int i, int j,
    int x_start,
    int x_end,
    int y_start,
    int y_end
    
  do
	x_start := x;
	x_end := x + 8;
	if x < 0 then
   		x_start := 0;
    else 
    	if (x + 8) > vop_width_in_samples_U then
        	if x >= vop_width_in_samples_U then
        		x_start := vop_width_in_samples_U - 1;
        		x_end := vop_width_in_samples_U - 1;
       	 	end
        	x_end := vop_width_in_samples_U;
      	end
    end

	y_start := y;
	y_end := y + 8;
	if y < 0 then
   		y_start := 0;
    else 
    	if (y + 8) > vop_height_in_samples_U then
        	if y >= vop_height_in_samples_U then
        		y_start := vop_height_in_samples_U - 1;
        		y_end := vop_height_in_samples_U - 1;
       	 	end
        	y_end := vop_height_in_samples_U;
      	end
    end
	
	i := x_start - x;
	j := y_start - y;
	foreach int row in y_start .. y_end do
		foreach int col in x_start .. x_end do
	      rd[9*j + i] := framebuffer_u[row][col];
	      i := i + 1;
		end
	    i := x_start - x;
	    j := j + 1;
	end
	
	// horizontal padding
	if x < 0 then
		foreach int m in 0 .. 8 do
			foreach int n in 0 .. (x_start - x) do
				 rd[9*m + n] := rd[9*m + (x_start - x)];
			end  
		end
	elsif (x + 8) >= vop_width_in_samples_U then
		foreach int m in 0 .. 8 do
			foreach int n in (x_end - x) .. 8 do
				 rd[9 * m + n] := rd[9 * m + (x_end - x) - 1];
			end  
		end
	end
		
	// vertical padding
    if y < 0 then
		foreach int m in 0 .. 8 do
			foreach int n in 0 .. (y_start - y) do
				 rd[9*n + m] := rd[9*(y_start-y) + m];
			end  
		end
	elsif (y + 8) >= vop_height_in_samples_U then
		foreach int m in 0 .. 8 do
			foreach int n in (y_end - y) .. 8 do
				 rd[9 * n + m] := rd[9*(y_end - y - 1) + m];
			end  
		end
	end
    advance_block();
  end
  
  //*****IF V********
  
  read_fb.V: action ==> RD:[rd] repeat 81
  guard 
  	outstanding_writes < max_outstanding_writes
  var
    List(type:uint(size=8), size=81) rd,
    int x = mbx_read*SAMPLES_PER_MB_UV + mvx,
    int y := mby_read*SAMPLES_PER_MB_UV + mvy,
    int i, int j,
    int x_start,
    int x_end,
    int y_start,
    int y_end
    
  do
	x_start := x;
	x_end := x + 8;
	if x < 0 then
   		x_start := 0;
    else 
    	if (x + 8) > vop_width_in_samples_U then
        	if x >= vop_width_in_samples_U then
        		x_start := vop_width_in_samples_U - 1;
        		x_end := vop_width_in_samples_U - 1;
       	 	end
        	x_end := vop_width_in_samples_U;
      	end
    end

	y_start := y;
	y_end := y + 8;
	if y < 0 then
   		y_start := 0;
    else 
    	if (y + 8) > vop_height_in_samples_U then
        	if y >= vop_height_in_samples_U then
        		y_start := vop_height_in_samples_U - 1;
        		y_end := vop_height_in_samples_U - 1;
       	 	end
        	y_end := vop_height_in_samples_U;
      	end
    end
	
	i := x_start - x;
	j := y_start - y;
	foreach int row in y_start .. y_end do
		foreach int col in x_start .. x_end do
	      rd[9*j + i] := framebuffer_v[row][col];
	      i := i + 1;
		end
	    i := x_start - x;
	    j := j + 1;
	end
	
	// horizontal padding
	if x < 0 then
		foreach int m in 0 .. 8 do
			foreach int n in 0 .. (x_start - x) do
				 rd[9*m + n] := rd[9*m + (x_start - x)];
			end  
		end
	elsif (x + 8) >= vop_width_in_samples_U then
		foreach int m in 0 .. 8 do
			foreach int n in (x_end - x) .. 8 do
				 rd[9 * m + n] := rd[9 * m + (x_end - x) - 1];
			end  
		end
	end
		
	// vertical padding
    if y < 0 then
		foreach int m in 0 .. 8 do
			foreach int n in 0 .. (y_start - y) do
				 rd[9*n + m] := rd[9*(y_start-y) + m];
			end  
		end
	elsif (y + 8) >= vop_height_in_samples_U then
		foreach int m in 0 .. 8 do
			foreach int n in (y_end - y) .. 8 do
				 rd[9 * n + m] := rd[9*(y_end - y - 1) + m];
			end  
		end
	end
    advance_block();
  end
  
  // free-running write to frame buffer is driven by token availability

  action WD:[wd] repeat 384 ==>
  guard 
  	outstanding_writes >= 6*(vop_width + 2) // MB read needs to be at least (line + 2) ahead of write
  do
    foreach int y in 0 .. 7 do
  	  foreach int x in 0 .. 7 do
  	    framebuffer[mby*16 + y + 0][mbx*16 + x + 0] := wd[8*y + x];
  	    framebuffer[mby*16 + y + 0][mbx*16 + x + 8] := wd[8*y + x + 64];
  	    framebuffer[mby*16 + y + 8][mbx*16 + x + 0] := wd[8*y + x + 128];
  	    framebuffer[mby*16 + y + 8][mbx*16 + x + 8] := wd[8*y + x + 192];
  	    framebuffer_u[mby*8 + y][mbx*8 + x] := wd[8*y + x + 256];
  	    framebuffer_v[mby*8 + y][mbx*8 + x] := wd[8*y + x + 320];
  	  end
  	end

    // Advance component to write
    outstanding_writes := outstanding_writes - 6;
     
   	mbx := mbx + 1;   
   	if mbx = vop_width then
      mbx := 0;   
      mby := mby + 1;
      if mby = vop_height then
        mby := 0;
      end
    end
   
  end

	
  schedule fsm cmd:
    cmd          ( cmd.newVop     ) --> get_w_h;
	get_w_h      ( get_w_h        ) --> cmd;   
    cmd          ( cmd.noMotion   ) --> cmd;
    cmd          ( cmd.motion     ) --> read_mv;
    cmd          ( cmd.neither    ) --> read_fb;
    read_mv      ( read_mv        ) --> read_fb;
    read_fb      ( read_fb        ) --> cmd;     
  end

  priority
    cmd.newVop > cmd.noMotion > cmd.motion > cmd.neither;
    read_fb.Y > read_fb.U > read_fb.V;
  end

end

