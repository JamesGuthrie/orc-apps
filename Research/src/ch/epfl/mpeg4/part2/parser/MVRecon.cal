// MVReconstruct.cal
//
// Author: David B. Parlour (dave.parlour@xilinx.com)
//
// Copyright (c) 2004-2006 Xilinx Inc.
// All Rights Reserved
//
// Disclaimer:  THIS PROGRAM IS PROVIDED "AS IS" WITH NO WARRANTY 
//              WHATSOEVER AND XILINX SPECIFICALLY DISCLAIMS ANY 
//              IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
//              A PARTICULAR PURPOSE, OR AGAINST INFRINGEMENT.

package ch.epfl.mpeg4.part2.parser;

import std.util.Math.*;
import org.mpeg4.part2.Constants.FOURMV;
import org.mpeg4.part2.Constants.BTYPE_SZ;
import org.mpeg4.part2.Constants.CLOSEST_POW2_MAXW_IN_MB;
import org.mpeg4.part2.Constants.MB_COORD_SZ;
import org.mpeg4.part2.Constants.MV_SZ;
import org.mpeg4.part2.Constants.FCODE_MASK;
import org.mpeg4.part2.Constants.FCODE_SHIFT;
import org.mpeg4.part2.Constants.INTER;
import org.mpeg4.part2.Constants.NEWVOP;
import org.mpeg4.part2.Constants.MOTION;

actor MVRecon ()
	int(size=BTYPE_SZ) BTYPE, int(size=MV_SZ) MVIN ==>
	int(size=MV_SZ) MV :

	// Motion vector line buffers - pointer behavior must be implemented exactly as in MVSequence.cal
	int(size=MB_COORD_SZ) mbx := 0;

	int(size=MB_COORD_SZ) mby := 0;

	int(size=MV_SZ) buf2[CLOSEST_POW2_MAXW_IN_MB][2][4][2];
	
	int(size=4) comp := 0;

	int(size=MB_COORD_SZ) mbwidth := 0;

	int(size=MV_SZ) mv_rsize;

	int(size=MV_SZ) mv_range;

	int(size=MV_SZ) mv_low;

	int(size=MV_SZ) mv_high;
	
	int(size=MV_SZ) mv_x;

	int(size=MV_SZ) mv_y;

	int(size=MV_SZ + 2) sum_x;

	int(size=MV_SZ + 2) sum_y;


	

	// New VOP
	start: action BTYPE:[ cmd ] ==>
	guard
		(cmd & NEWVOP) != 0
	var
		int(size=4) fcode = (cmd & FCODE_MASK) >> FCODE_SHIFT
	do
		mbx := 0;
		mby := 0;
		comp := 0;
		if fcode > 0 then
			mv_rsize := fcode - 1;
			mv_range := 1 << (mv_rsize + 5);
			mv_low := -mv_range;
			mv_high := mv_range - 1;
			mv_range := (mv_range << 1);
		end	
	end
	
	get_w_h: action BTYPE:[w, h] ==>
	do
		mbwidth := w;
	end

	// No motion vector
	read.noMotion: action BTYPE:[ cmd ] ==>
	guard
		(cmd & INTER) = 0 or (cmd & MOTION) = 0, (cmd & NEWVOP) = 0
	do
		if comp < 4 then
			buf2[mbx][mby & 1][comp][0] := 0;
			buf2[mbx][mby & 1][comp][1] := 0;
		end
	end

	bool fourmv;

	// Motion vectors - detect fourmv
	read.motion: action BTYPE:[ cmd ] ==>
	guard
		(cmd & INTER) != 0,
		(cmd & MOTION) != 0,
		(cmd & NEWVOP) = 0
	do
		if comp = 0 then
			fourmv := (cmd & FOURMV) != 0;
			sum_x := 0;
			sum_y := 0;
		end
	end

	// No need to compute any more MVs for chroma or for luma blocks > 1 if not fourmv
	compute.done: action ==>
	guard
		comp > 3 or (comp != 0 and not fourmv)
	end

	function predict(int a, int b, int c, int(size=9) mag, int(size=9) res) --> int(size=9)
	var
		int pred := if comp >= 2 or mby != 0 then median(a, b, c) else a end, 
		int shift := ( if mag < 0 then ~(mag) else mag - 1 end << mv_rsize) + res + 1	
	:
  		mvclip( mvcalc( pred, mag, shift ) )
	end
	
	compute.predict.y0: action MVIN:[ mag_x, res_x, mag_y, res_y ] ==>
	guard
		comp = 0
	var
		int a_x := 0, int b_x := 0, int c_x := 0,
		int a_y := 0, int b_y := 0, int c_y := 0
	do
		if mbx != 0 then
			a_x := buf2[mbx - 1][mby & 1][1][0];
			a_y := buf2[mbx - 1][mby & 1][1][1];
		end
		
		if mby != 0  then  
			b_x := buf2[mbx][(mby - 1) & 1][2][0];
			b_y := buf2[mbx][(mby - 1) & 1][2][1];
			if mbx != (mbwidth - 1) then
				c_x := buf2[mbx + 1][(mby - 1) & 1][2][0];
				c_y := buf2[mbx + 1][(mby - 1) & 1][2][1];
			end
		end

		mv_x := predict(a_x, b_x, c_x, mag_x, res_x);
		sum_x := sum_x + mv_x;

		mv_y := predict(a_y, b_y, c_y, mag_y, res_y);
		sum_y := sum_y + mv_y;
	end

	// block 1    0      above->3    above_right->2
	compute.predict.y1: action MVIN:[ mag_x, res_x, mag_y, res_y ] ==>
	guard
		comp = 1
	var
		int a_x := 0, int b_x := 0, int c_x := 0,
		int a_y := 0, int b_y := 0, int c_y := 0
	do
		a_x := buf2[mbx - 1][mby & 1][0][0];
		a_y := buf2[mbx - 1][mby & 1][0][1];
	
		if mby != 0  then
			b_x := buf2[mbx][(mby - 1) & 1][3][0];
			b_y := buf2[mbx][(mby - 1) & 1][3][1];
			if mbx != (mbwidth - 1) then 
				c_x := buf2[mbx + 1][(mby - 1) & 1][2][0];
				c_y := buf2[mbx + 1][(mby - 1) & 1][2][1];
			end
		end
		
		mv_x := predict(a_x, b_x, c_x, mag_x, res_x);
		sum_x := sum_x + mv_x;
		mv_y := predict(a_y, b_y, c_y, mag_y, res_y);
		sum_y := sum_y + mv_y;
		
	end

	// block 2 left->3       0            1
	compute.predict.y2: action MVIN:[ mag_x, res_x, mag_y, res_y ] ==>
	guard
		comp = 2
var
		int a_x := 0, int b_x := 0, int c_x := 0,
		int a_y := 0, int b_y := 0, int c_y := 0
	do
		if mbx != 0 then
			a_x := buf2[mbx - 1][mby & 1][3][0];
			a_y := buf2[mbx - 1][mby & 1][3][1];
		end
		
		b_x := buf2[mbx][(mby - 1) & 1][0][0];
		c_x := buf2[mbx + 1][(mby - 1) & 1][1][0];
		b_y := buf2[mbx][(mby - 1) & 1][0][1];
		c_y := buf2[mbx + 1][(mby - 1) & 1][1][1];
		
		mv_x := predict(a_x, b_x, c_x, mag_x, res_x);
		sum_x := sum_x + mv_x;
		mv_y := predict(a_y, b_y, c_y, mag_y, res_y);
		sum_y := sum_y + mv_y;
		
	end

	// block 3    2          0            1
	compute.predict.y3: action MVIN:[ mag_x, res_x, mag_y, res_y ] ==>
	var
		int a_x := 0, int b_x := 0, int c_x := 0,
		int a_y := 0, int b_y := 0, int c_y := 0
	do
		a_x := buf2[mbx - 1][mby & 1][2][0];
		b_x := buf2[mbx][(mby - 1) & 1][0][0];
		c_x := buf2[mbx + 1][(mby - 1) & 1][1][0];
		
		a_y := buf2[mbx - 1][mby & 1][2][1];
		b_y := buf2[mbx][(mby - 1) & 1][0][1];
		c_y := buf2[mbx + 1][(mby - 1) & 1][1][1];

		mv_x := predict(a_x, b_x, c_x, mag_x, res_x);
		sum_x := sum_x + mv_x;
		mv_y := predict(a_y, b_y, c_y, mag_y, res_y);
		sum_y := sum_y + mv_y;
	end

	function mvcalc(int pred, int mv_mag, int mag_shift) --> int :
		if mv_rsize = 0 or mv_mag = 0 then
			pred + mv_mag
		else
			if mv_mag < 0 then
				pred - mag_shift
			else
				pred + mag_shift
			end
		end
	end

	function mvclip(int v) --> int :
		if v < mv_low then
			v + mv_range
		else
			if v > mv_high then
				v - mv_range
			else
				v
			end
		end
	end

	write.luma: action ==> MV:[ mv_x, mv_y ]
	guard
		comp < 4
	do
		buf2[mbx][mby & 1][comp][0] := mv_x;
		buf2[mbx][mby & 1][comp][1] := mv_y;
	end

	function uvclip_1(int v) --> int :
		(v >> 1) | if (v & 3) = 0 then 0 else 1 end
	end

	function uvclip_4(int v) --> int
	var
		bool sign = v < 0,
		int absv = if sign then
			-v
		else
			v
		end,
//		int resv = (absv - ((absv >> 4) << 4)),
		int resv = (absv & 15),
		// resv := |v|%16
		int delta = if resv < 3 then 0 else if resv > 13 then 2 else 1 end end,
		int vv = ((absv >> 4) << 1) + delta :
		if sign then
			-vv
		else
			vv
		end
	end

	// Written to be called four times in succession ( u.x, u.y, v.x, v.y )
	write.chroma: action ==> MV:[ mv_x, mv_y ]
	var
		int(size=MV_SZ) mv_x = if fourmv then uvclip_4(sum_x) else uvclip_1(sum_x) end, 
		int(size=MV_SZ) mv_y = if fourmv then uvclip_4(sum_y) else uvclip_1(sum_y) end
	end

	advance: action ==>
	do
		comp := comp + 1;
		if comp = 6 then
			comp := 0;
			mbx := mbx + 1;
			if mbx = mbwidth then
				mbx := 0;
				mby := mby + 1;
			end
		end
	end

	schedule fsm read :
		read ( start ) --> get_w_h;
		get_w_h (get_w_h) --> read;
		read ( read.motion ) --> compute;
		read ( read.noMotion ) --> advance;
		compute ( compute.done ) --> write;
		compute ( compute.predict ) --> write;
		write ( write ) --> advance;
		advance ( advance ) --> read;
	end

	priority
		start > read;
		read.noMotion > read.motion;
		compute.done > compute.predict;
		compute.predict.y0 > compute.predict.y1 > compute.predict.y2 > compute.predict.y3;
		write.luma > write.chroma;
	end

end